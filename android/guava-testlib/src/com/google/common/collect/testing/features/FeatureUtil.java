begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect.testing.features
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|features
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|Helpers
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|AnnotatedElement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Utilities for collecting and validating tester requirements from annotations.  *  * @author George van den Driessche  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
DECL|class|FeatureUtil
specifier|public
class|class
name|FeatureUtil
block|{
comment|/** A cache of annotated objects (typically a Class or Method) to its set of annotations. */
DECL|field|annotationCache
specifier|private
specifier|static
name|Map
argument_list|<
name|AnnotatedElement
argument_list|,
name|List
argument_list|<
name|Annotation
argument_list|>
argument_list|>
name|annotationCache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|classTesterRequirementsCache
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TesterRequirements
argument_list|>
name|classTesterRequirementsCache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|methodTesterRequirementsCache
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Method
argument_list|,
name|TesterRequirements
argument_list|>
name|methodTesterRequirementsCache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Given a set of features, add to it all the features directly or indirectly    * implied by any of them, and return it.    * @param features the set of features to expand    * @return the same set of features, expanded with all implied features    */
DECL|method|addImpliedFeatures (Set<Feature<?>> features)
specifier|public
specifier|static
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|addImpliedFeatures
parameter_list|(
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|features
parameter_list|)
block|{
name|Queue
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|(
name|features
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Feature
argument_list|<
name|?
argument_list|>
name|feature
init|=
name|queue
operator|.
name|remove
argument_list|()
decl_stmt|;
for|for
control|(
name|Feature
argument_list|<
name|?
argument_list|>
name|implied
range|:
name|feature
operator|.
name|getImpliedFeatures
argument_list|()
control|)
block|{
if|if
condition|(
name|features
operator|.
name|add
argument_list|(
name|implied
argument_list|)
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|implied
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|features
return|;
block|}
comment|/**    * Given a set of features, return a new set of all features directly or    * indirectly implied by any of them.    * @param features the set of features whose implications to find    * @return the implied set of features    */
DECL|method|impliedFeatures (Set<Feature<?>> features)
specifier|public
specifier|static
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|impliedFeatures
parameter_list|(
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|features
parameter_list|)
block|{
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|impliedSet
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Queue
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|(
name|features
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Feature
argument_list|<
name|?
argument_list|>
name|feature
init|=
name|queue
operator|.
name|remove
argument_list|()
decl_stmt|;
for|for
control|(
name|Feature
argument_list|<
name|?
argument_list|>
name|implied
range|:
name|feature
operator|.
name|getImpliedFeatures
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|features
operator|.
name|contains
argument_list|(
name|implied
argument_list|)
operator|&&
name|impliedSet
operator|.
name|add
argument_list|(
name|implied
argument_list|)
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|implied
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|impliedSet
return|;
block|}
comment|/**    * Get the full set of requirements for a tester class.    * @param testerClass a tester class    * @return all the constraints implicitly or explicitly required by the class    * or any of its superclasses.    * @throws ConflictingRequirementsException if the requirements are mutually    * inconsistent.    */
DECL|method|getTesterRequirements (Class<?> testerClass)
specifier|public
specifier|static
name|TesterRequirements
name|getTesterRequirements
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|testerClass
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
synchronized|synchronized
init|(
name|classTesterRequirementsCache
init|)
block|{
name|TesterRequirements
name|requirements
init|=
name|classTesterRequirementsCache
operator|.
name|get
argument_list|(
name|testerClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|requirements
operator|==
literal|null
condition|)
block|{
name|requirements
operator|=
name|buildTesterRequirements
argument_list|(
name|testerClass
argument_list|)
expr_stmt|;
name|classTesterRequirementsCache
operator|.
name|put
argument_list|(
name|testerClass
argument_list|,
name|requirements
argument_list|)
expr_stmt|;
block|}
return|return
name|requirements
return|;
block|}
block|}
comment|/**    * Get the full set of requirements for a tester class.    * @param testerMethod a test method of a tester class    * @return all the constraints implicitly or explicitly required by the    * method, its declaring class, or any of its superclasses.    * @throws ConflictingRequirementsException if the requirements are    * mutually inconsistent.    */
DECL|method|getTesterRequirements (Method testerMethod)
specifier|public
specifier|static
name|TesterRequirements
name|getTesterRequirements
parameter_list|(
name|Method
name|testerMethod
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
synchronized|synchronized
init|(
name|methodTesterRequirementsCache
init|)
block|{
name|TesterRequirements
name|requirements
init|=
name|methodTesterRequirementsCache
operator|.
name|get
argument_list|(
name|testerMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|requirements
operator|==
literal|null
condition|)
block|{
name|requirements
operator|=
name|buildTesterRequirements
argument_list|(
name|testerMethod
argument_list|)
expr_stmt|;
name|methodTesterRequirementsCache
operator|.
name|put
argument_list|(
name|testerMethod
argument_list|,
name|requirements
argument_list|)
expr_stmt|;
block|}
return|return
name|requirements
return|;
block|}
block|}
comment|/**    * Construct the full set of requirements for a tester class.    * @param testerClass a tester class    * @return all the constraints implicitly or explicitly required by the class    * or any of its superclasses.    * @throws ConflictingRequirementsException if the requirements are mutually    * inconsistent.    */
DECL|method|buildTesterRequirements (Class<?> testerClass)
specifier|static
name|TesterRequirements
name|buildTesterRequirements
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|testerClass
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
specifier|final
name|TesterRequirements
name|declaredRequirements
init|=
name|buildDeclaredTesterRequirements
argument_list|(
name|testerClass
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|baseClass
init|=
name|testerClass
operator|.
name|getSuperclass
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseClass
operator|==
literal|null
condition|)
block|{
return|return
name|declaredRequirements
return|;
block|}
else|else
block|{
specifier|final
name|TesterRequirements
name|clonedBaseRequirements
init|=
operator|new
name|TesterRequirements
argument_list|(
name|getTesterRequirements
argument_list|(
name|baseClass
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|incorporateRequirements
argument_list|(
name|clonedBaseRequirements
argument_list|,
name|declaredRequirements
argument_list|,
name|testerClass
argument_list|)
return|;
block|}
block|}
comment|/**    * Construct the full set of requirements for a tester method.    * @param testerMethod a test method of a tester class    * @return all the constraints implicitly or explicitly required by the    * method, its declaring class, or any of its superclasses.    * @throws ConflictingRequirementsException if the requirements are mutually    * inconsistent.    */
DECL|method|buildTesterRequirements (Method testerMethod)
specifier|static
name|TesterRequirements
name|buildTesterRequirements
parameter_list|(
name|Method
name|testerMethod
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
name|TesterRequirements
name|clonedClassRequirements
init|=
operator|new
name|TesterRequirements
argument_list|(
name|getTesterRequirements
argument_list|(
name|testerMethod
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|TesterRequirements
name|declaredRequirements
init|=
name|buildDeclaredTesterRequirements
argument_list|(
name|testerMethod
argument_list|)
decl_stmt|;
return|return
name|incorporateRequirements
argument_list|(
name|clonedClassRequirements
argument_list|,
name|declaredRequirements
argument_list|,
name|testerMethod
argument_list|)
return|;
block|}
comment|/**    * Construct the set of requirements specified by annotations    * directly on a tester class or method.    * @param classOrMethod a tester class or a test method thereof    * @return all the constraints implicitly or explicitly required by    *         annotations on the class or method.    * @throws ConflictingRequirementsException if the requirements are mutually    *         inconsistent.    */
DECL|method|buildDeclaredTesterRequirements (AnnotatedElement classOrMethod)
specifier|public
specifier|static
name|TesterRequirements
name|buildDeclaredTesterRequirements
parameter_list|(
name|AnnotatedElement
name|classOrMethod
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
name|TesterRequirements
name|requirements
init|=
operator|new
name|TesterRequirements
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Annotation
argument_list|>
name|testerAnnotations
init|=
name|getTesterAnnotations
argument_list|(
name|classOrMethod
argument_list|)
decl_stmt|;
for|for
control|(
name|Annotation
name|testerAnnotation
range|:
name|testerAnnotations
control|)
block|{
name|TesterRequirements
name|moreRequirements
init|=
name|buildTesterRequirements
argument_list|(
name|testerAnnotation
argument_list|)
decl_stmt|;
name|incorporateRequirements
argument_list|(
name|requirements
argument_list|,
name|moreRequirements
argument_list|,
name|testerAnnotation
argument_list|)
expr_stmt|;
block|}
return|return
name|requirements
return|;
block|}
comment|/**    * Find all the tester annotations declared on a tester class or method.    * @param classOrMethod a class or method whose tester annotations to find    * @return an iterable sequence of tester annotations on the class    */
DECL|method|getTesterAnnotations (AnnotatedElement classOrMethod)
specifier|public
specifier|static
name|Iterable
argument_list|<
name|Annotation
argument_list|>
name|getTesterAnnotations
parameter_list|(
name|AnnotatedElement
name|classOrMethod
parameter_list|)
block|{
synchronized|synchronized
init|(
name|annotationCache
init|)
block|{
name|List
argument_list|<
name|Annotation
argument_list|>
name|annotations
init|=
name|annotationCache
operator|.
name|get
argument_list|(
name|classOrMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotations
operator|==
literal|null
condition|)
block|{
name|annotations
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Annotation
name|a
range|:
name|classOrMethod
operator|.
name|getDeclaredAnnotations
argument_list|()
control|)
block|{
if|if
condition|(
name|a
operator|.
name|annotationType
argument_list|()
operator|.
name|isAnnotationPresent
argument_list|(
name|TesterAnnotation
operator|.
name|class
argument_list|)
condition|)
block|{
name|annotations
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|annotations
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|annotations
argument_list|)
expr_stmt|;
name|annotationCache
operator|.
name|put
argument_list|(
name|classOrMethod
argument_list|,
name|annotations
argument_list|)
expr_stmt|;
block|}
return|return
name|annotations
return|;
block|}
block|}
comment|/**    * Find all the constraints explicitly or implicitly specified by a single    * tester annotation.    * @param testerAnnotation a tester annotation    * @return the requirements specified by the annotation    * @throws ConflictingRequirementsException if the requirements are mutually    *         inconsistent.    */
DECL|method|buildTesterRequirements (Annotation testerAnnotation)
specifier|private
specifier|static
name|TesterRequirements
name|buildTesterRequirements
parameter_list|(
name|Annotation
name|testerAnnotation
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|annotationClass
init|=
name|testerAnnotation
operator|.
name|annotationType
argument_list|()
decl_stmt|;
specifier|final
name|Feature
argument_list|<
name|?
argument_list|>
index|[]
name|presentFeatures
decl_stmt|;
specifier|final
name|Feature
argument_list|<
name|?
argument_list|>
index|[]
name|absentFeatures
decl_stmt|;
try|try
block|{
name|presentFeatures
operator|=
operator|(
name|Feature
index|[]
operator|)
name|annotationClass
operator|.
name|getMethod
argument_list|(
literal|"value"
argument_list|)
operator|.
name|invoke
argument_list|(
name|testerAnnotation
argument_list|)
expr_stmt|;
name|absentFeatures
operator|=
operator|(
name|Feature
index|[]
operator|)
name|annotationClass
operator|.
name|getMethod
argument_list|(
literal|"absent"
argument_list|)
operator|.
name|invoke
argument_list|(
name|testerAnnotation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Error extracting features from tester annotation."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|allPresentFeatures
init|=
name|addImpliedFeatures
argument_list|(
name|Helpers
operator|.
expr|<
name|Feature
argument_list|<
name|?
argument_list|>
operator|>
name|copyToSet
argument_list|(
name|presentFeatures
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|allAbsentFeatures
init|=
name|addImpliedFeatures
argument_list|(
name|Helpers
operator|.
expr|<
name|Feature
argument_list|<
name|?
argument_list|>
operator|>
name|copyToSet
argument_list|(
name|absentFeatures
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|allPresentFeatures
argument_list|,
name|allAbsentFeatures
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConflictingRequirementsException
argument_list|(
literal|"Annotation explicitly or "
operator|+
literal|"implicitly requires one or more features to be both present "
operator|+
literal|"and absent."
argument_list|,
name|intersection
argument_list|(
name|allPresentFeatures
argument_list|,
name|allAbsentFeatures
argument_list|)
argument_list|,
name|testerAnnotation
argument_list|)
throw|;
block|}
return|return
operator|new
name|TesterRequirements
argument_list|(
name|allPresentFeatures
argument_list|,
name|allAbsentFeatures
argument_list|)
return|;
block|}
comment|/**    * Incorporate additional requirements into an existing requirements object.    * @param requirements the existing requirements object    * @param moreRequirements more requirements to incorporate    * @param source the source of the additional requirements    *        (used only for error reporting)    * @return the existing requirements object, modified to include the    *         additional requirements    * @throws ConflictingRequirementsException if the additional requirements    *         are inconsistent with the existing requirements    */
DECL|method|incorporateRequirements ( TesterRequirements requirements, TesterRequirements moreRequirements, Object source)
specifier|private
specifier|static
name|TesterRequirements
name|incorporateRequirements
parameter_list|(
name|TesterRequirements
name|requirements
parameter_list|,
name|TesterRequirements
name|moreRequirements
parameter_list|,
name|Object
name|source
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|presentFeatures
init|=
name|requirements
operator|.
name|getPresentFeatures
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|absentFeatures
init|=
name|requirements
operator|.
name|getAbsentFeatures
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|morePresentFeatures
init|=
name|moreRequirements
operator|.
name|getPresentFeatures
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|moreAbsentFeatures
init|=
name|moreRequirements
operator|.
name|getAbsentFeatures
argument_list|()
decl_stmt|;
name|checkConflict
argument_list|(
literal|"absent"
argument_list|,
name|absentFeatures
argument_list|,
literal|"present"
argument_list|,
name|morePresentFeatures
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|checkConflict
argument_list|(
literal|"present"
argument_list|,
name|presentFeatures
argument_list|,
literal|"absent"
argument_list|,
name|moreAbsentFeatures
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|presentFeatures
operator|.
name|addAll
argument_list|(
name|morePresentFeatures
argument_list|)
expr_stmt|;
name|absentFeatures
operator|.
name|addAll
argument_list|(
name|moreAbsentFeatures
argument_list|)
expr_stmt|;
return|return
name|requirements
return|;
block|}
comment|// Used by incorporateRequirements() only
DECL|method|checkConflict ( String earlierRequirement, Set<Feature<?>> earlierFeatures, String newRequirement, Set<Feature<?>> newFeatures, Object source)
specifier|private
specifier|static
name|void
name|checkConflict
parameter_list|(
name|String
name|earlierRequirement
parameter_list|,
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|earlierFeatures
parameter_list|,
name|String
name|newRequirement
parameter_list|,
name|Set
argument_list|<
name|Feature
argument_list|<
name|?
argument_list|>
argument_list|>
name|newFeatures
parameter_list|,
name|Object
name|source
parameter_list|)
throws|throws
name|ConflictingRequirementsException
block|{
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|newFeatures
argument_list|,
name|earlierFeatures
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConflictingRequirementsException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Annotation requires to be %s features that earlier "
operator|+
literal|"annotations required to be %s."
argument_list|,
name|newRequirement
argument_list|,
name|earlierRequirement
argument_list|)
argument_list|,
name|intersection
argument_list|(
name|newFeatures
argument_list|,
name|earlierFeatures
argument_list|)
argument_list|,
name|source
argument_list|)
throw|;
block|}
block|}
comment|/**    * Construct a new {@link java.util.Set} that is the intersection    * of the given sets.    */
DECL|method|intersection (Set<? extends T> set1, Set<? extends T> set2)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|intersection
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|set2
parameter_list|)
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|result
init|=
name|Helpers
operator|.
expr|<
name|T
operator|>
name|copyToSet
argument_list|(
name|set1
argument_list|)
decl_stmt|;
name|result
operator|.
name|retainAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

