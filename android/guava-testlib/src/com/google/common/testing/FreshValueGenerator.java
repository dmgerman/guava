begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.testing
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
operator|.
name|throwIfUnchecked
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashBasedTable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableTable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|RowSortedTable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeBasedTable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Primitives
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|UnsignedInteger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|UnsignedLong
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|AbstractInvocationHandler
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Invokable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Reflection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|TypeToken
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|ElementType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Target
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|TypeVariable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|Buffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|DoubleBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|FloatBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|LongBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ShortBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Currency
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Generates fresh instances of types that are different from each other (if possible).  *  * @author Ben Yu  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
DECL|class|FreshValueGenerator
class|class
name|FreshValueGenerator
block|{
DECL|field|GENERATORS
specifier|private
specifier|static
specifier|final
name|ImmutableMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Method
argument_list|>
name|GENERATORS
decl_stmt|;
static|static
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Method
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|FreshValueGenerator
operator|.
name|class
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|method
operator|.
name|isAnnotationPresent
argument_list|(
name|Generates
operator|.
name|class
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|method
operator|.
name|getReturnType
argument_list|()
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
name|GENERATORS
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
DECL|field|EMPTY_GENERATORS
specifier|private
specifier|static
specifier|final
name|ImmutableMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Method
argument_list|>
name|EMPTY_GENERATORS
decl_stmt|;
static|static
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Method
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|FreshValueGenerator
operator|.
name|class
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|method
operator|.
name|isAnnotationPresent
argument_list|(
name|Empty
operator|.
name|class
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|method
operator|.
name|getReturnType
argument_list|()
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
name|EMPTY_GENERATORS
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
DECL|field|freshness
specifier|private
specifier|final
name|AtomicInteger
name|freshness
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|sampleInstances
specifier|private
specifier|final
name|ListMultimap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Object
argument_list|>
name|sampleInstances
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * The freshness level at which the {@link Empty @Empty} annotated method was invoked to generate    * instance.    */
DECL|field|emptyInstanceGenerated
specifier|private
specifier|final
name|Map
argument_list|<
name|Type
argument_list|,
name|Integer
argument_list|>
name|emptyInstanceGenerated
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|addSampleInstances (Class<T> type, Iterable<? extends T> instances)
specifier|final
parameter_list|<
name|T
parameter_list|>
name|void
name|addSampleInstances
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|instances
parameter_list|)
block|{
name|sampleInstances
operator|.
name|putAll
argument_list|(
name|checkNotNull
argument_list|(
name|type
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|instances
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a fresh instance for {@code type} if possible. The returned instance could be:    *<ul>    *<li>exactly of the given type, including generic type parameters, such as    *     {@code ImmutableList<String>};    *<li>of the raw type;    *<li>null if no value can be generated.    *</ul>    */
DECL|method|generateFresh (TypeToken<?> type)
annotation|@
name|Nullable
specifier|final
name|Object
name|generateFresh
parameter_list|(
name|TypeToken
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
name|Object
name|generated
init|=
name|generate
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|generated
operator|!=
literal|null
condition|)
block|{
name|freshness
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|generated
return|;
block|}
DECL|method|generateFresh (Class<T> type)
annotation|@
name|Nullable
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|generateFresh
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|Primitives
operator|.
name|wrap
argument_list|(
name|type
argument_list|)
operator|.
name|cast
argument_list|(
name|generateFresh
argument_list|(
name|TypeToken
operator|.
name|of
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newFreshProxy (final Class<T> interfaceType)
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|newFreshProxy
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|interfaceType
parameter_list|)
block|{
name|T
name|proxy
init|=
name|newProxy
argument_list|(
name|interfaceType
argument_list|)
decl_stmt|;
name|freshness
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|proxy
return|;
block|}
comment|/**    * Generates an instance for {@code type} using the current {@link #freshness}.    * The generated instance may or may not be unique across different calls.    */
DECL|method|generate (TypeToken<?> type)
specifier|private
name|Object
name|generate
parameter_list|(
name|TypeToken
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
init|=
name|type
operator|.
name|getRawType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|samples
init|=
name|sampleInstances
operator|.
name|get
argument_list|(
name|rawType
argument_list|)
decl_stmt|;
name|Object
name|sample
init|=
name|pickInstance
argument_list|(
name|samples
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|sample
operator|!=
literal|null
condition|)
block|{
return|return
name|sample
return|;
block|}
if|if
condition|(
name|rawType
operator|.
name|isEnum
argument_list|()
condition|)
block|{
return|return
name|pickInstance
argument_list|(
name|rawType
operator|.
name|getEnumConstants
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|TypeToken
argument_list|<
name|?
argument_list|>
name|componentType
init|=
name|type
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|Object
name|array
init|=
name|Array
operator|.
name|newInstance
argument_list|(
name|componentType
operator|.
name|getRawType
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|Array
operator|.
name|set
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|generate
argument_list|(
name|componentType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
name|Method
name|emptyGenerate
init|=
name|EMPTY_GENERATORS
operator|.
name|get
argument_list|(
name|rawType
argument_list|)
decl_stmt|;
if|if
condition|(
name|emptyGenerate
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|emptyInstanceGenerated
operator|.
name|containsKey
argument_list|(
name|type
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// empty instance already generated
if|if
condition|(
name|emptyInstanceGenerated
operator|.
name|get
argument_list|(
name|type
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
operator|==
name|freshness
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// same freshness, generate again.
return|return
name|invokeGeneratorMethod
argument_list|(
name|emptyGenerate
argument_list|)
return|;
block|}
else|else
block|{
comment|// Cannot use empty generator. Proceed with other generators.
block|}
block|}
else|else
block|{
comment|// never generated empty instance for this type before.
name|Object
name|emptyInstance
init|=
name|invokeGeneratorMethod
argument_list|(
name|emptyGenerate
argument_list|)
decl_stmt|;
name|emptyInstanceGenerated
operator|.
name|put
argument_list|(
name|type
operator|.
name|getType
argument_list|()
argument_list|,
name|freshness
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|emptyInstance
return|;
block|}
block|}
name|Method
name|generate
init|=
name|GENERATORS
operator|.
name|get
argument_list|(
name|rawType
argument_list|)
decl_stmt|;
if|if
condition|(
name|generate
operator|!=
literal|null
condition|)
block|{
name|ImmutableList
argument_list|<
name|Parameter
argument_list|>
name|params
init|=
name|Invokable
operator|.
name|from
argument_list|(
name|generate
argument_list|)
operator|.
name|getParameters
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|args
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|params
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|TypeVariable
argument_list|<
name|?
argument_list|>
index|[]
name|typeVars
init|=
name|rawType
operator|.
name|getTypeParameters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TypeToken
argument_list|<
name|?
argument_list|>
name|paramType
init|=
name|type
operator|.
name|resolveType
argument_list|(
name|typeVars
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// We require all @Generates methods to either be parameter-less or accept non-null
comment|// values for their generic parameter types.
name|Object
name|argValue
init|=
name|generate
argument_list|(
name|paramType
argument_list|)
decl_stmt|;
if|if
condition|(
name|argValue
operator|==
literal|null
condition|)
block|{
comment|// When a parameter of a @Generates method cannot be created,
comment|// The type most likely is a collection.
comment|// Our distinct proxy doesn't work for collections.
comment|// So just refuse to generate.
return|return
literal|null
return|;
block|}
name|args
operator|.
name|add
argument_list|(
name|argValue
argument_list|)
expr_stmt|;
block|}
return|return
name|invokeGeneratorMethod
argument_list|(
name|generate
argument_list|,
name|args
operator|.
name|toArray
argument_list|()
argument_list|)
return|;
block|}
return|return
name|defaultGenerate
argument_list|(
name|rawType
argument_list|)
return|;
block|}
DECL|method|defaultGenerate (Class<T> rawType)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|defaultGenerate
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|rawType
parameter_list|)
block|{
if|if
condition|(
name|rawType
operator|.
name|isInterface
argument_list|()
condition|)
block|{
comment|// always create a new proxy
return|return
name|newProxy
argument_list|(
name|rawType
argument_list|)
return|;
block|}
return|return
name|ArbitraryInstances
operator|.
name|get
argument_list|(
name|rawType
argument_list|)
return|;
block|}
DECL|method|newProxy (final Class<T> interfaceType)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|newProxy
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|interfaceType
parameter_list|)
block|{
return|return
name|Reflection
operator|.
name|newProxy
argument_list|(
name|interfaceType
argument_list|,
operator|new
name|FreshInvocationHandler
argument_list|(
name|interfaceType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|invokeGeneratorMethod (Method generator, Object... args)
specifier|private
name|Object
name|invokeGeneratorMethod
parameter_list|(
name|Method
name|generator
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
try|try
block|{
return|return
name|generator
operator|.
name|invoke
argument_list|(
name|this
argument_list|,
name|args
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|class|FreshInvocationHandler
specifier|private
specifier|final
class|class
name|FreshInvocationHandler
extends|extends
name|AbstractInvocationHandler
block|{
DECL|field|identity
specifier|private
specifier|final
name|int
name|identity
init|=
name|generateInt
argument_list|()
decl_stmt|;
DECL|field|interfaceType
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|interfaceType
decl_stmt|;
DECL|method|FreshInvocationHandler (Class<?> interfaceType)
name|FreshInvocationHandler
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|interfaceType
parameter_list|)
block|{
name|this
operator|.
name|interfaceType
operator|=
name|interfaceType
expr_stmt|;
block|}
DECL|method|handleInvocation (Object proxy, Method method, Object[] args)
annotation|@
name|Override
specifier|protected
name|Object
name|handleInvocation
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
block|{
return|return
name|interfaceMethodCalled
argument_list|(
name|interfaceType
argument_list|,
name|method
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|identity
return|;
block|}
DECL|method|equals (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|FreshInvocationHandler
condition|)
block|{
name|FreshInvocationHandler
name|that
init|=
operator|(
name|FreshInvocationHandler
operator|)
name|obj
decl_stmt|;
return|return
name|identity
operator|==
name|that
operator|.
name|identity
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|paramString
argument_list|(
name|interfaceType
argument_list|,
name|identity
argument_list|)
return|;
block|}
block|}
comment|/** Subclasses can override to provide different return value for proxied interface methods. */
DECL|method|interfaceMethodCalled (Class<?> interfaceType, Method method)
name|Object
name|interfaceMethodCalled
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|interfaceType
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|pickInstance (T[] instances, T defaultValue)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|pickInstance
parameter_list|(
name|T
index|[]
name|instances
parameter_list|,
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|pickInstance
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|instances
argument_list|)
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
DECL|method|pickInstance (Collection<T> instances, T defaultValue)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|pickInstance
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|instances
parameter_list|,
name|T
name|defaultValue
parameter_list|)
block|{
if|if
condition|(
name|instances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
comment|// generateInt() is 1-based.
return|return
name|Iterables
operator|.
name|get
argument_list|(
name|instances
argument_list|,
operator|(
name|generateInt
argument_list|()
operator|-
literal|1
operator|)
operator|%
name|instances
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
DECL|method|paramString (Class<?> type, int i)
specifier|private
specifier|static
name|String
name|paramString
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|type
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|'@'
operator|+
name|i
return|;
block|}
comment|/**    * Annotates a method to be the instance generator of a certain type. The return type is the    * generated type. The method parameters correspond to the generated type's type parameters.    * For example, if the annotated method returns {@code Map<K, V>}, the method signature should be:    * {@code Map<K, V> generateMap(K key, V value)}.    */
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|METHOD
argument_list|)
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
DECL|annotation|Generates
specifier|private
annotation_defn|@interface
name|Generates
block|{}
comment|/**    * Annotates a method to generate the "empty" instance of a collection. This method should accept    * no parameter. The value it generates should be unequal to the values generated by methods    * annotated with {@link Generates}.    */
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|METHOD
argument_list|)
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
DECL|annotation|Empty
specifier|private
annotation_defn|@interface
name|Empty
block|{}
DECL|method|generateClass ()
annotation|@
name|Generates
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|generateClass
parameter_list|()
block|{
return|return
name|pickInstance
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|void
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|,
name|Iterable
operator|.
name|class
argument_list|)
argument_list|,
name|Object
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|generateObject ()
annotation|@
name|Generates
specifier|private
name|Object
name|generateObject
parameter_list|()
block|{
return|return
name|generateString
argument_list|()
return|;
block|}
DECL|method|generateNumber ()
annotation|@
name|Generates
specifier|private
name|Number
name|generateNumber
parameter_list|()
block|{
return|return
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateInt ()
annotation|@
name|Generates
specifier|private
name|int
name|generateInt
parameter_list|()
block|{
return|return
name|freshness
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|generateInteger ()
annotation|@
name|Generates
specifier|private
name|Integer
name|generateInteger
parameter_list|()
block|{
return|return
operator|new
name|Integer
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateLong ()
annotation|@
name|Generates
specifier|private
name|long
name|generateLong
parameter_list|()
block|{
return|return
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateLongObject ()
annotation|@
name|Generates
specifier|private
name|Long
name|generateLongObject
parameter_list|()
block|{
return|return
operator|new
name|Long
argument_list|(
name|generateLong
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateFloat ()
annotation|@
name|Generates
specifier|private
name|float
name|generateFloat
parameter_list|()
block|{
return|return
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateFloatObject ()
annotation|@
name|Generates
specifier|private
name|Float
name|generateFloatObject
parameter_list|()
block|{
return|return
operator|new
name|Float
argument_list|(
name|generateFloat
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateDouble ()
annotation|@
name|Generates
specifier|private
name|double
name|generateDouble
parameter_list|()
block|{
return|return
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateDoubleObject ()
annotation|@
name|Generates
specifier|private
name|Double
name|generateDoubleObject
parameter_list|()
block|{
return|return
operator|new
name|Double
argument_list|(
name|generateDouble
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateShort ()
annotation|@
name|Generates
specifier|private
name|short
name|generateShort
parameter_list|()
block|{
return|return
operator|(
name|short
operator|)
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateShortObject ()
annotation|@
name|Generates
specifier|private
name|Short
name|generateShortObject
parameter_list|()
block|{
return|return
operator|new
name|Short
argument_list|(
name|generateShort
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateByte ()
annotation|@
name|Generates
specifier|private
name|byte
name|generateByte
parameter_list|()
block|{
return|return
operator|(
name|byte
operator|)
name|generateInt
argument_list|()
return|;
block|}
DECL|method|generateByteObject ()
annotation|@
name|Generates
specifier|private
name|Byte
name|generateByteObject
parameter_list|()
block|{
return|return
operator|new
name|Byte
argument_list|(
name|generateByte
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateChar ()
annotation|@
name|Generates
specifier|private
name|char
name|generateChar
parameter_list|()
block|{
return|return
name|generateString
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|method|generateCharacter ()
annotation|@
name|Generates
specifier|private
name|Character
name|generateCharacter
parameter_list|()
block|{
return|return
operator|new
name|Character
argument_list|(
name|generateChar
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateBoolean ()
annotation|@
name|Generates
specifier|private
name|boolean
name|generateBoolean
parameter_list|()
block|{
return|return
name|generateInt
argument_list|()
operator|%
literal|2
operator|==
literal|0
return|;
block|}
DECL|method|generateBooleanObject ()
annotation|@
name|Generates
specifier|private
name|Boolean
name|generateBooleanObject
parameter_list|()
block|{
return|return
operator|new
name|Boolean
argument_list|(
name|generateBoolean
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateUnsignedInteger ()
annotation|@
name|Generates
specifier|private
name|UnsignedInteger
name|generateUnsignedInteger
parameter_list|()
block|{
return|return
name|UnsignedInteger
operator|.
name|fromIntBits
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateUnsignedLong ()
annotation|@
name|Generates
specifier|private
name|UnsignedLong
name|generateUnsignedLong
parameter_list|()
block|{
return|return
name|UnsignedLong
operator|.
name|fromLongBits
argument_list|(
name|generateLong
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateBigInteger ()
annotation|@
name|Generates
specifier|private
name|BigInteger
name|generateBigInteger
parameter_list|()
block|{
return|return
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateBigDecimal ()
annotation|@
name|Generates
specifier|private
name|BigDecimal
name|generateBigDecimal
parameter_list|()
block|{
return|return
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateCharSequence ()
annotation|@
name|Generates
specifier|private
name|CharSequence
name|generateCharSequence
parameter_list|()
block|{
return|return
name|generateString
argument_list|()
return|;
block|}
DECL|method|generateString ()
annotation|@
name|Generates
specifier|private
name|String
name|generateString
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateComparable ()
annotation|@
name|Generates
specifier|private
name|Comparable
argument_list|<
name|?
argument_list|>
name|generateComparable
parameter_list|()
block|{
return|return
name|generateString
argument_list|()
return|;
block|}
DECL|method|generatePattern ()
annotation|@
name|Generates
specifier|private
name|Pattern
name|generatePattern
parameter_list|()
block|{
return|return
name|Pattern
operator|.
name|compile
argument_list|(
name|generateString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateCharset ()
annotation|@
name|Generates
specifier|private
name|Charset
name|generateCharset
parameter_list|()
block|{
return|return
name|pickInstance
argument_list|(
name|Charset
operator|.
name|availableCharsets
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
DECL|method|generateLocale ()
annotation|@
name|Generates
specifier|private
name|Locale
name|generateLocale
parameter_list|()
block|{
return|return
name|pickInstance
argument_list|(
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
argument_list|,
name|Locale
operator|.
name|US
argument_list|)
return|;
block|}
DECL|method|generateCurrency ()
annotation|@
name|Generates
specifier|private
name|Currency
name|generateCurrency
parameter_list|()
block|{
try|try
block|{
name|Method
name|method
init|=
name|Currency
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getAvailableCurrencies"
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// getAvailableCurrencies() returns Set<Currency>.
name|Set
argument_list|<
name|Currency
argument_list|>
name|currencies
init|=
operator|(
name|Set
argument_list|<
name|Currency
argument_list|>
operator|)
name|method
operator|.
name|invoke
argument_list|(
literal|null
argument_list|)
decl_stmt|;
return|return
name|pickInstance
argument_list|(
name|currencies
argument_list|,
name|Currency
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
decl||
name|InvocationTargetException
name|notJava7
parameter_list|)
block|{
return|return
name|preJava7FreshCurrency
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|preJava7FreshCurrency ()
specifier|private
name|Currency
name|preJava7FreshCurrency
parameter_list|()
block|{
for|for
control|(
name|Set
argument_list|<
name|Locale
argument_list|>
name|uselessLocales
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
init|;
condition|;
control|)
block|{
name|Locale
name|locale
init|=
name|generateLocale
argument_list|()
decl_stmt|;
if|if
condition|(
name|uselessLocales
operator|.
name|contains
argument_list|(
name|locale
argument_list|)
condition|)
block|{
comment|// exhausted all locales
return|return
name|Currency
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
return|;
block|}
try|try
block|{
return|return
name|Currency
operator|.
name|getInstance
argument_list|(
name|locale
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|uselessLocales
operator|.
name|add
argument_list|(
name|locale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// common.base
annotation|@
name|Empty
DECL|method|generateGoogleOptional ()
specifier|private
parameter_list|<
name|T
parameter_list|>
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
argument_list|<
name|T
argument_list|>
name|generateGoogleOptional
parameter_list|()
block|{
return|return
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
operator|.
name|absent
argument_list|()
return|;
block|}
annotation|@
name|Generates
DECL|method|generateGoogleOptional (T value)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
argument_list|<
name|T
argument_list|>
name|generateGoogleOptional
parameter_list|(
name|T
name|value
parameter_list|)
block|{
return|return
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
operator|.
name|of
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|generateJoiner ()
annotation|@
name|Generates
specifier|private
name|Joiner
name|generateJoiner
parameter_list|()
block|{
return|return
name|Joiner
operator|.
name|on
argument_list|(
name|generateString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateSplitter ()
annotation|@
name|Generates
specifier|private
name|Splitter
name|generateSplitter
parameter_list|()
block|{
return|return
name|Splitter
operator|.
name|on
argument_list|(
name|generateString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateEquivalence ()
annotation|@
name|Generates
specifier|private
parameter_list|<
name|T
parameter_list|>
name|Equivalence
argument_list|<
name|T
argument_list|>
name|generateEquivalence
parameter_list|()
block|{
return|return
operator|new
name|Equivalence
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|doEquivalent
parameter_list|(
name|T
name|a
parameter_list|,
name|T
name|b
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|doHash
parameter_list|(
name|T
name|t
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|String
name|string
init|=
name|paramString
argument_list|(
name|Equivalence
operator|.
name|class
argument_list|,
name|generateInt
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|string
return|;
block|}
block|}
return|;
block|}
DECL|method|generateCharMatcher ()
annotation|@
name|Generates
specifier|private
name|CharMatcher
name|generateCharMatcher
parameter_list|()
block|{
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|String
name|string
init|=
name|paramString
argument_list|(
name|CharMatcher
operator|.
name|class
argument_list|,
name|generateInt
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|string
return|;
block|}
block|}
return|;
block|}
DECL|method|generateTicker ()
annotation|@
name|Generates
specifier|private
name|Ticker
name|generateTicker
parameter_list|()
block|{
return|return
operator|new
name|Ticker
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|read
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|String
name|string
init|=
name|paramString
argument_list|(
name|Ticker
operator|.
name|class
argument_list|,
name|generateInt
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|string
return|;
block|}
block|}
return|;
block|}
comment|// collect
DECL|method|generateComparator ()
annotation|@
name|Generates
specifier|private
parameter_list|<
name|T
parameter_list|>
name|Comparator
argument_list|<
name|T
argument_list|>
name|generateComparator
parameter_list|()
block|{
return|return
name|generateOrdering
argument_list|()
return|;
block|}
DECL|method|generateOrdering ()
annotation|@
name|Generates
specifier|private
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|generateOrdering
parameter_list|()
block|{
return|return
operator|new
name|Ordering
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|T
name|left
parameter_list|,
name|T
name|right
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|String
name|string
init|=
name|paramString
argument_list|(
name|Ordering
operator|.
name|class
argument_list|,
name|generateInt
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|string
return|;
block|}
block|}
return|;
block|}
DECL|method|generateRange ()
annotation|@
name|Empty
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Range
argument_list|<
name|C
argument_list|>
name|generateRange
parameter_list|()
block|{
return|return
name|Range
operator|.
name|all
argument_list|()
return|;
block|}
DECL|method|generateRange (C freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Range
argument_list|<
name|C
argument_list|>
name|generateRange
parameter_list|(
name|C
name|freshElement
parameter_list|)
block|{
return|return
name|Range
operator|.
name|singleton
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateIterable (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|generateIterable
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateList
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateCollection (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|generateCollection
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateList
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateList (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|generateList
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateArrayList
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateArrayList (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|generateArrayList
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|generateLinkedList (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedList
argument_list|<
name|E
argument_list|>
name|generateLinkedList
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newLinkedList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|generateImmutableList (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|generateImmutableList
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateImmutableCollection (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableCollection
argument_list|<
name|E
argument_list|>
name|generateImmutableCollection
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateImmutableList
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateSet (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|generateSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateHashSet
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateHashSet (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|generateHashSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateLinkedHashSet
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateLinkedHashSet (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|generateLinkedHashSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|set
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
DECL|method|generateImmutableSet (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|generateImmutableSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
DECL|method|generateSortedSet (E freshElement)
name|generateSortedSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateNavigableSet
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
DECL|method|generateNavigableSet (E freshElement)
name|generateNavigableSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateTreeSet
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateTreeSet ( E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|generateTreeSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
name|set
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
DECL|method|generateImmutableSortedSet (E freshElement)
name|generateImmutableSortedSet
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|ImmutableSortedSet
operator|.
name|of
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateMultiset (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Multiset
argument_list|<
name|E
argument_list|>
name|generateMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateHashMultiset
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateHashMultiset (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashMultiset
argument_list|<
name|E
argument_list|>
name|generateHashMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|HashMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|HashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
DECL|method|generateLinkedHashMultiset (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashMultiset
argument_list|<
name|E
argument_list|>
name|generateLinkedHashMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|LinkedHashMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|LinkedHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
DECL|method|generateImmutableMultiset (E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableMultiset
argument_list|<
name|E
argument_list|>
name|generateImmutableMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|ImmutableMultiset
operator|.
name|of
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateSortedMultiset ( E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|generateSortedMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|generateTreeMultiset
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateTreeMultiset ( E freshElement)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|generateTreeMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|TreeMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|freshElement
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
DECL|method|generateImmutableSortedMultiset (E freshElement)
name|generateImmutableSortedMultiset
parameter_list|(
name|E
name|freshElement
parameter_list|)
block|{
return|return
name|ImmutableSortedMultiset
operator|.
name|of
argument_list|(
name|freshElement
argument_list|)
return|;
block|}
DECL|method|generateMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateHashdMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateHashdMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateHashdMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateLinkedHashMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateLinkedHashMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateLinkedHashMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
DECL|method|generateImmutableMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateImmutableMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableMap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateConcurrentMap ()
annotation|@
name|Empty
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateConcurrentMap
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
return|;
block|}
DECL|method|generateConcurrentMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateConcurrentMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|generateSortedMap (K key, V value)
name|generateSortedMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateNavigableMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|generateNavigableMap (K key, V value)
name|generateNavigableMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateTreeMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateTreeMap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateTreeMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|ImmutableSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|generateImmutableSortedMap (K key, V value)
name|generateImmutableSortedMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateMultimap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateListMultimap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateImmutableMultimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateImmutableMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableMultimap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateListMultimap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateListMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateArrayListMultimap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateArrayListMultimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ArrayListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateArrayListMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|ArrayListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|multimap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|multimap
return|;
block|}
DECL|method|generateImmutableListMultimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateImmutableListMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableListMultimap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateSetMultimap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateSetMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateLinkedHashMultimap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateHashMultimap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateHashMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|HashMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
init|=
name|HashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|multimap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|multimap
return|;
block|}
DECL|method|generateLinkedHashMultimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateLinkedHashMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|LinkedHashMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|multimap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|multimap
return|;
block|}
DECL|method|generateImmutableSetMultimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateImmutableSetMultimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableSetMultimap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateBimap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateBimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateHashBiMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateHashBiMap (K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateHashBiMap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|HashBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|bimap
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|bimap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|bimap
return|;
block|}
DECL|method|generateImmutableBimap ( K key, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|generateImmutableBimap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableBiMap
operator|.
name|of
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateTable (R row, C column, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|generateTable
parameter_list|(
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateHashBasedTable
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|generateHashBasedTable ( R row, C column, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|HashBasedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|generateHashBasedTable
parameter_list|(
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|HashBasedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|table
init|=
name|HashBasedTable
operator|.
name|create
argument_list|()
decl_stmt|;
name|table
operator|.
name|put
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
comment|// TreeBasedTable.create() is defined as such
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|R
extends|extends
name|Comparable
parameter_list|,
name|C
extends|extends
name|Comparable
parameter_list|,
name|V
parameter_list|>
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
DECL|method|generateRowSortedTable (R row, C column, V value)
name|generateRowSortedTable
parameter_list|(
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|generateTreeBasedTable
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
comment|// TreeBasedTable.create() is defined as such
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|R
extends|extends
name|Comparable
parameter_list|,
name|C
extends|extends
name|Comparable
parameter_list|,
name|V
parameter_list|>
name|TreeBasedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
DECL|method|generateTreeBasedTable (R row, C column, V value)
name|generateTreeBasedTable
parameter_list|(
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|TreeBasedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|table
init|=
name|TreeBasedTable
operator|.
name|create
argument_list|()
decl_stmt|;
name|table
operator|.
name|put
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
DECL|method|generateImmutableTable ( R row, C column, V value)
annotation|@
name|Generates
specifier|private
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|ImmutableTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|generateImmutableTable
parameter_list|(
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|ImmutableTable
operator|.
name|of
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|// common.reflect
DECL|method|generateTypeToken ()
annotation|@
name|Generates
specifier|private
name|TypeToken
argument_list|<
name|?
argument_list|>
name|generateTypeToken
parameter_list|()
block|{
return|return
name|TypeToken
operator|.
name|of
argument_list|(
name|generateClass
argument_list|()
argument_list|)
return|;
block|}
comment|// io types
DECL|method|generateFile ()
annotation|@
name|Generates
specifier|private
name|File
name|generateFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|generateString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateByteArrayInputStream ()
annotation|@
name|Generates
specifier|private
specifier|static
name|ByteArrayInputStream
name|generateByteArrayInputStream
parameter_list|()
block|{
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
return|;
block|}
DECL|method|generateInputStream ()
annotation|@
name|Generates
specifier|private
specifier|static
name|InputStream
name|generateInputStream
parameter_list|()
block|{
return|return
name|generateByteArrayInputStream
argument_list|()
return|;
block|}
DECL|method|generateStringReader ()
annotation|@
name|Generates
specifier|private
name|StringReader
name|generateStringReader
parameter_list|()
block|{
return|return
operator|new
name|StringReader
argument_list|(
name|generateString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateReader ()
annotation|@
name|Generates
specifier|private
name|Reader
name|generateReader
parameter_list|()
block|{
return|return
name|generateStringReader
argument_list|()
return|;
block|}
DECL|method|generateReadable ()
annotation|@
name|Generates
specifier|private
name|Readable
name|generateReadable
parameter_list|()
block|{
return|return
name|generateReader
argument_list|()
return|;
block|}
DECL|method|generateBuffer ()
annotation|@
name|Generates
specifier|private
name|Buffer
name|generateBuffer
parameter_list|()
block|{
return|return
name|generateCharBuffer
argument_list|()
return|;
block|}
DECL|method|generateCharBuffer ()
annotation|@
name|Generates
specifier|private
name|CharBuffer
name|generateCharBuffer
parameter_list|()
block|{
return|return
name|CharBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateByteBuffer ()
annotation|@
name|Generates
specifier|private
name|ByteBuffer
name|generateByteBuffer
parameter_list|()
block|{
return|return
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateShortBuffer ()
annotation|@
name|Generates
specifier|private
name|ShortBuffer
name|generateShortBuffer
parameter_list|()
block|{
return|return
name|ShortBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateIntBuffer ()
annotation|@
name|Generates
specifier|private
name|IntBuffer
name|generateIntBuffer
parameter_list|()
block|{
return|return
name|IntBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateLongBuffer ()
annotation|@
name|Generates
specifier|private
name|LongBuffer
name|generateLongBuffer
parameter_list|()
block|{
return|return
name|LongBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateFloatBuffer ()
annotation|@
name|Generates
specifier|private
name|FloatBuffer
name|generateFloatBuffer
parameter_list|()
block|{
return|return
name|FloatBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
DECL|method|generateDoubleBuffer ()
annotation|@
name|Generates
specifier|private
name|DoubleBuffer
name|generateDoubleBuffer
parameter_list|()
block|{
return|return
name|DoubleBuffer
operator|.
name|allocate
argument_list|(
name|generateInt
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

