begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Enumerates several algorithms providing equivalent functionality to {@link Quantiles}, for use in  * {@link QuantilesBenchmark}. These algorithms each calculate either a single quantile or multiple  * quantiles. All algorithms modify the dataset they are given (the cost of a copy to avoid this  * will be constant across algorithms).  *  * @author Pete Gillin  * @since 20.0  */
end_comment

begin_enum
DECL|enum|QuantilesAlgorithm
enum|enum
name|QuantilesAlgorithm
block|{
comment|/**    * Sorts the dataset, and picks values from it. When computing multiple quantiles, we sort once    * and pick multiple values.    */
DECL|enumConstant|SORTING
name|SORTING
block|{
annotation|@
name|Override
name|double
name|singleQuantile
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|dataset
argument_list|)
expr_stmt|;
return|return
name|singleQuantileFromSorted
argument_list|(
name|index
argument_list|,
name|scale
argument_list|,
name|dataset
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|multipleQuantiles
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|dataset
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|indexes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|singleQuantileFromSorted
argument_list|(
name|index
argument_list|,
name|scale
argument_list|,
name|dataset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|double
name|singleQuantileFromSorted
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
name|long
name|numerator
init|=
operator|(
name|long
operator|)
name|index
operator|*
operator|(
name|dataset
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|positionFloor
init|=
operator|(
name|int
operator|)
name|LongMath
operator|.
name|divide
argument_list|(
name|numerator
argument_list|,
name|scale
argument_list|,
name|RoundingMode
operator|.
name|DOWN
argument_list|)
decl_stmt|;
name|int
name|remainder
init|=
call|(
name|int
call|)
argument_list|(
name|numerator
operator|-
name|positionFloor
operator|*
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
return|return
name|dataset
index|[
name|positionFloor
index|]
return|;
block|}
else|else
block|{
name|double
name|positionFrac
init|=
operator|(
name|double
operator|)
name|remainder
operator|/
name|scale
decl_stmt|;
return|return
name|dataset
index|[
name|positionFloor
index|]
operator|+
name|positionFrac
operator|*
operator|(
name|dataset
index|[
name|positionFloor
operator|+
literal|1
index|]
operator|-
name|dataset
index|[
name|positionFloor
index|]
operator|)
return|;
block|}
block|}
block|}
block|,
comment|/**    * Uses quickselect. When calculating multiple quantiles, each quickselect starts from scratch.    */
DECL|enumConstant|QUICKSELECT
name|QUICKSELECT
block|{
annotation|@
name|Override
name|double
name|singleQuantile
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
name|long
name|numerator
init|=
operator|(
name|long
operator|)
name|index
operator|*
operator|(
name|dataset
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|positionFloor
init|=
operator|(
name|int
operator|)
name|LongMath
operator|.
name|divide
argument_list|(
name|numerator
argument_list|,
name|scale
argument_list|,
name|RoundingMode
operator|.
name|DOWN
argument_list|)
decl_stmt|;
name|int
name|remainder
init|=
call|(
name|int
call|)
argument_list|(
name|numerator
operator|-
name|positionFloor
operator|*
name|scale
argument_list|)
decl_stmt|;
name|double
name|percentileFloor
init|=
name|select
argument_list|(
name|positionFloor
argument_list|,
name|dataset
argument_list|)
decl_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
return|return
name|percentileFloor
return|;
block|}
else|else
block|{
name|double
name|percentileCeiling
init|=
name|getMinValue
argument_list|(
name|dataset
argument_list|,
name|positionFloor
operator|+
literal|1
argument_list|)
decl_stmt|;
name|double
name|positionFrac
init|=
operator|(
name|double
operator|)
name|remainder
operator|/
name|scale
decl_stmt|;
return|return
name|percentileFloor
operator|+
name|positionFrac
operator|*
operator|(
name|percentileCeiling
operator|-
name|percentileFloor
operator|)
return|;
block|}
block|}
annotation|@
name|Override
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|multipleQuantiles
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|indexes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|singleQuantile
argument_list|(
name|index
argument_list|,
name|scale
argument_list|,
name|dataset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
block|,
comment|/** Uses {@link Quantiles}. */
DECL|enumConstant|TARGET
name|TARGET
block|{
annotation|@
name|Override
name|double
name|singleQuantile
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
return|return
name|Quantiles
operator|.
name|scale
argument_list|(
name|scale
argument_list|)
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|computeInPlace
argument_list|(
name|dataset
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|multipleQuantiles
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
block|{
return|return
name|Quantiles
operator|.
name|scale
argument_list|(
name|scale
argument_list|)
operator|.
name|indexes
argument_list|(
name|indexes
argument_list|)
operator|.
name|computeInPlace
argument_list|(
name|dataset
argument_list|)
return|;
block|}
block|}
block|,   ;
comment|/**    * Calculates a single quantile. Equivalent to {@code    * Quantiles.scale(scale).index(index).computeInPlace(dataset)}.    */
DECL|method|singleQuantile (int index, int scale, double[] dataset)
specifier|abstract
name|double
name|singleQuantile
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
function_decl|;
comment|/**    * Calculates multiple quantiles. Equivalent to {@code    * Quantiles.scale(scale).indexes(indexes).computeInPlace(dataset)}.    */
DECL|method|multipleQuantiles ( Collection<Integer> indexes, int scale, double[] dataset)
specifier|abstract
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|multipleQuantiles
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|,
name|int
name|scale
parameter_list|,
name|double
index|[]
name|dataset
parameter_list|)
function_decl|;
DECL|method|getMinValue (double[] array, int from)
specifier|static
name|double
name|getMinValue
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|// This is basically a copy of com.google.math.Rank#getMinValue, with a small change in the
comment|// method signature: we always search to the end of the array.
name|int
name|min
init|=
name|from
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
operator|+
literal|1
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|array
index|[
name|min
index|]
operator|>
name|array
index|[
name|i
index|]
condition|)
block|{
name|min
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|array
index|[
name|min
index|]
return|;
block|}
DECL|method|select (int k, double[] array)
specifier|static
name|double
name|select
parameter_list|(
name|int
name|k
parameter_list|,
name|double
index|[]
name|array
parameter_list|)
block|{
comment|// This is basically a copy of com.google.math.Rank#select, with a small change in the method
comment|// signature: we make k 0-based rather than 1-based; and we drop from and to, and always work on
comment|// the whole array.
name|int
name|from
init|=
literal|0
decl_stmt|;
name|int
name|to
init|=
name|array
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|to
operator|<=
name|from
operator|+
literal|1
condition|)
block|{
comment|// Two or less elements left.
if|if
condition|(
name|to
operator|==
name|from
operator|+
literal|1
operator|&&
name|array
index|[
name|to
index|]
operator|<
name|array
index|[
name|from
index|]
condition|)
block|{
comment|// Exactly two elements left.
name|swap
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|array
index|[
name|k
index|]
return|;
block|}
else|else
block|{
name|int
name|midIndex
init|=
operator|(
name|from
operator|+
name|to
operator|)
operator|>>>
literal|1
decl_stmt|;
comment|// Choose the median of the elements at the from, to and mid indexes,
comment|// and rearrange so that array[from]<=array[from+1], and
comment|// array[to] => array[from + 1].
name|swap
argument_list|(
name|array
argument_list|,
name|midIndex
argument_list|,
name|from
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
index|[
name|from
index|]
operator|>
name|array
index|[
name|to
index|]
condition|)
block|{
name|swap
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|array
index|[
name|from
operator|+
literal|1
index|]
operator|>
name|array
index|[
name|to
index|]
condition|)
block|{
name|swap
argument_list|(
name|array
argument_list|,
name|from
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|array
index|[
name|from
index|]
operator|>
name|array
index|[
name|from
operator|+
literal|1
index|]
condition|)
block|{
name|swap
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|from
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Perform a partition with the selected median.
name|int
name|low
init|=
name|from
operator|+
literal|1
operator|,
name|high
operator|=
name|to
expr_stmt|;
comment|// Indexes for partitioning.
name|double
name|partition
init|=
name|array
index|[
name|from
operator|+
literal|1
index|]
decl_stmt|;
comment|// Choose partitioning element.
while|while
condition|(
literal|true
condition|)
block|{
comment|// Skip the elements smaller than the partition.
do|do
block|{
name|low
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|array
index|[
name|low
index|]
operator|<
name|partition
condition|)
do|;
comment|// Skip the elements larger than the partition.
do|do
block|{
name|high
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|array
index|[
name|high
index|]
operator|>
name|partition
condition|)
do|;
if|if
condition|(
name|high
operator|<
name|low
condition|)
block|{
break|break;
comment|// Pointers crossed. Partitioning complete.
block|}
name|swap
argument_list|(
name|array
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
comment|// End of innermost loop.
block|}
name|array
index|[
name|from
operator|+
literal|1
index|]
operator|=
name|array
index|[
name|high
index|]
expr_stmt|;
comment|// Insert partitioning element.
name|array
index|[
name|high
index|]
operator|=
name|partition
expr_stmt|;
comment|// Continue the partition that contains the kth element.
if|if
condition|(
name|high
operator|>=
name|k
condition|)
block|{
name|to
operator|=
name|high
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|<=
name|k
condition|)
block|{
name|from
operator|=
name|low
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|swap (double[] array, int i, int j)
specifier|private
specifier|static
name|void
name|swap
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
comment|// This is a copy of com.google.math.Rank#swap.
name|double
name|temp
init|=
name|array
index|[
name|i
index|]
decl_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_enum

end_unit

