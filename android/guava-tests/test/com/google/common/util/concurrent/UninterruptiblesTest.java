begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not  * use this file except in compliance with the License. You may obtain a copy of  * the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|InterruptionUtil
operator|.
name|repeatedlyInterruptTestThread
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|joinUninterruptibly
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|putUninterruptibly
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|takeUninterruptibly
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|tryAcquireUninterruptibly
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|TearDown
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|TearDownStack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_comment
comment|/**  * Tests for {@link Uninterruptibles}.  *  * @author Anthony Zana  */
end_comment

begin_class
DECL|class|UninterruptiblesTest
specifier|public
class|class
name|UninterruptiblesTest
extends|extends
name|TestCase
block|{
DECL|field|EXPECTED_TAKE
specifier|private
specifier|static
specifier|final
name|String
name|EXPECTED_TAKE
init|=
literal|"expectedTake"
decl_stmt|;
comment|/**    * Timeout to use when we don't expect the timeout to expire.    */
DECL|field|LONG_DELAY_MS
specifier|private
specifier|static
specifier|final
name|long
name|LONG_DELAY_MS
init|=
literal|2500
decl_stmt|;
DECL|field|SLEEP_SLACK
specifier|private
specifier|static
specifier|final
name|long
name|SLEEP_SLACK
init|=
literal|2
decl_stmt|;
DECL|field|tearDownStack
specifier|private
specifier|final
name|TearDownStack
name|tearDownStack
init|=
operator|new
name|TearDownStack
argument_list|()
decl_stmt|;
comment|// NOTE: All durations in these tests are expressed in milliseconds
annotation|@
name|Override
DECL|method|setUp ()
specifier|protected
name|void
name|setUp
parameter_list|()
block|{
comment|// Clear any previous interrupt before running the test.
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Thread interrupted on test entry. "
operator|+
literal|"Some test probably didn't clear the interrupt state"
argument_list|)
throw|;
block|}
name|tearDownStack
operator|.
name|addTearDown
argument_list|(
operator|new
name|TearDown
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|tearDown
parameter_list|()
block|{
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tearDown ()
specifier|protected
name|void
name|tearDown
parameter_list|()
block|{
name|tearDownStack
operator|.
name|runTearDown
argument_list|()
expr_stmt|;
block|}
DECL|method|testNull ()
specifier|public
name|void
name|testNull
parameter_list|()
throws|throws
name|Exception
block|{
operator|new
name|NullPointerTester
argument_list|()
operator|.
name|setDefault
argument_list|(
name|CountDownLatch
operator|.
name|class
argument_list|,
operator|new
name|CountDownLatch
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|setDefault
argument_list|(
name|Semaphore
operator|.
name|class
argument_list|,
operator|new
name|Semaphore
argument_list|(
literal|999
argument_list|)
argument_list|)
operator|.
name|testAllPublicStaticMethods
argument_list|(
name|Uninterruptibles
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// IncrementableCountDownLatch.await() tests
comment|// CountDownLatch.await() tests
comment|// BlockingQueue.put() tests
DECL|method|testPutWithNoWait ()
specifier|public
name|void
name|testPutWithNoWait
parameter_list|()
block|{
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
init|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
literal|999
argument_list|)
decl_stmt|;
name|putUninterruptibly
argument_list|(
name|queue
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|queue
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutNoInterrupt ()
specifier|public
name|void
name|testPutNoInterrupt
parameter_list|()
block|{
name|TimedPutQueue
name|queue
init|=
name|TimedPutQueue
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|queue
operator|.
name|putSuccessfully
argument_list|()
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testPutSingleInterrupt ()
specifier|public
name|void
name|testPutSingleInterrupt
parameter_list|()
block|{
name|TimedPutQueue
name|queue
init|=
name|TimedPutQueue
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|queue
operator|.
name|putSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testPutMultiInterrupt ()
specifier|public
name|void
name|testPutMultiInterrupt
parameter_list|()
block|{
name|TimedPutQueue
name|queue
init|=
name|TimedPutQueue
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|queue
operator|.
name|putSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
comment|// BlockingQueue.take() tests
DECL|method|testTakeWithNoWait ()
specifier|public
name|void
name|testTakeWithNoWait
parameter_list|()
block|{
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
init|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|queue
operator|.
name|offer
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|takeUninterruptibly
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|testTakeNoInterrupt ()
specifier|public
name|void
name|testTakeNoInterrupt
parameter_list|()
block|{
name|TimedTakeQueue
name|queue
init|=
name|TimedTakeQueue
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|queue
operator|.
name|takeSuccessfully
argument_list|()
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTakeSingleInterrupt ()
specifier|public
name|void
name|testTakeSingleInterrupt
parameter_list|()
block|{
name|TimedTakeQueue
name|queue
init|=
name|TimedTakeQueue
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|queue
operator|.
name|takeSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTakeMultiInterrupt ()
specifier|public
name|void
name|testTakeMultiInterrupt
parameter_list|()
block|{
name|TimedTakeQueue
name|queue
init|=
name|TimedTakeQueue
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|queue
operator|.
name|takeSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
comment|// join() tests
DECL|method|testJoinWithNoWait ()
specifier|public
name|void
name|testJoinWithNoWait
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|JoinTarget
argument_list|(
literal|15
argument_list|)
argument_list|)
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|thread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|,
operator|-
literal|42
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|,
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|testJoinNoInterrupt ()
specifier|public
name|void
name|testJoinNoInterrupt
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|()
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutNoInterruptNotExpired ()
specifier|public
name|void
name|testJoinTimeoutNoInterruptNotExpired
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutNoInterruptExpired ()
specifier|public
name|void
name|testJoinTimeoutNoInterruptExpired
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|thread
operator|.
name|joinUnsuccessfully
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinSingleInterrupt ()
specifier|public
name|void
name|testJoinSingleInterrupt
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutSingleInterruptNoExpire ()
specifier|public
name|void
name|testJoinTimeoutSingleInterruptNoExpire
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutSingleInterruptExpired ()
specifier|public
name|void
name|testJoinTimeoutSingleInterruptExpired
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinUnsuccessfully
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinMultiInterrupt ()
specifier|public
name|void
name|testJoinMultiInterrupt
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|()
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutMultiInterruptNoExpire ()
specifier|public
name|void
name|testJoinTimeoutMultiInterruptNoExpire
parameter_list|()
block|{
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testJoinTimeoutMultiInterruptExpired ()
specifier|public
name|void
name|testJoinTimeoutMultiInterruptExpired
parameter_list|()
block|{
comment|/*      * We don't "need" to schedule a thread completion at all here, but by doing      * so, we come the closest we can to testing that the wait time is      * appropriately decreased on each progressive join() call.      */
name|TimedThread
name|thread
init|=
name|TimedThread
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|thread
operator|.
name|joinUnsuccessfully
argument_list|(
literal|70
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
comment|// sleep() Tests
DECL|method|testSleepNoInterrupt ()
specifier|public
name|void
name|testSleepNoInterrupt
parameter_list|()
block|{
name|sleepSuccessfully
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|method|testSleepSingleInterrupt ()
specifier|public
name|void
name|testSleepSingleInterrupt
parameter_list|()
block|{
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sleepSuccessfully
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testSleepMultiInterrupt ()
specifier|public
name|void
name|testSleepMultiInterrupt
parameter_list|()
block|{
name|repeatedlyInterruptTestThread
argument_list|(
literal|10
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|sleepSuccessfully
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
comment|// Semaphore.tryAcquire() tests
DECL|method|testTryAcquireWithNoWait ()
specifier|public
name|void
name|testTryAcquireWithNoWait
parameter_list|()
block|{
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|Semaphore
name|semaphore
init|=
operator|new
name|Semaphore
argument_list|(
literal|99
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
literal|0
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
operator|-
literal|42
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutNoInterruptNotExpired ()
specifier|public
name|void
name|testTryAcquireTimeoutNoInterruptNotExpired
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutNoInterruptExpired ()
specifier|public
name|void
name|testTryAcquireTimeoutNoInterruptExpired
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutSingleInterruptNoExpire ()
specifier|public
name|void
name|testTryAcquireTimeoutSingleInterruptNoExpire
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutSingleInterruptExpired ()
specifier|public
name|void
name|testTryAcquireTimeoutSingleInterruptExpired
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutMultiInterruptNoExpire ()
specifier|public
name|void
name|testTryAcquireTimeoutMultiInterruptNoExpire
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutMultiInterruptExpired ()
specifier|public
name|void
name|testTryAcquireTimeoutMultiInterruptExpired
parameter_list|()
block|{
comment|/*      * We don't "need" to schedule a release() call at all here, but by doing      * so, we come the closest we can to testing that the wait time is      * appropriately decreased on each progressive tryAcquire() call.      */
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|70
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireWithNoWaitMultiPermit ()
specifier|public
name|void
name|testTryAcquireWithNoWaitMultiPermit
parameter_list|()
block|{
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|Semaphore
name|semaphore
init|=
operator|new
name|Semaphore
argument_list|(
literal|99
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
literal|10
argument_list|,
operator|-
literal|42
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
literal|10
argument_list|,
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutNoInterruptNotExpiredMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutNoInterruptNotExpiredMultiPermit
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
literal|10
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutNoInterruptExpiredMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutNoInterruptExpiredMultiPermit
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|10
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|assertNotInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutSingleInterruptNoExpireMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutSingleInterruptNoExpireMultiPermit
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
literal|10
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutSingleInterruptExpiredMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutSingleInterruptExpiredMultiPermit
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|requestInterruptIn
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|10
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutMultiInterruptNoExpireMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutMultiInterruptNoExpireMultiPermit
parameter_list|()
block|{
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireSuccessfully
argument_list|(
literal|10
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
DECL|method|testTryAcquireTimeoutMultiInterruptExpiredMultiPermit ()
specifier|public
name|void
name|testTryAcquireTimeoutMultiInterruptExpiredMultiPermit
parameter_list|()
block|{
comment|/*      * We don't "need" to schedule a release() call at all here, but by doing      * so, we come the closest we can to testing that the wait time is      * appropriately decreased on each progressive tryAcquire() call.      */
name|TimedSemaphore
name|semaphore
init|=
name|TimedSemaphore
operator|.
name|createWithDelay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
decl_stmt|;
name|repeatedlyInterruptTestThread
argument_list|(
literal|20
argument_list|,
name|tearDownStack
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|tryAcquireUnsuccessfully
argument_list|(
literal|10
argument_list|,
literal|70
argument_list|)
expr_stmt|;
name|assertInterrupted
argument_list|()
expr_stmt|;
block|}
comment|/**    * Wrapper around {@link Stopwatch} which also contains an    * "expected completion time." Creating a {@code Completion} starts the    * underlying stopwatch.    */
DECL|class|Completion
specifier|private
specifier|static
specifier|final
class|class
name|Completion
block|{
DECL|field|stopwatch
specifier|final
name|Stopwatch
name|stopwatch
decl_stmt|;
DECL|field|expectedCompletionWaitMillis
specifier|final
name|long
name|expectedCompletionWaitMillis
decl_stmt|;
DECL|method|Completion (long expectedCompletionWaitMillis)
name|Completion
parameter_list|(
name|long
name|expectedCompletionWaitMillis
parameter_list|)
block|{
name|this
operator|.
name|expectedCompletionWaitMillis
operator|=
name|expectedCompletionWaitMillis
expr_stmt|;
name|stopwatch
operator|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
expr_stmt|;
block|}
comment|/**      * Asserts that the expected completion time has passed (and not "too much"      * time beyond that).      */
DECL|method|assertCompletionExpected ()
name|void
name|assertCompletionExpected
parameter_list|()
block|{
name|assertAtLeastTimePassed
argument_list|(
name|stopwatch
argument_list|,
name|expectedCompletionWaitMillis
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|expectedCompletionWaitMillis
operator|+
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Asserts that at least {@code timeout} has passed but the expected      * completion time has not.      */
DECL|method|assertCompletionNotExpected (long timeout)
name|void
name|assertCompletionNotExpected
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|timeout
operator|<
name|expectedCompletionWaitMillis
argument_list|)
expr_stmt|;
name|assertAtLeastTimePassed
argument_list|(
name|stopwatch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|assertTimeNotPassed
argument_list|(
name|stopwatch
argument_list|,
name|expectedCompletionWaitMillis
argument_list|)
expr_stmt|;
block|}
DECL|method|assertAtLeastTimePassed ( Stopwatch stopwatch, long expectedMillis)
specifier|private
specifier|static
name|void
name|assertAtLeastTimePassed
parameter_list|(
name|Stopwatch
name|stopwatch
parameter_list|,
name|long
name|expectedMillis
parameter_list|)
block|{
name|long
name|elapsedMillis
init|=
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|MILLISECONDS
argument_list|)
decl_stmt|;
comment|/*        * The "+ 5" below is to permit, say, sleep(10) to sleep only 9 milliseconds. We see such        * behavior sometimes when running these tests publicly as part of Guava. "+ 5" is probably        * more generous than it needs to be.        */
name|assertTrue
argument_list|(
literal|"Expected elapsed millis to be>= "
operator|+
name|expectedMillis
operator|+
literal|" but was "
operator|+
name|elapsedMillis
argument_list|,
name|elapsedMillis
operator|+
literal|5
operator|>=
name|expectedMillis
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO(cpovirk): Split this into separate CountDownLatch and IncrementableCountDownLatch classes.
comment|/**    * Manages a {@link BlockingQueue} and associated timings for a {@code put}    * call.    */
DECL|class|TimedPutQueue
specifier|private
specifier|static
specifier|final
class|class
name|TimedPutQueue
block|{
DECL|field|queue
specifier|final
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
decl_stmt|;
DECL|field|completed
specifier|final
name|Completion
name|completed
decl_stmt|;
comment|/**      * Creates a {@link EnableWrites} which open up a spot for a {@code put} to      * succeed in {@code countdownInMillis}.      */
DECL|method|createWithDelay (long countdownInMillis)
specifier|static
name|TimedPutQueue
name|createWithDelay
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
return|return
operator|new
name|TimedPutQueue
argument_list|(
name|countdownInMillis
argument_list|)
return|;
block|}
DECL|method|TimedPutQueue (long countdownInMillis)
specifier|private
name|TimedPutQueue
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|queue
operator|.
name|offer
argument_list|(
literal|"blocksPutCallsUntilRemoved"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|completed
operator|=
operator|new
name|Completion
argument_list|(
name|countdownInMillis
argument_list|)
expr_stmt|;
name|scheduleEnableWrites
argument_list|(
name|this
operator|.
name|queue
argument_list|,
name|countdownInMillis
argument_list|)
expr_stmt|;
block|}
comment|/**      * Perform a {@code put} and assert that operation completed in the expected      * timeframe.      */
DECL|method|putSuccessfully ()
name|void
name|putSuccessfully
parameter_list|()
block|{
name|putUninterruptibly
argument_list|(
name|queue
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|queue
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|scheduleEnableWrites ( BlockingQueue<String> queue, long countdownInMillis)
specifier|private
specifier|static
name|void
name|scheduleEnableWrites
parameter_list|(
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
parameter_list|,
name|long
name|countdownInMillis
parameter_list|)
block|{
name|Runnable
name|toRun
init|=
operator|new
name|EnableWrites
argument_list|(
name|queue
argument_list|,
name|countdownInMillis
argument_list|)
decl_stmt|;
comment|// TODO(cpovirk): automatically fail the test if this thread throws
name|Thread
name|enablerThread
init|=
operator|new
name|Thread
argument_list|(
name|toRun
argument_list|)
decl_stmt|;
name|enablerThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Manages a {@link BlockingQueue} and associated timings for a {@code take}    * call.    */
DECL|class|TimedTakeQueue
specifier|private
specifier|static
specifier|final
class|class
name|TimedTakeQueue
block|{
DECL|field|queue
specifier|final
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
decl_stmt|;
DECL|field|completed
specifier|final
name|Completion
name|completed
decl_stmt|;
comment|/**      * Creates a {@link EnableReads} which insert an element for a {@code take}      * to receive in {@code countdownInMillis}.      */
DECL|method|createWithDelay (long countdownInMillis)
specifier|static
name|TimedTakeQueue
name|createWithDelay
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
return|return
operator|new
name|TimedTakeQueue
argument_list|(
name|countdownInMillis
argument_list|)
return|;
block|}
DECL|method|TimedTakeQueue (long countdownInMillis)
specifier|private
name|TimedTakeQueue
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|completed
operator|=
operator|new
name|Completion
argument_list|(
name|countdownInMillis
argument_list|)
expr_stmt|;
name|scheduleEnableReads
argument_list|(
name|this
operator|.
name|queue
argument_list|,
name|countdownInMillis
argument_list|)
expr_stmt|;
block|}
comment|/**      * Perform a {@code take} and assert that operation completed in the      * expected timeframe.      */
DECL|method|takeSuccessfully ()
name|void
name|takeSuccessfully
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|EXPECTED_TAKE
argument_list|,
name|takeUninterruptibly
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|queue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|scheduleEnableReads ( BlockingQueue<String> queue, long countdownInMillis)
specifier|private
specifier|static
name|void
name|scheduleEnableReads
parameter_list|(
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
parameter_list|,
name|long
name|countdownInMillis
parameter_list|)
block|{
name|Runnable
name|toRun
init|=
operator|new
name|EnableReads
argument_list|(
name|queue
argument_list|,
name|countdownInMillis
argument_list|)
decl_stmt|;
comment|// TODO(cpovirk): automatically fail the test if this thread throws
name|Thread
name|enablerThread
init|=
operator|new
name|Thread
argument_list|(
name|toRun
argument_list|)
decl_stmt|;
name|enablerThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Manages a {@link Semaphore} and associated timings.    */
DECL|class|TimedSemaphore
specifier|private
specifier|static
specifier|final
class|class
name|TimedSemaphore
block|{
DECL|field|semaphore
specifier|final
name|Semaphore
name|semaphore
decl_stmt|;
DECL|field|completed
specifier|final
name|Completion
name|completed
decl_stmt|;
comment|/**      * Create a {@link Release} which will release a semaphore permit in      * {@code countdownInMillis}.      */
DECL|method|createWithDelay (long countdownInMillis)
specifier|static
name|TimedSemaphore
name|createWithDelay
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
return|return
operator|new
name|TimedSemaphore
argument_list|(
name|countdownInMillis
argument_list|)
return|;
block|}
DECL|method|TimedSemaphore (long countdownInMillis)
specifier|private
name|TimedSemaphore
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
name|this
operator|.
name|semaphore
operator|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|completed
operator|=
operator|new
name|Completion
argument_list|(
name|countdownInMillis
argument_list|)
expr_stmt|;
name|scheduleRelease
argument_list|(
name|countdownInMillis
argument_list|)
expr_stmt|;
block|}
comment|/**      * Requests a permit from the semaphore with a timeout and asserts that operation completed in      * the expected timeframe.      */
DECL|method|tryAcquireSuccessfully (long timeoutMillis)
name|void
name|tryAcquireSuccessfully
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
block|}
comment|/**      * Requests a permit from the semaphore with a timeout and asserts that the wait returned      * within the expected timeout.      */
DECL|method|tryAcquireUnsuccessfully (long timeoutMillis)
specifier|private
name|void
name|tryAcquireUnsuccessfully
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionNotExpected
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
block|}
DECL|method|tryAcquireSuccessfully (int permits, long timeoutMillis)
name|void
name|tryAcquireSuccessfully
parameter_list|(
name|int
name|permits
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
name|permits
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
block|}
DECL|method|tryAcquireUnsuccessfully (int permits, long timeoutMillis)
specifier|private
name|void
name|tryAcquireUnsuccessfully
parameter_list|(
name|int
name|permits
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|tryAcquireUninterruptibly
argument_list|(
name|semaphore
argument_list|,
name|permits
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionNotExpected
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
block|}
DECL|method|scheduleRelease (long countdownInMillis)
specifier|private
name|void
name|scheduleRelease
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
name|DelayedActionRunnable
name|toRun
init|=
operator|new
name|Release
argument_list|(
name|semaphore
argument_list|,
name|countdownInMillis
argument_list|)
decl_stmt|;
comment|// TODO(cpovirk): automatically fail the test if this thread throws
name|Thread
name|releaserThread
init|=
operator|new
name|Thread
argument_list|(
name|toRun
argument_list|)
decl_stmt|;
name|releaserThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|DelayedActionRunnable
specifier|private
specifier|abstract
specifier|static
class|class
name|DelayedActionRunnable
implements|implements
name|Runnable
block|{
DECL|field|tMinus
specifier|private
specifier|final
name|long
name|tMinus
decl_stmt|;
DECL|method|DelayedActionRunnable (long tMinus)
specifier|protected
name|DelayedActionRunnable
parameter_list|(
name|long
name|tMinus
parameter_list|)
block|{
name|this
operator|.
name|tMinus
operator|=
name|tMinus
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|doAction
argument_list|()
expr_stmt|;
block|}
DECL|method|doAction ()
specifier|protected
specifier|abstract
name|void
name|doAction
parameter_list|()
function_decl|;
block|}
DECL|class|CountDown
specifier|private
specifier|static
class|class
name|CountDown
extends|extends
name|DelayedActionRunnable
block|{
DECL|field|latch
specifier|private
specifier|final
name|CountDownLatch
name|latch
decl_stmt|;
DECL|method|CountDown (CountDownLatch latch, long tMinus)
specifier|public
name|CountDown
parameter_list|(
name|CountDownLatch
name|latch
parameter_list|,
name|long
name|tMinus
parameter_list|)
block|{
name|super
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
name|this
operator|.
name|latch
operator|=
name|latch
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doAction ()
specifier|protected
name|void
name|doAction
parameter_list|()
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EnableWrites
specifier|private
specifier|static
class|class
name|EnableWrites
extends|extends
name|DelayedActionRunnable
block|{
DECL|field|queue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
decl_stmt|;
DECL|method|EnableWrites (BlockingQueue<String> queue, long tMinus)
specifier|public
name|EnableWrites
parameter_list|(
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
parameter_list|,
name|long
name|tMinus
parameter_list|)
block|{
name|super
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|queue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|queue
operator|.
name|offer
argument_list|(
literal|"shouldBeRejected"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doAction ()
specifier|protected
name|void
name|doAction
parameter_list|()
block|{
name|assertNotNull
argument_list|(
name|queue
operator|.
name|remove
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|EnableReads
specifier|private
specifier|static
class|class
name|EnableReads
extends|extends
name|DelayedActionRunnable
block|{
DECL|field|queue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
decl_stmt|;
DECL|method|EnableReads (BlockingQueue<String> queue, long tMinus)
specifier|public
name|EnableReads
parameter_list|(
name|BlockingQueue
argument_list|<
name|String
argument_list|>
name|queue
parameter_list|,
name|long
name|tMinus
parameter_list|)
block|{
name|super
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|queue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doAction ()
specifier|protected
name|void
name|doAction
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|queue
operator|.
name|offer
argument_list|(
name|EXPECTED_TAKE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|TimedThread
specifier|private
specifier|static
specifier|final
class|class
name|TimedThread
block|{
DECL|field|thread
specifier|private
specifier|final
name|Thread
name|thread
decl_stmt|;
DECL|field|completed
specifier|private
specifier|final
name|Completion
name|completed
decl_stmt|;
DECL|method|createWithDelay (long countdownInMillis)
specifier|static
name|TimedThread
name|createWithDelay
parameter_list|(
name|long
name|countdownInMillis
parameter_list|)
block|{
return|return
operator|new
name|TimedThread
argument_list|(
name|countdownInMillis
argument_list|)
return|;
block|}
DECL|method|TimedThread (long expectedCompletionWaitMillis)
specifier|private
name|TimedThread
parameter_list|(
name|long
name|expectedCompletionWaitMillis
parameter_list|)
block|{
name|completed
operator|=
operator|new
name|Completion
argument_list|(
name|expectedCompletionWaitMillis
argument_list|)
expr_stmt|;
name|thread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|JoinTarget
argument_list|(
name|expectedCompletionWaitMillis
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|joinSuccessfully ()
name|void
name|joinSuccessfully
parameter_list|()
block|{
name|Uninterruptibles
operator|.
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|thread
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|joinSuccessfully (long timeoutMillis)
name|void
name|joinSuccessfully
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
block|{
name|Uninterruptibles
operator|.
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|thread
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|joinUnsuccessfully (long timeoutMillis)
name|void
name|joinUnsuccessfully
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
block|{
name|Uninterruptibles
operator|.
name|joinUninterruptibly
argument_list|(
name|thread
argument_list|,
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionNotExpected
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
operator|.
name|equals
argument_list|(
name|thread
operator|.
name|getState
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|JoinTarget
specifier|private
specifier|static
class|class
name|JoinTarget
extends|extends
name|DelayedActionRunnable
block|{
DECL|method|JoinTarget (long tMinus)
specifier|public
name|JoinTarget
parameter_list|(
name|long
name|tMinus
parameter_list|)
block|{
name|super
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doAction ()
specifier|protected
name|void
name|doAction
parameter_list|()
block|{     }
block|}
DECL|class|Release
specifier|private
specifier|static
class|class
name|Release
extends|extends
name|DelayedActionRunnable
block|{
DECL|field|semaphore
specifier|private
specifier|final
name|Semaphore
name|semaphore
decl_stmt|;
DECL|method|Release (Semaphore semaphore, long tMinus)
specifier|public
name|Release
parameter_list|(
name|Semaphore
name|semaphore
parameter_list|,
name|long
name|tMinus
parameter_list|)
block|{
name|super
argument_list|(
name|tMinus
argument_list|)
expr_stmt|;
name|this
operator|.
name|semaphore
operator|=
name|semaphore
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doAction ()
specifier|protected
name|void
name|doAction
parameter_list|()
block|{
name|semaphore
operator|.
name|release
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sleepSuccessfully (long sleepMillis)
specifier|private
specifier|static
name|void
name|sleepSuccessfully
parameter_list|(
name|long
name|sleepMillis
parameter_list|)
block|{
name|Completion
name|completed
init|=
operator|new
name|Completion
argument_list|(
name|sleepMillis
operator|-
name|SLEEP_SLACK
argument_list|)
decl_stmt|;
name|Uninterruptibles
operator|.
name|sleepUninterruptibly
argument_list|(
name|sleepMillis
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|completed
operator|.
name|assertCompletionExpected
argument_list|()
expr_stmt|;
block|}
DECL|method|assertTimeNotPassed (Stopwatch stopwatch, long timelimitMillis)
specifier|private
specifier|static
name|void
name|assertTimeNotPassed
parameter_list|(
name|Stopwatch
name|stopwatch
parameter_list|,
name|long
name|timelimitMillis
parameter_list|)
block|{
name|long
name|elapsedMillis
init|=
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|elapsedMillis
operator|<
name|timelimitMillis
argument_list|)
expr_stmt|;
block|}
comment|/**    * Await an interrupt, then clear the interrupt status. Similar to    * {@code assertTrue(Thread.interrupted())} except that this version tolerates    * late interrupts.    */
DECL|method|assertInterrupted ()
specifier|private
specifier|static
name|void
name|assertInterrupted
parameter_list|()
block|{
try|try
block|{
comment|/*        * The sleep() will end immediately if we've already been interrupted or        * wait patiently for the interrupt if not.        */
name|Thread
operator|.
name|sleep
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Dude, where's my interrupt?"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|assertNotInterrupted ()
specifier|private
specifier|static
name|void
name|assertNotInterrupted
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|Thread
operator|.
name|interrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|requestInterruptIn (long millis)
specifier|private
specifier|static
name|void
name|requestInterruptIn
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
name|InterruptionUtil
operator|.
name|requestInterruptIn
argument_list|(
name|millis
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

