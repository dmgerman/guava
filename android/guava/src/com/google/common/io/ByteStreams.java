begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_comment
comment|/**  * Provides utility methods for working with byte arrays and I/O streams.  *  * @author Chris Nokleberg  * @author Colin Decker  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|ByteStreams
specifier|public
specifier|final
class|class
name|ByteStreams
block|{
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|8192
decl_stmt|;
comment|/** Creates a new byte array for buffering reads or writes. */
DECL|method|createBuffer ()
specifier|static
name|byte
index|[]
name|createBuffer
parameter_list|()
block|{
return|return
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
return|;
block|}
comment|/**    * There are three methods to implement {@link FileChannel#transferTo(long, long,    * WritableByteChannel)}:    *    *<ol>    *<li>Use sendfile(2) or equivalent. Requires that both the input channel and the output    *       channel have their own file descriptors. Generally this only happens when both channels    *       are files or sockets. This performs zero copies - the bytes never enter userspace.    *<li>Use mmap(2) or equivalent. Requires that either the input channel or the output channel    *       have file descriptors. Bytes are copied from the file into a kernel buffer, then directly    *       into the other buffer (userspace). Note that if the file is very large, a naive    *       implementation will effectively put the whole file in memory. On many systems with paging    *       and virtual memory, this is not a problem - because it is mapped read-only, the kernel    *       can always page it to disk "for free". However, on systems where killing processes    *       happens all the time in normal conditions (i.e., android) the OS must make a tradeoff    *       between paging memory and killing other processes - so allocating a gigantic buffer and    *       then sequentially accessing it could result in other processes dying. This is solvable    *       via madvise(2), but that obviously doesn't exist in java.    *<li>Ordinary copy. Kernel copies bytes into a kernel buffer, from a kernel buffer into a    *       userspace buffer (byte[] or ByteBuffer), then copies them from that buffer into the    *       destination channel.    *</ol>    *    * This value is intended to be large enough to make the overhead of system calls negligible,    * without being so large that it causes problems for systems with atypical memory management if    * approaches 2 or 3 are used.    */
DECL|field|ZERO_COPY_CHUNK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|ZERO_COPY_CHUNK_SIZE
init|=
literal|512
operator|*
literal|1024
decl_stmt|;
DECL|method|ByteStreams ()
specifier|private
name|ByteStreams
parameter_list|()
block|{}
comment|/**    * Copies all bytes from the input stream to the output stream. Does not close or flush either    * stream.    *    * @param from the input stream to read from    * @param to the output stream to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|copy (InputStream from, OutputStream to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|InputStream
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
name|createBuffer
argument_list|()
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|r
init|=
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|total
operator|+=
name|r
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Copies all bytes from the readable channel to the writable channel. Does not close or flush    * either channel.    *    * @param from the readable channel to read from    * @param to the writable channel to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|copy (ReadableByteChannel from, WritableByteChannel to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|ReadableByteChannel
name|from
parameter_list|,
name|WritableByteChannel
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|instanceof
name|FileChannel
condition|)
block|{
name|FileChannel
name|sourceChannel
init|=
operator|(
name|FileChannel
operator|)
name|from
decl_stmt|;
name|long
name|oldPosition
init|=
name|sourceChannel
operator|.
name|position
argument_list|()
decl_stmt|;
name|long
name|position
init|=
name|oldPosition
decl_stmt|;
name|long
name|copied
decl_stmt|;
do|do
block|{
name|copied
operator|=
name|sourceChannel
operator|.
name|transferTo
argument_list|(
name|position
argument_list|,
name|ZERO_COPY_CHUNK_SIZE
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|position
operator|+=
name|copied
expr_stmt|;
name|sourceChannel
operator|.
name|position
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|copied
operator|>
literal|0
operator|||
name|position
operator|<
name|sourceChannel
operator|.
name|size
argument_list|()
condition|)
do|;
return|return
name|position
operator|-
name|oldPosition
return|;
block|}
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|createBuffer
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|total
operator|+=
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/** Max array length on JVM */
DECL|field|MAX_ARRAY_LEN
specifier|private
specifier|static
specifier|final
name|int
name|MAX_ARRAY_LEN
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|8
decl_stmt|;
comment|/**    * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have    * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given    * input stream.    */
DECL|method|toByteArrayInternal (InputStream in, Deque<byte[]> bufs, int totalLen)
specifier|private
specifier|static
name|byte
index|[]
name|toByteArrayInternal
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|Deque
argument_list|<
name|byte
index|[]
argument_list|>
name|bufs
parameter_list|,
name|int
name|totalLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ByteArrayOutputStream uses a single byte array as a buffer and copies it to a new, larger
comment|// buffer each time it needs more space. By contrast, this method just allocates a new buffer
comment|// each time it needs more space and then copies all the buffers to a single array at the end.
comment|// Like ByteArrayOutputStream, the size of each successive buffer is larger than the previous
comment|// one (doubling each time, in this case), to reduce the number of allocations and potentially
comment|// the number of calls to read() needed.
if|if
condition|(
name|totalLen
operator|==
name|MAX_ARRAY_LEN
condition|)
block|{
comment|// true iff called from toByteArray(in, MAX_ARRAY_LEN - 1)
return|return
name|toByteArrayAtMaxLength
argument_list|(
name|in
argument_list|,
name|bufs
argument_list|)
return|;
block|}
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|min
argument_list|(
name|BUFFER_SIZE
argument_list|,
name|MAX_ARRAY_LEN
operator|-
name|totalLen
argument_list|)
index|]
decl_stmt|;
name|bufs
operator|.
name|add
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|// always OK to completely fill buf; its size plus the rest of bufs is never more than
comment|// MAX_ARRAY_LEN
while|while
condition|(
operator|(
name|r
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|buf
operator|.
name|length
operator|-
name|off
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|totalLen
operator|+=
name|r
operator|)
operator|==
name|MAX_ARRAY_LEN
condition|)
block|{
return|return
name|toByteArrayAtMaxLength
argument_list|(
name|in
argument_list|,
name|bufs
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|off
operator|+=
name|r
operator|)
operator|==
name|buf
operator|.
name|length
condition|)
block|{
comment|// need a new buffer if we're going to read any more
name|int
name|nextBufLen
init|=
name|IntMath
operator|.
name|saturatedMultiply
argument_list|(
name|buf
operator|.
name|length
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|Math
operator|.
name|min
argument_list|(
name|nextBufLen
argument_list|,
name|MAX_ARRAY_LEN
operator|-
name|totalLen
argument_list|)
index|]
expr_stmt|;
name|bufs
operator|.
name|add
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|combineBuffers
argument_list|(
name|bufs
argument_list|,
name|totalLen
argument_list|)
return|;
block|}
DECL|method|combineBuffers (Iterable<byte[]> bufs, int totalLen)
specifier|private
specifier|static
name|byte
index|[]
name|combineBuffers
parameter_list|(
name|Iterable
argument_list|<
name|byte
index|[]
argument_list|>
name|bufs
parameter_list|,
name|int
name|totalLen
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|totalLen
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|byte
index|[]
argument_list|>
name|iter
init|=
name|bufs
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|remaining
init|=
name|totalLen
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|buf
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// since uncopied bytes remain, it's guaranteed there is a next
name|int
name|bytesToCopy
init|=
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|resultOffset
init|=
name|totalLen
operator|-
name|remaining
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|resultOffset
argument_list|,
name|bytesToCopy
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|bytesToCopy
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Called when toByteArray has not finished reading and cannot read anymore bytes into a single    * array. Typically throws OOME but may, if the stream was somehow exactly the right length,    * return an array of max length.    */
DECL|method|toByteArrayAtMaxLength (InputStream in, Iterable<byte[]> bufs)
specifier|private
specifier|static
name|byte
index|[]
name|toByteArrayAtMaxLength
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|Iterable
argument_list|<
name|byte
index|[]
argument_list|>
name|bufs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|combineBuffers
argument_list|(
name|bufs
argument_list|,
name|MAX_ARRAY_LEN
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
literal|"input is too large to fit in a byte array"
argument_list|)
throw|;
block|}
block|}
comment|/** Large enough to never need to expand, given the geometric progression of buffer sizes. */
DECL|field|TO_BYTE_ARRAY_DEQUE_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|TO_BYTE_ARRAY_DEQUE_SIZE
init|=
literal|22
decl_stmt|;
comment|/**    * Reads all bytes from an input stream into a byte array. Does not close the stream.    *    * @param in the input stream to read from    * @return a byte array containing all the bytes from the stream    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray (InputStream in)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|toByteArrayInternal
argument_list|(
name|in
argument_list|,
operator|new
name|ArrayDeque
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|TO_BYTE_ARRAY_DEQUE_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Reads all bytes from an input stream into a byte array. The given expected size is used to    * create an initial byte array, but if the actual number of bytes read from the stream differs,    * the correct result will be returned anyway.    */
DECL|method|toByteArray (InputStream in, long expectedSize)
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|expectedSize
parameter_list|)
throws|throws
name|IOException
block|{
name|checkArgument
argument_list|(
name|expectedSize
operator|>=
literal|0
argument_list|,
literal|"expectedSize (%s) must be non-negative"
argument_list|,
name|expectedSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedSize
operator|>
name|MAX_ARRAY_LEN
condition|)
block|{
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|expectedSize
operator|+
literal|" bytes is too large to fit in a byte array"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|expectedSize
index|]
decl_stmt|;
name|int
name|remaining
init|=
operator|(
name|int
operator|)
name|expectedSize
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|int
name|off
init|=
operator|(
name|int
operator|)
name|expectedSize
operator|-
name|remaining
decl_stmt|;
name|int
name|read
init|=
name|in
operator|.
name|read
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|==
operator|-
literal|1
condition|)
block|{
comment|// end of stream before reading expectedSize bytes
comment|// just return the bytes read so far
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|)
return|;
block|}
name|remaining
operator|-=
name|read
expr_stmt|;
block|}
comment|// bytes is now full
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|bytes
return|;
block|}
comment|// the stream was longer, so read the rest normally
name|Deque
argument_list|<
name|byte
index|[]
argument_list|>
name|bufs
init|=
operator|new
name|ArrayDeque
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|TO_BYTE_ARRAY_DEQUE_SIZE
argument_list|)
decl_stmt|;
name|bufs
operator|.
name|add
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|bufs
operator|.
name|add
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|b
block|}
argument_list|)
expr_stmt|;
return|return
name|toByteArrayInternal
argument_list|(
name|in
argument_list|,
name|bufs
argument_list|,
name|bytes
operator|.
name|length
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**    * Reads and discards data from the given {@code InputStream} until the end of the stream is    * reached. Returns the total number of bytes read. Does not close the stream.    *    * @since 20.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|exhaust (InputStream in)
specifier|public
specifier|static
name|long
name|exhaust
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|total
init|=
literal|0
decl_stmt|;
name|long
name|read
decl_stmt|;
name|byte
index|[]
name|buf
init|=
name|createBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|read
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|total
operator|+=
name|read
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array from the    * beginning.    */
DECL|method|newDataInput (byte[] bytes)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
name|newDataInput
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array,    * starting at the given position.    *    * @throws IndexOutOfBoundsException if {@code start} is negative or greater than the length of    *     the array    */
DECL|method|newDataInput (byte[] bytes, int start)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|newDataInput
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|start
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the given {@code    * ByteArrayInputStream}. The given input stream is not reset before being read from by the    * returned {@code ByteArrayDataInput}.    *    * @since 17.0    */
DECL|method|newDataInput (ByteArrayInputStream byteArrayInputStream)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|ByteArrayInputStream
name|byteArrayInputStream
parameter_list|)
block|{
return|return
operator|new
name|ByteArrayDataInputStream
argument_list|(
name|checkNotNull
argument_list|(
name|byteArrayInputStream
argument_list|)
argument_list|)
return|;
block|}
DECL|class|ByteArrayDataInputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataInputStream
implements|implements
name|ByteArrayDataInput
block|{
DECL|field|input
specifier|final
name|DataInput
name|input
decl_stmt|;
DECL|method|ByteArrayDataInputStream (ByteArrayInputStream byteArrayInputStream)
name|ByteArrayDataInputStream
parameter_list|(
name|ByteArrayInputStream
name|byteArrayInputStream
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
operator|new
name|DataInputStream
argument_list|(
name|byteArrayInputStream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readFully (byte b[])
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFully (byte b[], int off, int len)
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|skipBytes (int n)
specifier|public
name|int
name|skipBytes
parameter_list|(
name|int
name|n
parameter_list|)
block|{
try|try
block|{
return|return
name|input
operator|.
name|skipBytes
argument_list|(
name|n
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readBoolean ()
specifier|public
name|boolean
name|readBoolean
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readBoolean
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readByte ()
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readUnsignedByte ()
specifier|public
name|int
name|readUnsignedByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readShort ()
specifier|public
name|short
name|readShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readUnsignedShort ()
specifier|public
name|int
name|readUnsignedShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readChar ()
specifier|public
name|char
name|readChar
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readChar
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readInt ()
specifier|public
name|int
name|readInt
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readInt
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readLong ()
specifier|public
name|long
name|readLong
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLong
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFloat ()
specifier|public
name|float
name|readFloat
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readFloat
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readDouble ()
specifier|public
name|double
name|readDouble
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readDouble
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readLine ()
specifier|public
name|String
name|readLine
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLine
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readUTF ()
specifier|public
name|String
name|readUTF
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUTF
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Returns a new {@link ByteArrayDataOutput} instance with a default size. */
DECL|method|newDataOutput ()
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|()
block|{
return|return
name|newDataOutput
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance sized to hold {@code size} bytes before    * resizing.    *    * @throws IllegalArgumentException if {@code size} is negative    */
DECL|method|newDataOutput (int size)
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|(
name|int
name|size
parameter_list|)
block|{
comment|// When called at high frequency, boxing size generates too much garbage,
comment|// so avoid doing that if we can.
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid size: %s"
argument_list|,
name|size
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|newDataOutput
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance which writes to the given {@code    * ByteArrayOutputStream}. The given output stream is not reset before being written to by the    * returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.    *    *<p>Note that if the given output stream was not empty or is modified after the {@code    * ByteArrayDataOutput} is created, the contract for {@link ByteArrayDataOutput#toByteArray} will    * not be honored (the bytes returned in the byte array may not be exactly what was written via    * calls to {@code ByteArrayDataOutput}).    *    * @since 17.0    */
DECL|method|newDataOutput (ByteArrayOutputStream byteArrayOutputSteam)
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|(
name|ByteArrayOutputStream
name|byteArrayOutputSteam
parameter_list|)
block|{
return|return
operator|new
name|ByteArrayDataOutputStream
argument_list|(
name|checkNotNull
argument_list|(
name|byteArrayOutputSteam
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// for writeBytes
DECL|class|ByteArrayDataOutputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataOutputStream
implements|implements
name|ByteArrayDataOutput
block|{
DECL|field|output
specifier|final
name|DataOutput
name|output
decl_stmt|;
DECL|field|byteArrayOutputSteam
specifier|final
name|ByteArrayOutputStream
name|byteArrayOutputSteam
decl_stmt|;
DECL|method|ByteArrayDataOutputStream (ByteArrayOutputStream byteArrayOutputSteam)
name|ByteArrayDataOutputStream
parameter_list|(
name|ByteArrayOutputStream
name|byteArrayOutputSteam
parameter_list|)
block|{
name|this
operator|.
name|byteArrayOutputSteam
operator|=
name|byteArrayOutputSteam
expr_stmt|;
name|output
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|byteArrayOutputSteam
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (byte[] b)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeBoolean (boolean v)
specifier|public
name|void
name|writeBoolean
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBoolean
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeByte (int v)
specifier|public
name|void
name|writeByte
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeBytes (String s)
specifier|public
name|void
name|writeBytes
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBytes
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeChar (int v)
specifier|public
name|void
name|writeChar
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChar
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeChars (String s)
specifier|public
name|void
name|writeChars
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChars
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeDouble (double v)
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeDouble
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeFloat (float v)
specifier|public
name|void
name|writeFloat
parameter_list|(
name|float
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeFloat
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeInt (int v)
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeLong (long v)
specifier|public
name|void
name|writeLong
parameter_list|(
name|long
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeLong
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeShort (int v)
specifier|public
name|void
name|writeShort
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeShort
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeUTF (String s)
specifier|public
name|void
name|writeUTF
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeUTF
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toByteArray ()
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|byteArrayOutputSteam
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
DECL|field|NULL_OUTPUT_STREAM
specifier|private
specifier|static
specifier|final
name|OutputStream
name|NULL_OUTPUT_STREAM
init|=
operator|new
name|OutputStream
argument_list|()
block|{
comment|/** Discards the specified byte. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{}
comment|/** Discards the specified byte array. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/** Discards the specified byte array. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteStreams.nullOutputStream()"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns an {@link OutputStream} that simply discards written bytes.    *    * @since 14.0 (since 1.0 as com.google.common.io.NullOutputStream)    */
DECL|method|nullOutputStream ()
specifier|public
specifier|static
name|OutputStream
name|nullOutputStream
parameter_list|()
block|{
return|return
name|NULL_OUTPUT_STREAM
return|;
block|}
comment|/**    * Wraps a {@link InputStream}, limiting the number of bytes which can be read.    *    * @param in the input stream to be wrapped    * @param limit the maximum number of bytes to be read    * @return a length-limited {@link InputStream}    * @since 14.0 (since 1.0 as com.google.common.io.LimitInputStream)    */
DECL|method|limit (InputStream in, long limit)
specifier|public
specifier|static
name|InputStream
name|limit
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
return|return
operator|new
name|LimitedInputStream
argument_list|(
name|in
argument_list|,
name|limit
argument_list|)
return|;
block|}
DECL|class|LimitedInputStream
specifier|private
specifier|static
specifier|final
class|class
name|LimitedInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|left
specifier|private
name|long
name|left
decl_stmt|;
DECL|field|mark
specifier|private
name|long
name|mark
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|LimitedInputStream (InputStream in, long limit)
name|LimitedInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|limit
operator|>=
literal|0
argument_list|,
literal|"limit must be non-negative"
argument_list|)
expr_stmt|;
name|left
operator|=
name|limit
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|in
operator|.
name|available
argument_list|()
argument_list|,
name|left
argument_list|)
return|;
block|}
comment|// it's okay to mark even if mark isn't supported, as reset won't work
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{
name|in
operator|.
name|mark
argument_list|(
name|readLimit
argument_list|)
expr_stmt|;
name|mark
operator|=
name|left
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
operator|--
name|left
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
name|left
operator|-=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark not supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mark
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark not set"
argument_list|)
throw|;
block|}
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
name|left
operator|=
name|mark
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|n
operator|=
name|Math
operator|.
name|min
argument_list|(
name|n
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|long
name|skipped
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|left
operator|-=
name|skipped
expr_stmt|;
return|return
name|skipped
return|;
block|}
block|}
comment|/**    * Attempts to read enough bytes from the stream to fill the given byte array, with the same    * behavior as {@link DataInput#readFully(byte[])}. Does not close the stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @throws EOFException if this stream reaches the end before reading all the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully (InputStream in, byte[] b)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempts to read {@code len} bytes from the stream into the given array starting at {@code    * off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not close    * the stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @param off an int specifying the offset into the data.    * @param len an int specifying the number of bytes to read.    * @throws EOFException if this stream reaches the end before reading all the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully (InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|read
init|=
name|read
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
name|len
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"reached end of stream after reading "
operator|+
name|read
operator|+
literal|" bytes; "
operator|+
name|len
operator|+
literal|" bytes expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Discards {@code n} bytes of data from the input stream. This method will block until the full    * amount has been skipped. Does not close the stream.    *    * @param in the input stream to read from    * @param n the number of bytes to skip    * @throws EOFException if this stream reaches the end before skipping all the bytes    * @throws IOException if an I/O error occurs, or the stream does not support skipping    */
DECL|method|skipFully (InputStream in, long n)
specifier|public
specifier|static
name|void
name|skipFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|skipped
init|=
name|skipUpTo
argument_list|(
name|in
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|skipped
operator|<
name|n
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"reached end of stream after skipping "
operator|+
name|skipped
operator|+
literal|" bytes; "
operator|+
name|n
operator|+
literal|" bytes expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Discards up to {@code n} bytes of data from the input stream. This method will block until    * either the full amount has been skipped or until the end of the stream is reached, whichever    * happens first. Returns the total number of bytes skipped.    */
DECL|method|skipUpTo (InputStream in, final long n)
specifier|static
name|long
name|skipUpTo
parameter_list|(
name|InputStream
name|in
parameter_list|,
specifier|final
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|totalSkipped
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|buf
init|=
name|createBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|totalSkipped
operator|<
name|n
condition|)
block|{
name|long
name|remaining
init|=
name|n
operator|-
name|totalSkipped
decl_stmt|;
name|long
name|skipped
init|=
name|skipSafely
argument_list|(
name|in
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|skipped
operator|==
literal|0
condition|)
block|{
comment|// Do a buffered read since skipSafely could return 0 repeatedly, for example if
comment|// in.available() always returns 0 (the default).
name|int
name|skip
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|skipped
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Reached EOF
break|break;
block|}
block|}
name|totalSkipped
operator|+=
name|skipped
expr_stmt|;
block|}
return|return
name|totalSkipped
return|;
block|}
comment|/**    * Attempts to skip up to {@code n} bytes from the given input stream, but not more than {@code    * in.available()} bytes. This prevents {@code FileInputStream} from skipping more bytes than    * actually remain in the file, something that it {@linkplain java.io.FileInputStream#skip(long)    * specifies} it can do in its Javadoc despite the fact that it is violating the contract of    * {@code InputStream.skip()}.    */
DECL|method|skipSafely (InputStream in, long n)
specifier|private
specifier|static
name|long
name|skipSafely
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|available
init|=
name|in
operator|.
name|available
argument_list|()
decl_stmt|;
return|return
name|available
operator|==
literal|0
condition|?
literal|0
else|:
name|in
operator|.
name|skip
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|available
argument_list|,
name|n
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Process the bytes of the given input stream using the given processor.    *    * @param input the input stream to process    * @param processor the object to which to pass the bytes of the stream    * @return the result of the byte processor    * @throws IOException if an I/O error occurs    * @since 14.0    */
annotation|@
name|CanIgnoreReturnValue
comment|// some processors won't return a useful result
DECL|method|readBytes (InputStream input, ByteProcessor<T> processor)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readBytes
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|ByteProcessor
argument_list|<
name|T
argument_list|>
name|processor
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|processor
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
name|createBuffer
argument_list|()
decl_stmt|;
name|int
name|read
decl_stmt|;
do|do
block|{
name|read
operator|=
name|input
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|read
operator|!=
operator|-
literal|1
operator|&&
name|processor
operator|.
name|processBytes
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|read
argument_list|)
condition|)
do|;
return|return
name|processor
operator|.
name|getResult
argument_list|()
return|;
block|}
comment|/**    * Reads some bytes from an input stream and stores them into the buffer array {@code b}. This    * method blocks until {@code len} bytes of input data have been read into the array, or end of    * file is detected. The number of bytes read is returned, possibly zero. Does not close the    * stream.    *    *<p>A caller can detect EOF if the number of bytes read is less than {@code len}. All subsequent    * calls on the same stream will return zero.    *    *<p>If {@code b} is null, a {@code NullPointerException} is thrown. If {@code off} is negative,    * or {@code len} is negative, or {@code off+len} is greater than the length of the array {@code    * b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no bytes    * are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next one    * into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to {@code len}.    *    * @param in the input stream to read from    * @param b the buffer into which the data is read    * @param off an int specifying the offset into the data    * @param len an int specifying the number of bytes to read    * @return the number of bytes read    * @throws IOException if an I/O error occurs    */
annotation|@
name|CanIgnoreReturnValue
comment|// Sometimes you don't care how many bytes you actually read, I guess.
comment|// (You know that it's either going to read len bytes or stop at EOF.)
DECL|method|read (InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|int
name|read
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len is negative"
argument_list|)
throw|;
block|}
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|total
argument_list|,
name|len
operator|-
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|total
operator|+=
name|result
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
block|}
end_class

end_unit

