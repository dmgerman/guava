begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.reflect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|transform
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|AnnotatedElement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericArrayType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericDeclaration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Proxy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|TypeVariable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|WildcardType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * Utilities for working with {@link Type}.  *  * @author Ben Yu  */
end_comment

begin_class
DECL|class|Types
specifier|final
class|class
name|Types
block|{
comment|/** Class#toString without the "class " and "interface " prefixes */
DECL|field|TYPE_NAME
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Type
argument_list|,
name|String
argument_list|>
name|TYPE_NAME
init|=
operator|new
name|Function
argument_list|<
name|Type
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|Type
name|from
parameter_list|)
block|{
return|return
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|typeName
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|COMMA_JOINER
specifier|private
specifier|static
specifier|final
name|Joiner
name|COMMA_JOINER
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|useForNull
argument_list|(
literal|"null"
argument_list|)
decl_stmt|;
comment|/** Returns the array type of {@code componentType}. */
DECL|method|newArrayType (Type componentType)
specifier|static
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
if|if
condition|(
name|componentType
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|wildcard
init|=
operator|(
name|WildcardType
operator|)
name|componentType
decl_stmt|;
name|Type
index|[]
name|lowerBounds
init|=
name|wildcard
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|lowerBounds
operator|.
name|length
operator|<=
literal|1
argument_list|,
literal|"Wildcard cannot have more than one lower bounds."
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|supertypeOf
argument_list|(
name|newArrayType
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|Type
index|[]
name|upperBounds
init|=
name|wildcard
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|upperBounds
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"Wildcard should have only one upper bound."
argument_list|)
expr_stmt|;
return|return
name|subtypeOf
argument_list|(
name|newArrayType
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|newArrayType
argument_list|(
name|componentType
argument_list|)
return|;
block|}
comment|/**    * Returns a type where {@code rawType} is parameterized by {@code arguments} and is owned by    * {@code ownerType}.    */
DECL|method|newParameterizedTypeWithOwner ( @ullableDecl Type ownerType, Class<?> rawType, Type... arguments)
specifier|static
name|ParameterizedType
name|newParameterizedTypeWithOwner
parameter_list|(
annotation|@
name|NullableDecl
name|Type
name|ownerType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
modifier|...
name|arguments
parameter_list|)
block|{
if|if
condition|(
name|ownerType
operator|==
literal|null
condition|)
block|{
return|return
name|newParameterizedType
argument_list|(
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|// ParameterizedTypeImpl constructor already checks, but we want to throw NPE before IAE
name|checkNotNull
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
operator|!=
literal|null
argument_list|,
literal|"Owner type for unenclosed %s"
argument_list|,
name|rawType
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParameterizedTypeImpl
argument_list|(
name|ownerType
argument_list|,
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/** Returns a type where {@code rawType} is parameterized by {@code arguments}. */
DECL|method|newParameterizedType (Class<?> rawType, Type... arguments)
specifier|static
name|ParameterizedType
name|newParameterizedType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|ParameterizedTypeImpl
argument_list|(
name|ClassOwnership
operator|.
name|JVM_BEHAVIOR
operator|.
name|getOwnerType
argument_list|(
name|rawType
argument_list|)
argument_list|,
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/** Decides what owner type to use for constructing {@link ParameterizedType} from a raw class. */
DECL|enum|ClassOwnership
specifier|private
enum|enum
name|ClassOwnership
block|{
DECL|enumConstant|OWNED_BY_ENCLOSING_CLASS
name|OWNED_BY_ENCLOSING_CLASS
block|{
annotation|@
name|Override
annotation|@
name|NullableDecl
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
block|{
return|return
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|LOCAL_CLASS_HAS_NO_OWNER
name|LOCAL_CLASS_HAS_NO_OWNER
block|{
annotation|@
name|Override
annotation|@
name|NullableDecl
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
block|{
if|if
condition|(
name|rawType
operator|.
name|isLocalClass
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
return|;
block|}
block|}
block|}
block|;
annotation|@
name|NullableDecl
DECL|method|getOwnerType (Class<?> rawType)
specifier|abstract
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
function_decl|;
DECL|field|JVM_BEHAVIOR
specifier|static
specifier|final
name|ClassOwnership
name|JVM_BEHAVIOR
init|=
name|detectJvmBehavior
argument_list|()
decl_stmt|;
DECL|method|detectJvmBehavior ()
specifier|private
specifier|static
name|ClassOwnership
name|detectJvmBehavior
parameter_list|()
block|{
class|class
name|LocalClass
parameter_list|<
name|T
parameter_list|>
block|{}
name|Class
argument_list|<
name|?
argument_list|>
name|subclass
init|=
operator|new
name|LocalClass
argument_list|<
name|String
argument_list|>
argument_list|()
block|{}
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|ParameterizedType
name|parameterizedType
init|=
operator|(
name|ParameterizedType
operator|)
name|subclass
operator|.
name|getGenericSuperclass
argument_list|()
decl_stmt|;
for|for
control|(
name|ClassOwnership
name|behavior
range|:
name|ClassOwnership
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|behavior
operator|.
name|getOwnerType
argument_list|(
name|LocalClass
operator|.
name|class
argument_list|)
operator|==
name|parameterizedType
operator|.
name|getOwnerType
argument_list|()
condition|)
block|{
return|return
name|behavior
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**    * Returns a new {@link TypeVariable} that belongs to {@code declaration} with {@code name} and    * {@code bounds}.    */
DECL|method|newArtificialTypeVariable ( D declaration, String name, Type... bounds)
specifier|static
parameter_list|<
name|D
extends|extends
name|GenericDeclaration
parameter_list|>
name|TypeVariable
argument_list|<
name|D
argument_list|>
name|newArtificialTypeVariable
parameter_list|(
name|D
name|declaration
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|newTypeVariableImpl
argument_list|(
name|declaration
argument_list|,
name|name
argument_list|,
operator|(
name|bounds
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
operator|new
name|Type
index|[]
block|{
name|Object
operator|.
name|class
block|}
else|:
name|bounds
argument_list|)
return|;
block|}
comment|/** Returns a new {@link WildcardType} with {@code upperBound}. */
annotation|@
name|VisibleForTesting
DECL|method|subtypeOf (Type upperBound)
specifier|static
name|WildcardType
name|subtypeOf
parameter_list|(
name|Type
name|upperBound
parameter_list|)
block|{
return|return
operator|new
name|WildcardTypeImpl
argument_list|(
operator|new
name|Type
index|[
literal|0
index|]
argument_list|,
operator|new
name|Type
index|[]
block|{
name|upperBound
block|}
argument_list|)
return|;
block|}
comment|/** Returns a new {@link WildcardType} with {@code lowerBound}. */
annotation|@
name|VisibleForTesting
DECL|method|supertypeOf (Type lowerBound)
specifier|static
name|WildcardType
name|supertypeOf
parameter_list|(
name|Type
name|lowerBound
parameter_list|)
block|{
return|return
operator|new
name|WildcardTypeImpl
argument_list|(
operator|new
name|Type
index|[]
block|{
name|lowerBound
block|}
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Object
operator|.
name|class
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns human readable string representation of {@code type}.    *    *<p>The format is subject to change.    */
DECL|method|toString (Type type)
specifier|static
name|String
name|toString
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|instanceof
name|Class
operator|)
condition|?
operator|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
operator|)
operator|.
name|getName
argument_list|()
else|:
name|type
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|NullableDecl
DECL|method|getComponentType (Type type)
specifier|static
name|Type
name|getComponentType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|Type
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
operator|new
name|TypeVisitor
argument_list|()
block|{
annotation|@
name|Override
name|void
name|visitTypeVariable
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|subtypeOfComponentType
argument_list|(
name|t
operator|.
name|getBounds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitWildcardType
parameter_list|(
name|WildcardType
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|subtypeOfComponentType
argument_list|(
name|t
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitGenericArrayType
parameter_list|(
name|GenericArrayType
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|t
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|t
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|visit
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null    * otherwise.    */
annotation|@
name|NullableDecl
DECL|method|subtypeOfComponentType (Type[] bounds)
specifier|private
specifier|static
name|Type
name|subtypeOfComponentType
parameter_list|(
name|Type
index|[]
name|bounds
parameter_list|)
block|{
for|for
control|(
name|Type
name|bound
range|:
name|bounds
control|)
block|{
name|Type
name|componentType
init|=
name|getComponentType
argument_list|(
name|bound
argument_list|)
decl_stmt|;
if|if
condition|(
name|componentType
operator|!=
literal|null
condition|)
block|{
comment|// Only the first bound can be a class or array.
comment|// Bounds after the first can only be interfaces.
if|if
condition|(
name|componentType
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|componentClass
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|componentType
decl_stmt|;
if|if
condition|(
name|componentClass
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
return|return
name|componentClass
return|;
block|}
block|}
return|return
name|subtypeOf
argument_list|(
name|componentType
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|class|GenericArrayTypeImpl
specifier|private
specifier|static
specifier|final
class|class
name|GenericArrayTypeImpl
implements|implements
name|GenericArrayType
implements|,
name|Serializable
block|{
DECL|field|componentType
specifier|private
specifier|final
name|Type
name|componentType
decl_stmt|;
DECL|method|GenericArrayTypeImpl (Type componentType)
name|GenericArrayTypeImpl
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
name|this
operator|.
name|componentType
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|componentType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGenericComponentType ()
specifier|public
name|Type
name|getGenericComponentType
parameter_list|()
block|{
return|return
name|componentType
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Types
operator|.
name|toString
argument_list|(
name|componentType
argument_list|)
operator|+
literal|"[]"
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|componentType
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|GenericArrayType
condition|)
block|{
name|GenericArrayType
name|that
init|=
operator|(
name|GenericArrayType
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|getGenericComponentType
argument_list|()
argument_list|,
name|that
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|ParameterizedTypeImpl
specifier|private
specifier|static
specifier|final
class|class
name|ParameterizedTypeImpl
implements|implements
name|ParameterizedType
implements|,
name|Serializable
block|{
DECL|field|ownerType
annotation|@
name|NullableDecl
specifier|private
specifier|final
name|Type
name|ownerType
decl_stmt|;
DECL|field|argumentsList
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|argumentsList
decl_stmt|;
DECL|field|rawType
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
decl_stmt|;
DECL|method|ParameterizedTypeImpl (@ullableDecl Type ownerType, Class<?> rawType, Type[] typeArguments)
name|ParameterizedTypeImpl
parameter_list|(
annotation|@
name|NullableDecl
name|Type
name|ownerType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
index|[]
name|typeArguments
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|rawType
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|typeArguments
operator|.
name|length
operator|==
name|rawType
operator|.
name|getTypeParameters
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|disallowPrimitiveType
argument_list|(
name|typeArguments
argument_list|,
literal|"type parameter"
argument_list|)
expr_stmt|;
name|this
operator|.
name|ownerType
operator|=
name|ownerType
expr_stmt|;
name|this
operator|.
name|rawType
operator|=
name|rawType
expr_stmt|;
name|this
operator|.
name|argumentsList
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|typeArguments
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getActualTypeArguments ()
specifier|public
name|Type
index|[]
name|getActualTypeArguments
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|argumentsList
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getRawType ()
specifier|public
name|Type
name|getRawType
parameter_list|()
block|{
return|return
name|rawType
return|;
block|}
annotation|@
name|Override
DECL|method|getOwnerType ()
specifier|public
name|Type
name|getOwnerType
parameter_list|()
block|{
return|return
name|ownerType
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|ownerType
operator|!=
literal|null
operator|&&
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|jdkTypeDuplicatesOwnerName
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|typeName
argument_list|(
name|ownerType
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|append
argument_list|(
name|rawType
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'<'
argument_list|)
operator|.
name|append
argument_list|(
name|COMMA_JOINER
operator|.
name|join
argument_list|(
name|transform
argument_list|(
name|argumentsList
argument_list|,
name|TYPE_NAME
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'>'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|ownerType
operator|==
literal|null
condition|?
literal|0
else|:
name|ownerType
operator|.
name|hashCode
argument_list|()
operator|)
operator|^
name|argumentsList
operator|.
name|hashCode
argument_list|()
operator|^
name|rawType
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|ParameterizedType
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ParameterizedType
name|that
init|=
operator|(
name|ParameterizedType
operator|)
name|other
decl_stmt|;
return|return
name|getRawType
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getRawType
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|getOwnerType
argument_list|()
argument_list|,
name|that
operator|.
name|getOwnerType
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|getActualTypeArguments
argument_list|()
argument_list|,
name|that
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|newTypeVariableImpl ( D genericDeclaration, String name, Type[] bounds)
specifier|private
specifier|static
parameter_list|<
name|D
extends|extends
name|GenericDeclaration
parameter_list|>
name|TypeVariable
argument_list|<
name|D
argument_list|>
name|newTypeVariableImpl
parameter_list|(
name|D
name|genericDeclaration
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
index|[]
name|bounds
parameter_list|)
block|{
name|TypeVariableImpl
argument_list|<
name|D
argument_list|>
name|typeVariableImpl
init|=
operator|new
name|TypeVariableImpl
argument_list|<
name|D
argument_list|>
argument_list|(
name|genericDeclaration
argument_list|,
name|name
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|TypeVariable
argument_list|<
name|D
argument_list|>
name|typeVariable
init|=
name|Reflection
operator|.
name|newProxy
argument_list|(
name|TypeVariable
operator|.
name|class
argument_list|,
operator|new
name|TypeVariableInvocationHandler
argument_list|(
name|typeVariableImpl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|typeVariable
return|;
block|}
comment|/**    * Invocation handler to work around a compatibility problem between Java 7 and Java 8.    *    *<p>Java 8 introduced a new method {@code getAnnotatedBounds()} in the {@link TypeVariable}    * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. That means that we    * cannot implement that interface in source code in a way that will compile on both Java 7 and    * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it    * won't compile on Java 7, while if we don't include the method then the compiler will complain    * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an    * implementation. If the method being called on the {@code TypeVariable} instance has the same    * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method    * on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link    * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This    * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link    * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that    * should hopefully be rare.    *    *<p>This workaround should be removed at a distant future time when we no longer support Java    * versions earlier than 8.    */
DECL|class|TypeVariableInvocationHandler
specifier|private
specifier|static
specifier|final
class|class
name|TypeVariableInvocationHandler
implements|implements
name|InvocationHandler
block|{
DECL|field|typeVariableMethods
specifier|private
specifier|static
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Method
argument_list|>
name|typeVariableMethods
decl_stmt|;
static|static
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Method
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|TypeVariableImpl
operator|.
name|class
operator|.
name|getMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|method
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|equals
argument_list|(
name|TypeVariableImpl
operator|.
name|class
argument_list|)
condition|)
block|{
try|try
block|{
name|method
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
comment|// OK: the method is accessible to us anyway. The setAccessible call is only for
comment|// unusual execution environments where that might not be true.
block|}
name|builder
operator|.
name|put
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
name|typeVariableMethods
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
DECL|field|typeVariableImpl
specifier|private
specifier|final
name|TypeVariableImpl
argument_list|<
name|?
argument_list|>
name|typeVariableImpl
decl_stmt|;
DECL|method|TypeVariableInvocationHandler (TypeVariableImpl<?> typeVariableImpl)
name|TypeVariableInvocationHandler
parameter_list|(
name|TypeVariableImpl
argument_list|<
name|?
argument_list|>
name|typeVariableImpl
parameter_list|)
block|{
name|this
operator|.
name|typeVariableImpl
operator|=
name|typeVariableImpl
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|invoke (Object proxy, Method method, Object[] args)
specifier|public
name|Object
name|invoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|String
name|methodName
init|=
name|method
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Method
name|typeVariableMethod
init|=
name|typeVariableMethods
operator|.
name|get
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeVariableMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|methodName
argument_list|)
throw|;
block|}
else|else
block|{
try|try
block|{
return|return
name|typeVariableMethod
operator|.
name|invoke
argument_list|(
name|typeVariableImpl
argument_list|,
name|args
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
block|}
block|}
block|}
DECL|class|TypeVariableImpl
specifier|private
specifier|static
specifier|final
class|class
name|TypeVariableImpl
parameter_list|<
name|D
extends|extends
name|GenericDeclaration
parameter_list|>
block|{
DECL|field|genericDeclaration
specifier|private
specifier|final
name|D
name|genericDeclaration
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|bounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|bounds
decl_stmt|;
DECL|method|TypeVariableImpl (D genericDeclaration, String name, Type[] bounds)
name|TypeVariableImpl
parameter_list|(
name|D
name|genericDeclaration
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
index|[]
name|bounds
parameter_list|)
block|{
name|disallowPrimitiveType
argument_list|(
name|bounds
argument_list|,
literal|"bound for type variable"
argument_list|)
expr_stmt|;
name|this
operator|.
name|genericDeclaration
operator|=
name|checkNotNull
argument_list|(
name|genericDeclaration
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|checkNotNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|bounds
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
DECL|method|getBounds ()
specifier|public
name|Type
index|[]
name|getBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|bounds
argument_list|)
return|;
block|}
DECL|method|getGenericDeclaration ()
specifier|public
name|D
name|getGenericDeclaration
parameter_list|()
block|{
return|return
name|genericDeclaration
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getTypeName ()
specifier|public
name|String
name|getTypeName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|genericDeclaration
operator|.
name|hashCode
argument_list|()
operator|^
name|name
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|NativeTypeVariableEquals
operator|.
name|NATIVE_TYPE_VARIABLE_ONLY
condition|)
block|{
comment|// equal only to our TypeVariable implementation with identical bounds
if|if
condition|(
name|obj
operator|!=
literal|null
operator|&&
name|Proxy
operator|.
name|isProxyClass
argument_list|(
name|obj
operator|.
name|getClass
argument_list|()
argument_list|)
operator|&&
name|Proxy
operator|.
name|getInvocationHandler
argument_list|(
name|obj
argument_list|)
operator|instanceof
name|TypeVariableInvocationHandler
condition|)
block|{
name|TypeVariableInvocationHandler
name|typeVariableInvocationHandler
init|=
operator|(
name|TypeVariableInvocationHandler
operator|)
name|Proxy
operator|.
name|getInvocationHandler
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|TypeVariableImpl
argument_list|<
name|?
argument_list|>
name|that
init|=
name|typeVariableInvocationHandler
operator|.
name|typeVariableImpl
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|genericDeclaration
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|)
operator|&&
name|bounds
operator|.
name|equals
argument_list|(
name|that
operator|.
name|bounds
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// equal to any TypeVariable implementation regardless of bounds
if|if
condition|(
name|obj
operator|instanceof
name|TypeVariable
condition|)
block|{
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|genericDeclaration
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
DECL|class|WildcardTypeImpl
specifier|static
specifier|final
class|class
name|WildcardTypeImpl
implements|implements
name|WildcardType
implements|,
name|Serializable
block|{
DECL|field|lowerBounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|lowerBounds
decl_stmt|;
DECL|field|upperBounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|upperBounds
decl_stmt|;
DECL|method|WildcardTypeImpl (Type[] lowerBounds, Type[] upperBounds)
name|WildcardTypeImpl
parameter_list|(
name|Type
index|[]
name|lowerBounds
parameter_list|,
name|Type
index|[]
name|upperBounds
parameter_list|)
block|{
name|disallowPrimitiveType
argument_list|(
name|lowerBounds
argument_list|,
literal|"lower bound for wildcard"
argument_list|)
expr_stmt|;
name|disallowPrimitiveType
argument_list|(
name|upperBounds
argument_list|,
literal|"upper bound for wildcard"
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowerBounds
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|lowerBounds
argument_list|)
expr_stmt|;
name|this
operator|.
name|upperBounds
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|upperBounds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getLowerBounds ()
specifier|public
name|Type
index|[]
name|getLowerBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|lowerBounds
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getUpperBounds ()
specifier|public
name|Type
index|[]
name|getUpperBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|upperBounds
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|that
init|=
operator|(
name|WildcardType
operator|)
name|obj
decl_stmt|;
return|return
name|lowerBounds
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|that
operator|.
name|getLowerBounds
argument_list|()
argument_list|)
argument_list|)
operator|&&
name|upperBounds
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|that
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|lowerBounds
operator|.
name|hashCode
argument_list|()
operator|^
name|upperBounds
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"?"
argument_list|)
decl_stmt|;
for|for
control|(
name|Type
name|lowerBound
range|:
name|lowerBounds
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" super "
argument_list|)
operator|.
name|append
argument_list|(
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|typeName
argument_list|(
name|lowerBound
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Type
name|upperBound
range|:
name|filterUpperBounds
argument_list|(
name|upperBounds
argument_list|)
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" extends "
argument_list|)
operator|.
name|append
argument_list|(
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|typeName
argument_list|(
name|upperBound
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|toArray (Collection<Type> types)
specifier|private
specifier|static
name|Type
index|[]
name|toArray
parameter_list|(
name|Collection
argument_list|<
name|Type
argument_list|>
name|types
parameter_list|)
block|{
return|return
name|types
operator|.
name|toArray
argument_list|(
operator|new
name|Type
index|[
name|types
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|filterUpperBounds (Iterable<Type> bounds)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|Type
argument_list|>
name|filterUpperBounds
parameter_list|(
name|Iterable
argument_list|<
name|Type
argument_list|>
name|bounds
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|filter
argument_list|(
name|bounds
argument_list|,
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
expr|<
name|Type
operator|>
name|equalTo
argument_list|(
name|Object
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|disallowPrimitiveType (Type[] types, String usedAs)
specifier|private
specifier|static
name|void
name|disallowPrimitiveType
parameter_list|(
name|Type
index|[]
name|types
parameter_list|,
name|String
name|usedAs
parameter_list|)
block|{
for|for
control|(
name|Type
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
decl_stmt|;
name|checkArgument
argument_list|(
operator|!
name|cls
operator|.
name|isPrimitive
argument_list|()
argument_list|,
literal|"Primitive type '%s' used as %s"
argument_list|,
name|cls
argument_list|,
name|usedAs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns the {@code Class} object of arrays with {@code componentType}. */
DECL|method|getArrayClass (Class<?> componentType)
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getArrayClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|componentType
parameter_list|)
block|{
comment|// TODO(user): This is not the most efficient way to handle generic
comment|// arrays, but is there another way to extract the array class in a
comment|// non-hacky way (i.e. using String value class names- "[L...")?
return|return
name|Array
operator|.
name|newInstance
argument_list|(
name|componentType
argument_list|,
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
return|;
block|}
comment|// TODO(benyu): Once behavior is the same for all Java versions we support, delete this.
DECL|enum|JavaVersion
enum|enum
name|JavaVersion
block|{
DECL|enumConstant|JAVA6
name|JAVA6
block|{
annotation|@
name|Override
name|GenericArrayType
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|componentType
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
decl_stmt|;
if|if
condition|(
name|cls
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|cls
operator|.
name|getComponentType
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|type
return|;
block|}
block|}
block|,
DECL|enumConstant|JAVA7
name|JAVA7
block|{
annotation|@
name|Override
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
if|if
condition|(
name|componentType
operator|instanceof
name|Class
condition|)
block|{
return|return
name|getArrayClass
argument_list|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|componentType
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|componentType
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|JAVA8
name|JAVA8
block|{
annotation|@
name|Override
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
return|return
name|JAVA7
operator|.
name|newArrayType
argument_list|(
name|componentType
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|JAVA7
operator|.
name|usedInGenericType
argument_list|(
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|String
name|typeName
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
try|try
block|{
name|Method
name|getTypeName
init|=
name|Type
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getTypeName"
argument_list|)
decl_stmt|;
return|return
operator|(
name|String
operator|)
name|getTypeName
operator|.
name|invoke
argument_list|(
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Type.getTypeName should be available in Java 8"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
decl||
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|,
DECL|enumConstant|JAVA9
name|JAVA9
block|{
annotation|@
name|Override
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
return|return
name|JAVA8
operator|.
name|newArrayType
argument_list|(
name|componentType
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|JAVA8
operator|.
name|usedInGenericType
argument_list|(
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|String
name|typeName
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|JAVA8
operator|.
name|typeName
argument_list|(
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|boolean
name|jdkTypeDuplicatesOwnerName
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
block|;
DECL|field|CURRENT
specifier|static
specifier|final
name|JavaVersion
name|CURRENT
decl_stmt|;
static|static
block|{
if|if
condition|(
name|AnnotatedElement
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|TypeVariable
operator|.
name|class
argument_list|)
condition|)
block|{
if|if
condition|(
operator|new
name|TypeCapture
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|int
index|[]
index|[]
argument_list|>
argument_list|>
argument_list|()
block|{}
operator|.
name|capture
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"java.util.Map.java.util.Map"
argument_list|)
block|)
block|{
name|CURRENT
operator|=
name|JAVA8
expr_stmt|;
block|}
else|else
block|{
name|CURRENT
operator|=
name|JAVA9
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|new
name|TypeCapture
argument_list|<
name|int
index|[]
argument_list|>
argument_list|()
block|{}
operator|.
name|capture
argument_list|()
operator|instanceof
name|Class
block|)
block|{
name|CURRENT
init|=
name|JAVA7
block|;       }
else|else
block|{
name|CURRENT
operator|=
name|JAVA6
expr_stmt|;
block|}
block|}
end_class

begin_function_decl
DECL|method|newArrayType (Type componentType)
specifier|abstract
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
DECL|method|usedInGenericType (Type type)
specifier|abstract
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|method|usedInGenericType (Type[] types)
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|usedInGenericType
parameter_list|(
name|Type
index|[]
name|types
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Type
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Type
name|type
range|:
name|types
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|usedInGenericType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_function
DECL|method|typeName (Type type)
name|String
name|typeName
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|Types
operator|.
name|toString
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|jdkTypeDuplicatesOwnerName ()
name|boolean
name|jdkTypeDuplicatesOwnerName
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function

begin_comment
unit|}
comment|/**    * Per<a href="https://code.google.com/p/guava-libraries/issues/detail?id=1635">issue 1635</a>,    * In JDK 1.7.0_51-b13, {@link TypeVariableImpl#equals(Object)} is changed to no longer be equal    * to custom TypeVariable implementations. As a result, we need to make sure our TypeVariable    * implementation respects symmetry. Moreover, we don't want to reconstruct a native type variable    * {@code<A>} using our implementation unless some of its bounds have changed in resolution. This    * avoids creating unequal TypeVariable implementation unnecessarily. When the bounds do change,    * however, it's fine for the synthetic TypeVariable to be unequal to any native TypeVariable    * anyway.    */
end_comment

begin_class
DECL|class|NativeTypeVariableEquals
unit|static
specifier|final
class|class
name|NativeTypeVariableEquals
parameter_list|<
name|X
parameter_list|>
block|{
DECL|field|NATIVE_TYPE_VARIABLE_ONLY
specifier|static
specifier|final
name|boolean
name|NATIVE_TYPE_VARIABLE_ONLY
init|=
operator|!
name|NativeTypeVariableEquals
operator|.
name|class
operator|.
name|getTypeParameters
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|newArtificialTypeVariable
argument_list|(
name|NativeTypeVariableEquals
operator|.
name|class
argument_list|,
literal|"X"
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_class

begin_constructor
DECL|method|Types ()
specifier|private
name|Types
parameter_list|()
block|{}
end_constructor

unit|}
end_unit

