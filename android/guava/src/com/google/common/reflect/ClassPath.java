begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.reflect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|StandardSystemProperty
operator|.
name|JAVA_CLASS_PATH
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|StandardSystemProperty
operator|.
name|PATH_SEPARATOR
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
operator|.
name|WARNING
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|FluentIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MultimapBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteSource
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|CharSource
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * Scans the source of a {@link ClassLoader} and finds all loadable classes and resources.  *  *<p><b>Warning:</b> Current limitations:  *  *<ul>  *<li>Looks only for files and JARs in URLs available from {@link URLClassLoader} instances or  *       the {@linkplain ClassLoader#getSystemClassLoader() system class loader}.  *<li>Only understands {@code file:} URLs.  *</ul>  *  *<p>In the case of directory classloaders, symlinks are supported but cycles are not traversed.  * This guarantees discovery of each<em>unique</em> loadable resource. However, not all possible  * aliases for resources on cyclic paths will be listed.  *  * @author Ben Yu  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|ClassPath
specifier|public
specifier|final
class|class
name|ClassPath
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ClassPath
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|IS_TOP_LEVEL
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|ClassInfo
argument_list|>
name|IS_TOP_LEVEL
init|=
operator|new
name|Predicate
argument_list|<
name|ClassInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|ClassInfo
name|info
parameter_list|)
block|{
return|return
name|info
operator|.
name|className
operator|.
name|indexOf
argument_list|(
literal|'$'
argument_list|)
operator|==
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|/** Separator for the Class-Path manifest attribute value in jar files. */
DECL|field|CLASS_PATH_ATTRIBUTE_SEPARATOR
specifier|private
specifier|static
specifier|final
name|Splitter
name|CLASS_PATH_ATTRIBUTE_SEPARATOR
init|=
name|Splitter
operator|.
name|on
argument_list|(
literal|" "
argument_list|)
operator|.
name|omitEmptyStrings
argument_list|()
decl_stmt|;
DECL|field|CLASS_FILE_NAME_EXTENSION
specifier|private
specifier|static
specifier|final
name|String
name|CLASS_FILE_NAME_EXTENSION
init|=
literal|".class"
decl_stmt|;
DECL|field|resources
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|ResourceInfo
argument_list|>
name|resources
decl_stmt|;
DECL|method|ClassPath (ImmutableSet<ResourceInfo> resources)
specifier|private
name|ClassPath
parameter_list|(
name|ImmutableSet
argument_list|<
name|ResourceInfo
argument_list|>
name|resources
parameter_list|)
block|{
name|this
operator|.
name|resources
operator|=
name|resources
expr_stmt|;
block|}
comment|/**    * Returns a {@code ClassPath} representing all classes and resources loadable from {@code    * classloader} and its ancestor class loaders.    *    *<p><b>Warning:</b> {@code ClassPath} can find classes and resources only from:    *    *<ul>    *<li>{@link URLClassLoader} instances' {@code file:} URLs    *<li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the    *       system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code    *       ClassPath} searches the files from the {@code java.class.path} system property.    *</ul>    *    * @throws IOException if the attempt to read class path resources (jar files or directories)    *     failed.    */
DECL|method|from (ClassLoader classloader)
specifier|public
specifier|static
name|ClassPath
name|from
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|)
throws|throws
name|IOException
block|{
name|DefaultScanner
name|scanner
init|=
operator|new
name|DefaultScanner
argument_list|()
decl_stmt|;
name|scanner
operator|.
name|scan
argument_list|(
name|classloader
argument_list|)
expr_stmt|;
return|return
operator|new
name|ClassPath
argument_list|(
name|scanner
operator|.
name|getResources
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns all resources loadable from the current class path, including the class files of all    * loadable classes but excluding the "META-INF/MANIFEST.MF" file.    */
DECL|method|getResources ()
specifier|public
name|ImmutableSet
argument_list|<
name|ResourceInfo
argument_list|>
name|getResources
parameter_list|()
block|{
return|return
name|resources
return|;
block|}
comment|/**    * Returns all classes loadable from the current class path.    *    * @since 16.0    */
DECL|method|getAllClasses ()
specifier|public
name|ImmutableSet
argument_list|<
name|ClassInfo
argument_list|>
name|getAllClasses
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|resources
argument_list|)
operator|.
name|filter
argument_list|(
name|ClassInfo
operator|.
name|class
argument_list|)
operator|.
name|toSet
argument_list|()
return|;
block|}
comment|/** Returns all top level classes loadable from the current class path. */
DECL|method|getTopLevelClasses ()
specifier|public
name|ImmutableSet
argument_list|<
name|ClassInfo
argument_list|>
name|getTopLevelClasses
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|resources
argument_list|)
operator|.
name|filter
argument_list|(
name|ClassInfo
operator|.
name|class
argument_list|)
operator|.
name|filter
argument_list|(
name|IS_TOP_LEVEL
argument_list|)
operator|.
name|toSet
argument_list|()
return|;
block|}
comment|/** Returns all top level classes whose package name is {@code packageName}. */
DECL|method|getTopLevelClasses (String packageName)
specifier|public
name|ImmutableSet
argument_list|<
name|ClassInfo
argument_list|>
name|getTopLevelClasses
parameter_list|(
name|String
name|packageName
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|packageName
argument_list|)
expr_stmt|;
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|ClassInfo
argument_list|>
name|builder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|ClassInfo
name|classInfo
range|:
name|getTopLevelClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|classInfo
operator|.
name|getPackageName
argument_list|()
operator|.
name|equals
argument_list|(
name|packageName
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|classInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns all top level classes whose package name is {@code packageName} or starts with {@code    * packageName} followed by a '.'.    */
DECL|method|getTopLevelClassesRecursive (String packageName)
specifier|public
name|ImmutableSet
argument_list|<
name|ClassInfo
argument_list|>
name|getTopLevelClassesRecursive
parameter_list|(
name|String
name|packageName
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|packageName
argument_list|)
expr_stmt|;
name|String
name|packagePrefix
init|=
name|packageName
operator|+
literal|'.'
decl_stmt|;
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|ClassInfo
argument_list|>
name|builder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|ClassInfo
name|classInfo
range|:
name|getTopLevelClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|classInfo
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|packagePrefix
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|classInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Represents a class path resource that can be either a class file or any other resource file    * loadable from the class path.    *    * @since 14.0    */
annotation|@
name|Beta
DECL|class|ResourceInfo
specifier|public
specifier|static
class|class
name|ResourceInfo
block|{
DECL|field|file
specifier|private
specifier|final
name|File
name|file
decl_stmt|;
DECL|field|resourceName
specifier|private
specifier|final
name|String
name|resourceName
decl_stmt|;
DECL|field|loader
specifier|final
name|ClassLoader
name|loader
decl_stmt|;
DECL|method|of (File file, String resourceName, ClassLoader loader)
specifier|static
name|ResourceInfo
name|of
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|ClassLoader
name|loader
parameter_list|)
block|{
if|if
condition|(
name|resourceName
operator|.
name|endsWith
argument_list|(
name|CLASS_FILE_NAME_EXTENSION
argument_list|)
condition|)
block|{
return|return
operator|new
name|ClassInfo
argument_list|(
name|file
argument_list|,
name|resourceName
argument_list|,
name|loader
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ResourceInfo
argument_list|(
name|file
argument_list|,
name|resourceName
argument_list|,
name|loader
argument_list|)
return|;
block|}
block|}
DECL|method|ResourceInfo (File file, String resourceName, ClassLoader loader)
name|ResourceInfo
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|ClassLoader
name|loader
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|this
operator|.
name|resourceName
operator|=
name|checkNotNull
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|checkNotNull
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the url identifying the resource.      *      *<p>See {@link ClassLoader#getResource}      *      * @throws NoSuchElementException if the resource cannot be loaded through the class loader,      *     despite physically existing in the class path.      */
DECL|method|url ()
specifier|public
specifier|final
name|URL
name|url
parameter_list|()
block|{
name|URL
name|url
init|=
name|loader
operator|.
name|getResource
argument_list|(
name|resourceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
name|resourceName
argument_list|)
throw|;
block|}
return|return
name|url
return|;
block|}
comment|/**      * Returns a {@link ByteSource} view of the resource from which its bytes can be read.      *      * @throws NoSuchElementException if the resource cannot be loaded through the class loader,      *     despite physically existing in the class path.      * @since 20.0      */
DECL|method|asByteSource ()
specifier|public
specifier|final
name|ByteSource
name|asByteSource
parameter_list|()
block|{
return|return
name|Resources
operator|.
name|asByteSource
argument_list|(
name|url
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a {@link CharSource} view of the resource from which its bytes can be read as      * characters decoded with the given {@code charset}.      *      * @throws NoSuchElementException if the resource cannot be loaded through the class loader,      *     despite physically existing in the class path.      * @since 20.0      */
DECL|method|asCharSource (Charset charset)
specifier|public
specifier|final
name|CharSource
name|asCharSource
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
return|return
name|Resources
operator|.
name|asCharSource
argument_list|(
name|url
argument_list|()
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|/** Returns the fully qualified name of the resource. Such as "com/mycomp/foo/bar.txt". */
DECL|method|getResourceName ()
specifier|public
specifier|final
name|String
name|getResourceName
parameter_list|()
block|{
return|return
name|resourceName
return|;
block|}
comment|/** Returns the file that includes this resource. */
DECL|method|getFile ()
specifier|final
name|File
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|resourceName
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|ResourceInfo
condition|)
block|{
name|ResourceInfo
name|that
init|=
operator|(
name|ResourceInfo
operator|)
name|obj
decl_stmt|;
return|return
name|resourceName
operator|.
name|equals
argument_list|(
name|that
operator|.
name|resourceName
argument_list|)
operator|&&
name|loader
operator|==
name|that
operator|.
name|loader
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// Do not change this arbitrarily. We rely on it for sorting ResourceInfo.
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|resourceName
return|;
block|}
block|}
comment|/**    * Represents a class that can be loaded through {@link #load}.    *    * @since 14.0    */
annotation|@
name|Beta
DECL|class|ClassInfo
specifier|public
specifier|static
specifier|final
class|class
name|ClassInfo
extends|extends
name|ResourceInfo
block|{
DECL|field|className
specifier|private
specifier|final
name|String
name|className
decl_stmt|;
DECL|method|ClassInfo (File file, String resourceName, ClassLoader loader)
name|ClassInfo
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|ClassLoader
name|loader
parameter_list|)
block|{
name|super
argument_list|(
name|file
argument_list|,
name|resourceName
argument_list|,
name|loader
argument_list|)
expr_stmt|;
name|this
operator|.
name|className
operator|=
name|getClassName
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the package name of the class, without attempting to load the class.      *      *<p>Behaves identically to {@link Package#getName()} but does not require the class (or      * package) to be loaded.      */
DECL|method|getPackageName ()
specifier|public
name|String
name|getPackageName
parameter_list|()
block|{
return|return
name|Reflection
operator|.
name|getPackageName
argument_list|(
name|className
argument_list|)
return|;
block|}
comment|/**      * Returns the simple name of the underlying class as given in the source code.      *      *<p>Behaves identically to {@link Class#getSimpleName()} but does not require the class to be      * loaded.      */
DECL|method|getSimpleName ()
specifier|public
name|String
name|getSimpleName
parameter_list|()
block|{
name|int
name|lastDollarSign
init|=
name|className
operator|.
name|lastIndexOf
argument_list|(
literal|'$'
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastDollarSign
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|innerClassName
init|=
name|className
operator|.
name|substring
argument_list|(
name|lastDollarSign
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// local and anonymous classes are prefixed with number (1,2,3...), anonymous classes are
comment|// entirely numeric whereas local classes have the user supplied name as a suffix
return|return
name|CharMatcher
operator|.
name|inRange
argument_list|(
literal|'0'
argument_list|,
literal|'9'
argument_list|)
operator|.
name|trimLeadingFrom
argument_list|(
name|innerClassName
argument_list|)
return|;
block|}
name|String
name|packageName
init|=
name|getPackageName
argument_list|()
decl_stmt|;
if|if
condition|(
name|packageName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|className
return|;
block|}
comment|// Since this is a top level class, its simple name is always the part after package name.
return|return
name|className
operator|.
name|substring
argument_list|(
name|packageName
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**      * Returns the fully qualified name of the class.      *      *<p>Behaves identically to {@link Class#getName()} but does not require the class to be      * loaded.      */
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|className
return|;
block|}
comment|/**      * Loads (but doesn't link or initialize) the class.      *      * @throws LinkageError when there were errors in loading classes that this class depends on.      *     For example, {@link NoClassDefFoundError}.      */
DECL|method|load ()
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|load
parameter_list|()
block|{
try|try
block|{
return|return
name|loader
operator|.
name|loadClass
argument_list|(
name|className
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// Shouldn't happen, since the class name is read from the class path.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|className
return|;
block|}
block|}
comment|/**    * Abstract class that scans through the class path represented by a {@link ClassLoader} and calls    * {@link #scanDirectory} and {@link #scanJarFile} for directories and jar files on the class path    * respectively.    */
DECL|class|Scanner
specifier|abstract
specifier|static
class|class
name|Scanner
block|{
comment|// We only scan each file once independent of the classloader that resource might be associated
comment|// with. Use concurrent set so that subclasses can be thread-safe.
DECL|field|scannedUris
specifier|private
specifier|final
name|Set
argument_list|<
name|File
argument_list|>
name|scannedUris
init|=
name|Sets
operator|.
name|newConcurrentHashSet
argument_list|()
decl_stmt|;
DECL|method|scan (ClassLoader classloader)
specifier|public
specifier|final
name|void
name|scan
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|File
argument_list|,
name|ClassLoader
argument_list|>
name|entry
range|:
name|getClassPathEntries
argument_list|(
name|classloader
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|scan
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|scan (File file, ClassLoader classloader)
specifier|final
name|void
name|scan
parameter_list|(
name|File
name|file
parameter_list|,
name|ClassLoader
name|classloader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|scannedUris
operator|.
name|add
argument_list|(
name|file
operator|.
name|getCanonicalFile
argument_list|()
argument_list|)
condition|)
block|{
name|scanFrom
argument_list|(
name|file
argument_list|,
name|classloader
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Called each time a resource (uniqueness not guaranteed if the class path includes redundant      * entries)      */
DECL|method|scanResource (ResourceInfo resource)
specifier|protected
specifier|abstract
name|void
name|scanResource
parameter_list|(
name|ResourceInfo
name|resource
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|scanFrom (File file, ClassLoader classloader)
specifier|protected
name|void
name|scanFrom
parameter_list|(
name|File
name|file
parameter_list|,
name|ClassLoader
name|classloader
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warning
argument_list|(
literal|"Cannot access "
operator|+
name|file
operator|+
literal|": "
operator|+
name|e
argument_list|)
expr_stmt|;
comment|// TODO(emcmanus): consider whether to log other failure cases too.
return|return;
block|}
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|scanDirectory
argument_list|(
name|classloader
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scanJar
argument_list|(
name|file
argument_list|,
name|classloader
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|scanJar (File file, ClassLoader classloader)
specifier|private
name|void
name|scanJar
parameter_list|(
name|File
name|file
parameter_list|,
name|ClassLoader
name|classloader
parameter_list|)
throws|throws
name|IOException
block|{
name|JarFile
name|jarFile
decl_stmt|;
try|try
block|{
name|jarFile
operator|=
operator|new
name|JarFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Not a jar file
return|return;
block|}
try|try
block|{
for|for
control|(
name|File
name|path
range|:
name|getClassPathFromManifest
argument_list|(
name|file
argument_list|,
name|jarFile
operator|.
name|getManifest
argument_list|()
argument_list|)
control|)
block|{
name|scan
argument_list|(
name|path
argument_list|,
name|classloader
argument_list|)
expr_stmt|;
block|}
name|scanJarFile
argument_list|(
name|classloader
argument_list|,
name|jarFile
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|jarFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
comment|/**      * Returns the class path URIs specified by the {@code Class-Path} manifest attribute, according      * to<a      * href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes">JAR      * File Specification</a>. If {@code manifest} is null, it means the jar file has no manifest,      * and an empty set will be returned.      */
annotation|@
name|VisibleForTesting
DECL|method|getClassPathFromManifest ( File jarFile, @NullableDecl Manifest manifest)
specifier|static
name|ImmutableSet
argument_list|<
name|File
argument_list|>
name|getClassPathFromManifest
parameter_list|(
name|File
name|jarFile
parameter_list|,
annotation|@
name|NullableDecl
name|Manifest
name|manifest
parameter_list|)
block|{
if|if
condition|(
name|manifest
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|File
argument_list|>
name|builder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|classpathAttribute
init|=
name|manifest
operator|.
name|getMainAttributes
argument_list|()
operator|.
name|getValue
argument_list|(
name|Attributes
operator|.
name|Name
operator|.
name|CLASS_PATH
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|classpathAttribute
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|path
range|:
name|CLASS_PATH_ATTRIBUTE_SEPARATOR
operator|.
name|split
argument_list|(
name|classpathAttribute
argument_list|)
control|)
block|{
name|URL
name|url
decl_stmt|;
try|try
block|{
name|url
operator|=
name|getClassPathEntry
argument_list|(
name|jarFile
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
comment|// Ignore bad entry
name|logger
operator|.
name|warning
argument_list|(
literal|"Invalid Class-Path entry: "
operator|+
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|url
operator|.
name|getProtocol
argument_list|()
operator|.
name|equals
argument_list|(
literal|"file"
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|toFile
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getClassPathEntries (ClassLoader classloader)
specifier|static
name|ImmutableMap
argument_list|<
name|File
argument_list|,
name|ClassLoader
argument_list|>
name|getClassPathEntries
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|File
argument_list|,
name|ClassLoader
argument_list|>
name|entries
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
comment|// Search parent first, since it's the order ClassLoader#loadClass() uses.
name|ClassLoader
name|parent
init|=
name|classloader
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|entries
operator|.
name|putAll
argument_list|(
name|getClassPathEntries
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|URL
name|url
range|:
name|getClassLoaderUrls
argument_list|(
name|classloader
argument_list|)
control|)
block|{
if|if
condition|(
name|url
operator|.
name|getProtocol
argument_list|()
operator|.
name|equals
argument_list|(
literal|"file"
argument_list|)
condition|)
block|{
name|File
name|file
init|=
name|toFile
argument_list|(
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entries
operator|.
name|containsKey
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|entries
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|classloader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|entries
argument_list|)
return|;
block|}
DECL|method|getClassLoaderUrls (ClassLoader classloader)
specifier|private
specifier|static
name|ImmutableList
argument_list|<
name|URL
argument_list|>
name|getClassLoaderUrls
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|)
block|{
if|if
condition|(
name|classloader
operator|instanceof
name|URLClassLoader
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
operator|(
operator|(
name|URLClassLoader
operator|)
name|classloader
operator|)
operator|.
name|getURLs
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|classloader
operator|.
name|equals
argument_list|(
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|parseJavaClassPath
argument_list|()
return|;
block|}
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|/**      * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain      * System#getProperty system property}.      */
annotation|@
name|VisibleForTesting
comment|// TODO(b/65488446): Make this a public API.
DECL|method|parseJavaClassPath ()
specifier|static
name|ImmutableList
argument_list|<
name|URL
argument_list|>
name|parseJavaClassPath
parameter_list|()
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|URL
argument_list|>
name|urls
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|entry
range|:
name|Splitter
operator|.
name|on
argument_list|(
name|PATH_SEPARATOR
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|split
argument_list|(
name|JAVA_CLASS_PATH
operator|.
name|value
argument_list|()
argument_list|)
control|)
block|{
try|try
block|{
try|try
block|{
name|urls
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|entry
argument_list|)
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
comment|// File.toURI checks to see if the file is a directory
name|urls
operator|.
name|add
argument_list|(
operator|new
name|URL
argument_list|(
literal|"file"
argument_list|,
literal|null
argument_list|,
operator|new
name|File
argument_list|(
name|entry
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|WARNING
argument_list|,
literal|"malformed classpath entry: "
operator|+
name|entry
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|urls
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Returns the absolute uri of the Class-Path entry value as specified in<a      * href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes">JAR      * File Specification</a>. Even though the specification only talks about relative urls,      * absolute urls are actually supported too (for example, in Maven surefire plugin).      */
annotation|@
name|VisibleForTesting
DECL|method|getClassPathEntry (File jarFile, String path)
specifier|static
name|URL
name|getClassPathEntry
parameter_list|(
name|File
name|jarFile
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|MalformedURLException
block|{
return|return
operator|new
name|URL
argument_list|(
name|jarFile
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|,
name|path
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|scanJarFile (ClassLoader classloader, JarFile file)
name|void
name|scanJarFile
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|,
name|JarFile
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|Enumeration
argument_list|<
name|JarEntry
argument_list|>
name|entries
init|=
name|file
operator|.
name|entries
argument_list|()
decl_stmt|;
while|while
condition|(
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|JarEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|isDirectory
argument_list|()
operator|||
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|JarFile
operator|.
name|MANIFEST_NAME
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|scanResource
argument_list|(
name|ResourceInfo
operator|.
name|of
argument_list|(
operator|new
name|File
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|classloader
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|scanDirectory (ClassLoader classloader, File directory)
specifier|private
name|void
name|scanDirectory
parameter_list|(
name|ClassLoader
name|classloader
parameter_list|,
name|File
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|File
argument_list|>
name|currentPath
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|currentPath
operator|.
name|add
argument_list|(
name|directory
operator|.
name|getCanonicalFile
argument_list|()
argument_list|)
expr_stmt|;
name|scanDirectory
argument_list|(
name|directory
argument_list|,
name|classloader
argument_list|,
literal|""
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
block|}
comment|/**      * Recursively scan the given directory, adding resources for each file encountered. Symlinks      * which have already been traversed in the current tree path will be skipped to eliminate      * cycles; otherwise symlinks are traversed.      *      * @param directory the root of the directory to scan      * @param classloader the classloader that includes resources found in {@code directory}      * @param packagePrefix resource path prefix inside {@code classloader} for any files found      *     under {@code directory}      * @param currentPath canonical files already visited in the current directory tree path, for      *     cycle elimination      */
DECL|method|scanDirectory ( File directory, ClassLoader classloader, String packagePrefix, Set<File> currentPath)
specifier|private
name|void
name|scanDirectory
parameter_list|(
name|File
name|directory
parameter_list|,
name|ClassLoader
name|classloader
parameter_list|,
name|String
name|packagePrefix
parameter_list|,
name|Set
argument_list|<
name|File
argument_list|>
name|currentPath
parameter_list|)
throws|throws
name|IOException
block|{
name|File
index|[]
name|files
init|=
name|directory
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|warning
argument_list|(
literal|"Cannot read directory "
operator|+
name|directory
argument_list|)
expr_stmt|;
comment|// IO error, just skip the directory
return|return;
block|}
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|String
name|name
init|=
name|f
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|File
name|deref
init|=
name|f
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentPath
operator|.
name|add
argument_list|(
name|deref
argument_list|)
condition|)
block|{
name|scanDirectory
argument_list|(
name|deref
argument_list|,
name|classloader
argument_list|,
name|packagePrefix
operator|+
name|name
operator|+
literal|"/"
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|currentPath
operator|.
name|remove
argument_list|(
name|deref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|resourceName
init|=
name|packagePrefix
operator|+
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|resourceName
operator|.
name|equals
argument_list|(
name|JarFile
operator|.
name|MANIFEST_NAME
argument_list|)
condition|)
block|{
name|scanResource
argument_list|(
name|ResourceInfo
operator|.
name|of
argument_list|(
name|f
argument_list|,
name|resourceName
argument_list|,
name|classloader
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|class|DefaultScanner
specifier|static
specifier|final
class|class
name|DefaultScanner
extends|extends
name|Scanner
block|{
DECL|field|resources
specifier|private
specifier|final
name|SetMultimap
argument_list|<
name|ClassLoader
argument_list|,
name|ResourceInfo
argument_list|>
name|resources
init|=
name|MultimapBuilder
operator|.
name|hashKeys
argument_list|()
operator|.
name|linkedHashSetValues
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|method|getResources ()
name|ImmutableSet
argument_list|<
name|ResourceInfo
argument_list|>
name|getResources
parameter_list|()
block|{
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|resources
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|scanResource (ResourceInfo resource)
specifier|protected
name|void
name|scanResource
parameter_list|(
name|ResourceInfo
name|resource
parameter_list|)
block|{
name|resources
operator|.
name|put
argument_list|(
name|resource
operator|.
name|loader
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getClassName (String filename)
specifier|static
name|String
name|getClassName
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|int
name|classNameEnd
init|=
name|filename
operator|.
name|length
argument_list|()
operator|-
name|CLASS_FILE_NAME_EXTENSION
operator|.
name|length
argument_list|()
decl_stmt|;
return|return
name|filename
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|classNameEnd
argument_list|)
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
return|;
block|}
comment|// TODO(benyu): Try java.nio.file.Paths#get() when Guava drops JDK 6 support.
annotation|@
name|VisibleForTesting
DECL|method|toFile (URL url)
specifier|static
name|File
name|toFile
parameter_list|(
name|URL
name|url
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|url
operator|.
name|getProtocol
argument_list|()
operator|.
name|equals
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|url
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
comment|// Accepts escaped characters like %20.
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
comment|// URL.toURI() doesn't escape chars.
return|return
operator|new
name|File
argument_list|(
name|url
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
comment|// Accepts non-escaped chars like space.
block|}
block|}
block|}
end_class

end_unit

