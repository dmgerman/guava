begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NullnessCasts
operator|.
name|uncheckedCastNullableTToT
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * This class contains static utility methods that operate on or return objects of type {@link  * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the  * {@link Iterables} class.  *  *<p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class  * are<i>lazy</i>, which means that they only advance the backing iteration when absolutely  * necessary.  *  *<p>See the Guava User Guide section on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"> {@code  * Iterators}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|ElementTypesAreNonnullByDefault
DECL|class|Iterators
specifier|public
specifier|final
class|class
name|Iterators
block|{
DECL|method|Iterators ()
specifier|private
name|Iterators
parameter_list|()
block|{}
comment|/**    * Returns the empty iterator.    *    *<p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.    */
DECL|method|emptyIterator ()
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|emptyIterator
argument_list|()
block|{
return|return
name|emptyListIterator
argument_list|()
return|;
block|}
comment|/**    * Returns the empty iterator.    *    *<p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.    */
comment|// Casting to any type is safe since there are no actual elements.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyListIterator ()
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
name|emptyListIterator
argument_list|()
block|{
return|return
operator|(
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
operator|)
name|ArrayItr
operator|.
name|EMPTY
return|;
block|}
comment|/**    * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only    * referenced by emptyModifiableIterator().    */
DECL|enum|EmptyModifiableIterator
specifier|private
enum|enum
name|EmptyModifiableIterator
implements|implements
name|Iterator
argument_list|<
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Object
name|next
parameter_list|()
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link    * UnsupportedOperationException} on a call to {@link Iterator#remove()}.    */
comment|// Casting to any type is safe since there are no actual elements.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyModifiableIterator ()
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|emptyModifiableIterator
argument_list|()
block|{
return|return
operator|(
name|Iterator
argument_list|<
name|T
argument_list|>
operator|)
name|EmptyModifiableIterator
operator|.
name|INSTANCE
return|;
block|}
comment|/** Returns an unmodifiable view of {@code iterator}. */
DECL|method|unmodifiableIterator ( final Iterator<? extends T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|unmodifiableIterator
argument_list|(
name|final
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
if|if
condition|(
name|iterator
operator|instanceof
name|UnmodifiableIterator
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Since it's unmodifiable, the covariant cast is safe
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|(
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
decl_stmt|;
return|return
name|result
return|;
block|}
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
block|}
return|;
block|}
end_class

begin_comment
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_annotation
annotation|@
name|Deprecated
end_annotation

begin_expr_stmt
DECL|method|unmodifiableIterator ( UnmodifiableIterator<T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|unmodifiableIterator
argument_list|(
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the number of elements remaining in {@code iterator}. The iterator will be left    * exhausted: its {@code hasNext()} method will return {@code false}.    */
end_comment

begin_function
DECL|method|size (Iterator<?> iterator)
specifier|public
specifier|static
name|int
name|size
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|long
name|count
init|=
literal|0L
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Returns {@code true} if {@code iterator} contains {@code element}. */
end_comment

begin_function
DECL|method|contains (Iterator<?> iterator, @CheckForNull Object element)
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iterator
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|/**    * Traverses an iterator and removes every element that belongs to the provided collection. The    * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param elementsToRemove the elements to remove    * @return {@code true} if any element was removed from {@code iterator}    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|removeAll (Iterator<?> removeFrom, Collection<?> elementsToRemove)
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRemove
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elementsToRemove
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|removeFrom
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|elementsToRemove
operator|.
name|contains
argument_list|(
name|removeFrom
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    * Removes every element that satisfies the provided predicate from the iterator. The iterator    * will be left exhausted: its {@code hasNext()} method will return {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param predicate a predicate that determines whether an element should be removed    * @return {@code true} if any elements were removed from the iterator    * @since 2.0    */
end_comment

begin_annotation
annotation|@
name|CanIgnoreReturnValue
end_annotation

begin_expr_stmt
DECL|method|removeIf ( Iterator<T> removeFrom, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|removeIf
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|removeFrom
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
block|;
name|boolean
name|modified
operator|=
literal|false
block|;
while|while
condition|(
name|removeFrom
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|removeFrom
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
name|modified
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Traverses an iterator and removes every element that does not belong to the provided    * collection. The iterator will be left exhausted: its {@code hasNext()} method will return    * {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param elementsToRetain the elements to retain    * @return {@code true} if any element was removed from {@code iterator}    */
end_comment

begin_function
unit|@
name|CanIgnoreReturnValue
DECL|method|retainAll (Iterator<?> removeFrom, Collection<?> elementsToRetain)
specifier|public
specifier|static
name|boolean
name|retainAll
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRetain
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elementsToRetain
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|removeFrom
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|elementsToRetain
operator|.
name|contains
argument_list|(
name|removeFrom
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether two iterators contain equal elements in the same order. More specifically,    * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same    * number of elements and every element of {@code iterator1} is equal to the corresponding element    * of {@code iterator2}.    *    *<p>Note that this will modify the supplied iterators, since they will have been advanced some    * number of elements forward.    */
end_comment

begin_function
DECL|method|elementsEqual (Iterator<?> iterator1, Iterator<?> iterator2)
specifier|public
specifier|static
name|boolean
name|elementsEqual
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator1
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator2
parameter_list|)
block|{
while|while
condition|(
name|iterator1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|iterator2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Object
name|o1
init|=
name|iterator1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|iterator2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Objects
operator|.
name|equal
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
operator|!
name|iterator2
operator|.
name|hasNext
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.    * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.    */
end_comment

begin_function
DECL|method|toString (Iterator<?> iterator)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the single element contained in {@code iterator}.    *    * @throws NoSuchElementException if the iterator is empty    * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the    *     iterator is unspecified.    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getOnlyElement (Iterator<T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getOnlyElement
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
name|T
name|first
operator|=
name|iterator
operator|.
name|next
argument_list|()
block|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|first
return|;
block|}
name|StringBuilder
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|"expected one element but was:<"
argument_list|)
operator|.
name|append
argument_list|(
name|first
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|sb
operator|.
name|append
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
end_expr_stmt

begin_throw
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
end_throw

begin_comment
unit|}
comment|/**    * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the    * iterator is empty.    *    * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the    *     iterator is unspecified.    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|getOnlyElement ( Iterator<? extends T> iterator, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getOnlyElement
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|getOnlyElement
argument_list|(
name|iterator
argument_list|)
else|:
name|defaultValue
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code    * hasNext()} method will return {@code false}.    *    * @param iterator the iterator to copy    * @param type the type of the elements    * @return a newly-allocated array into which all the elements of the iterator have been copied    */
end_comment

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// Array.newInstance(Class, int)
comment|// For discussion of this signature, see the corresponding overload of *Iterables*.toArray.
DECL|method|toArray (Iterator<? extends @Nullable T> iterator, Class<T> type)
specifier|public
specifier|static
argument_list|<
name|T
argument_list|>
annotation|@
name|Nullable
name|T
index|[]
name|toArray
argument_list|(
name|Iterator
operator|<
condition|?
then|extends @
name|Nullable
name|T
operator|>
name|iterator
argument_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
argument_list|)
block|{
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
return|return
name|Iterables
operator|.
name|toArray
argument_list|(
name|list
argument_list|,
name|type
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/**    * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left    * exhausted: its {@code hasNext()} method will return {@code false}.    *    * @return {@code true} if {@code collection} was modified as a result of this operation    */
end_comment

begin_annotation
annotation|@
name|CanIgnoreReturnValue
end_annotation

begin_expr_stmt
DECL|method|addAll ( Collection<T> addTo, Iterator<? extends T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|addAll
argument_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|addTo
argument_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|addTo
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
name|boolean
name|wasModified
operator|=
literal|false
block|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wasModified
operator||=
name|addTo
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|wasModified
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns the number of elements in the specified iterator that equal the specified object. The    * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.    *    * @see Collections#frequency    */
end_comment

begin_function
DECL|method|frequency (Iterator<?> iterator, @CheckForNull Object element)
unit|public
specifier|static
name|int
name|frequency
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|contains
argument_list|(
name|iterator
argument_list|,
name|element
argument_list|)
condition|)
block|{
comment|// Since it lives in the same class, we know contains gets to the element and then stops,
comment|// though that isn't currently publicly documented.
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.    *    *<p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code    * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code    * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}    * is empty.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    */
end_comment

begin_expr_stmt
DECL|method|cycle (final Iterable<T> iterable)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|cycle
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
init|=
name|emptyModifiableIterator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
comment|/*          * Don't store a new Iterator until we know the user can't remove() the last returned          * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating          * the new one. The result is a ConcurrentModificationException or other bad behavior.          *          * (If we decide that we really, really hate allocating two Iterators per cycle instead of          * one, we can optimistically store the new Iterator and then be willing to throw it out if          * the user calls remove().)          */
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
operator|||
name|iterable
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|next
argument_list|()
block|{
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|=
name|iterable
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}         return
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}        @
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Returns an iterator that cycles indefinitely over the provided elements.    *    *<p>The returned iterator supports {@code remove()}. After {@code remove()} is called,    * subsequent cycles omit the removed element, but {@code elements} does not change. The    * iterator's {@code hasNext()} method returns {@code true} until all of the original elements    * have been removed.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    */
end_comment

begin_expr_stmt
unit|@
name|SafeVarargs
DECL|method|cycle (T... elements)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|cycle
argument_list|(
name|T
operator|...
name|elements
argument_list|)
block|{
return|return
name|cycle
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an Iterator that walks the specified array, nulling out elements behind it. This can    * avoid memory leaks when an element is no longer necessary.    *    *<p>This method accepts an array with element type {@code @Nullable T}, but callers must pass an    * array whose contents are initially non-null. The {@code @Nullable} annotation indicates that    * this method will write nulls into the array during iteration.    *    *<p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.    */
end_comment

begin_function
DECL|method|consumingForArray ( final @Nullable I... elements)
specifier|private
specifier|static
parameter_list|<
name|I
extends|extends
name|Iterator
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Iterator
argument_list|<
name|I
argument_list|>
name|consumingForArray
parameter_list|(
specifier|final
annotation|@
name|Nullable
name|I
modifier|...
name|elements
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|I
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|elements
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|I
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
comment|/*          * requireNonNull is safe because our callers always pass non-null arguments. Each element          * of the array becomes null only when we iterate past it and then clear it.          */
name|I
name|result
init|=
name|requireNonNull
argument_list|(
name|elements
index|[
name|index
index|]
argument_list|)
decl_stmt|;
name|elements
index|[
name|index
index|]
operator|=
literal|null
expr_stmt|;
name|index
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Combines two iterators into a single iterator. The returned iterator iterates across the    * elements in {@code a}, followed by the elements in {@code b}. The source iterators are not    * polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding input iterator    * supports it.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterator<? extends T> a, Iterator<? extends T> b)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
block|;
return|return
name|concat
argument_list|(
name|consumingForArray
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines three iterators into a single iterator. The returned iterator iterates across the    * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in    * {@code c}. The source iterators are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding input iterator    * supports it.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|c
argument_list|)
block|;
return|return
name|concat
argument_list|(
name|consumingForArray
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines four iterators into a single iterator. The returned iterator iterates across the    * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in    * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until    * necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding input iterator    * supports it.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c, Iterator<? extends T> d)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
operator|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|d
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|c
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|d
argument_list|)
block|;
return|return
name|concat
argument_list|(
name|consumingForArray
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines multiple iterators into a single iterator. The returned iterator iterates across the    * elements of each iterator in {@code inputs}. The input iterators are not polled until    * necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding input iterator    * supports it.    *    * @throws NullPointerException if any of the provided iterators is null    */
end_comment

begin_expr_stmt
DECL|method|concat (Iterator<? extends T>.... inputs)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
operator|...
name|inputs
argument_list|)
block|{
return|return
name|concatNoDefensiveCopy
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|inputs
argument_list|,
name|inputs
operator|.
name|length
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines multiple iterators into a single iterator. The returned iterator iterates across the    * elements of each iterator in {@code inputs}. The input iterators are not polled until    * necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding input iterator    * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any    * of the input iterators is null.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterator<? extends Iterator<? extends T>> inputs)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|inputs
argument_list|)
block|{
return|return
operator|new
name|ConcatenatedIterator
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** Concats a varargs array of iterators without making a defensive copy of the array. */
end_comment

begin_expr_stmt
DECL|method|concatNoDefensiveCopy ( Iterator<? extends T>.... inputs)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concatNoDefensiveCopy
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
operator|...
name|inputs
argument_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|input
range|:
name|checkNotNull
argument_list|(
name|inputs
argument_list|)
control|)
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|concat
argument_list|(
name|consumingForArray
argument_list|(
name|inputs
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Divides an iterator into unmodifiable sublists of the given size (the final list may be    * smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a    * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two    * inner lists of three and two elements, all in the original order.    *    *<p>The returned lists implement {@link java.util.RandomAccess}.    *    * @param iterator the iterator to return a partitioned view of    * @param size the desired size of each partition (the last may be smaller)    * @return an iterator of immutable lists containing the elements of {@code iterator} divided into    *     partitions    * @throws IllegalArgumentException if {@code size} is nonpositive    */
end_comment

begin_expr_stmt
DECL|method|partition ( Iterator<T> iterator, int size)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|int
name|size
argument_list|)
block|{
return|return
name|partitionImpl
argument_list|(
name|iterator
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Divides an iterator into unmodifiable sublists of the given size, padding the final iterator    * with null values if necessary. For example, partitioning an iterator containing {@code [a, b,    * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer    * iterator containing two inner lists of three elements each, all in the original order.    *    *<p>The returned lists implement {@link java.util.RandomAccess}.    *    * @param iterator the iterator to return a partitioned view of    * @param size the desired size of each partition    * @return an iterator of immutable lists containing the elements of {@code iterator} divided into    *     partitions (the final iterable may have trailing null elements)    * @throws IllegalArgumentException if {@code size} is nonpositive    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|paddedPartition (Iterator<T> iterator, int size)
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
argument_list|>
name|paddedPartition
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|int
name|size
argument_list|)
block|{
return|return
name|partitionImpl
argument_list|(
name|iterator
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
DECL|method|partitionImpl ( final Iterator<T> iterator, final int size, final boolean pad)
specifier|private
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
argument_list|>
name|partitionImpl
argument_list|(
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|final
name|int
name|size
argument_list|,
name|final
name|boolean
name|pad
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
block|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
specifier|public
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
name|next
argument_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
expr|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// we only put Ts in it
expr|@
name|Nullable
name|T
index|[]
name|array
operator|=
operator|(
expr|@
name|Nullable
name|T
index|[]
operator|)
operator|new
name|Object
index|[
name|size
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|count
operator|<
name|size
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|array
index|[
name|count
index|]
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|int
name|i
init|=
name|count
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|array
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// for GWT
block|}
end_for

begin_decl_stmt
name|List
argument_list|<
annotation|@
name|Nullable
name|T
argument_list|>
name|list
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
end_comment

begin_if
if|if
condition|(
name|pad
operator|||
name|count
operator|==
name|size
condition|)
block|{
return|return
name|list
return|;
block|}
else|else
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|count
argument_list|)
return|;
block|}
end_if

begin_empty_stmt
unit|}     }
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate    * {@code retainIfTrue}.    */
end_comment

begin_expr_stmt
DECL|method|filter ( final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|filter
argument_list|(
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|retainIfTrue
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|retainIfTrue
argument_list|)
block|;
return|return
operator|new
name|AbstractIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
annotation|@
name|CheckForNull
specifier|protected
name|T
name|computeNext
parameter_list|()
block|{
while|while
condition|(
name|unfiltered
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|element
init|=
name|unfiltered
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|retainIfTrue
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
name|element
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}         return
name|endOfData
argument_list|()
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|}     }
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Returns a view of {@code unfiltered} containing all elements that are of the type {@code    * desiredType}.    */
end_comment

begin_expr_stmt
unit|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// can cast to<T> because non-Ts are removed
expr|@
name|GwtIncompatible
comment|// Class.isInstance
DECL|method|filter (Iterator<?> unfiltered, Class<T> desiredType)
specifier|public
specifier|static
operator|<
name|T
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|filter
argument_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|unfiltered
operator|,
name|Class
argument_list|<
name|T
argument_list|>
name|desiredType
argument_list|)
block|{
return|return
operator|(
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
operator|)
name|filter
argument_list|(
name|unfiltered
argument_list|,
name|instanceOf
argument_list|(
name|desiredType
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given    * predicate.    */
end_comment

begin_expr_stmt
DECL|method|any ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|any
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
return|return
name|indexOf
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@code true} if every element returned by {@code iterator} satisfies the given    * predicate. If {@code iterator} is empty, {@code true} is returned.    */
end_comment

begin_expr_stmt
DECL|method|all ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|all
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
block|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|element
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
literal|true
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns the first element in {@code iterator} that satisfies the given predicate; use this    * method only when such an element is known to exist. If no such element is found, the iterator    * will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is    * possible that<i>no</i> element will match, use {@link #tryFind} or {@link #find(Iterator,    * Predicate, Object)} instead.    *    * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|find ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|find
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
block|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|t
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|t
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     throw
operator|new
name|NoSuchElementException
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns the first element in {@code iterator} that satisfies the given predicate. If no such    * element is found, {@code defaultValue} will be returned from this method and the iterator will    * be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can    * usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.    *    * @since 7.0    */
end_comment

begin_comment
comment|// For discussion of this signature, see the corresponding overload of *Iterables*.find.
end_comment

begin_expr_stmt
unit|@
name|CheckForNull
DECL|method|find ( Iterator<? extends T> iterator, Predicate<? super T> predicate, @CheckForNull T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|find
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
operator|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
operator|,
condition|@
name|CheckForNull
name|T
name|defaultValue
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
block|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|t
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|t
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
name|defaultValue
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the    * given predicate, if such an element exists. If no such element is found, an empty {@link    * Optional} will be returned from this method and the iterator will be left exhausted: its {@code    * hasNext()} method will return {@code false}.    *    *<p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}    * is matched in {@code iterator}, a NullPointerException will be thrown.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|tryFind (Iterator<T> iterator, Predicate<? super T> predicate)
unit|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|tryFind
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|t
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
return|return
name|Optional
operator|.
name|absent
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the index in {@code iterator} of the first element that satisfies the provided {@code    * predicate}, or {@code -1} if the Iterator has no such elements.    *    *<p>More formally, returns the lowest index {@code i} such that {@code    * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no    * such index.    *    *<p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will    * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the    * {@code predicate}.    *    * @since 2.0    */
end_comment

begin_expr_stmt
DECL|method|indexOf ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|int
name|indexOf
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|,
literal|"predicate"
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|T
name|current
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|current
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns a view containing the result of applying {@code function} to each element of {@code    * fromIterator}.    *    *<p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a    * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding    * element.    */
end_comment

begin_expr_stmt
DECL|method|transform ( final Iterator<F> fromIterator, final Function<? super F, ? extends T> function)
unit|public
specifier|static
operator|<
name|F
expr|extends @
name|Nullable
name|Object
operator|,
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|transform
argument_list|(
name|final
name|Iterator
argument_list|<
name|F
argument_list|>
name|fromIterator
argument_list|,
name|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
block|;
return|return
operator|new
name|TransformedIterator
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromIterator
argument_list|)
block|{
annotation|@
name|ParametricNullness
annotation|@
name|Override
name|T
name|transform
parameter_list|(
annotation|@
name|ParametricNullness
name|F
name|from
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|from
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code    * position}th position.    *    * @param position position of the element to return    * @return the element at the specified position in {@code iterator}    * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to    *     the number of elements remaining in {@code iterator}    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|get (Iterator<T> iterator, int position)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|get
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|int
name|position
argument_list|)
block|{
name|checkNonnegative
argument_list|(
name|position
argument_list|)
block|;
name|int
name|skipped
operator|=
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
block|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"position ("
operator|+
name|position
operator|+
literal|") must be less than the number of elements that remained ("
operator|+
name|skipped
operator|+
literal|")"
argument_list|)
throw|;
block|}
end_expr_stmt

begin_return
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/**    * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code    * position}th position or {@code defaultValue} otherwise.    *    * @param position position of the element to return    * @param defaultValue the default value to return if the iterator is empty or if {@code position}    *     is greater than the number of elements remaining in {@code iterator}    * @return the element at the specified position in {@code iterator} or {@code defaultValue} if    *     {@code iterator} produces fewer than {@code position + 1} elements.    * @throws IndexOutOfBoundsException if {@code position} is negative    * @since 4.0    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|get ( Iterator<? extends T> iterator, int position, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|get
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
operator|,
name|int
name|position
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
name|checkNonnegative
argument_list|(
name|position
argument_list|)
block|;
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
block|;
return|return
name|getNext
argument_list|(
name|iterator
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
DECL|method|checkNonnegative (int position)
specifier|static
name|void
name|checkNonnegative
parameter_list|(
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"position ("
operator|+
name|position
operator|+
literal|") must not be negative"
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.    * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.    *    * @param defaultValue the default value to return if the iterator is empty    * @return the next element of {@code iterator} or the default value    * @since 7.0    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getNext ( Iterator<? extends T> iterator, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getNext
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|iterator
operator|.
name|next
argument_list|()
else|:
name|defaultValue
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Advances {@code iterator} to the end, returning the last element.    *    * @return the last element of {@code iterator}    * @throws NoSuchElementException if the iterator is empty    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getLast (Iterator<T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getLast
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|T
name|current
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|current
return|;
block|}
end_expr_stmt

begin_comment
unit|}   }
comment|/**    * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the    * iterator is empty.    *    * @param defaultValue the default value to return if the iterator is empty    * @return the last element of {@code iterator}    * @since 3.0    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getLast ( Iterator<? extends T> iterator, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getLast
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|getLast
argument_list|(
name|iterator
argument_list|)
else|:
name|defaultValue
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code    * hasNext()} returns {@code false}, whichever comes first.    *    * @return the number of elements the iterator was advanced    * @since 13.0 (since 3.0 as {@code Iterators.skip})    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|advance (Iterator<?> iterator, int numberToAdvance)
specifier|public
specifier|static
name|int
name|advance
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
name|int
name|numberToAdvance
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|numberToAdvance
operator|>=
literal|0
argument_list|,
literal|"numberToAdvance must be nonnegative"
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberToAdvance
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code    * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its    * elements. The returned iterator supports {@code remove()} if {@code iterator} does.    *    * @param iterator the iterator to limit    * @param limitSize the maximum number of elements in the returned iterator    * @throws IllegalArgumentException if {@code limitSize} is negative    * @since 3.0    */
end_comment

begin_expr_stmt
DECL|method|limit ( final Iterator<T> iterator, final int limitSize)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|limit
argument_list|(
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|,
name|final
name|int
name|limitSize
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
name|checkArgument
argument_list|(
name|limitSize
operator|>=
literal|0
argument_list|,
literal|"limit is negative"
argument_list|)
block|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|count
operator|<
name|limitSize
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|next
argument_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|count
operator|++
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
end_return

begin_function
unit|}        @
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Returns a view of the supplied {@code iterator} that removes each element from the supplied    * {@code iterator} as it is returned.    *    *<p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator    * will fail on the first call to {@code next}.    *    * @param iterator the iterator to remove and return elements from    * @return an iterator that removes and returns elements from the supplied iterator    * @since 2.0    */
end_comment

begin_expr_stmt
DECL|method|consumingIterator ( final Iterator<T> iterator)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|consumingIterator
argument_list|(
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|next
argument_list|()
block|{
name|T
name|next
operator|=
name|iterator
operator|.
name|next
argument_list|()
block|;
name|iterator
operator|.
name|remove
argument_list|()
block|;
return|return
name|next
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Iterators.consumingIterator(...)"
return|;
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Deletes and returns the next value from the iterator, or returns {@code null} if there is no    * such value.    */
end_comment

begin_expr_stmt
unit|@
name|CheckForNull
DECL|method|pollNext (Iterator<T> iterator)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|pollNext
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|result
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
literal|null
return|;
block|}
end_else

begin_comment
unit|}
comment|// Methods only in Iterators, not in Iterables
end_comment

begin_comment
comment|/** Clears the iterator using its remove method. */
end_comment

begin_function
DECL|method|clear (Iterator<?> iterator)
unit|static
name|void
name|clear
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns an iterator containing the elements of {@code array} in order. The returned iterator is    * a view of the array; subsequent changes to the array will be reflected in the iterator.    *    *<p><b>Note:</b> It is often preferable to represent your data using a collection type, for    * example using {@link Arrays#asList(Object[])}, making this method unnecessary.    *    *<p>The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},    * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.    */
end_comment

begin_annotation
annotation|@
name|SafeVarargs
end_annotation

begin_expr_stmt
DECL|method|forArray (final T... array)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|forArray
argument_list|(
name|final
name|T
operator|...
name|array
argument_list|)
block|{
return|return
name|forArray
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|array
operator|.
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a list iterator containing the elements in the specified range of {@code array} in    * order, starting at the specified index.    *    *<p>The {@code Iterable} equivalent of this method is {@code    * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.    */
end_comment

begin_expr_stmt
DECL|method|forArray ( final T[] array, final int offset, int length, int index)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
name|forArray
argument_list|(
name|final
name|T
index|[]
name|array
argument_list|,
name|final
name|int
name|offset
argument_list|,
name|int
name|length
argument_list|,
name|int
name|index
argument_list|)
block|{
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|)
block|;
name|int
name|end
operator|=
name|offset
operator|+
name|length
block|;
comment|// Technically we should give a slightly more descriptive error on overflow
name|Preconditions
operator|.
name|checkPositionIndexes
argument_list|(
name|offset
argument_list|,
name|end
argument_list|,
name|array
operator|.
name|length
argument_list|)
block|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|index
argument_list|,
name|length
argument_list|)
block|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|emptyListIterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|ArrayItr
argument_list|<
name|T
argument_list|>
argument_list|(
name|array
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|index
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    private
DECL|class|ArrayItr
specifier|static
name|final
name|class
name|ArrayItr
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractIndexedListIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|EMPTY
specifier|static
name|final
name|UnmodifiableListIterator
argument_list|<
name|Object
argument_list|>
name|EMPTY
operator|=
operator|new
name|ArrayItr
argument_list|<>
argument_list|(
operator|new
name|Object
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|;
DECL|field|array
specifier|private
name|final
name|T
index|[]
name|array
block|;
DECL|field|offset
specifier|private
name|final
name|int
name|offset
block|;
DECL|method|ArrayItr (T[] array, int offset, int length, int index)
name|ArrayItr
argument_list|(
name|T
index|[]
name|array
argument_list|,
name|int
name|offset
argument_list|,
name|int
name|length
argument_list|,
name|int
name|index
argument_list|)
block|{
name|super
argument_list|(
name|length
argument_list|,
name|index
argument_list|)
block|;
name|this
operator|.
name|array
operator|=
name|array
block|;
name|this
operator|.
name|offset
operator|=
name|offset
block|;     }
expr|@
name|Override
expr|@
name|ParametricNullness
DECL|method|get (int index)
specifier|protected
name|T
name|get
argument_list|(
name|int
name|index
argument_list|)
block|{
return|return
name|array
index|[
name|offset
operator|+
name|index
index|]
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns an iterator containing only {@code value}.    *    *<p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.    */
end_comment

begin_expr_stmt
DECL|method|singletonIterator ( @arametricNullness final T value)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|singletonIterator
argument_list|(
annotation|@
name|ParametricNullness
name|final
name|T
name|value
argument_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|done
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|done
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|next
argument_list|()
block|{
if|if
condition|(
name|done
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|value
return|;
end_return

begin_empty_stmt
unit|}     }
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Adapts an {@code Enumeration} to the {@code Iterator} interface.    *    *<p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as    * an {@code Iterable} is impossible. However, the contents can be<i>copied</i> into a collection    * using {@link Collections#list}.    *    *<p><b>Java 9 users:</b> use {@code enumeration.asIterator()} instead, unless it is important to    * return an {@code UnmodifiableIterator} instead of a plain {@code Iterator}.    */
end_comment

begin_expr_stmt
DECL|method|forEnumeration ( final Enumeration<T> enumeration)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|forEnumeration
argument_list|(
name|final
name|Enumeration
argument_list|<
name|T
argument_list|>
name|enumeration
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|enumeration
argument_list|)
block|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|enumeration
operator|.
name|hasMoreElements
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|next
argument_list|()
block|{
return|return
name|enumeration
operator|.
name|nextElement
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Adapts an {@code Iterator} to the {@code Enumeration} interface.    *    *<p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if    * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.    */
end_comment

begin_expr_stmt
DECL|method|asEnumeration ( final Iterator<T> iterator)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Enumeration
argument_list|<
name|T
argument_list|>
name|asEnumeration
argument_list|(
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;
return|return
operator|new
name|Enumeration
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
specifier|public
name|T
name|nextElement
argument_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/** Implementation of PeekingIterator that avoids peeking unless necessary. */
end_comment

begin_expr_stmt
DECL|class|PeekingImpl
unit|private
specifier|static
name|class
name|PeekingImpl
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
expr|implements
name|PeekingIterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|iterator
specifier|private
name|final
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
block|;
DECL|field|hasPeeked
specifier|private
name|boolean
name|hasPeeked
block|;     @
DECL|field|peekedElement
name|CheckForNull
specifier|private
name|E
name|peekedElement
block|;
DECL|method|PeekingImpl (Iterator<? extends E> iterator)
specifier|public
name|PeekingImpl
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
argument_list|)
block|{
name|this
operator|.
name|iterator
operator|=
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
argument_list|()
block|{
return|return
name|hasPeeked
operator|||
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
expr|@
name|ParametricNullness
DECL|method|next ()
specifier|public
name|E
name|next
argument_list|()
block|{
if|if
condition|(
operator|!
name|hasPeeked
condition|)
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
comment|// The cast is safe because of the hasPeeked check.
name|E
name|result
operator|=
name|uncheckedCastNullableTToT
argument_list|(
name|peekedElement
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hasPeeked
operator|=
literal|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|peekedElement
operator|=
literal|null
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|result
return|;
end_return

begin_function
unit|}      @
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|hasPeeked
argument_list|,
literal|"Can't remove after you've peeked at next"
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|peek ()
specifier|public
name|E
name|peek
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasPeeked
condition|)
block|{
name|peekedElement
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|hasPeeked
operator|=
literal|true
expr_stmt|;
block|}
comment|// The cast is safe because of the hasPeeked check.
return|return
name|uncheckedCastNullableTToT
argument_list|(
name|peekedElement
argument_list|)
return|;
block|}
end_function

begin_comment
unit|}
comment|/**    * Returns a {@code PeekingIterator} backed by the given iterator.    *    *<p>Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the    * iteration, and hence return the same object each time. A subsequent call to {@code next} is    * guaranteed to return the same object again. For example:    *    *<pre>{@code    * PeekingIterator<String> peekingIterator =    *     Iterators.peekingIterator(Iterators.forArray("a", "b"));    * String a1 = peekingIterator.peek(); // returns "a"    * String a2 = peekingIterator.peek(); // also returns "a"    * String a3 = peekingIterator.next(); // also returns "a"    * }</pre>    *    *<p>Any structural changes to the underlying iteration (aside from those performed by the    * iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined    * state.    *    *<p>The returned iterator does not support removal after peeking, as explained by {@link    * PeekingIterator#remove()}.    *    *<p>Note: If the given iterator is already a {@code PeekingIterator}, it<i>might</i> be    * returned to the caller, although this is neither guaranteed to occur nor required to be    * consistent. For example, this method<i>might</i> choose to pass through recognized    * implementations of {@code PeekingIterator} when the behavior of the implementation is known to    * meet the contract guaranteed by this method.    *    *<p>There is no {@link Iterable} equivalent to this method, so use this method to wrap each    * individual iterator as it is generated.    *    * @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this    *     iterator, so users should cease making direct calls to it after calling this method.    * @return a peeking iterator backed by that iterator. Apart from the additional {@link    *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.    */
end_comment

begin_expr_stmt
DECL|method|peekingIterator ( Iterator<? extends T> iterator)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|peekingIterator
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
argument_list|)
block|{
if|if
condition|(
name|iterator
operator|instanceof
name|PeekingImpl
condition|)
block|{
comment|// Safe to cast<? extends T> to<T> because PeekingImpl only uses T
comment|// covariantly (and cannot be subclassed to add non-covariant uses).
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|PeekingImpl
argument_list|<
name|T
argument_list|>
name|peeking
init|=
operator|(
name|PeekingImpl
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
decl_stmt|;
return|return
name|peeking
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|PeekingImpl
argument_list|<
name|T
argument_list|>
argument_list|(
name|iterator
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_expr_stmt
unit|@
name|Deprecated
DECL|method|peekingIterator ( PeekingIterator<T> iterator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|peekingIterator
argument_list|(
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an iterator over the merged contents of all given {@code iterators}, traversing every    * element of the input iterators. Equivalent entries will not be de-duplicated.    *    *<p>Callers must ensure that the source {@code iterators} are in non-descending order as this    * method does not sort its input.    *    *<p>For any equivalent elements across all {@code iterators}, it is undefined which element is    * returned first.    *    * @since 11.0    */
end_comment

begin_annotation
annotation|@
name|Beta
end_annotation

begin_expr_stmt
DECL|method|mergeSorted ( Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|mergeSorted
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterators
operator|,
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|comparator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterators
argument_list|,
literal|"iterators"
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|comparator
argument_list|,
literal|"comparator"
argument_list|)
block|;
return|return
operator|new
name|MergingIterator
argument_list|<
name|T
argument_list|>
argument_list|(
name|iterators
argument_list|,
name|comparator
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * An iterator that performs a lazy N-way merge, calculating the next value each time the iterator    * is polled. This amortizes the sorting cost over the iteration and requires less memory than    * sorting all elements at once.    *    *<p>Retrieving a single element takes approximately O(log(M)) time, where M is the number of    * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total    * number of elements.)    */
end_comment

begin_expr_stmt
DECL|class|MergingIterator
specifier|private
specifier|static
name|class
name|MergingIterator
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|queue
name|final
name|Queue
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
name|queue
block|;
DECL|method|MergingIterator ( Iterable<? extends Iterator<? extends T>> iterators, final Comparator<? super T> itemComparator)
specifier|public
name|MergingIterator
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterators
operator|,
name|final
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|itemComparator
argument_list|)
block|{
comment|// A comparator that's used by the heap, allowing the heap
comment|// to be sorted based on the top of each iterator.
name|Comparator
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
name|heapComparator
operator|=
parameter_list|(
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|o1
parameter_list|,
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|o2
parameter_list|)
lambda|->
name|itemComparator
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|peek
argument_list|()
argument_list|,
name|o2
operator|.
name|peek
argument_list|()
argument_list|)
block|;
name|queue
operator|=
operator|new
name|PriorityQueue
argument_list|<>
argument_list|(
literal|2
argument_list|,
name|heapComparator
argument_list|)
block|;
for|for
control|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
range|:
name|iterators
control|)
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|Iterators
operator|.
name|peekingIterator
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_expr_stmt

begin_function
unit|}      @
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|next ()
specifier|public
name|T
name|next
parameter_list|()
block|{
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|nextIter
init|=
name|queue
operator|.
name|remove
argument_list|()
decl_stmt|;
name|T
name|next
init|=
name|nextIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|nextIter
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_expr_stmt
unit|}    private
DECL|class|ConcatenatedIterator
specifier|static
name|class
name|ConcatenatedIterator
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
expr|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
comment|/* The last iterator to return an element.  Calls to remove() go to this iterator. */
DECL|field|toRemove
block|@
name|CheckForNull
specifier|private
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|toRemove
block|;
comment|/* The iterator currently returning elements. */
DECL|field|iterator
specifier|private
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
block|;
comment|/*      * We track the "meta iterators," the iterators-of-iterators, below.  Usually, topMetaIterator      * is the only one in use, but if we encounter nested concatenations, we start a deque of      * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each      * operation O(1).      */
DECL|field|topMetaIterator
block|@
name|CheckForNull
specifier|private
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|topMetaIterator
block|;
comment|// Only becomes nonnull if we encounter nested concatenations.
DECL|field|metaIterators
block|@
name|CheckForNull
specifier|private
name|Deque
argument_list|<
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
argument_list|>
name|metaIterators
block|;
DECL|method|ConcatenatedIterator (Iterator<? extends Iterator<? extends T>> metaIterator)
name|ConcatenatedIterator
argument_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|metaIterator
argument_list|)
block|{
name|iterator
operator|=
name|emptyIterator
argument_list|()
block|;
name|topMetaIterator
operator|=
name|checkNotNull
argument_list|(
name|metaIterator
argument_list|)
block|;     }
comment|// Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
expr|@
name|CheckForNull
DECL|method|getTopMetaIterator ()
specifier|private
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|getTopMetaIterator
argument_list|()
block|{
while|while
condition|(
name|topMetaIterator
operator|==
literal|null
operator|||
operator|!
name|topMetaIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|metaIterators
operator|!=
literal|null
operator|&&
operator|!
name|metaIterators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|topMetaIterator
operator|=
name|metaIterators
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
literal|null
return|;
block|}
end_else

begin_expr_stmt
unit|}       return
name|topMetaIterator
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
while|while
condition|(
operator|!
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// this weird checkNotNull positioning appears required by our tests, which expect
comment|// both hasNext and next to throw NPE if an input iterator is null.
name|topMetaIterator
operator|=
name|getTopMetaIterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|topMetaIterator
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|iterator
operator|=
name|topMetaIterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|iterator
operator|instanceof
name|ConcatenatedIterator
condition|)
block|{
comment|// Instead of taking linear time in the number of nested concatenations, unpack
comment|// them into the queue
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ConcatenatedIterator
argument_list|<
name|T
argument_list|>
name|topConcat
init|=
operator|(
name|ConcatenatedIterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
decl_stmt|;
name|iterator
operator|=
name|topConcat
operator|.
name|iterator
expr_stmt|;
comment|// topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,
comment|// then this.metaIterators
if|if
condition|(
name|this
operator|.
name|metaIterators
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|metaIterators
operator|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|metaIterators
operator|.
name|addFirst
argument_list|(
name|this
operator|.
name|topMetaIterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|topConcat
operator|.
name|metaIterators
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
operator|!
name|topConcat
operator|.
name|metaIterators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|metaIterators
operator|.
name|addFirst
argument_list|(
name|topConcat
operator|.
name|metaIterators
operator|.
name|removeLast
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|topMetaIterator
operator|=
name|topConcat
operator|.
name|topMetaIterator
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|next ()
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|toRemove
operator|=
name|iterator
expr_stmt|;
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|toRemove
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no calls to next() since the last call to remove()"
argument_list|)
throw|;
block|}
name|toRemove
operator|.
name|remove
argument_list|()
expr_stmt|;
name|toRemove
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
end_comment

begin_expr_stmt
DECL|method|cast (Iterator<T> iterator)
unit|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|ListIterator
argument_list|<
name|T
argument_list|>
name|cast
argument_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|)
block|{
return|return
operator|(
name|ListIterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
return|;
block|}
end_expr_stmt

unit|}
end_unit

