begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An assortment of mainly legacy static utility methods that operate on or return objects of type  * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method  * in the {@link Iterators} class.  *  *<p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for  * comparisons. This class is not being deprecated, but we gently encourage you to migrate to  * streams.  *  *<p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class  * are<i>lazy</i>, which means that their iterators only advance the backing iteration when  * absolutely necessary.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"> {@code  * Iterables}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Iterables
specifier|public
specifier|final
class|class
name|Iterables
block|{
DECL|method|Iterables ()
specifier|private
name|Iterables
parameter_list|()
block|{}
comment|/** Returns an unmodifiable view of {@code iterable}. */
DECL|method|unmodifiableIterable (final Iterable<? extends T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|unmodifiableIterable
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterable
operator|instanceof
name|UnmodifiableIterable
operator|||
name|iterable
operator|instanceof
name|ImmutableCollection
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Since it's unmodifiable, the covariant cast is safe
name|Iterable
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|(
name|Iterable
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|result
return|;
block|}
return|return
operator|new
name|UnmodifiableIterable
argument_list|<>
argument_list|(
name|iterable
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
annotation|@
name|Deprecated
DECL|method|unmodifiableIterable (ImmutableCollection<E> iterable)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|unmodifiableIterable
parameter_list|(
name|ImmutableCollection
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
return|;
block|}
DECL|class|UnmodifiableIterable
specifier|private
specifier|static
specifier|final
class|class
name|UnmodifiableIterable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|FluentIterable
argument_list|<
name|T
argument_list|>
block|{
DECL|field|iterable
specifier|private
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
decl_stmt|;
DECL|method|UnmodifiableIterable (Iterable<? extends T> iterable)
specifier|private
name|UnmodifiableIterable
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|this
operator|.
name|iterable
operator|=
name|iterable
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// no equals and hashCode; it would break the contract!
block|}
comment|/**    * Returns the number of elements in {@code iterable}.    */
DECL|method|size (Iterable<?> iterable)
specifier|public
specifier|static
name|int
name|size
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|size
argument_list|()
else|:
name|Iterators
operator|.
name|size
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code    * Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in    * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link    * ClassCastException}.    */
DECL|method|contains (Iterable<?> iterable, @Nullable Object element)
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|Collections2
operator|.
name|safeContains
argument_list|(
name|collection
argument_list|,
name|element
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that belongs to the provided    * collection.    *    *<p>This method calls {@link Collection#removeAll} if {@code iterable} is a    * collection, and {@link Iterators#removeAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRemove the elements to remove    * @return {@code true} if any element was removed from {@code iterable}    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|removeAll (Iterable<?> removeFrom, Collection<?> elementsToRemove)
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRemove
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRemove
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|removeAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRemove
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that does not belong to the    * provided collection.    *    *<p>This method calls {@link Collection#retainAll} if {@code iterable} is a    * collection, and {@link Iterators#retainAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRetain the elements to retain    * @return {@code true} if any element was removed from {@code iterable}    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|retainAll (Iterable<?> removeFrom, Collection<?> elementsToRetain)
specifier|public
specifier|static
name|boolean
name|retainAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRetain
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRetain
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|retainAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRetain
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that satisfies the provided    * predicate.    *    *<p>Removals may or may not happen immediately as each element is tested    * against the predicate.  The behavior of this method is not specified if    * {@code predicate} is dependent on {@code removeFrom}.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param predicate a predicate that determines whether an element should    *     be removed    * @return {@code true} if any elements were removed from the iterable    *    * @throws UnsupportedOperationException if the iterable does not support    *     {@code remove()}.    * @since 2.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|removeIf (Iterable<T> removeFrom, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|removeIf
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|removeFrom
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|removeFrom
operator|instanceof
name|RandomAccess
operator|&&
name|removeFrom
operator|instanceof
name|List
condition|)
block|{
return|return
name|removeIfFromRandomAccessList
argument_list|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|removeFrom
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|removeIf
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|removeIfFromRandomAccessList ( List<T> list, Predicate<? super T> predicate)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|removeIfFromRandomAccessList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// Note: Not all random access lists support set(). Additionally, it's possible
comment|// for a list to reject setting an element, such as when the list does not permit
comment|// duplicate elements. For both of those cases,  we need to fall back to a slower
comment|// implementation.
name|int
name|from
init|=
literal|0
decl_stmt|;
name|int
name|to
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|from
operator|++
control|)
block|{
name|T
name|element
init|=
name|list
operator|.
name|get
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
try|try
block|{
name|list
operator|.
name|set
argument_list|(
name|to
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|slowRemoveIfForRemainingElements
argument_list|(
name|list
argument_list|,
name|predicate
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|slowRemoveIfForRemainingElements
argument_list|(
name|list
argument_list|,
name|predicate
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|to
operator|++
expr_stmt|;
block|}
block|}
comment|// Clear the tail of any remaining items
name|list
operator|.
name|subList
argument_list|(
name|to
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|from
operator|!=
name|to
return|;
block|}
DECL|method|slowRemoveIfForRemainingElements ( List<T> list, Predicate<? super T> predicate, int to, int from)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|slowRemoveIfForRemainingElements
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|// Here we know that:
comment|// * (to< from) and that both are valid indices.
comment|// * Everything with (index< to) should be kept.
comment|// * Everything with (to<= index< from) should be removed.
comment|// * The element with (index == from) should be kept.
comment|// * Everything with (index> from) has not been checked yet.
comment|// Check from the end of the list backwards (minimize expected cost of
comment|// moving elements when remove() is called). Stop before 'from' because
comment|// we already know that should be kept.
for|for
control|(
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|n
operator|>
name|from
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|// And now remove everything in the range [to, from) (going backwards).
for|for
control|(
name|int
name|n
init|=
name|from
operator|-
literal|1
init|;
name|n
operator|>=
name|to
condition|;
name|n
operator|--
control|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Removes and returns the first matching element, or returns {@code null} if there is none.    */
annotation|@
name|Nullable
DECL|method|removeFirstMatching (Iterable<T> removeFrom, Predicate<? super T> predicate)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|removeFirstMatching
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|removeFrom
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
init|=
name|removeFrom
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|next
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Determines whether two iterables contain equal elements in the same order.    * More specifically, this method returns {@code true} if {@code iterable1}    * and {@code iterable2} contain the same number of elements and every element    * of {@code iterable1} is equal to the corresponding element of    * {@code iterable2}.    */
DECL|method|elementsEqual (Iterable<?> iterable1, Iterable<?> iterable2)
specifier|public
specifier|static
name|boolean
name|elementsEqual
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable1
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable2
parameter_list|)
block|{
if|if
condition|(
name|iterable1
operator|instanceof
name|Collection
operator|&&
name|iterable2
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|collection1
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable1
decl_stmt|;
name|Collection
argument_list|<
name|?
argument_list|>
name|collection2
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable2
decl_stmt|;
if|if
condition|(
name|collection1
operator|.
name|size
argument_list|()
operator|!=
name|collection2
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|Iterators
operator|.
name|elementsEqual
argument_list|(
name|iterable1
operator|.
name|iterator
argument_list|()
argument_list|,
name|iterable2
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of {@code iterable}, with the format {@code    * [e1, e2, ..., en]} (that is, identical to {@link java.util.Arrays    * Arrays}{@code .toString(Iterables.toArray(iterable))}). Note that for    *<i>most</i> implementations of {@link Collection}, {@code    * collection.toString()} also gives the same result, but that behavior is not    * generally guaranteed.    */
DECL|method|toString (Iterable<?> iterable)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|toString
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the single element contained in {@code iterable}.    *    *<p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code    * stream.collect(MoreCollectors.onlyElement())}.    *    * @throws NoSuchElementException if the iterable is empty    * @throws IllegalArgumentException if the iterable contains multiple elements    */
DECL|method|getOnlyElement (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the    * iterable is empty.    *    *<p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code    * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.    *    * @throws IllegalArgumentException if the iterator contains multiple elements    */
annotation|@
name|Nullable
DECL|method|getOnlyElement (Iterable<? extends T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Copies an iterable's elements into an array.    *    * @param iterable the iterable to copy    * @param type the type of the elements    * @return a newly-allocated array into which all the elements of the iterable    *     have been copied    */
annotation|@
name|GwtIncompatible
comment|// Array.newInstance(Class, int)
DECL|method|toArray (Iterable<? extends T> iterable, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|toArray
argument_list|(
name|iterable
argument_list|,
name|ObjectArrays
operator|.
name|newArray
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toArray (Iterable<? extends T> iterable, T[] array)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|T
index|[]
name|array
parameter_list|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|collection
init|=
name|castOrCopyToCollection
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
return|return
name|collection
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
comment|/**    * Copies an iterable's elements into an array.    *    * @param iterable the iterable to copy    * @return a newly-allocated array into which all the elements of the iterable    *     have been copied    */
DECL|method|toArray (Iterable<?> iterable)
specifier|static
name|Object
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|castOrCopyToCollection
argument_list|(
name|iterable
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
comment|/**    * Converts an iterable into a collection. If the iterable is already a    * collection, it is returned. Otherwise, an {@link java.util.ArrayList} is    * created with the contents of the iterable in the same iteration order.    */
DECL|method|castOrCopyToCollection (Iterable<E> iterable)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|castOrCopyToCollection
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
else|:
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Adds all elements in {@code iterable} to {@code collection}.    *    * @return {@code true} if {@code collection} was modified as a result of this    *     operation.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|addAll (Collection<T> addTo, Iterable<? extends T> elementsToAdd)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|addTo
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|elementsToAdd
parameter_list|)
block|{
if|if
condition|(
name|elementsToAdd
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
init|=
name|Collections2
operator|.
name|cast
argument_list|(
name|elementsToAdd
argument_list|)
decl_stmt|;
return|return
name|addTo
operator|.
name|addAll
argument_list|(
name|c
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|addAll
argument_list|(
name|addTo
argument_list|,
name|checkNotNull
argument_list|(
name|elementsToAdd
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the number of elements in the specified iterable that equal the specified object. This    * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.    *    *<p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code    * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code    * stream.filter(Predicate.isEqual(element)).count()} instead.    *    * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,    *      Object)    */
DECL|method|frequency (Iterable<?> iterable, @Nullable Object element)
specifier|public
specifier|static
name|int
name|frequency
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Multiset
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Multiset
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|contains
argument_list|(
name|element
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
name|Iterators
operator|.
name|frequency
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.    *    *<p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code    * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code    * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}    * is empty.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    *    *<p>To cycle over the iterable {@code n} times, use the following: {@code    * Iterables.concat(Collections.nCopies(n, iterable))}    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Stream.generate(() -> iterable).flatMap(Streams::stream)}.    */
DECL|method|cycle (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|cycle
argument_list|(
name|iterable
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
operator|+
literal|" (cycled)"
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the provided elements.    *    *<p>After {@code remove} is invoked on a generated iterator, the removed element will no longer    * appear in either that iterator or any other iterator created from the same source iterable.    * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.    * The iterator's {@code hasNext} method returns {@code true} until all of the original elements    * have been removed.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    *    *<p>To cycle over the elements {@code n} times, use the following: {@code    * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}    *    *<p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of    * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection    * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.    */
annotation|@
name|SafeVarargs
DECL|method|cycle (T... elements)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
name|T
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|cycle
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines two iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}. The source    * iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Stream.concat(a, b)}.    */
DECL|method|concat (Iterable<? extends T> a, Iterable<? extends T> b)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
comment|/**    * Combines three iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the    * elements in {@code c}. The source iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(a, b, c)}.    */
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
return|;
block|}
comment|/**    * Combines four iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the    * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not    * polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(a, b, c, d)}.    */
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c, Iterable<? extends T> d)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|d
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled    * until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(...)}.    *    * @throws NullPointerException if any of the provided iterables is null    */
annotation|@
name|SafeVarargs
DECL|method|concat (Iterable<? extends T>.... inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
modifier|...
name|inputs
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|inputs
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled    * until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it. The methods of the returned iterable may throw {@code    * NullPointerException} if any of the input iterators is null.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * streamOfStreams.flatMap(s -> s)}.    */
DECL|method|concat (Iterable<? extends Iterable<? extends T>> inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|inputs
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|inputs
argument_list|)
return|;
block|}
comment|/**    * Divides an iterable into unmodifiable sublists of the given size (the final    * iterable may be smaller). For example, partitioning an iterable containing    * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code    * [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of    * three and two elements, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link    * Iterator#remove()} method. The returned lists implement {@link    * RandomAccess}, whether or not the input list does.    *    *<p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link    * Lists#partition(List, int)} instead.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition (the last may be smaller)    * @return an iterable of unmodifiable lists containing the elements of {@code    *     iterable} divided into partitions    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|partition (final Iterable<T> iterable, final int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|partition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Divides an iterable into unmodifiable sublists of the given size, padding    * the final iterable with null values if necessary. For example, partitioning    * an iterable containing {@code [a, b, c, d, e]} with a partition size of 3    * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing    * two inner lists of three elements each, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link    * Iterator#remove()} method.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition    * @return an iterable of unmodifiable lists containing the elements of {@code    *     iterable} divided into partitions (the final iterable may have    *     trailing null elements)    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|paddedPartition (final Iterable<T> iterable, final int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|paddedPartition
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|paddedPartition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate    * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.    */
DECL|method|filter ( final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|retainIfTrue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|retainIfTrue
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|iterator
argument_list|()
argument_list|,
name|retainIfTrue
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of {@code unfiltered} containing all elements that are of the type {@code    * desiredType}. The returned iterable's iterator does not support {@code remove()}.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.    * This does perform a little more work than necessary, so another option is to insert an    * unchecked cast at some later point:    *    *<pre>    * {@code @SuppressWarnings("unchecked") // safe because of ::isInstance check    * ImmutableList<NewType> result =    *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}    *</pre>    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|GwtIncompatible
comment|// Class.isInstance
DECL|method|filter (final Iterable<?> unfiltered, final Class<T> desiredType)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|desiredType
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|desiredType
argument_list|)
expr_stmt|;
return|return
operator|(
name|Iterable
argument_list|<
name|T
argument_list|>
operator|)
name|filter
argument_list|(
name|unfiltered
argument_list|,
name|Predicates
operator|.
name|instanceOf
argument_list|(
name|desiredType
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if any element in {@code iterable} satisfies the predicate.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.    */
DECL|method|any (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|any
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code    * iterable} is empty, {@code true} is returned.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.    */
DECL|method|all (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|all
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|all
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the first element in {@code iterable} that satisfies the given    * predicate; use this method only when such an element is known to exist. If    * it is possible that<i>no</i> element will match, use {@link #tryFind} or    * {@link #find(Iterable, Predicate, Object)} instead.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}    *    * @throws NoSuchElementException if no element in {@code iterable} matches    *     the given predicate    */
DECL|method|find (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the first element in {@code iterable} that satisfies the given    * predicate, or {@code defaultValue} if none found. Note that this can    * usually be handled more naturally using {@code    * tryFind(iterable, predicate).or(defaultValue)}.    *    *<p><b>{@code Stream} equivalent:</b>    * {@code stream.filter(predicate).findFirst().orElse(defaultValue)}    *    * @since 7.0    */
annotation|@
name|Nullable
DECL|method|find ( Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns an {@link Optional} containing the first element in {@code    * iterable} that satisfies the given predicate, if such an element exists.    *    *<p><b>Warning:</b> avoid using a {@code predicate} that matches {@code    * null}. If {@code null} is matched in {@code iterable}, a    * NullPointerException will be thrown.    *    *<p><b>{@code Stream} equivalent:</b>    * {@code stream.filter(predicate).findFirst()}    *    * @since 11.0    */
DECL|method|tryFind (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|tryFind
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|tryFind
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the index in {@code iterable} of the first element that satisfies    * the provided {@code predicate}, or {@code -1} if the Iterable has no such    * elements.    *    *<p>More formally, returns the lowest index {@code i} such that    * {@code predicate.apply(Iterables.get(iterable, i))} returns {@code true},    * or {@code -1} if there is no such index.    *    * @since 2.0    */
DECL|method|indexOf (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|indexOf
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|indexOf
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns a view containing the result of applying {@code function} to each    * element of {@code fromIterable}.    *    *<p>The returned iterable's iterator supports {@code remove()} if {@code    * fromIterable}'s iterator does. After a successful {@code remove()} call,    * {@code fromIterable} no longer contains the corresponding element.    *    *<p>If the input {@code Iterable} is known to be a {@code List} or other    * {@code Collection}, consider {@link Lists#transform} and {@link    * Collections2#transform}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#map}    */
DECL|method|transform ( final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|F
argument_list|>
name|fromIterable
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fromIterable
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromIterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the element at the specified position in an iterable.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()}    * (throws {@code NoSuchElementException} if out of bounds)    *    * @param position position of the element to return    * @return the element at the specified position in {@code iterable}    * @throws IndexOutOfBoundsException if {@code position} is negative or    *     greater than or equal to the size of {@code iterable}    */
DECL|method|get (Iterable<T> iterable, int position)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|(
name|iterable
operator|instanceof
name|List
operator|)
condition|?
operator|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|get
argument_list|(
name|position
argument_list|)
else|:
name|Iterators
operator|.
name|get
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|position
argument_list|)
return|;
block|}
comment|/**    * Returns the element at the specified position in an iterable or a default    * value otherwise.    *    *<p><b>{@code Stream} equivalent:</b>    * {@code stream.skip(position).findFirst().orElse(defaultValue)}    * (returns the default value if the index is out of bounds)    *    * @param position position of the element to return    * @param defaultValue the default value to return if {@code position} is    *     greater than or equal to the size of the iterable    * @return the element at the specified position in {@code iterable} or    *     {@code defaultValue} if {@code iterable} contains fewer than    *     {@code position + 1} elements.    * @throws IndexOutOfBoundsException if {@code position} is negative    * @since 4.0    */
annotation|@
name|Nullable
DECL|method|get (Iterable<? extends T> iterable, int position, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|int
name|position
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|Iterators
operator|.
name|checkNonnegative
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list
init|=
name|Lists
operator|.
name|cast
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
return|return
operator|(
name|position
operator|<
name|list
operator|.
name|size
argument_list|()
operator|)
condition|?
name|list
operator|.
name|get
argument_list|(
name|position
argument_list|)
else|:
name|defaultValue
return|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
expr_stmt|;
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|iterator
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.    * The {@link Iterators} analog to this method is {@link Iterators#getNext}.    *    *<p>If no default value is desired (and the caller instead wants a {@link    * NoSuchElementException} to be thrown), it is recommended that {@code    * iterable.iterator().next()} is used instead.    *    *<p>To get the only element in a single-element {@code Iterable}, consider using {@link    * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}    *    * @param defaultValue the default value to return if the iterable is empty    * @return the first element of {@code iterable} or the default value    * @since 7.0    */
annotation|@
name|Nullable
DECL|method|getFirst (Iterable<? extends T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getFirst
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with    * {@link RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}    *    * @return the last element of {@code iterable}    * @throws NoSuchElementException if the iterable is empty    */
DECL|method|getLast (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
comment|// TODO(kevinb): Support a concurrently modified collection?
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|getLastInNonemptyList
argument_list|(
name|list
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the last element of {@code iterable} or {@code defaultValue} if    * the iterable is empty. If {@code iterable} is a {@link List} with    * {@link RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.    *    *<p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}    *    * @param defaultValue the value to return if {@code iterable} is empty    * @return the last element of {@code iterable} or the default value    * @since 3.0    */
annotation|@
name|Nullable
DECL|method|getLast (Iterable<? extends T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
init|=
name|Collections2
operator|.
name|cast
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
elseif|else
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
return|return
name|getLastInNonemptyList
argument_list|(
name|Lists
operator|.
name|cast
argument_list|(
name|iterable
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
DECL|method|getLastInNonemptyList (List<T> list)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLastInNonemptyList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Returns a view of {@code iterable} that skips its first    * {@code numberToSkip} elements. If {@code iterable} contains fewer than    * {@code numberToSkip} elements, the returned iterable skips all of its    * elements.    *    *<p>Modifications to the underlying {@link Iterable} before a call to    * {@code iterator()} are reflected in the returned iterator. That is, the    * iterator skips the first {@code numberToSkip} elements that exist when the    * {@code Iterator} is created, not when {@code skip()} is called.    *    *<p>The returned iterable's iterator supports {@code remove()} if the    * iterator of the underlying iterable supports it. Note that it is    *<i>not</i> possible to delete the last skipped element by immediately    * calling {@code remove()} on that iterator, as the {@code Iterator}    * contract states that a call to {@code remove()} before a call to    * {@code next()} will throw an {@link IllegalStateException}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#skip}    *    * @since 3.0    */
DECL|method|skip (final Iterable<T> iterable, final int numberToSkip)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|skip
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|numberToSkip
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|numberToSkip
operator|>=
literal|0
argument_list|,
literal|"number to skip cannot be negative"
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
name|int
name|toSkip
init|=
name|Math
operator|.
name|min
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|numberToSkip
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|subList
argument_list|(
name|toSkip
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|advance
argument_list|(
name|iterator
argument_list|,
name|numberToSkip
argument_list|)
expr_stmt|;
comment|/*          * We can't just return the iterator because an immediate call to its          * remove() method would remove one of the skipped elements instead of          * throwing an IllegalStateException.          */
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|atStart
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
name|T
name|result
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|atStart
operator|=
literal|false
expr_stmt|;
comment|// not called if next() fails
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
operator|!
name|atStart
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of {@code iterable} containing its first {@code limitSize}    * elements. If {@code iterable} contains fewer than {@code limitSize}    * elements, the returned view contains all of its elements. The returned    * iterable's iterator supports {@code remove()} if {@code iterable}'s    * iterator does.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#limit}    *    * @param iterable the iterable to limit    * @param limitSize the maximum number of elements in the returned iterable    * @throws IllegalArgumentException if {@code limitSize} is negative    * @since 3.0    */
DECL|method|limit (final Iterable<T> iterable, final int limitSize)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|limit
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|limitSize
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|limitSize
operator|>=
literal|0
argument_list|,
literal|"limit is negative"
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|limit
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|limitSize
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of the supplied iterable that wraps each generated    * {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.    *    *<p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will    * get entries from {@link Queue#remove()} since {@link Queue}'s iteration    * order is undefined.  Calling {@link Iterator#hasNext()} on a generated    * iterator from the returned iterable may cause an item to be immediately    * dequeued for return on a subsequent call to {@link Iterator#next()}.    *    * @param iterable the iterable to wrap    * @return a view of the supplied iterable that wraps each generated iterator    *     through {@link Iterators#consumingIterator(Iterator)}; for queues,    *     an iterable that generates iterators that return and consume the    *     queue's elements in queue order    *    * @see Iterators#consumingIterator(Iterator)    * @since 2.0    */
DECL|method|consumingIterable (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|consumingIterable
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Queue
operator|)
condition|?
operator|new
name|ConsumingQueueIterator
argument_list|<>
argument_list|(
operator|(
name|Queue
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
argument_list|)
else|:
name|Iterators
operator|.
name|consumingIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Iterables.consumingIterable(...)"
return|;
block|}
block|}
return|;
block|}
comment|// Methods only in Iterables, not in Iterators
comment|/**    * Determines if the given iterable contains no elements.    *    *<p>There is no precise {@link Iterator} equivalent to this method, since    * one can only ask an iterator whether it has any elements<i>remaining</i>    * (which one does using {@link Iterator#hasNext}).    *    *<p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}    *    * @return {@code true} if the iterable contains no elements    */
DECL|method|isEmpty (Iterable<?> iterable)
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
return|return
operator|!
name|iterable
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
comment|/**    * Returns an iterable over the merged contents of all given    * {@code iterables}. Equivalent entries will not be de-duplicated.    *    *<p>Callers must ensure that the source {@code iterables} are in    * non-descending order as this method does not sort its input.    *    *<p>For any equivalent elements across all {@code iterables}, it is    * undefined which element is returned first.    *    * @since 11.0    */
annotation|@
name|Beta
DECL|method|mergeSorted ( final Iterable<? extends Iterable<? extends T>> iterables, final Comparator<? super T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|mergeSorted
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterables
parameter_list|,
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterables
argument_list|,
literal|"iterables"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|comparator
argument_list|,
literal|"comparator"
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
init|=
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|mergeSorted
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|iterables
argument_list|,
name|Iterables
operator|.
expr|<
name|T
operator|>
name|toIterator
argument_list|()
argument_list|)
argument_list|,
name|comparator
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterable
argument_list|<>
argument_list|(
name|iterable
argument_list|)
return|;
block|}
comment|// TODO(user): Is this the best place for this? Move to fluent functions?
comment|// Useful as a public method?
DECL|method|toIterator ()
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Function
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|toIterator
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|apply
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|iterable
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
empty_stmt|;
block|}
block|}
end_class

end_unit

