begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2019 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Helper classes and static methods for implementing compact hash-based collections.  *  * @author Jon Noack  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
annotation|@
name|ElementTypesAreNonnullByDefault
DECL|class|CompactHashing
specifier|final
class|class
name|CompactHashing
block|{
DECL|method|CompactHashing ()
specifier|private
name|CompactHashing
parameter_list|()
block|{}
comment|/** Indicates blank table entries. */
DECL|field|UNSET
specifier|static
specifier|final
name|byte
name|UNSET
init|=
literal|0
decl_stmt|;
comment|/** Number of bits used to store the numbers of hash table bits (max 30). */
DECL|field|HASH_TABLE_BITS_MAX_BITS
specifier|private
specifier|static
specifier|final
name|int
name|HASH_TABLE_BITS_MAX_BITS
init|=
literal|5
decl_stmt|;
comment|/** Use high bits of metadata for modification count. */
DECL|field|MODIFICATION_COUNT_INCREMENT
specifier|static
specifier|final
name|int
name|MODIFICATION_COUNT_INCREMENT
init|=
operator|(
literal|1
operator|<<
name|HASH_TABLE_BITS_MAX_BITS
operator|)
decl_stmt|;
comment|/** Bitmask that selects the low bits of metadata to get hashTableBits. */
DECL|field|HASH_TABLE_BITS_MASK
specifier|static
specifier|final
name|int
name|HASH_TABLE_BITS_MASK
init|=
operator|(
literal|1
operator|<<
name|HASH_TABLE_BITS_MAX_BITS
operator|)
operator|-
literal|1
decl_stmt|;
comment|/** Maximum size of a compact hash-based collection (2^30 - 1 because 0 is UNSET). */
DECL|field|MAX_SIZE
specifier|static
specifier|final
name|int
name|MAX_SIZE
init|=
name|Ints
operator|.
name|MAX_POWER_OF_TWO
operator|-
literal|1
decl_stmt|;
comment|/** Default size of a compact hash-based collection. */
DECL|field|DEFAULT_SIZE
specifier|static
specifier|final
name|int
name|DEFAULT_SIZE
init|=
literal|3
decl_stmt|;
comment|/**    * Minimum size of the hash table of a compact hash-based collection. Because small hash tables    * use a byte[], any smaller size uses the same amount of memory due to object padding.    */
DECL|field|MIN_HASH_TABLE_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_HASH_TABLE_SIZE
init|=
literal|4
decl_stmt|;
DECL|field|BYTE_MAX_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BYTE_MAX_SIZE
init|=
literal|1
operator|<<
name|Byte
operator|.
name|SIZE
decl_stmt|;
comment|// 2^8 = 256
DECL|field|BYTE_MASK
specifier|private
specifier|static
specifier|final
name|int
name|BYTE_MASK
init|=
operator|(
literal|1
operator|<<
name|Byte
operator|.
name|SIZE
operator|)
operator|-
literal|1
decl_stmt|;
comment|// 2^8 - 1 = 255
DECL|field|SHORT_MAX_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SHORT_MAX_SIZE
init|=
literal|1
operator|<<
name|Short
operator|.
name|SIZE
decl_stmt|;
comment|// 2^16 = 65_536
DECL|field|SHORT_MASK
specifier|private
specifier|static
specifier|final
name|int
name|SHORT_MASK
init|=
operator|(
literal|1
operator|<<
name|Short
operator|.
name|SIZE
operator|)
operator|-
literal|1
decl_stmt|;
comment|// 2^16 - 1 = 65_535
comment|/**    * Returns the power of 2 hashtable size required to hold the expected number of items or the    * minimum hashtable size, whichever is greater.    */
DECL|method|tableSize (int expectedSize)
specifier|static
name|int
name|tableSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
comment|// We use entries next == 0 to indicate UNSET, so actual capacity is 1 less than requested.
return|return
name|Math
operator|.
name|max
argument_list|(
name|MIN_HASH_TABLE_SIZE
argument_list|,
name|Hashing
operator|.
name|closedTableSize
argument_list|(
name|expectedSize
operator|+
literal|1
argument_list|,
literal|1.0f
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates and returns a properly-sized array with the given number of buckets. */
DECL|method|createTable (int buckets)
specifier|static
name|Object
name|createTable
parameter_list|(
name|int
name|buckets
parameter_list|)
block|{
if|if
condition|(
name|buckets
argument_list|<
literal|2
operator|||
name|buckets
argument_list|>
name|Ints
operator|.
name|MAX_POWER_OF_TWO
operator|||
name|Integer
operator|.
name|highestOneBit
argument_list|(
name|buckets
argument_list|)
operator|!=
name|buckets
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"must be power of 2 between 2^1 and 2^30: "
operator|+
name|buckets
argument_list|)
throw|;
block|}
if|if
condition|(
name|buckets
operator|<=
name|BYTE_MAX_SIZE
condition|)
block|{
return|return
operator|new
name|byte
index|[
name|buckets
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|buckets
operator|<=
name|SHORT_MAX_SIZE
condition|)
block|{
return|return
operator|new
name|short
index|[
name|buckets
index|]
return|;
block|}
else|else
block|{
return|return
operator|new
name|int
index|[
name|buckets
index|]
return|;
block|}
block|}
DECL|method|tableClear (Object table)
specifier|static
name|void
name|tableClear
parameter_list|(
name|Object
name|table
parameter_list|)
block|{
if|if
condition|(
name|table
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|table
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|table
operator|instanceof
name|short
index|[]
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
operator|(
name|short
index|[]
operator|)
name|table
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Arrays
operator|.
name|fill
argument_list|(
operator|(
name|int
index|[]
operator|)
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|tableGet (Object table, int index)
specifier|static
name|int
name|tableGet
parameter_list|(
name|Object
name|table
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|table
operator|instanceof
name|byte
index|[]
condition|)
block|{
return|return
operator|(
operator|(
name|byte
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
operator|&
name|BYTE_MASK
return|;
comment|// unsigned read
block|}
elseif|else
if|if
condition|(
name|table
operator|instanceof
name|short
index|[]
condition|)
block|{
return|return
operator|(
operator|(
name|short
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
operator|&
name|SHORT_MASK
return|;
comment|// unsigned read
block|}
else|else
block|{
return|return
operator|(
operator|(
name|int
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
return|;
block|}
block|}
DECL|method|tableSet (Object table, int index, int entry)
specifier|static
name|void
name|tableSet
parameter_list|(
name|Object
name|table
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|entry
parameter_list|)
block|{
if|if
condition|(
name|table
operator|instanceof
name|byte
index|[]
condition|)
block|{
operator|(
operator|(
name|byte
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
operator|=
operator|(
name|byte
operator|)
name|entry
expr_stmt|;
comment|// unsigned write
block|}
elseif|else
if|if
condition|(
name|table
operator|instanceof
name|short
index|[]
condition|)
block|{
operator|(
operator|(
name|short
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
operator|=
operator|(
name|short
operator|)
name|entry
expr_stmt|;
comment|// unsigned write
block|}
else|else
block|{
operator|(
operator|(
name|int
index|[]
operator|)
name|table
operator|)
index|[
name|index
index|]
operator|=
name|entry
expr_stmt|;
block|}
block|}
comment|/**    * Returns a larger power of 2 hashtable size given the current mask.    *    *<p>For hashtable sizes less than or equal to 32, the returned power of 2 is 4x the current    * hashtable size to reduce expensive rehashing. Otherwise the returned power of 2 is 2x the    * current hashtable size.    */
DECL|method|newCapacity (int mask)
specifier|static
name|int
name|newCapacity
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mask
operator|<
literal|32
operator|)
condition|?
literal|4
else|:
literal|2
operator|)
operator|*
operator|(
name|mask
operator|+
literal|1
operator|)
return|;
block|}
comment|/** Returns the hash prefix given the current mask. */
DECL|method|getHashPrefix (int value, int mask)
specifier|static
name|int
name|getHashPrefix
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
name|value
operator|&
operator|~
name|mask
return|;
block|}
comment|/** Returns the index, or 0 if the entry is "null". */
DECL|method|getNext (int entry, int mask)
specifier|static
name|int
name|getNext
parameter_list|(
name|int
name|entry
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
name|entry
operator|&
name|mask
return|;
block|}
comment|/** Returns a new value combining the prefix and suffix using the given mask. */
DECL|method|maskCombine (int prefix, int suffix, int mask)
specifier|static
name|int
name|maskCombine
parameter_list|(
name|int
name|prefix
parameter_list|,
name|int
name|suffix
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
operator|(
name|prefix
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|suffix
operator|&
name|mask
operator|)
return|;
block|}
DECL|method|remove ( @heckForNull Object key, @CheckForNull Object value, int mask, Object table, int[] entries, @Nullable Object[] keys, @CheckForNull @Nullable Object[] values)
specifier|static
name|int
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|,
name|int
name|mask
parameter_list|,
name|Object
name|table
parameter_list|,
name|int
index|[]
name|entries
parameter_list|,
annotation|@
name|Nullable
name|Object
index|[]
name|keys
parameter_list|,
annotation|@
name|CheckForNull
annotation|@
name|Nullable
name|Object
index|[]
name|values
parameter_list|)
block|{
name|int
name|hash
init|=
name|Hashing
operator|.
name|smearedHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|tableIndex
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|int
name|next
init|=
name|tableGet
argument_list|(
name|table
argument_list|,
name|tableIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|UNSET
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|hashPrefix
init|=
name|getHashPrefix
argument_list|(
name|hash
argument_list|,
name|mask
argument_list|)
decl_stmt|;
name|int
name|lastEntryIndex
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|int
name|entryIndex
init|=
name|next
operator|-
literal|1
decl_stmt|;
name|int
name|entry
init|=
name|entries
index|[
name|entryIndex
index|]
decl_stmt|;
if|if
condition|(
name|getHashPrefix
argument_list|(
name|entry
argument_list|,
name|mask
argument_list|)
operator|==
name|hashPrefix
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|key
argument_list|,
name|keys
index|[
name|entryIndex
index|]
argument_list|)
operator|&&
operator|(
name|values
operator|==
literal|null
operator|||
name|Objects
operator|.
name|equal
argument_list|(
name|value
argument_list|,
name|values
index|[
name|entryIndex
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|newNext
init|=
name|getNext
argument_list|(
name|entry
argument_list|,
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastEntryIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we need to update the root link from table[]
name|tableSet
argument_list|(
name|table
argument_list|,
name|tableIndex
argument_list|,
name|newNext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we need to update the link from the chain
name|entries
index|[
name|lastEntryIndex
index|]
operator|=
name|maskCombine
argument_list|(
name|entries
index|[
name|lastEntryIndex
index|]
argument_list|,
name|newNext
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
return|return
name|entryIndex
return|;
block|}
name|lastEntryIndex
operator|=
name|entryIndex
expr_stmt|;
name|next
operator|=
name|getNext
argument_list|(
name|entry
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|!=
name|UNSET
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_class

end_unit

