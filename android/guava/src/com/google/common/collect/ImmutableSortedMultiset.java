begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the  * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|LazyInit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * A {@link SortedMultiset} whose contents will never change, with many other important properties  * detailed at {@link ImmutableCollection}.  *  *<p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link  * Comparator} or {@link Comparable} type whose comparison behavior is<i>inconsistent with  * equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero  *<i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting  * collection will not correctly obey its specification.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">  * immutable collections</a>.  *  * @author Louis Wasserman  * @since 12.0  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
comment|// hasn't been tested yet
DECL|class|ImmutableSortedMultiset
specifier|public
specifier|abstract
class|class
name|ImmutableSortedMultiset
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSortedMultisetFauxverideShim
argument_list|<
name|E
argument_list|>
implements|implements
name|SortedMultiset
argument_list|<
name|E
argument_list|>
block|{
comment|// TODO(lowasser): GWT compatibility
comment|/**    * Returns the empty immutable sorted multiset.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|()
block|{
return|return
operator|(
name|ImmutableSortedMultiset
operator|)
name|RegularImmutableSortedMultiset
operator|.
name|NATURAL_EMPTY_MULTISET
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing a single element.    */
DECL|method|of (E element)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|elementSet
init|=
operator|(
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|ImmutableSortedSet
operator|.
name|of
argument_list|(
name|element
argument_list|)
decl_stmt|;
name|long
index|[]
name|cumulativeCounts
init|=
block|{
literal|0
block|,
literal|1
block|}
decl_stmt|;
return|return
operator|new
name|RegularImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|elementSet
argument_list|,
name|cumulativeCounts
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2, E e3)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|,
name|E
name|e6
parameter_list|,
name|E
modifier|...
name|remaining
parameter_list|)
block|{
name|int
name|size
init|=
name|remaining
operator|.
name|length
operator|+
literal|6
decl_stmt|;
name|List
argument_list|<
name|E
argument_list|>
name|all
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|all
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|all
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|all
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (E[] elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|E
index|[]
name|elements
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering. To create a copy of a {@code SortedMultiset} that preserves the    * comparator, call {@link #copyOfSorted} instead. This method iterates over {@code elements} at    * most once.    *    *<p>Note that if {@code s} is a {@code Multiset<String>}, then {@code    * ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}    * containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}    * returns an {@code ImmutableSortedMultiset<Multiset<String>>} containing one element (the given    * multiset itself).    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedMultisetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedMultisetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by the given {@code    * Comparator}.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by the given {@code    * Comparator}. This method iterates over {@code elements} at most once.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|copyOf ( Comparator<? super E> comparator, Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|ImmutableSortedMultiset
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// immutable collections are always safe for covariant casts
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
operator|(
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
operator|)
name|elements
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|equals
argument_list|(
name|multiset
operator|.
name|comparator
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|multiset
operator|.
name|isPartialView
argument_list|()
condition|)
block|{
return|return
name|copyOfSortedEntries
argument_list|(
name|comparator
argument_list|,
name|multiset
operator|.
name|entrySet
argument_list|()
operator|.
name|asList
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|multiset
return|;
block|}
block|}
block|}
return|return
operator|new
name|ImmutableSortedMultiset
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by    * the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which    * always uses the natural ordering of the elements.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent    * collection that is currently being modified by another thread.    *    * @throws NullPointerException if {@code sortedMultiset} or any of its elements is null    */
DECL|method|copyOfSorted (SortedMultiset<E> sortedMultiset)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOfSorted
parameter_list|(
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|sortedMultiset
parameter_list|)
block|{
return|return
name|copyOfSortedEntries
argument_list|(
name|sortedMultiset
operator|.
name|comparator
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|sortedMultiset
operator|.
name|entrySet
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|copyOfSortedEntries ( Comparator<? super E> comparator, Collection<Entry<E>> entries)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOfSortedEntries
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Collection
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|emptyMultiset
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|elementsBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|long
index|[]
name|cumulativeCounts
init|=
operator|new
name|long
index|[
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|E
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|elementsBuilder
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
name|cumulativeCounts
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cumulativeCounts
index|[
name|i
index|]
operator|+
name|entry
operator|.
name|getCount
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|RegularImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|elementsBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|comparator
argument_list|)
argument_list|,
name|cumulativeCounts
argument_list|,
literal|0
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyMultiset (Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|emptyMultiset
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|equals
argument_list|(
name|comparator
argument_list|)
condition|)
block|{
return|return
operator|(
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
operator|)
name|RegularImmutableSortedMultiset
operator|.
name|NATURAL_EMPTY_MULTISET
return|;
block|}
else|else
block|{
return|return
operator|new
name|RegularImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
block|}
DECL|method|ImmutableSortedMultiset ()
name|ImmutableSortedMultiset
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|elementSet
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|elementSet ()
specifier|public
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|elementSet
parameter_list|()
function_decl|;
annotation|@
name|LazyInit
DECL|field|descendingMultiset
specifier|transient
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|descendingMultiset
decl_stmt|;
annotation|@
name|Override
DECL|method|descendingMultiset ()
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|descendingMultiset
parameter_list|()
block|{
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|result
init|=
name|descendingMultiset
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|descendingMultiset
operator|=
name|this
operator|.
name|isEmpty
argument_list|()
condition|?
name|emptyMultiset
argument_list|(
name|Ordering
operator|.
name|from
argument_list|(
name|comparator
argument_list|()
argument_list|)
operator|.
name|reverse
argument_list|()
argument_list|)
else|:
operator|new
name|DescendingImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|E
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|E
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|headMultiset (E upperBound, BoundType boundType)
specifier|public
specifier|abstract
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|headMultiset
parameter_list|(
name|E
name|upperBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|subMultiset ( E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType)
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|subMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|lowerBoundType
parameter_list|,
name|E
name|upperBound
parameter_list|,
name|BoundType
name|upperBoundType
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
operator|<=
literal|0
argument_list|,
literal|"Expected lowerBound<= upperBound but %s> %s"
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
expr_stmt|;
return|return
name|tailMultiset
argument_list|(
name|lowerBound
argument_list|,
name|lowerBoundType
argument_list|)
operator|.
name|headMultiset
argument_list|(
name|upperBound
argument_list|,
name|upperBoundType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMultiset (E lowerBound, BoundType boundType)
specifier|public
specifier|abstract
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|tailMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
function_decl|;
comment|/**    * Returns a builder that creates immutable sorted multisets with an explicit comparator. If the    * comparator has a more general type than the set being generated, such as creating a {@code    * SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder}    * constructor instead.    *    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|orderedBy (Comparator<E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|orderedBy
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted multisets whose elements are ordered by the    * reverse of their natural ordering.    *    *<p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code    * Comparable<? super E>} as a workaround for javac<a    * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.    */
DECL|method|reverseOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|reverseOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted multisets whose elements are ordered by their    * natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This    * method provides more type-safety than {@link #builder}, as it can be called only for classes    * that implement {@link Comparable}.    *    *<p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code    * Comparable<? super E>} as a workaround for javac<a    * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.    */
DECL|method|naturalOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|naturalOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * A builder for creating immutable multiset instances, especially {@code public static final}    * multisets ("constant multisets"). Example:    *    *<pre> {@code    *    *   public static final ImmutableSortedMultiset<Bean> BEANS =    *       new ImmutableSortedMultiset.Builder<Bean>(colorComparator())    *           .addCopies(Bean.COCOA, 4)    *           .addCopies(Bean.GARDEN, 6)    *           .addCopies(Bean.RED, 8)    *           .addCopies(Bean.BLACK_EYED, 10)    *           .build();}</pre>    *    *<p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build    * multiple multisets in series.    *    * @since 12.0    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableMultiset
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
block|{
comment|/*      * We keep an array of elements and counts.  Periodically -- when we need more room in the       * array, or when we're building, or the like -- we sort, deduplicate, and combine the counts.      * Negative counts indicate a setCount operation with ~counts[i].      */
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|elements
name|E
index|[]
name|elements
decl_stmt|;
DECL|field|counts
specifier|private
name|int
index|[]
name|counts
decl_stmt|;
comment|/*       * The number of used positions in the elements array.  We deduplicate periodically, so this      * may fluctuate up and down.       */
DECL|field|length
specifier|private
name|int
name|length
decl_stmt|;
comment|// True if we just called build() and the elements array is being used by a created ISM, meaning
comment|// we shouldn't modify that array further.
DECL|field|forceCopyElements
specifier|private
name|boolean
name|forceCopyElements
decl_stmt|;
comment|/**      * Creates a new builder. The returned builder is equivalent to the builder generated by      * {@link ImmutableSortedMultiset#orderedBy(Comparator)}.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Builder (Comparator<? super E> comparator)
specifier|public
name|Builder
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// doesn't allocate hash table in supertype
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|elements
operator|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|ImmutableCollection
operator|.
name|Builder
operator|.
name|DEFAULT_INITIAL_CAPACITY
index|]
expr_stmt|;
name|this
operator|.
name|counts
operator|=
operator|new
name|int
index|[
name|ImmutableCollection
operator|.
name|Builder
operator|.
name|DEFAULT_INITIAL_CAPACITY
index|]
expr_stmt|;
block|}
comment|/**      * Check if we need to do deduplication and coalescing, and if so, do it.      */
DECL|method|maintenance ()
specifier|private
name|void
name|maintenance
parameter_list|()
block|{
if|if
condition|(
name|length
operator|==
name|elements
operator|.
name|length
condition|)
block|{
name|dedupAndCoalesce
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|forceCopyElements
condition|)
block|{
name|this
operator|.
name|elements
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|,
name|elements
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// we don't currently need to copy the counts array, because we don't use it directly
comment|// in built ISMs
block|}
name|forceCopyElements
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|dedupAndCoalesce (boolean maybeExpand)
specifier|private
name|void
name|dedupAndCoalesce
parameter_list|(
name|boolean
name|maybeExpand
parameter_list|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|E
index|[]
name|sortedElements
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedElements
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|int
name|uniques
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|sortedElements
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|sortedElements
index|[
name|uniques
operator|-
literal|1
index|]
argument_list|,
name|sortedElements
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sortedElements
index|[
name|uniques
index|]
operator|=
name|sortedElements
index|[
name|i
index|]
expr_stmt|;
name|uniques
operator|++
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|sortedElements
argument_list|,
name|uniques
argument_list|,
name|length
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybeExpand
operator|&&
name|uniques
operator|*
literal|4
operator|>
name|length
operator|*
literal|3
condition|)
block|{
comment|// lots of nonduplicated elements, expand the array by 50%
name|sortedElements
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|sortedElements
argument_list|,
name|IntMath
operator|.
name|saturatedAdd
argument_list|(
name|length
argument_list|,
name|length
operator|/
literal|2
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|sortedCounts
init|=
operator|new
name|int
index|[
name|sortedElements
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedElements
argument_list|,
literal|0
argument_list|,
name|uniques
argument_list|,
name|elements
index|[
name|i
index|]
argument_list|,
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|counts
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|sortedCounts
index|[
name|index
index|]
operator|+=
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|sortedCounts
index|[
name|index
index|]
operator|=
operator|~
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|// Note that we're not getting rid, yet, of elements with count 0.  We'll do that in build().
name|this
operator|.
name|elements
operator|=
name|sortedElements
expr_stmt|;
name|this
operator|.
name|counts
operator|=
name|sortedCounts
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|uniques
expr_stmt|;
block|}
comment|/**      * Adds {@code element} to the {@code ImmutableSortedMultiset}.      *      * @param element the element to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|add (E element)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
return|return
name|addCopies
argument_list|(
name|element
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**      * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.      *      * @param element the element to add      * @param occurrences the number of occurrences of the element to add. May be zero, in which      *        case no change will be made.      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation      *         would result in more than {@link Integer#MAX_VALUE} occurrences of the element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|addCopies (E element, int occurrences)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addCopies
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|CollectPreconditions
operator|.
name|checkNonnegative
argument_list|(
name|occurrences
argument_list|,
literal|"occurrences"
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
name|maintenance
argument_list|()
expr_stmt|;
name|elements
index|[
name|length
index|]
operator|=
name|element
expr_stmt|;
name|counts
index|[
name|length
index|]
operator|=
name|occurrences
expr_stmt|;
name|length
operator|++
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds or removes the necessary occurrences of an element such that the element attains the      * desired count.      *      * @param element the element to add or remove occurrences of      * @param count the desired count of the element in this multiset      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      * @throws IllegalArgumentException if {@code count} is negative      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|setCount (E element, int count)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|CollectPreconditions
operator|.
name|checkNonnegative
argument_list|(
name|count
argument_list|,
literal|"count"
argument_list|)
expr_stmt|;
name|maintenance
argument_list|()
expr_stmt|;
name|elements
index|[
name|length
index|]
operator|=
name|element
expr_stmt|;
name|counts
index|[
name|length
index|]
operator|=
operator|~
name|count
expr_stmt|;
name|length
operator|++
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the elements to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|add (E... elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
for|for
control|(
name|E
name|element
range|:
name|elements
control|)
block|{
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|addAll (Iterable<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Multiset
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|entry
range|:
operator|(
operator|(
name|Multiset
argument_list|<
name|?
extends|extends
name|E
argument_list|>
operator|)
name|elements
operator|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|addCopies
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|,
name|entry
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|E
name|e
range|:
name|elements
control|)
block|{
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the elements to add to the {@code ImmutableSortedMultiset}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|addAll (Iterator<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
while|while
condition|(
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|add
argument_list|(
name|elements
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|dedupAndCoalesceAndDeleteEmpty ()
specifier|private
name|void
name|dedupAndCoalesceAndDeleteEmpty
parameter_list|()
block|{
name|dedupAndCoalesce
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If there was a setCount(elem, 0), those elements are still present.  Eliminate them.
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|counts
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|elements
index|[
name|size
index|]
operator|=
name|elements
index|[
name|i
index|]
expr_stmt|;
name|counts
index|[
name|size
index|]
operator|=
name|counts
index|[
name|i
index|]
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|elements
argument_list|,
name|size
argument_list|,
name|length
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|counts
argument_list|,
name|size
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|length
operator|=
name|size
expr_stmt|;
block|}
comment|/**      * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code      * Builder}.      */
annotation|@
name|Override
DECL|method|build ()
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|build
parameter_list|()
block|{
name|dedupAndCoalesceAndDeleteEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|emptyMultiset
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|elementSet
init|=
operator|(
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|ImmutableSortedSet
operator|.
name|construct
argument_list|(
name|comparator
argument_list|,
name|length
argument_list|,
name|elements
argument_list|)
decl_stmt|;
name|long
index|[]
name|cumulativeCounts
init|=
operator|new
name|long
index|[
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cumulativeCounts
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cumulativeCounts
index|[
name|i
index|]
operator|+
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
name|forceCopyElements
operator|=
literal|true
expr_stmt|;
return|return
operator|new
name|RegularImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|elementSet
argument_list|,
name|cumulativeCounts
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
DECL|class|SerializedForm
specifier|private
specifier|static
specifier|final
class|class
name|SerializedForm
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|comparator
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|elements
specifier|final
name|E
index|[]
name|elements
decl_stmt|;
DECL|field|counts
specifier|final
name|int
index|[]
name|counts
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|SerializedForm (SortedMultiset<E> multiset)
name|SerializedForm
parameter_list|(
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|multiset
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|multiset
operator|.
name|comparator
argument_list|()
expr_stmt|;
name|int
name|n
init|=
name|multiset
operator|.
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|elements
operator|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|n
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|E
argument_list|>
name|entry
range|:
name|multiset
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|elements
index|[
name|i
index|]
operator|=
name|entry
operator|.
name|getElement
argument_list|()
expr_stmt|;
name|counts
index|[
name|i
index|]
operator|=
name|entry
operator|.
name|getCount
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
name|int
name|n
init|=
name|elements
operator|.
name|length
decl_stmt|;
name|Builder
argument_list|<
name|E
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|addCopies
argument_list|(
name|elements
index|[
name|i
index|]
argument_list|,
name|counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializedForm
argument_list|<
name|E
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

end_unit

