begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * A synchronization abstraction supporting waiting on arbitrary boolean conditions.  *  *<p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}  * is less error-prone and more readable than code using {@code ReentrantLock}, without significant  * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the  * evaluation and signaling of conditions. Signaling is entirely<a  * href="http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling">implicit</a>. By  * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a  * condition becomes true (no "signaling storms" due to use of {@link  * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost  * (no "hangs" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal  * Condition.signal}).  *  *<p>A thread is said to<i>occupy</i> a monitor if it has<i>entered</i> the monitor but not yet  *<i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also  * reentrant, so a thread may enter a monitor any number of times, and then must leave the same  * number of times. The<i>enter</i> and<i>leave</i> operations have the same synchronization  * semantics as the built-in Java language synchronization primitives.  *  *<p>A call to any of the<i>enter</i> methods with<b>void</b> return type should always be  * followed immediately by a<i>try/finally</i> block to ensure that the current thread leaves the  * monitor cleanly:  *  *<pre>{@code  * monitor.enter();  * try {  *   // do things while occupying the monitor  * } finally {  *   monitor.leave();  * }  * }</pre>  *  *<p>A call to any of the<i>enter</i> methods with<b>boolean</b> return type should always appear  * as the condition of an<i>if</i> statement containing a<i>try/finally</i> block to ensure that  * the current thread leaves the monitor cleanly:  *  *<pre>{@code  * if (monitor.tryEnter()) {  *   try {  *     // do things while occupying the monitor  *   } finally {  *     monitor.leave();  *   }  * } else {  *   // do other things since the monitor was not available  * }  * }</pre>  *  *<h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>  *  *<p>The following examples show a simple threadsafe holder expressed using {@code synchronized},  * {@link ReentrantLock}, and {@code Monitor}.  *  *<h3>{@code synchronized}</h3>  *  *<p>This version is the fewest lines of code, largely because the synchronization mechanism used  * is built into the language and runtime. But the programmer has to remember to avoid a couple of  * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and  * {@code notifyAll()} must be used instead of {@code notify()} because there are two different  * logical conditions being awaited.  *  *<pre>{@code  * public class SafeBox<V> {  *   private V value;  *  *   public synchronized V get() throws InterruptedException {  *     while (value == null) {  *       wait();  *     }  *     V result = value;  *     value = null;  *     notifyAll();  *     return result;  *   }  *  *   public synchronized void set(V newValue) throws InterruptedException {  *     while (value != null) {  *       wait();  *     }  *     value = newValue;  *     notifyAll();  *   }  * }  * }</pre>  *  *<h3>{@code ReentrantLock}</h3>  *  *<p>This version is much more verbose than the {@code synchronized} version, and still suffers  * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,  * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to  * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.  *  *<pre>{@code  * public class SafeBox<V> {  *   private final ReentrantLock lock = new ReentrantLock();  *   private final Condition valuePresent = lock.newCondition();  *   private final Condition valueAbsent = lock.newCondition();  *   private V value;  *  *   public V get() throws InterruptedException {  *     lock.lock();  *     try {  *       while (value == null) {  *         valuePresent.await();  *       }  *       V result = value;  *       value = null;  *       valueAbsent.signal();  *       return result;  *     } finally {  *       lock.unlock();  *     }  *   }  *  *   public void set(V newValue) throws InterruptedException {  *     lock.lock();  *     try {  *       while (value != null) {  *         valueAbsent.await();  *       }  *       value = newValue;  *       valuePresent.signal();  *     } finally {  *       lock.unlock();  *     }  *   }  * }  * }</pre>  *  *<h3>{@code Monitor}</h3>  *  *<p>This version adds some verbosity around the {@code Guard} objects, but removes that same  * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the  * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.  * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to  * remember to use {@code while} instead of {@code if}.  *  *<pre>{@code  * public class SafeBox<V> {  *   private final Monitor monitor = new Monitor();  *   private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {  *     public boolean isSatisfied() {  *       return value != null;  *     }  *   };  *   private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {  *     public boolean isSatisfied() {  *       return value == null;  *     }  *   };  *   private V value;  *  *   public V get() throws InterruptedException {  *     monitor.enterWhen(valuePresent);  *     try {  *       V result = value;  *       value = null;  *       return result;  *     } finally {  *       monitor.leave();  *     }  *   }  *  *   public void set(V newValue) throws InterruptedException {  *     monitor.enterWhen(valueAbsent);  *     try {  *       value = newValue;  *     } finally {  *       monitor.leave();  *     }  *   }  * }  * }</pre>  *  * @author Justin T. Sampson  * @author Martin Buchholz  * @since 10.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GuardedBy"
argument_list|)
comment|// TODO(b/35466881): Fix or suppress.
DECL|class|Monitor
specifier|public
specifier|final
class|class
name|Monitor
block|{
comment|// TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.
comment|// TODO(user): "Port" jsr166 tests for ReentrantLock.
comment|//
comment|// TODO(user): Change API to make it impossible to use a Guard with the "wrong" monitor,
comment|//    by making the monitor implicit, and to eliminate other sources of IMSE.
comment|//    Imagine:
comment|//    guard.lock();
comment|//    try { /* monitor locked and guard satisfied here */ }
comment|//    finally { guard.unlock(); }
comment|// Here are Justin's design notes about this:
comment|//
comment|// This idea has come up from time to time, and I think one of my
comment|// earlier versions of Monitor even did something like this. I ended
comment|// up strongly favoring the current interface.
comment|//
comment|// I probably can't remember all the reasons (it's possible you
comment|// could find them in the code review archives), but here are a few:
comment|//
comment|// 1. What about leaving/unlocking? Are you going to do
comment|//    guard.enter() paired with monitor.leave()? That might get
comment|//    confusing. It's nice for the finally block to look as close as
comment|//    possible to the thing right before the try. You could have
comment|//    guard.leave(), but that's a little odd as well because the
comment|//    guard doesn't have anything to do with leaving. You can't
comment|//    really enforce that the guard you're leaving is the same one
comment|//    you entered with, and it doesn't actually matter.
comment|//
comment|// 2. Since you can enter the monitor without a guard at all, some
comment|//    places you'll have monitor.enter()/monitor.leave() and other
comment|//    places you'll have guard.enter()/guard.leave() even though
comment|//    it's the same lock being acquired underneath. Always using
comment|//    monitor.enterXXX()/monitor.leave() will make it really clear
comment|//    which lock is held at any point in the code.
comment|//
comment|// 3. I think "enterWhen(notEmpty)" reads better than "notEmpty.enter()".
comment|//
comment|// TODO(user): Implement ReentrantLock features:
comment|//    - toString() method
comment|//    - getOwner() method
comment|//    - getQueuedThreads() method
comment|//    - getWaitingThreads(Guard) method
comment|//    - implement Serializable
comment|//    - redo the API to be as close to identical to ReentrantLock as possible,
comment|//      since, after all, this class is also a reentrant mutual exclusion lock!?
comment|/*    * One of the key challenges of this class is to prevent lost signals, while trying hard to    * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter    * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the    * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This    * includes exceptional exits, so all control paths involving signalling must be protected by a    * finally block.    *    * Further optimizations of this algorithm become increasingly subtle. A wait that terminates    * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit    * the monitor without signalling. If it timed out without being signalled, it does not need to    * "pass on" the signal to another thread. If it *was* signalled, then its guard must have been    * satisfied at the time of signal, and has since been modified by some other thread to be    * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility    * of signaling the next waiter.    *    * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be    * lost, because the signal may be sent to a condition whose sole waiter has just been    * interrupted.    *    * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,    * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions    * need to be signalled because it is not known which if any of them have waiters (and hasWaiters    * can't be used reliably because of a check-then-act race). With our Monitor guards, we only    * signal the first active guard that is satisfied. But the corresponding thread may have already    * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,    * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted    * threads take special action by participating in the signal-passing game.    */
comment|/*    * Timeout handling is intricate, especially given our ambitious goals:    * - Avoid underflow and overflow of timeout values when specified timeouts are close to    *   Long.MIN_VALUE or Long.MAX_VALUE.    * - Favor responding to interrupts over timeouts.    * - System.nanoTime() is expensive enough that we want to call it the minimum required number of    *   times, typically once before invoking a blocking method. This often requires keeping track of    *   the first time in a method that nanoTime() has been invoked, for which the special value 0L    *   is reserved to mean "uninitialized". If timeout is non-positive, then nanoTime need never be    *   called.    * - Keep behavior of fair and non-fair instances consistent.    */
comment|/**    * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single    * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying    * the monitor, so code should not be written to rely on how often a guard might or might not be    * checked.    *    *<p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is    * associated with, an {@link IllegalMonitorStateException} is thrown.    *    * @since 10.0    */
annotation|@
name|Beta
DECL|class|Guard
specifier|public
specifier|abstract
specifier|static
class|class
name|Guard
block|{
DECL|field|monitor
annotation|@
name|Weak
specifier|final
name|Monitor
name|monitor
decl_stmt|;
DECL|field|condition
specifier|final
name|Condition
name|condition
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor.lock"
argument_list|)
DECL|field|waiterCount
name|int
name|waiterCount
init|=
literal|0
decl_stmt|;
comment|/** The next active guard */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor.lock"
argument_list|)
DECL|field|next
annotation|@
name|NullableDecl
name|Guard
name|next
decl_stmt|;
DECL|method|Guard (Monitor monitor)
specifier|protected
name|Guard
parameter_list|(
name|Monitor
name|monitor
parameter_list|)
block|{
name|this
operator|.
name|monitor
operator|=
name|checkNotNull
argument_list|(
name|monitor
argument_list|,
literal|"monitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|monitor
operator|.
name|lock
operator|.
name|newCondition
argument_list|()
expr_stmt|;
block|}
comment|/**      * Evaluates this guard's boolean condition. This method is always called with the associated      * monitor already occupied. Implementations of this method must depend only on state protected      * by the associated monitor, and must not modify that state.      */
DECL|method|isSatisfied ()
specifier|public
specifier|abstract
name|boolean
name|isSatisfied
parameter_list|()
function_decl|;
block|}
comment|/** Whether this monitor is fair. */
DECL|field|fair
specifier|private
specifier|final
name|boolean
name|fair
decl_stmt|;
comment|/** The lock underlying this monitor. */
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
decl_stmt|;
comment|/**    * The guards associated with this monitor that currently have waiters ({@code waiterCount> 0}).    * A linked list threaded through the Guard.next field.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|field|activeGuards
specifier|private
name|Guard
name|activeGuards
init|=
literal|null
decl_stmt|;
comment|/**    * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code    * Monitor(false)}.    */
DECL|method|Monitor ()
specifier|public
name|Monitor
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a monitor with the given ordering policy.    *    * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but    *     fast) one    */
DECL|method|Monitor (boolean fair)
specifier|public
name|Monitor
parameter_list|(
name|boolean
name|fair
parameter_list|)
block|{
name|this
operator|.
name|fair
operator|=
name|fair
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|(
name|fair
argument_list|)
expr_stmt|;
block|}
comment|/** Enters this monitor. Blocks indefinitely. */
DECL|method|enter ()
specifier|public
name|void
name|enter
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Enters this monitor. Blocks indefinitely, but may be interrupted.    *    * @throws InterruptedException if interrupted while waiting    */
DECL|method|enterInterruptibly ()
specifier|public
name|void
name|enterInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/**    * Enters this monitor. Blocks at most the given time.    *    * @return whether the monitor was entered    */
DECL|method|enter (long time, TimeUnit unit)
specifier|public
name|boolean
name|enter
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
specifier|final
name|long
name|timeoutNanos
init|=
name|toSafeNanos
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
if|if
condition|(
operator|!
name|fair
operator|&&
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|interrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|remainingNanos
init|=
name|timeoutNanos
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|lock
operator|.
name|tryLock
argument_list|(
name|remainingNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interrupt
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
name|remainingNanos
operator|=
name|remainingNanos
argument_list|(
name|startTime
argument_list|,
name|timeoutNanos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor. Blocks at most the given time, and may be interrupted.    *    * @return whether the monitor was entered    * @throws InterruptedException if interrupted while waiting    */
DECL|method|enterInterruptibly (long time, TimeUnit unit)
specifier|public
name|boolean
name|enterInterruptibly
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|lock
operator|.
name|tryLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Enters this monitor if it is possible to do so immediately. Does not block.    *    *<p><b>Note:</b> This method disregards the fairness setting of this monitor.    *    * @return whether the monitor was entered    */
DECL|method|tryEnter ()
specifier|public
name|boolean
name|tryEnter
parameter_list|()
block|{
return|return
name|lock
operator|.
name|tryLock
argument_list|()
return|;
block|}
comment|/**    * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.    *    * @throws InterruptedException if interrupted while waiting    */
DECL|method|enterWhen (Guard guard)
specifier|public
name|void
name|enterWhen
parameter_list|(
name|Guard
name|guard
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|boolean
name|signalBeforeWaiting
init|=
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|await
argument_list|(
name|guard
argument_list|,
name|signalBeforeWaiting
argument_list|)
expr_stmt|;
block|}
name|satisfied
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Enters this monitor when the guard is satisfied. Blocks indefinitely. */
DECL|method|enterWhenUninterruptibly (Guard guard)
specifier|public
name|void
name|enterWhenUninterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|boolean
name|signalBeforeWaiting
init|=
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|awaitUninterruptibly
argument_list|(
name|guard
argument_list|,
name|signalBeforeWaiting
argument_list|)
expr_stmt|;
block|}
name|satisfied
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both    * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be    * interrupted.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    * @throws InterruptedException if interrupted while waiting    */
DECL|method|enterWhen (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|enterWhen
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
specifier|final
name|long
name|timeoutNanos
init|=
name|toSafeNanos
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|boolean
name|reentrant
init|=
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
literal|0L
decl_stmt|;
name|locked
label|:
block|{
if|if
condition|(
operator|!
name|fair
condition|)
block|{
comment|// Check interrupt status to get behavior consistent with fair case.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
if|if
condition|(
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
break|break
name|locked
break|;
block|}
block|}
name|startTime
operator|=
name|initNanoTime
argument_list|(
name|timeoutNanos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|tryLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
try|try
block|{
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
operator|||
name|awaitNanos
argument_list|(
name|guard
argument_list|,
operator|(
name|startTime
operator|==
literal|0L
operator|)
condition|?
name|timeoutNanos
else|:
name|remainingNanos
argument_list|(
name|startTime
argument_list|,
name|timeoutNanos
argument_list|)
argument_list|,
name|reentrant
argument_list|)
expr_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|satisfied
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
try|try
block|{
comment|// Don't need to signal if timed out, but do if interrupted
if|if
condition|(
name|threw
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|signalNextWaiter
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both    * the time to acquire the lock and the time to wait for the guard to be satisfied.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    */
DECL|method|enterWhenUninterruptibly (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|enterWhenUninterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
specifier|final
name|long
name|timeoutNanos
init|=
name|toSafeNanos
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|startTime
init|=
literal|0L
decl_stmt|;
name|boolean
name|signalBeforeWaiting
init|=
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
decl_stmt|;
name|boolean
name|interrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fair
operator|||
operator|!
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
name|startTime
operator|=
name|initNanoTime
argument_list|(
name|timeoutNanos
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|remainingNanos
init|=
name|timeoutNanos
init|;
condition|;
control|)
block|{
try|try
block|{
if|if
condition|(
name|lock
operator|.
name|tryLock
argument_list|(
name|remainingNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interrupt
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
name|remainingNanos
operator|=
name|remainingNanos
argument_list|(
name|startTime
argument_list|,
name|timeoutNanos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
if|if
condition|(
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|satisfied
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|remainingNanos
decl_stmt|;
if|if
condition|(
name|startTime
operator|==
literal|0L
condition|)
block|{
name|startTime
operator|=
name|initNanoTime
argument_list|(
name|timeoutNanos
argument_list|)
expr_stmt|;
name|remainingNanos
operator|=
name|timeoutNanos
expr_stmt|;
block|}
else|else
block|{
name|remainingNanos
operator|=
name|remainingNanos
argument_list|(
name|startTime
argument_list|,
name|timeoutNanos
argument_list|)
expr_stmt|;
block|}
name|satisfied
operator|=
name|awaitNanos
argument_list|(
name|guard
argument_list|,
name|remainingNanos
argument_list|,
name|signalBeforeWaiting
argument_list|)
expr_stmt|;
block|}
return|return
name|satisfied
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interrupt
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
name|signalBeforeWaiting
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// No need to signal if timed out
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does    * not wait for the guard to be satisfied.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    */
DECL|method|enterIf (Guard guard)
specifier|public
name|boolean
name|enterIf
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
return|return
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does    * not wait for the guard to be satisfied, and may be interrupted.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    * @throws InterruptedException if interrupted while waiting    */
DECL|method|enterIfInterruptibly (Guard guard)
specifier|public
name|boolean
name|enterIfInterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|lock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
return|return
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the    * lock, but does not wait for the guard to be satisfied.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    */
DECL|method|enterIf (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|enterIf
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|!
name|enter
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
return|return
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the    * lock, but does not wait for the guard to be satisfied, and may be interrupted.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    */
DECL|method|enterIfInterruptibly (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|enterIfInterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|tryLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
return|return
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not    * block acquiring the lock and does not wait for the guard to be satisfied.    *    *<p><b>Note:</b> This method disregards the fairness setting of this monitor.    *    * @return whether the monitor was entered, which guarantees that the guard is now satisfied    */
DECL|method|tryEnterIf (Guard guard)
specifier|public
name|boolean
name|tryEnterIf
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|satisfied
init|=
literal|false
decl_stmt|;
try|try
block|{
return|return
name|satisfied
operator|=
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|satisfied
condition|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called    * only by a thread currently occupying this monitor.    *    * @throws InterruptedException if interrupted while waiting    */
DECL|method|waitFor (Guard guard)
specifier|public
name|void
name|waitFor
parameter_list|(
name|Guard
name|guard
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|guard
operator|.
name|monitor
operator|==
name|this
operator|)
operator|&
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|await
argument_list|(
name|guard
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread    * currently occupying this monitor.    */
DECL|method|waitForUninterruptibly (Guard guard)
specifier|public
name|void
name|waitForUninterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|guard
operator|.
name|monitor
operator|==
name|this
operator|)
operator|&
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|awaitUninterruptibly
argument_list|(
name|guard
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May    * be called only by a thread currently occupying this monitor.    *    * @return whether the guard is now satisfied    * @throws InterruptedException if interrupted while waiting    */
DECL|method|waitFor (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|waitFor
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
specifier|final
name|long
name|timeoutNanos
init|=
name|toSafeNanos
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|guard
operator|.
name|monitor
operator|==
name|this
operator|)
operator|&
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
if|if
condition|(
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
return|return
name|awaitNanos
argument_list|(
name|guard
argument_list|,
name|timeoutNanos
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a    * thread currently occupying this monitor.    *    * @return whether the guard is now satisfied    */
DECL|method|waitForUninterruptibly (Guard guard, long time, TimeUnit unit)
specifier|public
name|boolean
name|waitForUninterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
specifier|final
name|long
name|timeoutNanos
init|=
name|toSafeNanos
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|guard
operator|.
name|monitor
operator|==
name|this
operator|)
operator|&
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
if|if
condition|(
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|signalBeforeWaiting
init|=
literal|true
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|initNanoTime
argument_list|(
name|timeoutNanos
argument_list|)
decl_stmt|;
name|boolean
name|interrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|long
name|remainingNanos
init|=
name|timeoutNanos
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|awaitNanos
argument_list|(
name|guard
argument_list|,
name|remainingNanos
argument_list|,
name|signalBeforeWaiting
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interrupt
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|signalBeforeWaiting
operator|=
literal|false
expr_stmt|;
name|remainingNanos
operator|=
name|remainingNanos
argument_list|(
name|startTime
argument_list|,
name|timeoutNanos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Leaves this monitor. May be called only by a thread currently occupying this monitor. */
DECL|method|leave ()
specifier|public
name|void
name|leave
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
try|try
block|{
comment|// No need to signal if we will still be holding the lock when we return
if|if
condition|(
name|lock
operator|.
name|getHoldCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|signalNextWaiter
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Will throw IllegalMonitorStateException if not held
block|}
block|}
comment|/** Returns whether this monitor is using a fair ordering policy. */
DECL|method|isFair ()
specifier|public
name|boolean
name|isFair
parameter_list|()
block|{
return|return
name|fair
return|;
block|}
comment|/**    * Returns whether this monitor is occupied by any thread. This method is designed for use in    * monitoring of the system state, not for synchronization control.    */
DECL|method|isOccupied ()
specifier|public
name|boolean
name|isOccupied
parameter_list|()
block|{
return|return
name|lock
operator|.
name|isLocked
argument_list|()
return|;
block|}
comment|/**    * Returns whether the current thread is occupying this monitor (has entered more times than it    * has left).    */
DECL|method|isOccupiedByCurrentThread ()
specifier|public
name|boolean
name|isOccupiedByCurrentThread
parameter_list|()
block|{
return|return
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
return|;
block|}
comment|/**    * Returns the number of times the current thread has entered this monitor in excess of the number    * of times it has left. Returns 0 if the current thread is not occupying this monitor.    */
DECL|method|getOccupiedDepth ()
specifier|public
name|int
name|getOccupiedDepth
parameter_list|()
block|{
return|return
name|lock
operator|.
name|getHoldCount
argument_list|()
return|;
block|}
comment|/**    * Returns an estimate of the number of threads waiting to enter this monitor. The value is only    * an estimate because the number of threads may change dynamically while this method traverses    * internal data structures. This method is designed for use in monitoring of the system state,    * not for synchronization control.    */
DECL|method|getQueueLength ()
specifier|public
name|int
name|getQueueLength
parameter_list|()
block|{
return|return
name|lock
operator|.
name|getQueueLength
argument_list|()
return|;
block|}
comment|/**    * Returns whether any threads are waiting to enter this monitor. Note that because cancellations    * may occur at any time, a {@code true} return does not guarantee that any other thread will ever    * enter this monitor. This method is designed primarily for use in monitoring of the system    * state.    */
DECL|method|hasQueuedThreads ()
specifier|public
name|boolean
name|hasQueuedThreads
parameter_list|()
block|{
return|return
name|lock
operator|.
name|hasQueuedThreads
argument_list|()
return|;
block|}
comment|/**    * Queries whether the given thread is waiting to enter this monitor. Note that because    * cancellations may occur at any time, a {@code true} return does not guarantee that this thread    * will ever enter this monitor. This method is designed primarily for use in monitoring of the    * system state.    */
DECL|method|hasQueuedThread (Thread thread)
specifier|public
name|boolean
name|hasQueuedThread
parameter_list|(
name|Thread
name|thread
parameter_list|)
block|{
return|return
name|lock
operator|.
name|hasQueuedThread
argument_list|(
name|thread
argument_list|)
return|;
block|}
comment|/**    * Queries whether any threads are waiting for the given guard to become satisfied. Note that    * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee    * that the guard becoming satisfied in the future will awaken any threads. This method is    * designed primarily for use in monitoring of the system state.    */
DECL|method|hasWaiters (Guard guard)
specifier|public
name|boolean
name|hasWaiters
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
return|return
name|getWaitQueueLength
argument_list|(
name|guard
argument_list|)
operator|>
literal|0
return|;
block|}
comment|/**    * Returns an estimate of the number of threads waiting for the given guard to become satisfied.    * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an    * upper bound on the actual number of waiters. This method is designed for use in monitoring of    * the system state, not for synchronization control.    */
DECL|method|getWaitQueueLength (Guard guard)
specifier|public
name|int
name|getWaitQueueLength
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|.
name|monitor
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|guard
operator|.
name|waiterCount
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of    * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.    * Actually waiting for more than 219 years is not supported!    */
DECL|method|toSafeNanos (long time, TimeUnit unit)
specifier|private
specifier|static
name|long
name|toSafeNanos
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|long
name|timeoutNanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|time
argument_list|)
decl_stmt|;
return|return
operator|(
name|timeoutNanos
operator|<=
literal|0L
operator|)
condition|?
literal|0L
else|:
operator|(
name|timeoutNanos
operator|>
operator|(
name|Long
operator|.
name|MAX_VALUE
operator|/
literal|4
operator|)
operator|*
literal|3
operator|)
condition|?
operator|(
name|Long
operator|.
name|MAX_VALUE
operator|/
literal|4
operator|)
operator|*
literal|3
else|:
name|timeoutNanos
return|;
block|}
comment|/**    * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the    * timeout has already elapsed.    */
DECL|method|initNanoTime (long timeoutNanos)
specifier|private
specifier|static
name|long
name|initNanoTime
parameter_list|(
name|long
name|timeoutNanos
parameter_list|)
block|{
if|if
condition|(
name|timeoutNanos
operator|<=
literal|0L
condition|)
block|{
return|return
literal|0L
return|;
block|}
else|else
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
return|return
operator|(
name|startTime
operator|==
literal|0L
operator|)
condition|?
literal|1L
else|:
name|startTime
return|;
block|}
block|}
comment|/**    * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.    * Caller must have previously sanitized timeoutNanos using toSafeNanos.    */
DECL|method|remainingNanos (long startTime, long timeoutNanos)
specifier|private
specifier|static
name|long
name|remainingNanos
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|timeoutNanos
parameter_list|)
block|{
comment|// assert timeoutNanos == 0L || startTime != 0L;
comment|// TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!
comment|// if (true) return timeoutNanos;
comment|// ONLY 2 TESTS FAIL IF WE DO:
comment|// if (true) return 0;
return|return
operator|(
name|timeoutNanos
operator|<=
literal|0L
operator|)
condition|?
literal|0L
else|:
name|timeoutNanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
return|;
block|}
comment|/**    * Signals some other thread waiting on a satisfied guard, if one exists.    *    *<p>We manage calls to this method carefully, to signal only when necessary, but never losing a    * signal, which is the classic problem of this kind of concurrency construct. We must signal if    * the current thread is about to relinquish the lock and may have changed the state protected by    * the monitor, thereby causing some guard to be satisfied.    *    *<p>In addition, any thread that has been signalled when its guard was satisfied acquires the    * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a    * normal Condition, there is no guarantee that an interrupted thread has not been signalled,    * since the concurrency control must manage multiple Conditions. So this method must generally be    * called when waits are interrupted.    *    *<p>On the other hand, if a signalled thread wakes up to discover that its guard is still not    * satisfied, it does *not* need to call this method before returning to wait. This can only    * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the    * current thread can and returning the guard to the unsatisfied state. In the latter case the    * other thread (last thread modifying the state protected by the monitor) takes over the    * responsibility of signalling the next waiter.    *    *<p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else    * the current thread's guard might be mistakenly signalled, leading to a lost signal.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|signalNextWaiter ()
specifier|private
name|void
name|signalNextWaiter
parameter_list|()
block|{
for|for
control|(
name|Guard
name|guard
init|=
name|activeGuards
init|;
name|guard
operator|!=
literal|null
condition|;
name|guard
operator|=
name|guard
operator|.
name|next
control|)
block|{
if|if
condition|(
name|isSatisfied
argument_list|(
name|guard
argument_list|)
condition|)
block|{
name|guard
operator|.
name|condition
operator|.
name|signal
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**    * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,    * because caller has previously checked that guardToSkip.isSatisfied() returned false. An    * optimization for the case that guardToSkip.isSatisfied() may be expensive.    *    *<p>We decided against using this method, since in practice, isSatisfied() is likely to be very    * cheap (typically one field read). Resurrect this method if you find that not to be true.    */
comment|//   @GuardedBy("lock")
comment|//   private void signalNextWaiterSkipping(Guard guardToSkip) {
comment|//     for (Guard guard = activeGuards; guard != null; guard = guard.next) {
comment|//       if (guard != guardToSkip&& isSatisfied(guard)) {
comment|//         guard.condition.signal();
comment|//         break;
comment|//       }
comment|//     }
comment|//   }
comment|/**    * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully    * unlikely) event that isSatisfied() throws.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|isSatisfied (Guard guard)
specifier|private
name|boolean
name|isSatisfied
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
try|try
block|{
return|return
name|guard
operator|.
name|isSatisfied
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|signalAllWaiters
argument_list|()
expr_stmt|;
throw|throw
name|Throwables
operator|.
name|propagate
argument_list|(
name|throwable
argument_list|)
throw|;
block|}
block|}
comment|/** Signals all threads waiting on guards. */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|signalAllWaiters ()
specifier|private
name|void
name|signalAllWaiters
parameter_list|()
block|{
for|for
control|(
name|Guard
name|guard
init|=
name|activeGuards
init|;
name|guard
operator|!=
literal|null
condition|;
name|guard
operator|=
name|guard
operator|.
name|next
control|)
block|{
name|guard
operator|.
name|condition
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Records that the current thread is about to wait on the specified guard. */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|beginWaitingFor (Guard guard)
specifier|private
name|void
name|beginWaitingFor
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
name|int
name|waiters
init|=
name|guard
operator|.
name|waiterCount
operator|++
decl_stmt|;
if|if
condition|(
name|waiters
operator|==
literal|0
condition|)
block|{
comment|// push guard onto activeGuards
name|guard
operator|.
name|next
operator|=
name|activeGuards
expr_stmt|;
name|activeGuards
operator|=
name|guard
expr_stmt|;
block|}
block|}
comment|/** Records that the current thread is no longer waiting on the specified guard. */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|endWaitingFor (Guard guard)
specifier|private
name|void
name|endWaitingFor
parameter_list|(
name|Guard
name|guard
parameter_list|)
block|{
name|int
name|waiters
init|=
operator|--
name|guard
operator|.
name|waiterCount
decl_stmt|;
if|if
condition|(
name|waiters
operator|==
literal|0
condition|)
block|{
comment|// unlink guard from activeGuards
for|for
control|(
name|Guard
name|p
init|=
name|activeGuards
init|,
name|pred
init|=
literal|null
init|;
condition|;
name|pred
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|guard
condition|)
block|{
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
block|{
name|activeGuards
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|.
name|next
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
name|p
operator|.
name|next
operator|=
literal|null
expr_stmt|;
comment|// help GC
break|break;
block|}
block|}
block|}
block|}
comment|/*    * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording    * this fact so that other threads know to check our guard and signal us. It's caller's    * responsibility to ensure that the guard is *not* currently satisfied.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|await (Guard guard, boolean signalBeforeWaiting)
specifier|private
name|void
name|await
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|boolean
name|signalBeforeWaiting
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|signalBeforeWaiting
condition|)
block|{
name|signalNextWaiter
argument_list|()
expr_stmt|;
block|}
name|beginWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
try|try
block|{
do|do
block|{
name|guard
operator|.
name|condition
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
do|;
block|}
finally|finally
block|{
name|endWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|awaitUninterruptibly (Guard guard, boolean signalBeforeWaiting)
specifier|private
name|void
name|awaitUninterruptibly
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|boolean
name|signalBeforeWaiting
parameter_list|)
block|{
if|if
condition|(
name|signalBeforeWaiting
condition|)
block|{
name|signalNextWaiter
argument_list|()
expr_stmt|;
block|}
name|beginWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
try|try
block|{
do|do
block|{
name|guard
operator|.
name|condition
operator|.
name|awaitUninterruptibly
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
do|;
block|}
finally|finally
block|{
name|endWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Caller should check before calling that guard is not satisfied. */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|method|awaitNanos (Guard guard, long nanos, boolean signalBeforeWaiting)
specifier|private
name|boolean
name|awaitNanos
parameter_list|(
name|Guard
name|guard
parameter_list|,
name|long
name|nanos
parameter_list|,
name|boolean
name|signalBeforeWaiting
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|boolean
name|firstTime
init|=
literal|true
decl_stmt|;
try|try
block|{
do|do
block|{
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|firstTime
condition|)
block|{
if|if
condition|(
name|signalBeforeWaiting
condition|)
block|{
name|signalNextWaiter
argument_list|()
expr_stmt|;
block|}
name|beginWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
name|firstTime
operator|=
literal|false
expr_stmt|;
block|}
name|nanos
operator|=
name|guard
operator|.
name|condition
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|guard
operator|.
name|isSatisfied
argument_list|()
condition|)
do|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|firstTime
condition|)
block|{
name|endWaitingFor
argument_list|(
name|guard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

