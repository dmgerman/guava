begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateCancelledFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Base class for services that can implement {@link #startUp} and {@link #shutDown} but while in  * the "running" state need to perform a periodic task. Subclasses can implement {@link #startUp},  * {@link #shutDown} and also a {@link #runOneIteration} method that will be executed periodically.  *  *<p>This class uses the {@link ScheduledExecutorService} returned from {@link #executor} to run  * the {@link #startUp} and {@link #shutDown} methods and also uses that service to schedule the  * {@link #runOneIteration} that will be executed periodically as specified by its {@link  * Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the periodic  * task (but not interrupt it) and wait for it to stop before running the {@link #shutDown} method.  *  *<p>Subclasses are guaranteed that the life cycle methods ({@link #runOneIteration}, {@link  * #startUp} and {@link #shutDown}) will never run concurrently. Notably, if any execution of {@link  * #runOneIteration} takes longer than its schedule defines, then subsequent executions may start  * late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify  * shared state without additional synchronization necessary for visibility to later executions of  * the life cycle methods.  *  *<h3>Usage Example</h3>  *  *<p>Here is a sketch of a service which crawls a website and uses the scheduling capabilities to  * rate limit itself.  *  *<pre>{@code  * class CrawlingService extends AbstractScheduledService {  *   private Set<Uri> visited;  *   private Queue<Uri> toCrawl;  *   protected void startUp() throws Exception {  *     toCrawl = readStartingUris();  *   }  *  *   protected void runOneIteration() throws Exception {  *     Uri uri = toCrawl.remove();  *     Collection<Uri> newUris = crawl(uri);  *     visited.add(uri);  *     for (Uri newUri : newUris) {  *       if (!visited.contains(newUri)) { toCrawl.add(newUri); }  *     }  *   }  *  *   protected void shutDown() throws Exception {  *     saveUris(toCrawl);  *   }  *  *   protected Scheduler scheduler() {  *     return Scheduler.newFixedRateSchedule(0, 1, TimeUnit.SECONDS);  *   }  * }  * }</pre>  *  *<p>This class uses the life cycle methods to read in a list of starting URIs and save the set of  * outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to  * rate limit the number of queries we perform.  *  * @author Luke Sandberg  * @since 11.0  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
annotation|@
name|ElementTypesAreNonnullByDefault
DECL|class|AbstractScheduledService
specifier|public
specifier|abstract
class|class
name|AbstractScheduledService
implements|implements
name|Service
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|AbstractScheduledService
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * A scheduler defines the policy for how the {@link AbstractScheduledService} should run its    * task.    *    *<p>Consider using the {@link #newFixedDelaySchedule} and {@link #newFixedRateSchedule} factory    * methods, these provide {@link Scheduler} instances for the common use case of running the    * service with a fixed schedule. If more flexibility is needed then consider subclassing {@link    * CustomScheduler}.    *    * @author Luke Sandberg    * @since 11.0    */
DECL|class|Scheduler
specifier|public
specifier|abstract
specifier|static
class|class
name|Scheduler
block|{
comment|/**      * Returns a {@link Scheduler} that schedules the task using the {@link      * ScheduledExecutorService#scheduleWithFixedDelay} method.      *      * @param initialDelay the time to delay first execution      * @param delay the delay between the termination of one execution and the commencement of the      *     next      * @param unit the time unit of the initialDelay and delay parameters      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// should accept a java.time.Duration
DECL|method|newFixedDelaySchedule ( final long initialDelay, final long delay, final TimeUnit unit)
specifier|public
specifier|static
name|Scheduler
name|newFixedDelaySchedule
parameter_list|(
specifier|final
name|long
name|initialDelay
parameter_list|,
specifier|final
name|long
name|delay
parameter_list|,
specifier|final
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|delay
operator|>
literal|0
argument_list|,
literal|"delay must be> 0, found %s"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
return|return
operator|new
name|Scheduler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Cancellable
name|schedule
parameter_list|(
name|AbstractService
name|service
parameter_list|,
name|ScheduledExecutorService
name|executor
parameter_list|,
name|Runnable
name|task
parameter_list|)
block|{
return|return
operator|new
name|FutureAsCancellable
argument_list|(
name|executor
operator|.
name|scheduleWithFixedDelay
argument_list|(
name|task
argument_list|,
name|initialDelay
argument_list|,
name|delay
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**      * Returns a {@link Scheduler} that schedules the task using the {@link      * ScheduledExecutorService#scheduleAtFixedRate} method.      *      * @param initialDelay the time to delay first execution      * @param period the period between successive executions of the task      * @param unit the time unit of the initialDelay and period parameters      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// should accept a java.time.Duration
DECL|method|newFixedRateSchedule ( final long initialDelay, final long period, final TimeUnit unit)
specifier|public
specifier|static
name|Scheduler
name|newFixedRateSchedule
parameter_list|(
specifier|final
name|long
name|initialDelay
parameter_list|,
specifier|final
name|long
name|period
parameter_list|,
specifier|final
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|period
operator|>
literal|0
argument_list|,
literal|"period must be> 0, found %s"
argument_list|,
name|period
argument_list|)
expr_stmt|;
return|return
operator|new
name|Scheduler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Cancellable
name|schedule
parameter_list|(
name|AbstractService
name|service
parameter_list|,
name|ScheduledExecutorService
name|executor
parameter_list|,
name|Runnable
name|task
parameter_list|)
block|{
return|return
operator|new
name|FutureAsCancellable
argument_list|(
name|executor
operator|.
name|scheduleAtFixedRate
argument_list|(
name|task
argument_list|,
name|initialDelay
argument_list|,
name|period
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Schedules the task to run on the provided executor on behalf of the service. */
DECL|method|schedule ( AbstractService service, ScheduledExecutorService executor, Runnable runnable)
specifier|abstract
name|Cancellable
name|schedule
parameter_list|(
name|AbstractService
name|service
parameter_list|,
name|ScheduledExecutorService
name|executor
parameter_list|,
name|Runnable
name|runnable
parameter_list|)
function_decl|;
DECL|method|Scheduler ()
specifier|private
name|Scheduler
parameter_list|()
block|{}
block|}
comment|/* use AbstractService for state management */
DECL|field|delegate
specifier|private
specifier|final
name|AbstractService
name|delegate
init|=
operator|new
name|ServiceDelegate
argument_list|()
decl_stmt|;
annotation|@
name|WeakOuter
DECL|class|ServiceDelegate
specifier|private
specifier|final
class|class
name|ServiceDelegate
extends|extends
name|AbstractService
block|{
comment|// A handle to the running task so that we can stop it when a shutdown has been requested.
comment|// These two fields are volatile because their values will be accessed from multiple threads.
DECL|field|runningTask
annotation|@
name|CheckForNull
specifier|private
specifier|volatile
name|Cancellable
name|runningTask
decl_stmt|;
DECL|field|executorService
annotation|@
name|CheckForNull
specifier|private
specifier|volatile
name|ScheduledExecutorService
name|executorService
decl_stmt|;
comment|// This lock protects the task so we can ensure that none of the template methods (startUp,
comment|// shutDown or runOneIteration) run concurrently with one another.
comment|// TODO(lukes): why don't we use ListenableFuture to sequence things? Then we could drop the
comment|// lock.
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
annotation|@
name|WeakOuter
DECL|class|Task
class|class
name|Task
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|/*            * requireNonNull is safe because Task isn't run (or at least it doesn't succeed in taking            * the lock) until after it's scheduled and the runningTask field is set.            */
if|if
condition|(
name|requireNonNull
argument_list|(
name|runningTask
argument_list|)
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
comment|// task may have been cancelled while blocked on the lock.
return|return;
block|}
name|AbstractScheduledService
operator|.
name|this
operator|.
name|runOneIteration
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
try|try
block|{
name|shutDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Error while attempting to shut down the service after failure."
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|notifyFailed
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// requireNonNull is safe now, just as it was above.
name|requireNonNull
argument_list|(
name|runningTask
argument_list|)
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// prevent future invocations.
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|task
specifier|private
specifier|final
name|Runnable
name|task
init|=
operator|new
name|Task
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
specifier|final
name|void
name|doStart
parameter_list|()
block|{
name|executorService
operator|=
name|MoreExecutors
operator|.
name|renamingDecorator
argument_list|(
name|executor
argument_list|()
argument_list|,
operator|new
name|Supplier
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|()
block|{
return|return
name|serviceName
argument_list|()
operator|+
literal|" "
operator|+
name|state
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|startUp
argument_list|()
expr_stmt|;
name|runningTask
operator|=
name|scheduler
argument_list|()
operator|.
name|schedule
argument_list|(
name|delegate
argument_list|,
name|executorService
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|notifyFailed
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|runningTask
operator|!=
literal|null
condition|)
block|{
comment|// prevent the task from running if possible
name|runningTask
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
specifier|final
name|void
name|doStop
parameter_list|()
block|{
comment|// Both requireNonNull calls are safe because doStop can run only after a successful doStart.
name|requireNonNull
argument_list|(
name|runningTask
argument_list|)
expr_stmt|;
name|requireNonNull
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|runningTask
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
argument_list|()
operator|!=
name|State
operator|.
name|STOPPING
condition|)
block|{
comment|// This means that the state has changed since we were scheduled. This implies
comment|// that an execution of runOneIteration has thrown an exception and we have
comment|// transitioned to a failed state, also this means that shutDown has already
comment|// been called, so we do not want to call it again.
return|return;
block|}
name|shutDown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|notifyFailed
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|AbstractScheduledService
operator|.
name|this
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Constructor for use by subclasses. */
DECL|method|AbstractScheduledService ()
specifier|protected
name|AbstractScheduledService
parameter_list|()
block|{}
comment|/**    * Run one iteration of the scheduled task. If any invocation of this method throws an exception,    * the service will transition to the {@link Service.State#FAILED} state and this method will no    * longer be called.    */
DECL|method|runOneIteration ()
specifier|protected
specifier|abstract
name|void
name|runOneIteration
parameter_list|()
throws|throws
name|Exception
function_decl|;
comment|/**    * Start the service.    *    *<p>By default this method does nothing.    */
DECL|method|startUp ()
specifier|protected
name|void
name|startUp
parameter_list|()
throws|throws
name|Exception
block|{}
comment|/**    * Stop the service. This is guaranteed not to run concurrently with {@link #runOneIteration}.    *    *<p>By default this method does nothing.    */
DECL|method|shutDown ()
specifier|protected
name|void
name|shutDown
parameter_list|()
throws|throws
name|Exception
block|{}
comment|/**    * Returns the {@link Scheduler} object used to configure this service. This method will only be    * called once.    */
comment|// TODO(cpovirk): @ForOverride
DECL|method|scheduler ()
specifier|protected
specifier|abstract
name|Scheduler
name|scheduler
parameter_list|()
function_decl|;
comment|/**    * Returns the {@link ScheduledExecutorService} that will be used to execute the {@link #startUp},    * {@link #runOneIteration} and {@link #shutDown} methods. If this method is overridden the    * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this service    * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED    * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}    * instance. This method is guaranteed to only be called once.    *    *<p>By default this returns a new {@link ScheduledExecutorService} with a single thread pool    * that sets the name of the thread to the {@linkplain #serviceName() service name}. Also, the    * pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service    * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED    * fails}.    */
DECL|method|executor ()
specifier|protected
name|ScheduledExecutorService
name|executor
parameter_list|()
block|{
annotation|@
name|WeakOuter
class|class
name|ThreadFactoryImpl
implements|implements
name|ThreadFactory
block|{
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
return|return
name|MoreExecutors
operator|.
name|newThread
argument_list|(
name|serviceName
argument_list|()
argument_list|,
name|runnable
argument_list|)
return|;
block|}
block|}
specifier|final
name|ScheduledExecutorService
name|executor
init|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|ThreadFactoryImpl
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add a listener to shutdown the executor after the service is stopped. This ensures that the
comment|// JVM shutdown will not be prevented from exiting after this service has stopped or failed.
comment|// Technically this listener is added after start() was called so it is a little gross, but it
comment|// is called within doStart() so we know that the service cannot terminate or fail concurrently
comment|// with adding this listener so it is impossible to miss an event that we are interested in.
name|addListener
argument_list|(
operator|new
name|Listener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|terminated
parameter_list|(
name|State
name|from
parameter_list|)
block|{
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|failed
parameter_list|(
name|State
name|from
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|executor
return|;
block|}
comment|/**    * Returns the name of this service. {@link AbstractScheduledService} may include the name in    * debugging output.    *    * @since 14.0    */
DECL|method|serviceName ()
specifier|protected
name|String
name|serviceName
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|serviceName
argument_list|()
operator|+
literal|" ["
operator|+
name|state
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|isRunning ()
specifier|public
specifier|final
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|isRunning
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|state ()
specifier|public
specifier|final
name|State
name|state
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|state
argument_list|()
return|;
block|}
comment|/** @since 13.0 */
annotation|@
name|Override
DECL|method|addListener (Listener listener, Executor executor)
specifier|public
specifier|final
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|delegate
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/** @since 14.0 */
annotation|@
name|Override
DECL|method|failureCause ()
specifier|public
specifier|final
name|Throwable
name|failureCause
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|failureCause
argument_list|()
return|;
block|}
comment|/** @since 15.0 */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|startAsync ()
specifier|public
specifier|final
name|Service
name|startAsync
parameter_list|()
block|{
name|delegate
operator|.
name|startAsync
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @since 15.0 */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|stopAsync ()
specifier|public
specifier|final
name|Service
name|stopAsync
parameter_list|()
block|{
name|delegate
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @since 15.0 */
annotation|@
name|Override
DECL|method|awaitRunning ()
specifier|public
specifier|final
name|void
name|awaitRunning
parameter_list|()
block|{
name|delegate
operator|.
name|awaitRunning
argument_list|()
expr_stmt|;
block|}
comment|/** @since 15.0 */
annotation|@
name|Override
DECL|method|awaitRunning (long timeout, TimeUnit unit)
specifier|public
specifier|final
name|void
name|awaitRunning
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|delegate
operator|.
name|awaitRunning
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/** @since 15.0 */
annotation|@
name|Override
DECL|method|awaitTerminated ()
specifier|public
specifier|final
name|void
name|awaitTerminated
parameter_list|()
block|{
name|delegate
operator|.
name|awaitTerminated
argument_list|()
expr_stmt|;
block|}
comment|/** @since 15.0 */
annotation|@
name|Override
DECL|method|awaitTerminated (long timeout, TimeUnit unit)
specifier|public
specifier|final
name|void
name|awaitTerminated
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|delegate
operator|.
name|awaitTerminated
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
DECL|interface|Cancellable
interface|interface
name|Cancellable
block|{
DECL|method|cancel (boolean mayInterruptIfRunning)
name|void
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
function_decl|;
DECL|method|isCancelled ()
name|boolean
name|isCancelled
parameter_list|()
function_decl|;
block|}
DECL|class|FutureAsCancellable
specifier|private
specifier|static
specifier|final
class|class
name|FutureAsCancellable
implements|implements
name|Cancellable
block|{
DECL|field|delegate
specifier|private
specifier|final
name|Future
argument_list|<
name|?
argument_list|>
name|delegate
decl_stmt|;
DECL|method|FutureAsCancellable (Future<?> delegate)
name|FutureAsCancellable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|void
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|delegate
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|isCancelled
argument_list|()
return|;
block|}
block|}
comment|/**    * A {@link Scheduler} that provides a convenient way for the {@link AbstractScheduledService} to    * use a dynamically changing schedule. After every execution of the task, assuming it hasn't been    * cancelled, the {@link #getNextSchedule} method will be called.    *    * @author Luke Sandberg    * @since 11.0    */
DECL|class|CustomScheduler
specifier|public
specifier|abstract
specifier|static
class|class
name|CustomScheduler
extends|extends
name|Scheduler
block|{
comment|/** A callable class that can reschedule itself using a {@link CustomScheduler}. */
DECL|class|ReschedulableCallable
specifier|private
specifier|final
class|class
name|ReschedulableCallable
implements|implements
name|Callable
argument_list|<
annotation|@
name|Nullable
name|Void
argument_list|>
block|{
comment|/** The underlying task. */
DECL|field|wrappedRunnable
specifier|private
specifier|final
name|Runnable
name|wrappedRunnable
decl_stmt|;
comment|/** The executor on which this Callable will be scheduled. */
DECL|field|executor
specifier|private
specifier|final
name|ScheduledExecutorService
name|executor
decl_stmt|;
comment|/**        * The service that is managing this callable. This is used so that failure can be reported        * properly.        */
DECL|field|service
specifier|private
specifier|final
name|AbstractService
name|service
decl_stmt|;
comment|/**        * This lock is used to ensure safe and correct cancellation, it ensures that a new task is        * not scheduled while a cancel is ongoing. Also it protects the currentFuture variable to        * ensure that it is assigned atomically with being scheduled.        */
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/** The future that represents the next execution of this task. */
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
annotation|@
name|CheckForNull
DECL|field|cancellationDelegate
specifier|private
name|SupplantableFuture
name|cancellationDelegate
decl_stmt|;
DECL|method|ReschedulableCallable ( AbstractService service, ScheduledExecutorService executor, Runnable runnable)
name|ReschedulableCallable
parameter_list|(
name|AbstractService
name|service
parameter_list|,
name|ScheduledExecutorService
name|executor
parameter_list|,
name|Runnable
name|runnable
parameter_list|)
block|{
name|this
operator|.
name|wrappedRunnable
operator|=
name|runnable
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|call ()
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|wrappedRunnable
operator|.
name|run
argument_list|()
expr_stmt|;
name|reschedule
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**        * Atomically reschedules this task and assigns the new future to {@link        * #cancellationDelegate}.        */
annotation|@
name|CanIgnoreReturnValue
DECL|method|reschedule ()
specifier|public
name|Cancellable
name|reschedule
parameter_list|()
block|{
comment|// invoke the callback outside the lock, prevents some shenanigans.
name|Schedule
name|schedule
decl_stmt|;
try|try
block|{
name|schedule
operator|=
name|CustomScheduler
operator|.
name|this
operator|.
name|getNextSchedule
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|service
operator|.
name|notifyFailed
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|new
name|FutureAsCancellable
argument_list|(
name|immediateCancelledFuture
argument_list|()
argument_list|)
return|;
block|}
comment|// We reschedule ourselves with a lock held for two reasons. 1. we want to make sure that
comment|// cancel calls cancel on the correct future. 2. we want to make sure that the assignment
comment|// to currentFuture doesn't race with itself so that currentFuture is assigned in the
comment|// correct order.
name|Throwable
name|scheduleFailure
init|=
literal|null
decl_stmt|;
name|Cancellable
name|toReturn
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|toReturn
operator|=
name|initializeOrUpdateCancellationDelegate
argument_list|(
name|schedule
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// If an exception is thrown by the subclass then we need to make sure that the service
comment|// notices and transitions to the FAILED state. We do it by calling notifyFailed directly
comment|// because the service does not monitor the state of the future so if the exception is not
comment|// caught and forwarded to the service the task would stop executing but the service would
comment|// have no idea.
comment|// TODO(lukes): consider building everything in terms of ListenableScheduledFuture then
comment|// the AbstractService could monitor the future directly. Rescheduling is still hard...
comment|// but it would help with some of these lock ordering issues.
name|scheduleFailure
operator|=
name|e
expr_stmt|;
name|toReturn
operator|=
operator|new
name|FutureAsCancellable
argument_list|(
name|immediateCancelledFuture
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Call notifyFailed outside the lock to avoid lock ordering issues.
if|if
condition|(
name|scheduleFailure
operator|!=
literal|null
condition|)
block|{
name|service
operator|.
name|notifyFailed
argument_list|(
name|scheduleFailure
argument_list|)
expr_stmt|;
block|}
return|return
name|toReturn
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
comment|/*        * The GuardedBy checker warns us that we're not holding cancellationDelegate.lock. But in        * fact we are holding it because it is the same as this.lock, which we know we are holding,        * thanks to @GuardedBy above. (cancellationDelegate.lock is initialized to this.lock in the        * call to `new SupplantableFuture` below.)        */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GuardedBy"
argument_list|)
DECL|method|initializeOrUpdateCancellationDelegate (Schedule schedule)
specifier|private
name|Cancellable
name|initializeOrUpdateCancellationDelegate
parameter_list|(
name|Schedule
name|schedule
parameter_list|)
block|{
if|if
condition|(
name|cancellationDelegate
operator|==
literal|null
condition|)
block|{
return|return
name|cancellationDelegate
operator|=
operator|new
name|SupplantableFuture
argument_list|(
name|lock
argument_list|,
name|submitToExecutor
argument_list|(
name|schedule
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|cancellationDelegate
operator|.
name|currentFuture
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
name|cancellationDelegate
operator|.
name|currentFuture
operator|=
name|submitToExecutor
argument_list|(
name|schedule
argument_list|)
expr_stmt|;
block|}
return|return
name|cancellationDelegate
return|;
block|}
DECL|method|submitToExecutor (Schedule schedule)
specifier|private
name|ScheduledFuture
argument_list|<
annotation|@
name|Nullable
name|Void
argument_list|>
name|submitToExecutor
parameter_list|(
name|Schedule
name|schedule
parameter_list|)
block|{
return|return
name|executor
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|schedule
operator|.
name|delay
argument_list|,
name|schedule
operator|.
name|unit
argument_list|)
return|;
block|}
block|}
comment|/**      * Contains the most recently submitted {@code Future}, which may be cancelled or updated,      * always under a lock.      */
DECL|class|SupplantableFuture
specifier|private
specifier|static
specifier|final
class|class
name|SupplantableFuture
implements|implements
name|Cancellable
block|{
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"lock"
argument_list|)
DECL|field|currentFuture
specifier|private
name|Future
argument_list|<
annotation|@
name|Nullable
name|Void
argument_list|>
name|currentFuture
decl_stmt|;
DECL|method|SupplantableFuture (ReentrantLock lock, Future<@Nullable Void> currentFuture)
name|SupplantableFuture
parameter_list|(
name|ReentrantLock
name|lock
parameter_list|,
name|Future
argument_list|<
annotation|@
name|Nullable
name|Void
argument_list|>
name|currentFuture
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|currentFuture
operator|=
name|currentFuture
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|void
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
comment|/*          * Lock to ensure that a task cannot be rescheduled while a cancel is ongoing.          *          * In theory, cancel() could execute arbitrary listeners -- bad to do while holding a lock.          * However, we don't expose currentFuture to users, so they can't attach listeners. And the          * Future might not even be a ListenableFuture, just a plain Future. That said, similar          * problems can exist with methods like FutureTask.done(), not to mention slow calls to          * Thread.interrupt() (as discussed in InterruptibleTask). At the end of the day, it's          * unlikely that cancel() will be slow, so we can probably get away with calling it while          * holding a lock. Still, it would be nice to avoid somehow.          */
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|currentFuture
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|currentFuture
operator|.
name|isCancelled
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|schedule ( AbstractService service, ScheduledExecutorService executor, Runnable runnable)
specifier|final
name|Cancellable
name|schedule
parameter_list|(
name|AbstractService
name|service
parameter_list|,
name|ScheduledExecutorService
name|executor
parameter_list|,
name|Runnable
name|runnable
parameter_list|)
block|{
return|return
operator|new
name|ReschedulableCallable
argument_list|(
name|service
argument_list|,
name|executor
argument_list|,
name|runnable
argument_list|)
operator|.
name|reschedule
argument_list|()
return|;
block|}
comment|/**      * A value object that represents an absolute delay until a task should be invoked.      *      * @author Luke Sandberg      * @since 11.0      */
DECL|class|Schedule
specifier|protected
specifier|static
specifier|final
class|class
name|Schedule
block|{
DECL|field|delay
specifier|private
specifier|final
name|long
name|delay
decl_stmt|;
DECL|field|unit
specifier|private
specifier|final
name|TimeUnit
name|unit
decl_stmt|;
comment|/**        * @param delay the time from now to delay execution        * @param unit the time unit of the delay parameter        */
DECL|method|Schedule (long delay, TimeUnit unit)
specifier|public
name|Schedule
parameter_list|(
name|long
name|delay
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|this
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
name|this
operator|.
name|unit
operator|=
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Calculates the time at which to next invoke the task.      *      *<p>This is guaranteed to be called immediately after the task has completed an iteration and      * on the same thread as the previous execution of {@link      * AbstractScheduledService#runOneIteration}.      *      * @return a schedule that defines the delay before the next execution.      */
comment|// TODO(cpovirk): @ForOverride
DECL|method|getNextSchedule ()
specifier|protected
specifier|abstract
name|Schedule
name|getNextSchedule
parameter_list|()
throws|throws
name|Exception
function_decl|;
block|}
block|}
end_class

end_unit

