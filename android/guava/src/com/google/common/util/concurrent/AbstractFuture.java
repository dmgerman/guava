begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
operator|.
name|throwIfUnchecked
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
operator|.
name|newUpdater
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|internal
operator|.
name|InternalFutureFailureAccess
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|internal
operator|.
name|InternalFutures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|ForOverride
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|ReflectionSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * An abstract implementation of {@link ListenableFuture}, intended for advanced users only. More  * common ways to create a {@code ListenableFuture} include instantiating a {@link SettableFuture},  * submitting a task to a {@link ListeningExecutorService}, and deriving a {@code Future} from an  * existing one, typically using methods like {@link Futures#transform(ListenableFuture,  * com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link  * Futures#catching(ListenableFuture, Class, com.google.common.base.Function,  * java.util.concurrent.Executor) Futures.catching}.  *  *<p>This class implements all methods in {@code ListenableFuture}. Subclasses should provide a way  * to set the result of the computation through the protected methods {@link #set(Object)}, {@link  * #setFuture(ListenableFuture)} and {@link #setException(Throwable)}. Subclasses may also override  * {@link #afterDone()}, which will be invoked automatically when the future completes. Subclasses  * should rarely override other methods.  *  * @author Sven Mawson  * @author Luke Sandberg  * @since 1.0  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ShortCircuitBoolean"
argument_list|)
comment|// we use non-short circuiting comparisons intentionally
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|ReflectionSupport
argument_list|(
name|value
operator|=
name|ReflectionSupport
operator|.
name|Level
operator|.
name|FULL
argument_list|)
DECL|class|AbstractFuture
specifier|public
specifier|abstract
class|class
name|AbstractFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|InternalFutureFailureAccess
implements|implements
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{
comment|// NOTE: Whenever both tests are cheap and functional, it's faster to use&, | instead of&&, ||
DECL|field|GENERATE_CANCELLATION_CAUSES
specifier|private
specifier|static
specifier|final
name|boolean
name|GENERATE_CANCELLATION_CAUSES
decl_stmt|;
static|static
block|{
comment|// System.getProperty may throw if the security policy does not permit access.
name|boolean
name|generateCancellationCauses
decl_stmt|;
try|try
block|{
name|generateCancellationCauses
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"guava.concurrent.generate_cancellation_cause"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|generateCancellationCauses
operator|=
literal|false
expr_stmt|;
block|}
name|GENERATE_CANCELLATION_CAUSES
operator|=
name|generateCancellationCauses
expr_stmt|;
block|}
comment|/**    * Tag interface marking trusted subclasses. This enables some optimizations. The implementation    * of this interface must also be an AbstractFuture and must not override or expose for overriding    * any of the public methods of ListenableFuture.    */
DECL|interface|Trusted
interface|interface
name|Trusted
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{}
comment|/**    * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.    */
DECL|class|TrustedFuture
specifier|abstract
specifier|static
class|class
name|TrustedFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractFuture
argument_list|<
name|V
argument_list|>
implements|implements
name|Trusted
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|get ()
specifier|public
specifier|final
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|super
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
specifier|final
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|super
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isDone ()
specifier|public
specifier|final
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|super
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
specifier|final
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|super
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor executor)
specifier|public
specifier|final
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|super
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
specifier|final
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|super
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
block|}
comment|// Logger to log exceptions caught when running listeners.
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|AbstractFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// A heuristic for timed gets. If the remaining timeout is less than this, spin instead of
comment|// blocking. This value is what AbstractQueuedSynchronizer uses.
DECL|field|SPIN_THRESHOLD_NANOS
specifier|private
specifier|static
specifier|final
name|long
name|SPIN_THRESHOLD_NANOS
init|=
literal|1000L
decl_stmt|;
DECL|field|ATOMIC_HELPER
specifier|private
specifier|static
specifier|final
name|AtomicHelper
name|ATOMIC_HELPER
decl_stmt|;
static|static
block|{
name|AtomicHelper
name|helper
decl_stmt|;
name|Throwable
name|thrownUnsafeFailure
init|=
literal|null
decl_stmt|;
name|Throwable
name|thrownAtomicReferenceFieldUpdaterFailure
init|=
literal|null
decl_stmt|;
try|try
block|{
name|helper
operator|=
operator|new
name|UnsafeAtomicHelper
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|unsafeFailure
parameter_list|)
block|{
name|thrownUnsafeFailure
operator|=
name|unsafeFailure
expr_stmt|;
comment|// catch absolutely everything and fall through to our 'SafeAtomicHelper'
comment|// The access control checks that ARFU does means the caller class has to be AbstractFuture
comment|// instead of SafeAtomicHelper, so we annoyingly define these here
try|try
block|{
name|helper
operator|=
operator|new
name|SafeAtomicHelper
argument_list|(
name|newUpdater
argument_list|(
name|Waiter
operator|.
name|class
argument_list|,
name|Thread
operator|.
name|class
argument_list|,
literal|"thread"
argument_list|)
argument_list|,
name|newUpdater
argument_list|(
name|Waiter
operator|.
name|class
argument_list|,
name|Waiter
operator|.
name|class
argument_list|,
literal|"next"
argument_list|)
argument_list|,
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Waiter
operator|.
name|class
argument_list|,
literal|"waiters"
argument_list|)
argument_list|,
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Listener
operator|.
name|class
argument_list|,
literal|"listeners"
argument_list|)
argument_list|,
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|atomicReferenceFieldUpdaterFailure
parameter_list|)
block|{
comment|// Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause
comment|// getDeclaredField to throw a NoSuchFieldException when the field is definitely there.
comment|// For these users fallback to a suboptimal implementation, based on synchronized. This will
comment|// be a definite performance hit to those users.
name|thrownAtomicReferenceFieldUpdaterFailure
operator|=
name|atomicReferenceFieldUpdaterFailure
expr_stmt|;
name|helper
operator|=
operator|new
name|SynchronizedHelper
argument_list|()
expr_stmt|;
block|}
block|}
name|ATOMIC_HELPER
operator|=
name|helper
expr_stmt|;
comment|// Prevent rare disastrous classloading in first call to LockSupport.park.
comment|// See: https://bugs.openjdk.java.net/browse/JDK-8074773
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|Class
argument_list|<
name|?
argument_list|>
name|ensureLoaded
init|=
name|LockSupport
operator|.
name|class
decl_stmt|;
comment|// Log after all static init is finished; if an installed logger uses any Futures methods, it
comment|// shouldn't break in cases where reflection is missing/broken.
if|if
condition|(
name|thrownAtomicReferenceFieldUpdaterFailure
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"UnsafeAtomicHelper is broken!"
argument_list|,
name|thrownUnsafeFailure
argument_list|)
expr_stmt|;
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"SafeAtomicHelper is broken!"
argument_list|,
name|thrownAtomicReferenceFieldUpdaterFailure
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Waiter links form a Treiber stack, in the {@link #waiters} field. */
DECL|class|Waiter
specifier|private
specifier|static
specifier|final
class|class
name|Waiter
block|{
DECL|field|TOMBSTONE
specifier|static
specifier|final
name|Waiter
name|TOMBSTONE
init|=
operator|new
name|Waiter
argument_list|(
literal|false
comment|/* ignored param */
argument_list|)
decl_stmt|;
DECL|field|thread
annotation|@
name|NullableDecl
specifier|volatile
name|Thread
name|thread
decl_stmt|;
DECL|field|next
annotation|@
name|NullableDecl
specifier|volatile
name|Waiter
name|next
decl_stmt|;
comment|/**      * Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded      * before the ATOMIC_HELPER. Apparently this is possible on some android platforms.      */
DECL|method|Waiter (boolean unused)
name|Waiter
parameter_list|(
name|boolean
name|unused
parameter_list|)
block|{}
DECL|method|Waiter ()
name|Waiter
parameter_list|()
block|{
comment|// avoid volatile write, write is made visible by subsequent CAS on waiters field
name|ATOMIC_HELPER
operator|.
name|putThread
argument_list|(
name|this
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// non-volatile write to the next field. Should be made visible by subsequent CAS on waiters
comment|// field.
DECL|method|setNext (Waiter next)
name|void
name|setNext
parameter_list|(
name|Waiter
name|next
parameter_list|)
block|{
name|ATOMIC_HELPER
operator|.
name|putNext
argument_list|(
name|this
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
DECL|method|unpark ()
name|void
name|unpark
parameter_list|()
block|{
comment|// This is racy with removeWaiter. The consequence of the race is that we may spuriously call
comment|// unpark even though the thread has already removed itself from the list. But even if we did
comment|// use a CAS, that race would still exist (it would just be ever so slightly smaller).
name|Thread
name|w
init|=
name|thread
decl_stmt|;
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Marks the given node as 'deleted' (null waiter) and then scans the list to unlink all deleted    * nodes. This is an O(n) operation in the common case (and O(n^2) in the worst), but we are saved    * by two things.    *    *<ul>    *<li>This is only called when a waiting thread times out or is interrupted. Both of which    *       should be rare.    *<li>The waiters list should be very short.    *</ul>    */
DECL|method|removeWaiter (Waiter node)
specifier|private
name|void
name|removeWaiter
parameter_list|(
name|Waiter
name|node
parameter_list|)
block|{
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
comment|// mark as 'deleted'
name|restart
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|Waiter
name|pred
init|=
literal|null
decl_stmt|;
name|Waiter
name|curr
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|curr
operator|==
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
return|return;
comment|// give up if someone is calling complete
block|}
name|Waiter
name|succ
decl_stmt|;
while|while
condition|(
name|curr
operator|!=
literal|null
condition|)
block|{
name|succ
operator|=
name|curr
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|.
name|thread
operator|!=
literal|null
condition|)
block|{
comment|// we aren't unlinking this node, update pred.
name|pred
operator|=
name|curr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
block|{
comment|// We are unlinking this node and it has a predecessor.
name|pred
operator|.
name|next
operator|=
name|succ
expr_stmt|;
if|if
condition|(
name|pred
operator|.
name|thread
operator|==
literal|null
condition|)
block|{
comment|// We raced with another node that unlinked pred. Restart.
continue|continue
name|restart
continue|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|curr
argument_list|,
name|succ
argument_list|)
condition|)
block|{
comment|// We are unlinking head
continue|continue
name|restart
continue|;
comment|// We raced with an add or complete
block|}
name|curr
operator|=
name|succ
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/** Listeners also form a stack through the {@link #listeners} field. */
DECL|class|Listener
specifier|private
specifier|static
specifier|final
class|class
name|Listener
block|{
DECL|field|TOMBSTONE
specifier|static
specifier|final
name|Listener
name|TOMBSTONE
init|=
operator|new
name|Listener
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
DECL|field|task
specifier|final
name|Runnable
name|task
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
comment|// writes to next are made visible by subsequent CAS's on the listeners field
DECL|field|next
annotation|@
name|NullableDecl
name|Listener
name|next
decl_stmt|;
DECL|method|Listener (Runnable task, Executor executor)
name|Listener
parameter_list|(
name|Runnable
name|task
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
block|}
comment|/** A special value to represent {@code null}. */
DECL|field|NULL
specifier|private
specifier|static
specifier|final
name|Object
name|NULL
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/** A special value to represent failure, when {@link #setException} is called successfully. */
DECL|class|Failure
specifier|private
specifier|static
specifier|final
class|class
name|Failure
block|{
DECL|field|FALLBACK_INSTANCE
specifier|static
specifier|final
name|Failure
name|FALLBACK_INSTANCE
init|=
operator|new
name|Failure
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"Failure occurred while trying to finish a future."
argument_list|)
block|{
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Throwable
name|fillInStackTrace
parameter_list|()
block|{
return|return
name|this
return|;
comment|// no stack trace
block|}
block|}
argument_list|)
decl_stmt|;
DECL|field|exception
specifier|final
name|Throwable
name|exception
decl_stmt|;
DECL|method|Failure (Throwable exception)
name|Failure
parameter_list|(
name|Throwable
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|checkNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** A special value to represent cancellation and the 'wasInterrupted' bit. */
DECL|class|Cancellation
specifier|private
specifier|static
specifier|final
class|class
name|Cancellation
block|{
comment|// constants to use when GENERATE_CANCELLATION_CAUSES = false
DECL|field|CAUSELESS_INTERRUPTED
specifier|static
specifier|final
name|Cancellation
name|CAUSELESS_INTERRUPTED
decl_stmt|;
DECL|field|CAUSELESS_CANCELLED
specifier|static
specifier|final
name|Cancellation
name|CAUSELESS_CANCELLED
decl_stmt|;
static|static
block|{
if|if
condition|(
name|GENERATE_CANCELLATION_CAUSES
condition|)
block|{
name|CAUSELESS_CANCELLED
operator|=
literal|null
expr_stmt|;
name|CAUSELESS_INTERRUPTED
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|CAUSELESS_CANCELLED
operator|=
operator|new
name|Cancellation
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|CAUSELESS_INTERRUPTED
operator|=
operator|new
name|Cancellation
argument_list|(
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|wasInterrupted
specifier|final
name|boolean
name|wasInterrupted
decl_stmt|;
DECL|field|cause
annotation|@
name|NullableDecl
specifier|final
name|Throwable
name|cause
decl_stmt|;
DECL|method|Cancellation (boolean wasInterrupted, @NullableDecl Throwable cause)
name|Cancellation
parameter_list|(
name|boolean
name|wasInterrupted
parameter_list|,
annotation|@
name|NullableDecl
name|Throwable
name|cause
parameter_list|)
block|{
name|this
operator|.
name|wasInterrupted
operator|=
name|wasInterrupted
expr_stmt|;
name|this
operator|.
name|cause
operator|=
name|cause
expr_stmt|;
block|}
block|}
comment|/** A special value that encodes the 'setFuture' state. */
DECL|class|SetFuture
specifier|private
specifier|static
specifier|final
class|class
name|SetFuture
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Runnable
block|{
DECL|field|owner
specifier|final
name|AbstractFuture
argument_list|<
name|V
argument_list|>
name|owner
decl_stmt|;
DECL|field|future
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
decl_stmt|;
DECL|method|SetFuture (AbstractFuture<V> owner, ListenableFuture<? extends V> future)
name|SetFuture
parameter_list|(
name|AbstractFuture
argument_list|<
name|V
argument_list|>
name|owner
parameter_list|,
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|owner
operator|.
name|value
operator|!=
name|this
condition|)
block|{
comment|// nothing to do, we must have been cancelled, don't bother inspecting the future.
return|return;
block|}
name|Object
name|valueToSet
init|=
name|getFutureValue
argument_list|(
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|owner
argument_list|,
name|this
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO(lukes): investigate using the @Contended annotation on these fields when jdk8 is
comment|// available.
comment|/**    * This field encodes the current state of the future.    *    *<p>The valid values are:    *    *<ul>    *<li>{@code null} initial state, nothing has happened.    *<li>{@link Cancellation} terminal state, {@code cancel} was called.    *<li>{@link Failure} terminal state, {@code setException} was called.    *<li>{@link SetFuture} intermediate state, {@code setFuture} was called.    *<li>{@link #NULL} terminal state, {@code set(null)} was called.    *<li>Any other non-null value, terminal state, {@code set} was called with a non-null    *       argument.    *</ul>    */
DECL|field|value
annotation|@
name|NullableDecl
specifier|private
specifier|volatile
name|Object
name|value
decl_stmt|;
comment|/** All listeners. */
DECL|field|listeners
annotation|@
name|NullableDecl
specifier|private
specifier|volatile
name|Listener
name|listeners
decl_stmt|;
comment|/** All waiting threads. */
DECL|field|waiters
annotation|@
name|NullableDecl
specifier|private
specifier|volatile
name|Waiter
name|waiters
decl_stmt|;
comment|/** Constructor for use by subclasses. */
DECL|method|AbstractFuture ()
specifier|protected
name|AbstractFuture
parameter_list|()
block|{}
comment|// Gets and Timed Gets
comment|//
comment|// * Be responsive to interruption
comment|// * Don't create Waiter nodes if you aren't going to park, this helps reduce contention on the
comment|//   waiters field.
comment|// * Future completion is defined by when #value becomes non-null/non SetFuture
comment|// * Future completion can be observed if the waiters field contains a TOMBSTONE
comment|// Timed Get
comment|// There are a few design constraints to consider
comment|// * We want to be responsive to small timeouts, unpark() has non trivial latency overheads (I
comment|//   have observed 12 micros on 64 bit linux systems to wake up a parked thread). So if the
comment|//   timeout is small we shouldn't park(). This needs to be traded off with the cpu overhead of
comment|//   spinning, so we use SPIN_THRESHOLD_NANOS which is what AbstractQueuedSynchronizer uses for
comment|//   similar purposes.
comment|// * We want to behave reasonably for timeouts of 0
comment|// * We are more responsive to completion than timeouts. This is because parkNanos depends on
comment|//   system scheduling and as such we could either miss our deadline, or unpark() could be delayed
comment|//   so that it looks like we timed out even though we didn't. For comparison FutureTask respects
comment|//   completion preferably and AQS is non-deterministic (depends on where in the queue the waiter
comment|//   is). If we wanted to be strict about it, we could store the unpark() time in the Waiter node
comment|//   and we could use that to make a decision about whether or not we timed out prior to being
comment|//   unparked.
comment|/**    * {@inheritDoc}    *    *<p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the    * current thread is interrupted during the call, even if the value is already available.    *    * @throws CancellationException {@inheritDoc}    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
throws|,
name|ExecutionException
block|{
comment|// NOTE: if timeout< 0, remainingNanos will be< 0 and we will fall into the while(true) loop
comment|// at the bottom and throw a timeoutexception.
specifier|final
name|long
name|timeoutNanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
comment|// we rely on the implicit null check on unit.
name|long
name|remainingNanos
init|=
name|timeoutNanos
decl_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
comment|// we delay calling nanoTime until we know we will need to either park or spin
specifier|final
name|long
name|endNanos
init|=
name|remainingNanos
operator|>
literal|0
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|remainingNanos
else|:
literal|0
decl_stmt|;
name|long_wait_loop
label|:
if|if
condition|(
name|remainingNanos
operator|>=
name|SPIN_THRESHOLD_NANOS
condition|)
block|{
name|Waiter
name|oldHead
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
name|Waiter
name|node
init|=
operator|new
name|Waiter
argument_list|()
decl_stmt|;
do|do
block|{
name|node
operator|.
name|setNext
argument_list|(
name|oldHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|node
argument_list|)
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|remainingNanos
argument_list|)
expr_stmt|;
comment|// Check interruption first, if we woke up due to interruption we need to honor that.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|// Otherwise re-read and check doneness. If we loop then it must have been a spurious
comment|// wakeup
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
comment|// timed out?
name|remainingNanos
operator|=
name|endNanos
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|remainingNanos
operator|<
name|SPIN_THRESHOLD_NANOS
condition|)
block|{
comment|// Remove the waiter, one way or another we are done parking this thread.
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break
name|long_wait_loop
break|;
comment|// jump down to the busy wait loop
block|}
block|}
block|}
name|oldHead
operator|=
name|waiters
expr_stmt|;
comment|// re-read and loop.
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
comment|// re-read value, if we get here then we must have observed a TOMBSTONE while trying to add a
comment|// waiter.
return|return
name|getDoneValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|// If we get here then we have remainingNanos< SPIN_THRESHOLD_NANOS and there is no node on the
comment|// waiters list
while|while
condition|(
name|remainingNanos
operator|>
literal|0
condition|)
block|{
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|remainingNanos
operator|=
name|endNanos
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
block|}
name|String
name|futureToString
init|=
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|unitString
init|=
name|unit
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|String
name|message
init|=
literal|"Waited "
operator|+
name|timeout
operator|+
literal|" "
operator|+
name|unit
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
comment|// Only report scheduling delay if larger than our spin threshold - otherwise it's just noise
if|if
condition|(
name|remainingNanos
operator|+
name|SPIN_THRESHOLD_NANOS
operator|<
literal|0
condition|)
block|{
comment|// We over-waited for our timeout.
name|message
operator|+=
literal|" (plus "
expr_stmt|;
name|long
name|overWaitNanos
init|=
operator|-
name|remainingNanos
decl_stmt|;
name|long
name|overWaitUnits
init|=
name|unit
operator|.
name|convert
argument_list|(
name|overWaitNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
decl_stmt|;
name|long
name|overWaitLeftoverNanos
init|=
name|overWaitNanos
operator|-
name|unit
operator|.
name|toNanos
argument_list|(
name|overWaitUnits
argument_list|)
decl_stmt|;
name|boolean
name|shouldShowExtraNanos
init|=
name|overWaitUnits
operator|==
literal|0
operator|||
name|overWaitLeftoverNanos
operator|>
name|SPIN_THRESHOLD_NANOS
decl_stmt|;
if|if
condition|(
name|overWaitUnits
operator|>
literal|0
condition|)
block|{
name|message
operator|+=
name|overWaitUnits
operator|+
literal|" "
operator|+
name|unitString
expr_stmt|;
if|if
condition|(
name|shouldShowExtraNanos
condition|)
block|{
name|message
operator|+=
literal|","
expr_stmt|;
block|}
name|message
operator|+=
literal|" "
expr_stmt|;
block|}
if|if
condition|(
name|shouldShowExtraNanos
condition|)
block|{
name|message
operator|+=
name|overWaitLeftoverNanos
operator|+
literal|" nanoseconds "
expr_stmt|;
block|}
name|message
operator|+=
literal|"delay)"
expr_stmt|;
block|}
comment|// It's confusing to see a completed future in a timeout message; if isDone() returns false,
comment|// then we know it must have given a pending toString value earlier. If not, then the future
comment|// completed after the timeout expired, and the message might be success.
if|if
condition|(
name|isDone
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
name|message
operator|+
literal|" but future completed as timeout expired"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|TimeoutException
argument_list|(
name|message
operator|+
literal|" for "
operator|+
name|futureToString
argument_list|)
throw|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the    * current thread is interrupted during the call, even if the value is already available.    *    * @throws CancellationException {@inheritDoc}    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
name|Waiter
name|oldHead
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
name|Waiter
name|node
init|=
operator|new
name|Waiter
argument_list|()
decl_stmt|;
do|do
block|{
name|node
operator|.
name|setNext
argument_list|(
name|oldHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|node
argument_list|)
condition|)
block|{
comment|// we are on the stack, now wait for completion.
while|while
condition|(
literal|true
condition|)
block|{
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Check interruption first, if we woke up due to interruption we need to honor that.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|// Otherwise re-read and check doneness. If we loop then it must have been a spurious
comment|// wakeup
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
block|}
block|}
name|oldHead
operator|=
name|waiters
expr_stmt|;
comment|// re-read and loop.
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
comment|// re-read value, if we get here then we must have observed a TOMBSTONE while trying to add a
comment|// waiter.
return|return
name|getDoneValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/** Unboxes {@code obj}. Assumes that obj is not {@code null} or a {@link SetFuture}. */
DECL|method|getDoneValue (Object obj)
specifier|private
name|V
name|getDoneValue
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|// While this seems like it might be too branch-y, simple benchmarking proves it to be
comment|// unmeasurable (comparing done AbstractFutures with immediateFuture)
if|if
condition|(
name|obj
operator|instanceof
name|Cancellation
condition|)
block|{
throw|throw
name|cancellationExceptionWithCause
argument_list|(
literal|"Task was cancelled."
argument_list|,
operator|(
operator|(
name|Cancellation
operator|)
name|obj
operator|)
operator|.
name|cause
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Failure
condition|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
operator|(
operator|(
name|Failure
operator|)
name|obj
operator|)
operator|.
name|exception
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// this is the only other option
name|V
name|asV
init|=
operator|(
name|V
operator|)
name|obj
decl_stmt|;
return|return
name|asV
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|isDone ()
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
name|localValue
operator|instanceof
name|Cancellation
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>If a cancellation attempt succeeds on a {@code Future} that had previously been {@linkplain    * #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate    * {@code Future} that was supplied in the {@code setFuture} call.    *    *<p>Rather than override this method to perform additional cancellation work or cleanup,    * subclasses should override {@link #afterDone}, consulting {@link #isCancelled} and {@link    * #wasInterrupted} as necessary. This ensures that the work is done even if the future is    * cancelled without a call to {@code cancel}, such as by calling {@code    * setFuture(cancelledFuture)}.    *    *<p>Beware of completing a future while holding a lock. Its listeners may do slow work or    * acquire other locks, risking deadlocks.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|Object
name|localValue
init|=
name|value
decl_stmt|;
name|boolean
name|rValue
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|localValue
operator|==
literal|null
operator||
name|localValue
operator|instanceof
name|SetFuture
condition|)
block|{
comment|// Try to delay allocating the exception. At this point we may still lose the CAS, but it is
comment|// certainly less likely.
name|Object
name|valueToSet
init|=
name|GENERATE_CANCELLATION_CAUSES
condition|?
operator|new
name|Cancellation
argument_list|(
name|mayInterruptIfRunning
argument_list|,
operator|new
name|CancellationException
argument_list|(
literal|"Future.cancel() was called."
argument_list|)
argument_list|)
else|:
operator|(
name|mayInterruptIfRunning
condition|?
name|Cancellation
operator|.
name|CAUSELESS_INTERRUPTED
else|:
name|Cancellation
operator|.
name|CAUSELESS_CANCELLED
operator|)
decl_stmt|;
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|abstractFuture
init|=
name|this
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|abstractFuture
argument_list|,
name|localValue
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|rValue
operator|=
literal|true
expr_stmt|;
comment|// We call interuptTask before calling complete(), which is consistent with
comment|// FutureTask
if|if
condition|(
name|mayInterruptIfRunning
condition|)
block|{
name|abstractFuture
operator|.
name|interruptTask
argument_list|()
expr_stmt|;
block|}
name|complete
argument_list|(
name|abstractFuture
argument_list|)
expr_stmt|;
if|if
condition|(
name|localValue
operator|instanceof
name|SetFuture
condition|)
block|{
comment|// propagate cancellation to the future set in setfuture, this is racy, and we don't
comment|// care if we are successful or not.
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|futureToPropagateTo
init|=
operator|(
operator|(
name|SetFuture
operator|)
name|localValue
operator|)
operator|.
name|future
decl_stmt|;
if|if
condition|(
name|futureToPropagateTo
operator|instanceof
name|Trusted
condition|)
block|{
comment|// If the future is a TrustedFuture then we specifically avoid calling cancel()
comment|// this has 2 benefits
comment|// 1. for long chains of futures strung together with setFuture we consume less stack
comment|// 2. we avoid allocating Cancellation objects at every level of the cancellation
comment|//    chain
comment|// We can only do this for TrustedFuture, because TrustedFuture.cancel is final and
comment|// does nothing but delegate to this method.
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|trusted
init|=
operator|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
operator|)
name|futureToPropagateTo
decl_stmt|;
name|localValue
operator|=
name|trusted
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|==
literal|null
operator||
name|localValue
operator|instanceof
name|SetFuture
condition|)
block|{
name|abstractFuture
operator|=
name|trusted
expr_stmt|;
continue|continue;
comment|// loop back up and try to complete the new future
block|}
block|}
else|else
block|{
comment|// not a TrustedFuture, call cancel directly.
name|futureToPropagateTo
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|// obj changed, reread
name|localValue
operator|=
name|abstractFuture
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|localValue
operator|instanceof
name|SetFuture
operator|)
condition|)
block|{
comment|// obj cannot be null at this point, because value can only change from null to non-null.
comment|// So if value changed (and it did since we lost the CAS), then it cannot be null and
comment|// since it isn't a SetFuture, then the future must be done and we should exit the loop
break|break;
block|}
block|}
block|}
return|return
name|rValue
return|;
block|}
comment|/**    * Subclasses can override this method to implement interruption of the future's computation. The    * method is invoked automatically by a successful call to {@link #cancel(boolean) cancel(true)}.    *    *<p>The default implementation does nothing.    *    *<p>This method is likely to be deprecated. Prefer to override {@link #afterDone}, consulting    * {@link #wasInterrupted} to decide whether to interrupt your task.    *    * @since 10.0    */
DECL|method|interruptTask ()
specifier|protected
name|void
name|interruptTask
parameter_list|()
block|{}
comment|/**    * Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code    * true}.    *    * @since 14.0    */
DECL|method|wasInterrupted ()
specifier|protected
specifier|final
name|boolean
name|wasInterrupted
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
operator|(
name|localValue
operator|instanceof
name|Cancellation
operator|)
operator|&&
operator|(
operator|(
name|Cancellation
operator|)
name|localValue
operator|)
operator|.
name|wasInterrupted
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @since 10.0    */
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|,
literal|"Runnable was null."
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|executor
argument_list|,
literal|"Executor was null."
argument_list|)
expr_stmt|;
comment|// Checking isDone and listeners != TOMBSTONE may seem redundant, but our contract for
comment|// addListener says that listeners execute 'immediate' if the future isDone(). However, our
comment|// protocol for completing a future is to assign the value field (which sets isDone to true) and
comment|// then to release waiters, followed by executing afterDone(), followed by releasing listeners.
comment|// That means that it is possible to observe that the future isDone and that your listeners
comment|// don't execute 'immediately'.  By checking isDone here we avoid that.
comment|// A corollary to all that is that we don't need to check isDone inside the loop because if we
comment|// get into the loop we know that we weren't done when we entered and therefore we aren't under
comment|// an obligation to execute 'immediately'.
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
name|Listener
name|oldHead
init|=
name|listeners
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Listener
operator|.
name|TOMBSTONE
condition|)
block|{
name|Listener
name|newNode
init|=
operator|new
name|Listener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
decl_stmt|;
do|do
block|{
name|newNode
operator|.
name|next
operator|=
name|oldHead
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casListeners
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
return|return;
block|}
name|oldHead
operator|=
name|listeners
expr_stmt|;
comment|// re-read
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Listener
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
block|}
comment|// If we get here then the Listener TOMBSTONE was set, which means the future is done, call
comment|// the listener.
name|executeListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the result of this {@code Future} unless this {@code Future} has already been cancelled or    * set (including {@linkplain #setFuture set asynchronously}). When a call to this method returns,    * the {@code Future} is guaranteed to be {@linkplain #isDone done}<b>only if</b> the call was    * accepted (in which case it returns {@code true}). If it returns {@code false}, the {@code    * Future} may have previously been set asynchronously, in which case its result may not be known    * yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}    * method, only by a call to {@link #cancel}.    *    *<p>Beware of completing a future while holding a lock. Its listeners may do slow work or    * acquire other locks, risking deadlocks.    *    * @param value the value to be used as the result    * @return true if the attempt was accepted, completing the {@code Future}    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|set (@ullableDecl V value)
specifier|protected
name|boolean
name|set
parameter_list|(
annotation|@
name|NullableDecl
name|V
name|value
parameter_list|)
block|{
name|Object
name|valueToSet
init|=
name|value
operator|==
literal|null
condition|?
name|NULL
else|:
name|value
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Sets the failed result of this {@code Future} unless this {@code Future} has already been    * cancelled or set (including {@linkplain #setFuture set asynchronously}). When a call to this    * method returns, the {@code Future} is guaranteed to be {@linkplain #isDone done}<b>only if</b>    * the call was accepted (in which case it returns {@code true}). If it returns {@code false}, the    * {@code Future} may have previously been set asynchronously, in which case its result may not be    * known yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}    * method, only by a call to {@link #cancel}.    *    *<p>Beware of completing a future while holding a lock. Its listeners may do slow work or    * acquire other locks, risking deadlocks.    *    * @param throwable the exception to be used as the failed result    * @return true if the attempt was accepted, completing the {@code Future}    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|setException (Throwable throwable)
specifier|protected
name|boolean
name|setException
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|Object
name|valueToSet
init|=
operator|new
name|Failure
argument_list|(
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Sets the result of this {@code Future} to match the supplied input {@code Future} once the    * supplied {@code Future} is done, unless this {@code Future} has already been cancelled or set    * (including "set asynchronously," defined below).    *    *<p>If the supplied future is {@linkplain #isDone done} when this method is called and the call    * is accepted, then this future is guaranteed to have been completed with the supplied future by    * the time this method returns. If the supplied future is not done and the call is accepted, then    * the future will be<i>set asynchronously</i>. Note that such a result, though not yet known,    * cannot be overridden by a call to a {@code set*} method, only by a call to {@link #cancel}.    *    *<p>If the call {@code setFuture(delegate)} is accepted and this {@code Future} is later    * cancelled, cancellation will be propagated to {@code delegate}. Additionally, any call to    * {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code    * Future}.    *    *<p>Note that, even if the supplied future is cancelled and it causes this future to complete,    * it will never trigger interruption behavior. In particular, it will not cause this future to    * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not    * return {@code true}.    *    *<p>Beware of completing a future while holding a lock. Its listeners may do slow work or    * acquire other locks, risking deadlocks.    *    * @param future the future to delegate to    * @return true if the attempt was accepted, indicating that the {@code Future} was not previously    *     cancelled or set.    * @since 19.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|setFuture (ListenableFuture<? extends V> future)
specifier|protected
name|boolean
name|setFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|getFutureValue
argument_list|(
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|complete
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
name|SetFuture
name|valueToSet
init|=
operator|new
name|SetFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
comment|// the listener is responsible for calling completeWithFuture, directExecutor is appropriate
comment|// since all we are doing is unpacking a completed future which should be fast.
try|try
block|{
name|future
operator|.
name|addListener
argument_list|(
name|valueToSet
argument_list|,
name|DirectExecutor
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// addListener has thrown an exception! SetFuture.run can't throw any exceptions so this
comment|// must have been caused by addListener itself. The most likely explanation is a
comment|// misconfigured mock. Try to switch to Failure.
name|Failure
name|failure
decl_stmt|;
try|try
block|{
name|failure
operator|=
operator|new
name|Failure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|oomMostLikely
parameter_list|)
block|{
name|failure
operator|=
name|Failure
operator|.
name|FALLBACK_INSTANCE
expr_stmt|;
block|}
comment|// Note: The only way this CAS could fail is if cancel() has raced with us. That is ok.
name|boolean
name|unused
init|=
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
name|valueToSet
argument_list|,
name|failure
argument_list|)
decl_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|localValue
operator|=
name|value
expr_stmt|;
comment|// we lost the cas, fall through and maybe cancel
block|}
comment|// The future has already been set to something. If it is cancellation we should cancel the
comment|// incoming future.
if|if
condition|(
name|localValue
operator|instanceof
name|Cancellation
condition|)
block|{
comment|// we don't care if it fails, this is best-effort.
name|future
operator|.
name|cancel
argument_list|(
operator|(
operator|(
name|Cancellation
operator|)
name|localValue
operator|)
operator|.
name|wasInterrupted
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns a value that satisfies the contract of the {@link #value} field based on the state of    * given future.    *    *<p>This is approximately the inverse of {@link #getDoneValue(Object)}    */
DECL|method|getFutureValue (ListenableFuture<?> future)
specifier|private
specifier|static
name|Object
name|getFutureValue
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|Trusted
condition|)
block|{
comment|// Break encapsulation for TrustedFuture instances since we know that subclasses cannot
comment|// override .get() (since it is final) and therefore this is equivalent to calling .get()
comment|// and unpacking the exceptions like we do below (just much faster because it is a single
comment|// field read instead of a read, several branches and possibly creating exceptions).
name|Object
name|v
init|=
operator|(
operator|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
operator|)
name|future
operator|)
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|v
operator|instanceof
name|Cancellation
condition|)
block|{
comment|// If the other future was interrupted, clear the interrupted bit while preserving the cause
comment|// this will make it consistent with how non-trustedfutures work which cannot propagate the
comment|// wasInterrupted bit
name|Cancellation
name|c
init|=
operator|(
name|Cancellation
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|wasInterrupted
condition|)
block|{
name|v
operator|=
name|c
operator|.
name|cause
operator|!=
literal|null
condition|?
operator|new
name|Cancellation
argument_list|(
comment|/* wasInterrupted= */
literal|false
argument_list|,
name|c
operator|.
name|cause
argument_list|)
else|:
name|Cancellation
operator|.
name|CAUSELESS_CANCELLED
expr_stmt|;
block|}
block|}
return|return
name|v
return|;
block|}
if|if
condition|(
name|future
operator|instanceof
name|InternalFutureFailureAccess
condition|)
block|{
name|Throwable
name|throwable
init|=
name|InternalFutures
operator|.
name|tryInternalFastPathGetFailure
argument_list|(
operator|(
name|InternalFutureFailureAccess
operator|)
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|throwable
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Failure
argument_list|(
name|throwable
argument_list|)
return|;
block|}
block|}
name|boolean
name|wasCancelled
init|=
name|future
operator|.
name|isCancelled
argument_list|()
decl_stmt|;
comment|// Don't allocate a CancellationException if it's not necessary
if|if
condition|(
operator|!
name|GENERATE_CANCELLATION_CAUSES
operator|&
name|wasCancelled
condition|)
block|{
return|return
name|Cancellation
operator|.
name|CAUSELESS_CANCELLED
return|;
block|}
comment|// Otherwise calculate the value by calling .get()
try|try
block|{
name|Object
name|v
init|=
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasCancelled
condition|)
block|{
return|return
operator|new
name|Cancellation
argument_list|(
literal|false
argument_list|,
operator|new
name|IllegalArgumentException
argument_list|(
literal|"get() did not throw CancellationException, despite reporting "
operator|+
literal|"isCancelled() == true: "
operator|+
name|future
argument_list|)
argument_list|)
return|;
block|}
return|return
name|v
operator|==
literal|null
condition|?
name|NULL
else|:
name|v
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|exception
parameter_list|)
block|{
if|if
condition|(
name|wasCancelled
condition|)
block|{
return|return
operator|new
name|Cancellation
argument_list|(
literal|false
argument_list|,
operator|new
name|IllegalArgumentException
argument_list|(
literal|"get() did not throw CancellationException, despite reporting "
operator|+
literal|"isCancelled() == true: "
operator|+
name|future
argument_list|,
name|exception
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|Failure
argument_list|(
name|exception
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|cancellation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wasCancelled
condition|)
block|{
return|return
operator|new
name|Failure
argument_list|(
operator|new
name|IllegalArgumentException
argument_list|(
literal|"get() threw CancellationException, despite reporting isCancelled() == false: "
operator|+
name|future
argument_list|,
name|cancellation
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|Cancellation
argument_list|(
literal|false
argument_list|,
name|cancellation
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
operator|new
name|Failure
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
comment|/**    * An inlined private copy of {@link Uninterruptibles#getUninterruptibly} used to break an    * internal dependency on other /util/concurrent classes.    */
DECL|method|getUninterruptibly (Future<V> future)
specifier|private
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|getUninterruptibly
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Unblocks all threads and runs all listeners. */
DECL|method|complete (AbstractFuture<?> future)
specifier|private
specifier|static
name|void
name|complete
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
name|Listener
name|next
init|=
literal|null
decl_stmt|;
name|outer
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|future
operator|.
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// We call this before the listeners in order to avoid needing to manage a separate stack data
comment|// structure for them.  Also, some implementations rely on this running prior to listeners
comment|// so that the cleanup work is visible to listeners.
comment|// afterDone() should be generally fast and only used for cleanup work... but in theory can
comment|// also be recursive and create StackOverflowErrors
name|future
operator|.
name|afterDone
argument_list|()
expr_stmt|;
comment|// push the current set of listeners onto next
name|next
operator|=
name|future
operator|.
name|clearListeners
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|future
operator|=
literal|null
expr_stmt|;
while|while
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|Listener
name|curr
init|=
name|next
decl_stmt|;
name|next
operator|=
name|next
operator|.
name|next
expr_stmt|;
name|Runnable
name|task
init|=
name|curr
operator|.
name|task
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|SetFuture
condition|)
block|{
name|SetFuture
argument_list|<
name|?
argument_list|>
name|setFuture
init|=
operator|(
name|SetFuture
argument_list|<
name|?
argument_list|>
operator|)
name|task
decl_stmt|;
comment|// We unwind setFuture specifically to avoid StackOverflowErrors in the case of long
comment|// chains of SetFutures
comment|// Handling this special case is important because there is no way to pass an executor to
comment|// setFuture, so a user couldn't break the chain by doing this themselves.  It is also
comment|// potentially common if someone writes a recursive Futures.transformAsync transformer.
name|future
operator|=
name|setFuture
operator|.
name|owner
expr_stmt|;
if|if
condition|(
name|future
operator|.
name|value
operator|==
name|setFuture
condition|)
block|{
name|Object
name|valueToSet
init|=
name|getFutureValue
argument_list|(
name|setFuture
operator|.
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|future
argument_list|,
name|setFuture
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
continue|continue
name|outer
continue|;
block|}
block|}
comment|// other wise the future we were trying to set is already done.
block|}
else|else
block|{
name|executeListener
argument_list|(
name|task
argument_list|,
name|curr
operator|.
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/**    * Callback method that is called exactly once after the future is completed.    *    *<p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it.    *    *<p>The default implementation of this method in {@code AbstractFuture} does nothing. This is    * intended for very lightweight cleanup work, for example, timing statistics or clearing fields.    * If your task does anything heavier consider, just using a listener with an executor.    *    * @since 20.0    */
annotation|@
name|Beta
annotation|@
name|ForOverride
DECL|method|afterDone ()
specifier|protected
name|void
name|afterDone
parameter_list|()
block|{}
comment|// TODO(b/114236866): Inherit doc from InternalFutureFailureAccess. Also, -link to its URL.
comment|/**    * Usually returns {@code null} but, if this {@code Future} has failed, may<i>optionally</i>    * return the cause of the failure. "Failure" means specifically "completed with an exception"; it    * does not include "was cancelled." To be explicit: If this method returns a non-null value,    * then:    *    *<ul>    *<li>{@code isDone()} must return {@code true}    *<li>{@code isCancelled()} must return {@code false}    *<li>{@code get()} must not block, and it must throw an {@code ExecutionException} with the    *       return value of this method as its cause    *</ul>    *    *<p>This method is {@code protected} so that classes like {@code    * com.google.common.util.concurrent.SettableFuture} do not expose it to their users as an    * instance method. In the unlikely event that you need to call this method, call {@link    * InternalFutures#tryInternalFastPathGetFailure(InternalFutureFailureAccess)}.    *    * @since 27.0    */
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|tryInternalFastPathGetFailure ()
specifier|protected
specifier|final
name|Throwable
name|tryInternalFastPathGetFailure
parameter_list|()
block|{
if|if
condition|(
name|this
operator|instanceof
name|Trusted
condition|)
block|{
name|Object
name|obj
init|=
name|value
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|Failure
condition|)
block|{
return|return
operator|(
operator|(
name|Failure
operator|)
name|obj
operator|)
operator|.
name|exception
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)    * the given future (if available).    */
DECL|method|maybePropagateCancellationTo (@ullableDecl Future<?> related)
specifier|final
name|void
name|maybePropagateCancellationTo
parameter_list|(
annotation|@
name|NullableDecl
name|Future
argument_list|<
name|?
argument_list|>
name|related
parameter_list|)
block|{
if|if
condition|(
name|related
operator|!=
literal|null
operator|&
name|isCancelled
argument_list|()
condition|)
block|{
name|related
operator|.
name|cancel
argument_list|(
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Releases all threads in the {@link #waiters} list, and clears the list. */
DECL|method|releaseWaiters ()
specifier|private
name|void
name|releaseWaiters
parameter_list|()
block|{
name|Waiter
name|head
decl_stmt|;
do|do
block|{
name|head
operator|=
name|waiters
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|head
argument_list|,
name|Waiter
operator|.
name|TOMBSTONE
argument_list|)
condition|)
do|;
for|for
control|(
name|Waiter
name|currentWaiter
init|=
name|head
init|;
name|currentWaiter
operator|!=
literal|null
condition|;
name|currentWaiter
operator|=
name|currentWaiter
operator|.
name|next
control|)
block|{
name|currentWaiter
operator|.
name|unpark
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Clears the {@link #listeners} list and prepends its contents to {@code onto}, least recently    * added first.    */
DECL|method|clearListeners (Listener onto)
specifier|private
name|Listener
name|clearListeners
parameter_list|(
name|Listener
name|onto
parameter_list|)
block|{
comment|// We need to
comment|// 1. atomically swap the listeners with TOMBSTONE, this is because addListener uses that to
comment|//    to synchronize with us
comment|// 2. reverse the linked list, because despite our rather clear contract, people depend on us
comment|//    executing listeners in the order they were added
comment|// 3. push all the items onto 'onto' and return the new head of the stack
name|Listener
name|head
decl_stmt|;
do|do
block|{
name|head
operator|=
name|listeners
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casListeners
argument_list|(
name|this
argument_list|,
name|head
argument_list|,
name|Listener
operator|.
name|TOMBSTONE
argument_list|)
condition|)
do|;
name|Listener
name|reversedList
init|=
name|onto
decl_stmt|;
while|while
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|Listener
name|tmp
init|=
name|head
decl_stmt|;
name|head
operator|=
name|head
operator|.
name|next
expr_stmt|;
name|tmp
operator|.
name|next
operator|=
name|reversedList
expr_stmt|;
name|reversedList
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|reversedList
return|;
block|}
comment|// TODO(user): move parts into a default method on ListenableFuture?
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|super
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"[status="
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCancelled
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"CANCELLED"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDone
argument_list|()
condition|)
block|{
name|addDoneString
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addPendingString
argument_list|(
name|builder
argument_list|)
expr_stmt|;
comment|// delegates to addDoneString if future completes mid-way
block|}
return|return
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Provide a human-readable explanation of why this future has not yet completed.    *    * @return null if an explanation cannot be provided (e.g. because the future is done).    * @since 23.0    */
annotation|@
name|NullableDecl
DECL|method|pendingToString ()
specifier|protected
name|String
name|pendingToString
parameter_list|()
block|{
comment|// TODO(diamondm) consider moving this into addPendingString so it's always in the output
if|if
condition|(
name|this
operator|instanceof
name|ScheduledFuture
condition|)
block|{
return|return
literal|"remaining delay=["
operator|+
operator|(
operator|(
name|ScheduledFuture
operator|)
name|this
operator|)
operator|.
name|getDelay
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|+
literal|" ms]"
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|addPendingString (StringBuilder builder)
specifier|private
name|void
name|addPendingString
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
comment|// Capture current builder length so it can be truncated if this future ends up completing while
comment|// the toString is being calculated
name|int
name|truncateLength
init|=
name|builder
operator|.
name|length
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"PENDING"
argument_list|)
expr_stmt|;
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|instanceof
name|SetFuture
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|", setFuture=["
argument_list|)
expr_stmt|;
name|appendUserObject
argument_list|(
name|builder
argument_list|,
operator|(
operator|(
name|SetFuture
operator|)
name|localValue
operator|)
operator|.
name|future
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|pendingDescription
decl_stmt|;
try|try
block|{
name|pendingDescription
operator|=
name|Strings
operator|.
name|emptyToNull
argument_list|(
name|pendingToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|StackOverflowError
name|e
parameter_list|)
block|{
comment|// Don't call getMessage or toString() on the exception, in case the exception thrown by the
comment|// subclass is implemented with bugs similar to the subclass.
name|pendingDescription
operator|=
literal|"Exception thrown from implementation: "
operator|+
name|e
operator|.
name|getClass
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pendingDescription
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|", info=["
argument_list|)
operator|.
name|append
argument_list|(
name|pendingDescription
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The future may complete while calculating the toString, so we check once more to see if the
comment|// future is done
if|if
condition|(
name|isDone
argument_list|()
condition|)
block|{
comment|// Truncate anything that was appended before realizing this future is done
name|builder
operator|.
name|delete
argument_list|(
name|truncateLength
argument_list|,
name|builder
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|addDoneString
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addDoneString (StringBuilder builder)
specifier|private
name|void
name|addDoneString
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
try|try
block|{
name|V
name|value
init|=
name|getUninterruptibly
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"SUCCESS, result=["
argument_list|)
expr_stmt|;
name|appendUserObject
argument_list|(
name|builder
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"FAILURE, cause=["
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"CANCELLED"
argument_list|)
expr_stmt|;
comment|// shouldn't be reachable
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"UNKNOWN, cause=["
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" thrown from get()]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Helper for printing user supplied objects into our toString method. */
DECL|method|appendUserObject (StringBuilder builder, Object o)
specifier|private
name|void
name|appendUserObject
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
comment|// This is some basic recursion detection for when people create cycles via set/setFuture or
comment|// when deep chains of futures exist resulting in a StackOverflowException. We could detect
comment|// arbitrary cycles using a thread local but this should be a good enough solution (it is also
comment|// what jdk collections do in these cases)
try|try
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"this future"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|StackOverflowError
name|e
parameter_list|)
block|{
comment|// Don't call getMessage or toString() on the exception, in case the exception thrown by the
comment|// user object is implemented with bugs similar to the user object.
name|builder
operator|.
name|append
argument_list|(
literal|"Exception thrown from implementation: "
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Submits the given runnable to the given {@link Executor} catching and logging all {@linkplain    * RuntimeException runtime exceptions} thrown by the executor.    */
DECL|method|executeListener (Runnable runnable, Executor executor)
specifier|private
specifier|static
name|void
name|executeListener
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if
comment|// we're given a bad one. We only catch RuntimeException because we want Errors to propagate
comment|// up.
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"RuntimeException while executing runnable "
operator|+
name|runnable
operator|+
literal|" with executor "
operator|+
name|executor
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|AtomicHelper
specifier|private
specifier|abstract
specifier|static
class|class
name|AtomicHelper
block|{
comment|/** Non volatile write of the thread to the {@link Waiter#thread} field. */
DECL|method|putThread (Waiter waiter, Thread newValue)
specifier|abstract
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|newValue
parameter_list|)
function_decl|;
comment|/** Non volatile write of the waiter to the {@link Waiter#next} field. */
DECL|method|putNext (Waiter waiter, Waiter newValue)
specifier|abstract
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|newValue
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #waiters} field. */
DECL|method|casWaiters (AbstractFuture<?> future, Waiter expect, Waiter update)
specifier|abstract
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Waiter
name|expect
parameter_list|,
name|Waiter
name|update
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #listeners} field. */
DECL|method|casListeners (AbstractFuture<?> future, Listener expect, Listener update)
specifier|abstract
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Listener
name|expect
parameter_list|,
name|Listener
name|update
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #value} field. */
DECL|method|casValue (AbstractFuture<?> future, Object expect, Object update)
specifier|abstract
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Object
name|expect
parameter_list|,
name|Object
name|update
parameter_list|)
function_decl|;
block|}
comment|/**    * {@link AtomicHelper} based on {@link sun.misc.Unsafe}.    *    *<p>Static initialization of this class will fail if the {@link sun.misc.Unsafe} object cannot    * be accessed.    */
DECL|class|UnsafeAtomicHelper
specifier|private
specifier|static
specifier|final
class|class
name|UnsafeAtomicHelper
extends|extends
name|AtomicHelper
block|{
DECL|field|UNSAFE
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|LISTENERS_OFFSET
specifier|static
specifier|final
name|long
name|LISTENERS_OFFSET
decl_stmt|;
DECL|field|WAITERS_OFFSET
specifier|static
specifier|final
name|long
name|WAITERS_OFFSET
decl_stmt|;
DECL|field|VALUE_OFFSET
specifier|static
specifier|final
name|long
name|VALUE_OFFSET
decl_stmt|;
DECL|field|WAITER_THREAD_OFFSET
specifier|static
specifier|final
name|long
name|WAITER_THREAD_OFFSET
decl_stmt|;
DECL|field|WAITER_NEXT_OFFSET
specifier|static
specifier|final
name|long
name|WAITER_NEXT_OFFSET
decl_stmt|;
static|static
block|{
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|unsafe
init|=
literal|null
decl_stmt|;
try|try
block|{
name|unsafe
operator|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{
try|try
block|{
name|unsafe
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|abstractFuture
init|=
name|AbstractFuture
operator|.
name|class
decl_stmt|;
name|WAITERS_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"waiters"
argument_list|)
argument_list|)
expr_stmt|;
name|LISTENERS_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"listeners"
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITER_THREAD_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|Waiter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"thread"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITER_NEXT_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|Waiter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
name|UNSAFE
operator|=
name|unsafe
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|putThread (Waiter waiter, Thread newValue)
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|newValue
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|waiter
argument_list|,
name|WAITER_THREAD_OFFSET
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putNext (Waiter waiter, Waiter newValue)
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|newValue
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|waiter
argument_list|,
name|WAITER_NEXT_OFFSET
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|/** Performs a CAS operation on the {@link #waiters} field. */
annotation|@
name|Override
DECL|method|casWaiters (AbstractFuture<?> future, Waiter expect, Waiter update)
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Waiter
name|expect
parameter_list|,
name|Waiter
name|update
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|WAITERS_OFFSET
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
comment|/** Performs a CAS operation on the {@link #listeners} field. */
annotation|@
name|Override
DECL|method|casListeners (AbstractFuture<?> future, Listener expect, Listener update)
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Listener
name|expect
parameter_list|,
name|Listener
name|update
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|LISTENERS_OFFSET
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
comment|/** Performs a CAS operation on the {@link #value} field. */
annotation|@
name|Override
DECL|method|casValue (AbstractFuture<?> future, Object expect, Object update)
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Object
name|expect
parameter_list|,
name|Object
name|update
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|VALUE_OFFSET
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
block|}
comment|/** {@link AtomicHelper} based on {@link AtomicReferenceFieldUpdater}. */
DECL|class|SafeAtomicHelper
specifier|private
specifier|static
specifier|final
class|class
name|SafeAtomicHelper
extends|extends
name|AtomicHelper
block|{
DECL|field|waiterThreadUpdater
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Thread
argument_list|>
name|waiterThreadUpdater
decl_stmt|;
DECL|field|waiterNextUpdater
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Waiter
argument_list|>
name|waiterNextUpdater
decl_stmt|;
DECL|field|waitersUpdater
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Waiter
argument_list|>
name|waitersUpdater
decl_stmt|;
DECL|field|listenersUpdater
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Listener
argument_list|>
name|listenersUpdater
decl_stmt|;
DECL|field|valueUpdater
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Object
argument_list|>
name|valueUpdater
decl_stmt|;
DECL|method|SafeAtomicHelper ( AtomicReferenceFieldUpdater<Waiter, Thread> waiterThreadUpdater, AtomicReferenceFieldUpdater<Waiter, Waiter> waiterNextUpdater, AtomicReferenceFieldUpdater<AbstractFuture, Waiter> waitersUpdater, AtomicReferenceFieldUpdater<AbstractFuture, Listener> listenersUpdater, AtomicReferenceFieldUpdater<AbstractFuture, Object> valueUpdater)
name|SafeAtomicHelper
parameter_list|(
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Thread
argument_list|>
name|waiterThreadUpdater
parameter_list|,
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Waiter
argument_list|>
name|waiterNextUpdater
parameter_list|,
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Waiter
argument_list|>
name|waitersUpdater
parameter_list|,
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Listener
argument_list|>
name|listenersUpdater
parameter_list|,
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Object
argument_list|>
name|valueUpdater
parameter_list|)
block|{
name|this
operator|.
name|waiterThreadUpdater
operator|=
name|waiterThreadUpdater
expr_stmt|;
name|this
operator|.
name|waiterNextUpdater
operator|=
name|waiterNextUpdater
expr_stmt|;
name|this
operator|.
name|waitersUpdater
operator|=
name|waitersUpdater
expr_stmt|;
name|this
operator|.
name|listenersUpdater
operator|=
name|listenersUpdater
expr_stmt|;
name|this
operator|.
name|valueUpdater
operator|=
name|valueUpdater
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putThread (Waiter waiter, Thread newValue)
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|newValue
parameter_list|)
block|{
name|waiterThreadUpdater
operator|.
name|lazySet
argument_list|(
name|waiter
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putNext (Waiter waiter, Waiter newValue)
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|newValue
parameter_list|)
block|{
name|waiterNextUpdater
operator|.
name|lazySet
argument_list|(
name|waiter
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|casWaiters (AbstractFuture<?> future, Waiter expect, Waiter update)
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Waiter
name|expect
parameter_list|,
name|Waiter
name|update
parameter_list|)
block|{
return|return
name|waitersUpdater
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|casListeners (AbstractFuture<?> future, Listener expect, Listener update)
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Listener
name|expect
parameter_list|,
name|Listener
name|update
parameter_list|)
block|{
return|return
name|listenersUpdater
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|casValue (AbstractFuture<?> future, Object expect, Object update)
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Object
name|expect
parameter_list|,
name|Object
name|update
parameter_list|)
block|{
return|return
name|valueUpdater
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|expect
argument_list|,
name|update
argument_list|)
return|;
block|}
block|}
comment|/**    * {@link AtomicHelper} based on {@code synchronized} and volatile writes.    *    *<p>This is an implementation of last resort for when certain basic VM features are broken (like    * AtomicReferenceFieldUpdater).    */
DECL|class|SynchronizedHelper
specifier|private
specifier|static
specifier|final
class|class
name|SynchronizedHelper
extends|extends
name|AtomicHelper
block|{
annotation|@
name|Override
DECL|method|putThread (Waiter waiter, Thread newValue)
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|newValue
parameter_list|)
block|{
name|waiter
operator|.
name|thread
operator|=
name|newValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putNext (Waiter waiter, Waiter newValue)
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|newValue
parameter_list|)
block|{
name|waiter
operator|.
name|next
operator|=
name|newValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|casWaiters (AbstractFuture<?> future, Waiter expect, Waiter update)
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Waiter
name|expect
parameter_list|,
name|Waiter
name|update
parameter_list|)
block|{
synchronized|synchronized
init|(
name|future
init|)
block|{
if|if
condition|(
name|future
operator|.
name|waiters
operator|==
name|expect
condition|)
block|{
name|future
operator|.
name|waiters
operator|=
name|update
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|casListeners (AbstractFuture<?> future, Listener expect, Listener update)
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Listener
name|expect
parameter_list|,
name|Listener
name|update
parameter_list|)
block|{
synchronized|synchronized
init|(
name|future
init|)
block|{
if|if
condition|(
name|future
operator|.
name|listeners
operator|==
name|expect
condition|)
block|{
name|future
operator|.
name|listeners
operator|=
name|update
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|casValue (AbstractFuture<?> future, Object expect, Object update)
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Object
name|expect
parameter_list|,
name|Object
name|update
parameter_list|)
block|{
synchronized|synchronized
init|(
name|future
init|)
block|{
if|if
condition|(
name|future
operator|.
name|value
operator|==
name|expect
condition|)
block|{
name|future
operator|.
name|value
operator|=
name|update
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
DECL|method|cancellationExceptionWithCause ( @ullableDecl String message, @NullableDecl Throwable cause)
specifier|private
specifier|static
name|CancellationException
name|cancellationExceptionWithCause
parameter_list|(
annotation|@
name|NullableDecl
name|String
name|message
parameter_list|,
annotation|@
name|NullableDecl
name|Throwable
name|cause
parameter_list|)
block|{
name|CancellationException
name|exception
init|=
operator|new
name|CancellationException
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|exception
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return
name|exception
return|;
block|}
block|}
end_class

end_unit

