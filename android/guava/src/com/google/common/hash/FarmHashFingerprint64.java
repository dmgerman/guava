begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.hash
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndexes
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|LittleEndianByteArray
operator|.
name|load32
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|LittleEndianByteArray
operator|.
name|load64
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Long
operator|.
name|rotateRight
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Implementation of FarmHash Fingerprint64, an open-source fingerprinting algorithm for strings.  *  *<p>Its speed is comparable to CityHash64, and its quality of hashing is at least as good.  *  *<p>Note to maintainers: This implementation relies on signed arithmetic being bit-wise equivalent  * to unsigned arithmetic in all cases except:  *  *<ul>  *<li>comparisons (signed values can be negative)  *<li>division (avoided here)  *<li>shifting (right shift must be unsigned)  *</ul>  *  * @author Kyle Maddison  * @author Geoff Pike  */
end_comment

begin_class
DECL|class|FarmHashFingerprint64
specifier|final
class|class
name|FarmHashFingerprint64
extends|extends
name|AbstractNonStreamingHashFunction
block|{
DECL|field|FARMHASH_FINGERPRINT_64
specifier|static
specifier|final
name|HashFunction
name|FARMHASH_FINGERPRINT_64
init|=
operator|new
name|FarmHashFingerprint64
argument_list|()
decl_stmt|;
comment|// Some primes between 2^63 and 2^64 for various uses.
DECL|field|K0
specifier|private
specifier|static
specifier|final
name|long
name|K0
init|=
literal|0xc3a5c85c97cb3127L
decl_stmt|;
DECL|field|K1
specifier|private
specifier|static
specifier|final
name|long
name|K1
init|=
literal|0xb492b66fbe98f273L
decl_stmt|;
DECL|field|K2
specifier|private
specifier|static
specifier|final
name|long
name|K2
init|=
literal|0x9ae16a3b2f90404fL
decl_stmt|;
annotation|@
name|Override
DECL|method|hashBytes (byte[] input, int off, int len)
specifier|public
name|HashCode
name|hashBytes
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|checkPositionIndexes
argument_list|(
name|off
argument_list|,
name|off
operator|+
name|len
argument_list|,
name|input
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|HashCode
operator|.
name|fromLong
argument_list|(
name|fingerprint
argument_list|(
name|input
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|bits ()
specifier|public
name|int
name|bits
parameter_list|()
block|{
return|return
literal|64
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Hashing.farmHashFingerprint64()"
return|;
block|}
comment|// End of public functions.
annotation|@
name|VisibleForTesting
DECL|method|fingerprint (byte[] bytes, int offset, int length)
specifier|static
name|long
name|fingerprint
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
literal|32
condition|)
block|{
if|if
condition|(
name|length
operator|<=
literal|16
condition|)
block|{
return|return
name|hashLength0to16
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|hashLength17to32
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|length
operator|<=
literal|64
condition|)
block|{
return|return
name|hashLength33To64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|hashLength65Plus
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
DECL|method|shiftMix (long val)
specifier|private
specifier|static
name|long
name|shiftMix
parameter_list|(
name|long
name|val
parameter_list|)
block|{
return|return
name|val
operator|^
operator|(
name|val
operator|>>>
literal|47
operator|)
return|;
block|}
DECL|method|hashLength16 (long u, long v, long mul)
specifier|private
specifier|static
name|long
name|hashLength16
parameter_list|(
name|long
name|u
parameter_list|,
name|long
name|v
parameter_list|,
name|long
name|mul
parameter_list|)
block|{
name|long
name|a
init|=
operator|(
name|u
operator|^
name|v
operator|)
operator|*
name|mul
decl_stmt|;
name|a
operator|^=
operator|(
name|a
operator|>>>
literal|47
operator|)
expr_stmt|;
name|long
name|b
init|=
operator|(
name|v
operator|^
name|a
operator|)
operator|*
name|mul
decl_stmt|;
name|b
operator|^=
operator|(
name|b
operator|>>>
literal|47
operator|)
expr_stmt|;
name|b
operator|*=
name|mul
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Computes intermediate hash of 32 bytes of byte array from the given offset. Results are    * returned in the output array because when we last measured, this was 12% faster than allocating    * new arrays every time.    */
DECL|method|weakHashLength32WithSeeds ( byte[] bytes, int offset, long seedA, long seedB, long[] output)
specifier|private
specifier|static
name|void
name|weakHashLength32WithSeeds
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|long
name|seedA
parameter_list|,
name|long
name|seedB
parameter_list|,
name|long
index|[]
name|output
parameter_list|)
block|{
name|long
name|part1
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|long
name|part2
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
decl_stmt|;
name|long
name|part3
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|16
argument_list|)
decl_stmt|;
name|long
name|part4
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|24
argument_list|)
decl_stmt|;
name|seedA
operator|+=
name|part1
expr_stmt|;
name|seedB
operator|=
name|rotateRight
argument_list|(
name|seedB
operator|+
name|seedA
operator|+
name|part4
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|long
name|c
init|=
name|seedA
decl_stmt|;
name|seedA
operator|+=
name|part2
expr_stmt|;
name|seedA
operator|+=
name|part3
expr_stmt|;
name|seedB
operator|+=
name|rotateRight
argument_list|(
name|seedA
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|seedA
operator|+
name|part4
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|seedB
operator|+
name|c
expr_stmt|;
block|}
DECL|method|hashLength0to16 (byte[] bytes, int offset, int length)
specifier|private
specifier|static
name|long
name|hashLength0to16
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|>=
literal|8
condition|)
block|{
name|long
name|mul
init|=
name|K2
operator|+
name|length
operator|*
literal|2
decl_stmt|;
name|long
name|a
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|+
name|K2
decl_stmt|;
name|long
name|b
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|8
argument_list|)
decl_stmt|;
name|long
name|c
init|=
name|rotateRight
argument_list|(
name|b
argument_list|,
literal|37
argument_list|)
operator|*
name|mul
operator|+
name|a
decl_stmt|;
name|long
name|d
init|=
operator|(
name|rotateRight
argument_list|(
name|a
argument_list|,
literal|25
argument_list|)
operator|+
name|b
operator|)
operator|*
name|mul
decl_stmt|;
return|return
name|hashLength16
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|mul
argument_list|)
return|;
block|}
if|if
condition|(
name|length
operator|>=
literal|4
condition|)
block|{
name|long
name|mul
init|=
name|K2
operator|+
name|length
operator|*
literal|2
decl_stmt|;
name|long
name|a
init|=
name|load32
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|&
literal|0xFFFFFFFFL
decl_stmt|;
return|return
name|hashLength16
argument_list|(
name|length
operator|+
operator|(
name|a
operator|<<
literal|3
operator|)
argument_list|,
name|load32
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|4
argument_list|)
operator|&
literal|0xFFFFFFFFL
argument_list|,
name|mul
argument_list|)
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|byte
name|a
init|=
name|bytes
index|[
name|offset
index|]
decl_stmt|;
name|byte
name|b
init|=
name|bytes
index|[
name|offset
operator|+
operator|(
name|length
operator|>>
literal|1
operator|)
index|]
decl_stmt|;
name|byte
name|c
init|=
name|bytes
index|[
name|offset
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|int
name|y
init|=
operator|(
name|a
operator|&
literal|0xFF
operator|)
operator|+
operator|(
operator|(
name|b
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
name|int
name|z
init|=
name|length
operator|+
operator|(
operator|(
name|c
operator|&
literal|0xFF
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
return|return
name|shiftMix
argument_list|(
name|y
operator|*
name|K2
operator|^
name|z
operator|*
name|K0
argument_list|)
operator|*
name|K2
return|;
block|}
return|return
name|K2
return|;
block|}
DECL|method|hashLength17to32 (byte[] bytes, int offset, int length)
specifier|private
specifier|static
name|long
name|hashLength17to32
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|long
name|mul
init|=
name|K2
operator|+
name|length
operator|*
literal|2
decl_stmt|;
name|long
name|a
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|*
name|K1
decl_stmt|;
name|long
name|b
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
decl_stmt|;
name|long
name|c
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|8
argument_list|)
operator|*
name|mul
decl_stmt|;
name|long
name|d
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|16
argument_list|)
operator|*
name|K2
decl_stmt|;
return|return
name|hashLength16
argument_list|(
name|rotateRight
argument_list|(
name|a
operator|+
name|b
argument_list|,
literal|43
argument_list|)
operator|+
name|rotateRight
argument_list|(
name|c
argument_list|,
literal|30
argument_list|)
operator|+
name|d
argument_list|,
name|a
operator|+
name|rotateRight
argument_list|(
name|b
operator|+
name|K2
argument_list|,
literal|18
argument_list|)
operator|+
name|c
argument_list|,
name|mul
argument_list|)
return|;
block|}
DECL|method|hashLength33To64 (byte[] bytes, int offset, int length)
specifier|private
specifier|static
name|long
name|hashLength33To64
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|long
name|mul
init|=
name|K2
operator|+
name|length
operator|*
literal|2
decl_stmt|;
name|long
name|a
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|*
name|K2
decl_stmt|;
name|long
name|b
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
decl_stmt|;
name|long
name|c
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|8
argument_list|)
operator|*
name|mul
decl_stmt|;
name|long
name|d
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|16
argument_list|)
operator|*
name|K2
decl_stmt|;
name|long
name|y
init|=
name|rotateRight
argument_list|(
name|a
operator|+
name|b
argument_list|,
literal|43
argument_list|)
operator|+
name|rotateRight
argument_list|(
name|c
argument_list|,
literal|30
argument_list|)
operator|+
name|d
decl_stmt|;
name|long
name|z
init|=
name|hashLength16
argument_list|(
name|y
argument_list|,
name|a
operator|+
name|rotateRight
argument_list|(
name|b
operator|+
name|K2
argument_list|,
literal|18
argument_list|)
operator|+
name|c
argument_list|,
name|mul
argument_list|)
decl_stmt|;
name|long
name|e
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|16
argument_list|)
operator|*
name|mul
decl_stmt|;
name|long
name|f
init|=
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|24
argument_list|)
decl_stmt|;
name|long
name|g
init|=
operator|(
name|y
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|32
argument_list|)
operator|)
operator|*
name|mul
decl_stmt|;
name|long
name|h
init|=
operator|(
name|z
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|length
operator|-
literal|24
argument_list|)
operator|)
operator|*
name|mul
decl_stmt|;
return|return
name|hashLength16
argument_list|(
name|rotateRight
argument_list|(
name|e
operator|+
name|f
argument_list|,
literal|43
argument_list|)
operator|+
name|rotateRight
argument_list|(
name|g
argument_list|,
literal|30
argument_list|)
operator|+
name|h
argument_list|,
name|e
operator|+
name|rotateRight
argument_list|(
name|f
operator|+
name|a
argument_list|,
literal|18
argument_list|)
operator|+
name|g
argument_list|,
name|mul
argument_list|)
return|;
block|}
comment|/*    * Compute an 8-byte hash of a byte array of length greater than 64 bytes.    */
DECL|method|hashLength65Plus (byte[] bytes, int offset, int length)
specifier|private
specifier|static
name|long
name|hashLength65Plus
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
name|seed
init|=
literal|81
decl_stmt|;
comment|// For strings over 64 bytes we loop. Internal state consists of 56 bytes: v, w, x, y, and z.
name|long
name|x
init|=
name|seed
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ConstantOverflow"
argument_list|)
name|long
name|y
init|=
name|seed
operator|*
name|K1
operator|+
literal|113
decl_stmt|;
name|long
name|z
init|=
name|shiftMix
argument_list|(
name|y
operator|*
name|K2
operator|+
literal|113
argument_list|)
operator|*
name|K2
decl_stmt|;
name|long
index|[]
name|v
init|=
operator|new
name|long
index|[
literal|2
index|]
decl_stmt|;
name|long
index|[]
name|w
init|=
operator|new
name|long
index|[
literal|2
index|]
decl_stmt|;
name|x
operator|=
name|x
operator|*
name|K2
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// Set end so that after the loop we have 1 to 64 bytes left to process.
name|int
name|end
init|=
name|offset
operator|+
operator|(
operator|(
name|length
operator|-
literal|1
operator|)
operator|/
literal|64
operator|)
operator|*
literal|64
decl_stmt|;
name|int
name|last64offset
init|=
name|end
operator|+
operator|(
operator|(
name|length
operator|-
literal|1
operator|)
operator|&
literal|63
operator|)
operator|-
literal|63
decl_stmt|;
do|do
block|{
name|x
operator|=
name|rotateRight
argument_list|(
name|x
operator|+
name|y
operator|+
name|v
index|[
literal|0
index|]
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
argument_list|,
literal|37
argument_list|)
operator|*
name|K1
expr_stmt|;
name|y
operator|=
name|rotateRight
argument_list|(
name|y
operator|+
name|v
index|[
literal|1
index|]
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|48
argument_list|)
argument_list|,
literal|42
argument_list|)
operator|*
name|K1
expr_stmt|;
name|x
operator|^=
name|w
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|v
index|[
literal|0
index|]
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|40
argument_list|)
expr_stmt|;
name|z
operator|=
name|rotateRight
argument_list|(
name|z
operator|+
name|w
index|[
literal|0
index|]
argument_list|,
literal|33
argument_list|)
operator|*
name|K1
expr_stmt|;
name|weakHashLength32WithSeeds
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|v
index|[
literal|1
index|]
operator|*
name|K1
argument_list|,
name|x
operator|+
name|w
index|[
literal|0
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|weakHashLength32WithSeeds
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|32
argument_list|,
name|z
operator|+
name|w
index|[
literal|1
index|]
argument_list|,
name|y
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|16
argument_list|)
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|long
name|tmp
init|=
name|x
decl_stmt|;
name|x
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|tmp
expr_stmt|;
name|offset
operator|+=
literal|64
expr_stmt|;
block|}
do|while
condition|(
name|offset
operator|!=
name|end
condition|)
do|;
name|long
name|mul
init|=
name|K1
operator|+
operator|(
operator|(
name|z
operator|&
literal|0xFF
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
comment|// Operate on the last 64 bytes of input.
name|offset
operator|=
name|last64offset
expr_stmt|;
name|w
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|length
operator|-
literal|1
operator|)
operator|&
literal|63
operator|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|+=
name|w
index|[
literal|0
index|]
expr_stmt|;
name|w
index|[
literal|0
index|]
operator|+=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|rotateRight
argument_list|(
name|x
operator|+
name|y
operator|+
name|v
index|[
literal|0
index|]
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
argument_list|,
literal|37
argument_list|)
operator|*
name|mul
expr_stmt|;
name|y
operator|=
name|rotateRight
argument_list|(
name|y
operator|+
name|v
index|[
literal|1
index|]
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|48
argument_list|)
argument_list|,
literal|42
argument_list|)
operator|*
name|mul
expr_stmt|;
name|x
operator|^=
name|w
index|[
literal|1
index|]
operator|*
literal|9
expr_stmt|;
name|y
operator|+=
name|v
index|[
literal|0
index|]
operator|*
literal|9
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|40
argument_list|)
expr_stmt|;
name|z
operator|=
name|rotateRight
argument_list|(
name|z
operator|+
name|w
index|[
literal|0
index|]
argument_list|,
literal|33
argument_list|)
operator|*
name|mul
expr_stmt|;
name|weakHashLength32WithSeeds
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|v
index|[
literal|1
index|]
operator|*
name|mul
argument_list|,
name|x
operator|+
name|w
index|[
literal|0
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|weakHashLength32WithSeeds
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|32
argument_list|,
name|z
operator|+
name|w
index|[
literal|1
index|]
argument_list|,
name|y
operator|+
name|load64
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|16
argument_list|)
argument_list|,
name|w
argument_list|)
expr_stmt|;
return|return
name|hashLength16
argument_list|(
name|hashLength16
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|,
name|w
index|[
literal|0
index|]
argument_list|,
name|mul
argument_list|)
operator|+
name|shiftMix
argument_list|(
name|y
argument_list|)
operator|*
name|K0
operator|+
name|x
argument_list|,
name|hashLength16
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
name|w
index|[
literal|1
index|]
argument_list|,
name|mul
argument_list|)
operator|+
name|z
argument_list|,
name|mul
argument_list|)
return|;
block|}
block|}
end_class

end_unit

