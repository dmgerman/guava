begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a  * {@link Map}) with a separator. It either appends the results to an {@link Appendable} or returns  * them as a {@link String}. Example:  *  *<pre>{@code  * Joiner joiner = Joiner.on("; ").skipNulls();  *  . . .  * return joiner.join("Harry", null, "Ron", "Hermione");  * }</pre>  *  *<p>This returns the string {@code "Harry; Ron; Hermione"}. Note that all input elements are  * converted to strings using {@link Object#toString()} before being appended.  *  *<p>If neither {@link #skipNulls()} nor {@link #useForNull(String)} is specified, the joining  * methods will throw {@link NullPointerException} if any given element is null.  *  *<p><b>Warning: joiner instances are always immutable</b>; a configuration method such as {@code  * useForNull} has no effect on the instance it is invoked on! You must store and use the new joiner  * instance returned by the method. This makes joiners thread-safe, and safe to store as {@code  * static final} constants.  *  *<pre>{@code  * // Bad! Do not do this!  * Joiner joiner = Joiner.on(',');  * joiner.skipNulls(); // does nothing!  * return joiner.join("wrong", null, "wrong");  * }</pre>  *  *<p>See the Guava User Guide article on<a  * href="https://github.com/google/guava/wiki/StringsExplained#joiner">{@code Joiner}</a>.  *  * @author Kevin Bourrillion  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Joiner
specifier|public
class|class
name|Joiner
block|{
comment|/** Returns a joiner which automatically places {@code separator} between consecutive elements. */
DECL|method|on (String separator)
specifier|public
specifier|static
name|Joiner
name|on
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
return|return
operator|new
name|Joiner
argument_list|(
name|separator
argument_list|)
return|;
block|}
comment|/** Returns a joiner which automatically places {@code separator} between consecutive elements. */
DECL|method|on (char separator)
specifier|public
specifier|static
name|Joiner
name|on
parameter_list|(
name|char
name|separator
parameter_list|)
block|{
return|return
operator|new
name|Joiner
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|separator
argument_list|)
argument_list|)
return|;
block|}
DECL|field|separator
specifier|private
specifier|final
name|String
name|separator
decl_stmt|;
DECL|method|Joiner (String separator)
specifier|private
name|Joiner
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|this
operator|.
name|separator
operator|=
name|checkNotNull
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
DECL|method|Joiner (Joiner prototype)
specifier|private
name|Joiner
parameter_list|(
name|Joiner
name|prototype
parameter_list|)
block|{
name|this
operator|.
name|separator
operator|=
name|prototype
operator|.
name|separator
expr_stmt|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code appendable}.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Iterable<?> parts)
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|appendTo
argument_list|(
name|appendable
argument_list|,
name|parts
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code appendable}.    *    * @since 11.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Iterator<?> parts)
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|appendable
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|parts
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|parts
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|appendable
return|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code appendable}.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Object[] parts)
specifier|public
specifier|final
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Object
index|[]
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|appendTo
argument_list|(
name|appendable
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|parts
argument_list|)
argument_list|)
return|;
block|}
comment|/** Appends to {@code appendable} the string representation of each of the remaining arguments. */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo ( A appendable, @NullableDecl Object first, @NullableDecl Object second, Object... rest)
specifier|public
specifier|final
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|first
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|second
parameter_list|,
name|Object
modifier|...
name|rest
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|appendTo
argument_list|(
name|appendable
argument_list|,
name|iterable
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|rest
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,    * Iterable)}, except that it does not throw {@link IOException}.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Iterable<?> parts)
specifier|public
specifier|final
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
name|builder
argument_list|,
name|parts
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,    * Iterable)}, except that it does not throw {@link IOException}.    *    * @since 11.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Iterator<?> parts)
specifier|public
specifier|final
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
block|{
try|try
block|{
name|appendTo
argument_list|(
operator|(
name|Appendable
operator|)
name|builder
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
return|return
name|builder
return|;
block|}
comment|/**    * Appends the string representation of each of {@code parts}, using the previously configured    * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,    * Iterable)}, except that it does not throw {@link IOException}.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Object[] parts)
specifier|public
specifier|final
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Object
index|[]
name|parts
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
name|builder
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|parts
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Appends to {@code builder} the string representation of each of the remaining arguments.    * Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not    * throw {@link IOException}.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo ( StringBuilder builder, @NullableDecl Object first, @NullableDecl Object second, Object... rest)
specifier|public
specifier|final
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|first
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|second
parameter_list|,
name|Object
modifier|...
name|rest
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
name|builder
argument_list|,
name|iterable
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|rest
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing the string representation of each of {@code parts}, using the    * previously configured separator between each.    */
DECL|method|join (Iterable<?> parts)
specifier|public
specifier|final
name|String
name|join
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|parts
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing the string representation of each of {@code parts}, using the    * previously configured separator between each.    *    * @since 11.0    */
DECL|method|join (Iterator<?> parts)
specifier|public
specifier|final
name|String
name|join
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|,
name|parts
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a string containing the string representation of each of {@code parts}, using the    * previously configured separator between each.    */
DECL|method|join (Object[] parts)
specifier|public
specifier|final
name|String
name|join
parameter_list|(
name|Object
index|[]
name|parts
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|parts
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing the string representation of each argument, using the previously    * configured separator between each.    */
DECL|method|join ( @ullableDecl Object first, @NullableDecl Object second, Object... rest)
specifier|public
specifier|final
name|String
name|join
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|first
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|second
parameter_list|,
name|Object
modifier|...
name|rest
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|iterable
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|rest
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a joiner with the same behavior as this one, except automatically substituting {@code    * nullText} for any provided null elements.    */
DECL|method|useForNull (final String nullText)
specifier|public
name|Joiner
name|useForNull
parameter_list|(
specifier|final
name|String
name|nullText
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|nullText
argument_list|)
expr_stmt|;
return|return
operator|new
name|Joiner
argument_list|(
name|this
argument_list|)
block|{
annotation|@
name|Override
name|CharSequence
name|toString
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|part
parameter_list|)
block|{
return|return
operator|(
name|part
operator|==
literal|null
operator|)
condition|?
name|nullText
else|:
name|Joiner
operator|.
name|this
operator|.
name|toString
argument_list|(
name|part
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Joiner
name|useForNull
parameter_list|(
name|String
name|nullText
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"already specified useForNull"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Joiner
name|skipNulls
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"already specified useForNull"
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a joiner with the same behavior as this joiner, except automatically skipping over any    * provided null elements.    */
DECL|method|skipNulls ()
specifier|public
name|Joiner
name|skipNulls
parameter_list|()
block|{
return|return
operator|new
name|Joiner
argument_list|(
name|this
argument_list|)
block|{
annotation|@
name|Override
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|appendable
argument_list|,
literal|"appendable"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|parts
argument_list|,
literal|"parts"
argument_list|)
expr_stmt|;
while|while
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|part
init|=
name|parts
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
name|Joiner
operator|.
name|this
operator|.
name|toString
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|part
init|=
name|parts
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|Joiner
operator|.
name|this
operator|.
name|toString
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|appendable
return|;
block|}
annotation|@
name|Override
specifier|public
name|Joiner
name|useForNull
parameter_list|(
name|String
name|nullText
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"already specified skipNulls"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoiner
name|withKeyValueSeparator
parameter_list|(
name|String
name|kvs
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"can't use .skipNulls() with maps"
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as    * this {@code Joiner} otherwise.    *    * @since 20.0    */
DECL|method|withKeyValueSeparator (char keyValueSeparator)
specifier|public
name|MapJoiner
name|withKeyValueSeparator
parameter_list|(
name|char
name|keyValueSeparator
parameter_list|)
block|{
return|return
name|withKeyValueSeparator
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|keyValueSeparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as    * this {@code Joiner} otherwise.    */
DECL|method|withKeyValueSeparator (String keyValueSeparator)
specifier|public
name|MapJoiner
name|withKeyValueSeparator
parameter_list|(
name|String
name|keyValueSeparator
parameter_list|)
block|{
return|return
operator|new
name|MapJoiner
argument_list|(
name|this
argument_list|,
name|keyValueSeparator
argument_list|)
return|;
block|}
comment|/**    * An object that joins map entries in the same manner as {@code Joiner} joins iterables and    * arrays. Like {@code Joiner}, it is thread-safe and immutable.    *    *<p>In addition to operating on {@code Map} instances, {@code MapJoiner} can operate on {@code    * Multimap} entries in two distinct modes:    *    *<ul>    *<li>To output a separate entry for each key-value pair, pass {@code multimap.entries()} to a    *       {@code MapJoiner} method that accepts entries as input, and receive output of the form    *       {@code key1=A&key1=B&key2=C}.    *<li>To output a single entry for each key, pass {@code multimap.asMap()} to a {@code    *       MapJoiner} method that accepts a map as input, and receive output of the form {@code    *       key1=[A, B]&key2=C}.    *</ul>    *    * @since 2.0    */
DECL|class|MapJoiner
specifier|public
specifier|static
specifier|final
class|class
name|MapJoiner
block|{
DECL|field|joiner
specifier|private
specifier|final
name|Joiner
name|joiner
decl_stmt|;
DECL|field|keyValueSeparator
specifier|private
specifier|final
name|String
name|keyValueSeparator
decl_stmt|;
DECL|method|MapJoiner (Joiner joiner, String keyValueSeparator)
specifier|private
name|MapJoiner
parameter_list|(
name|Joiner
name|joiner
parameter_list|,
name|String
name|keyValueSeparator
parameter_list|)
block|{
name|this
operator|.
name|joiner
operator|=
name|joiner
expr_stmt|;
comment|// only "this" is ever passed, so don't checkNotNull
name|this
operator|.
name|keyValueSeparator
operator|=
name|checkNotNull
argument_list|(
name|keyValueSeparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * Appends the string representation of each entry of {@code map}, using the previously      * configured separator and key-value separator, to {@code appendable}.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Map<?, ?> map)
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|appendTo
argument_list|(
name|appendable
argument_list|,
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Appends the string representation of each entry of {@code map}, using the previously      * configured separator and key-value separator, to {@code builder}. Identical to {@link      * #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Map<?, ?> map)
specifier|public
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
name|builder
argument_list|,
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a string containing the string representation of each entry of {@code map}, using the      * previously configured separator and key-value separator.      */
DECL|method|join (Map<?, ?> map)
specifier|public
name|String
name|join
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Appends the string representation of each entry in {@code entries}, using the previously      * configured separator and key-value separator, to {@code appendable}.      *      * @since 10.0      */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Iterable<? extends Entry<?, ?>> entries)
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|appendTo
argument_list|(
name|appendable
argument_list|,
name|entries
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Appends the string representation of each entry in {@code entries}, using the previously      * configured separator and key-value separator, to {@code appendable}.      *      * @since 11.0      */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (A appendable, Iterator<? extends Entry<?, ?>> parts)
specifier|public
parameter_list|<
name|A
extends|extends
name|Appendable
parameter_list|>
name|A
name|appendTo
parameter_list|(
name|A
name|appendable
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|appendable
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
name|parts
operator|.
name|next
argument_list|()
decl_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|joiner
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|keyValueSeparator
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|joiner
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|parts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
name|joiner
operator|.
name|separator
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
name|parts
operator|.
name|next
argument_list|()
decl_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|joiner
operator|.
name|toString
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|keyValueSeparator
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|joiner
operator|.
name|toString
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|appendable
return|;
block|}
comment|/**      * Appends the string representation of each entry in {@code entries}, using the previously      * configured separator and key-value separator, to {@code builder}. Identical to {@link      * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.      *      * @since 10.0      */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Iterable<? extends Entry<?, ?>> entries)
specifier|public
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
name|builder
argument_list|,
name|entries
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Appends the string representation of each entry in {@code entries}, using the previously      * configured separator and key-value separator, to {@code builder}. Identical to {@link      * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.      *      * @since 11.0      */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
DECL|method|appendTo (StringBuilder builder, Iterator<? extends Entry<?, ?>> entries)
specifier|public
name|StringBuilder
name|appendTo
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
try|try
block|{
name|appendTo
argument_list|(
operator|(
name|Appendable
operator|)
name|builder
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
return|return
name|builder
return|;
block|}
comment|/**      * Returns a string containing the string representation of each entry in {@code entries}, using      * the previously configured separator and key-value separator.      *      * @since 10.0      */
annotation|@
name|Beta
DECL|method|join (Iterable<? extends Entry<?, ?>> entries)
specifier|public
name|String
name|join
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|entries
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a string containing the string representation of each entry in {@code entries}, using      * the previously configured separator and key-value separator.      *      * @since 11.0      */
annotation|@
name|Beta
DECL|method|join (Iterator<? extends Entry<?, ?>> entries)
specifier|public
name|String
name|join
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
return|return
name|appendTo
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|,
name|entries
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns a map joiner with the same behavior as this one, except automatically substituting      * {@code nullText} for any provided null keys or values.      */
DECL|method|useForNull (String nullText)
specifier|public
name|MapJoiner
name|useForNull
parameter_list|(
name|String
name|nullText
parameter_list|)
block|{
return|return
operator|new
name|MapJoiner
argument_list|(
name|joiner
operator|.
name|useForNull
argument_list|(
name|nullText
argument_list|)
argument_list|,
name|keyValueSeparator
argument_list|)
return|;
block|}
block|}
DECL|method|toString (Object part)
name|CharSequence
name|toString
parameter_list|(
name|Object
name|part
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|// checkNotNull for GWT (do not optimize).
return|return
operator|(
name|part
operator|instanceof
name|CharSequence
operator|)
condition|?
operator|(
name|CharSequence
operator|)
name|part
else|:
name|part
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|iterable ( final Object first, final Object second, final Object[] rest)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|Object
argument_list|>
name|iterable
parameter_list|(
specifier|final
name|Object
name|first
parameter_list|,
specifier|final
name|Object
name|second
parameter_list|,
specifier|final
name|Object
index|[]
name|rest
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|rest
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rest
operator|.
name|length
operator|+
literal|2
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
return|return
name|first
return|;
case|case
literal|1
case|:
return|return
name|second
return|;
default|default:
return|return
name|rest
index|[
name|index
operator|-
literal|2
index|]
return|;
block|}
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

