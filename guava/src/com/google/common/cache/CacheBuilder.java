begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.cache
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
operator|.
name|firstNonNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ascii
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|SimpleStatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|StatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCacheAsMap
operator|.
name|Strength
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ForwardingConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_comment
comment|/**  *<p>A builder of {@link Cache} instances having any combination of the following features:  *  *<ul>  *<li>least-recently-used eviction when a maximum size is exceeded  *<li>time-based expiration of entries, measured since last access or last write  *<li>keys automatically wrapped in {@linkplain WeakReference weak} references  *<li>values automatically wrapped in {@linkplain WeakReference weak} or  *     {@linkplain SoftReference soft} references  *<li>notification of evicted (or otherwise removed) entries  *</ul>  *  *<p>Usage example:<pre>   {@code  *  *   Cache<Key, Graph> graphs = CacheBuilder.newBuilder()  *       .maximumSize(10000)  *       .expireAfterWrite(10, TimeUnit.MINUTES)  *       .removalListener(MY_LISTENER)  *       .build(  *           new CacheLoader<Key, Graph>() {  *             public Graph load(Key key) throws AnyException {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  *  * These features are all optional.  *  *<p>The returned cache is implemented as a hash table with similar performance characteristics to  * {@link ConcurrentHashMap}. It implements the optional operations {@link Cache#invalidate},  * {@link Cache#invalidateAll}, {@link Cache#size}, {@link Cache#stats}, and {@link Cache#asMap},  * with the following qualifications:  *  *<ul>  *<li>The {@code invalidateAll} method will invalidate all cached entries prior to returning, and  *     removal notifications will be issued for all invalidated entries.  *<li>The {@code asMap} view (and its collection views) have<i>weakly consistent iterators</i>.  *     This means that they are safe for concurrent use, but if other threads modify the cache after  *     the iterator is created, it is undefined which of these changes, if any, are reflected in  *     that iterator. These iterators never throw {@link ConcurrentModificationException}.  *</ul>  *  *<p><b>Note:</b> by default, the returned cache uses equality comparisons (the  * {@link Object#equals equals} method) to determine equality for keys or values. However, if  * {@link #weakKeys} was specified, the cache uses identity ({@code ==})  * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was  * specified, the cache uses identity comparisons for values.  *  *<p>If soft or weak references were requested, it is possible for a key or value present in the  * the cache to be reclaimed by the garbage collector. If this happens, the entry automatically  * disappears from the cache. A partially-reclaimed entry is never exposed to the user.  *  *<p>Certain cache configurations will result in the accrual of periodic maintenance tasks which  * will be performed during write operations, or during occasional read operations in the absense of  * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but  * calling it should not be necessary with a high throughput cache. Only caches built with  * {@linkplain CacheBuilder#removalListener removalListener},  * {@linkplain CacheBuilder#expireAfterWrite expireAfterWrite},  * {@linkplain CacheBuilder#expireAfterAccess expireAfterAccess},  * {@linkplain CacheBuilder#weakKeys weakKeys}, {@linkplain CacheBuilder#weakValues weakValues},  * or {@linkplain CacheBuilder#softValues softValues} perform periodic maintenance.  *  *<p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches  * retain all the configuration properties of the original cache. Note that the serialized form does  *<i>not</i> include cache contents, but only configuration.  *  * @param<K> the base key type for all caches created by this builder  * @param<V> the base value type for all caches created by this builder  * @author Charles Fry  * @author Kevin Bourrillion  * @since 10.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|CacheBuilder
specifier|public
specifier|final
class|class
name|CacheBuilder
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|4
decl_stmt|;
DECL|field|DEFAULT_EXPIRATION_NANOS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_EXPIRATION_NANOS
init|=
literal|0
decl_stmt|;
DECL|field|DEFAULT_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|DEFAULT_STATS_COUNTER
init|=
name|Suppliers
operator|.
name|ofInstance
argument_list|(
operator|new
name|StatsCounter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|recordHit
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordMiss
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadSuccess
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadException
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordEviction
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|CacheStats
name|snapshot
parameter_list|()
block|{
return|return
name|EMPTY_STATS
return|;
block|}
block|}
argument_list|)
decl_stmt|;
DECL|field|EMPTY_STATS
specifier|static
specifier|final
name|CacheStats
name|EMPTY_STATS
init|=
operator|new
name|CacheStats
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|CACHE_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|SimpleStatsCounter
argument_list|>
name|CACHE_STATS_COUNTER
init|=
operator|new
name|Supplier
argument_list|<
name|SimpleStatsCounter
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SimpleStatsCounter
name|get
parameter_list|()
block|{
return|return
operator|new
name|SimpleStatsCounter
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|enum|NullListener
enum|enum
name|NullListener
implements|implements
name|RemovalListener
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|onRemoval (RemovalNotification<Object, Object> notification)
specifier|public
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|notification
parameter_list|)
block|{}
block|}
DECL|enum|OneWeigher
enum|enum
name|OneWeigher
implements|implements
name|Weigher
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|weigh (Object key, Object value)
specifier|public
name|int
name|weigh
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
block|}
DECL|field|NULL_TICKER
specifier|static
specifier|final
name|Ticker
name|NULL_TICKER
init|=
operator|new
name|Ticker
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|read
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CacheBuilder
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|UNSET_INT
specifier|static
specifier|final
name|int
name|UNSET_INT
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|strictParsing
name|boolean
name|strictParsing
init|=
literal|true
decl_stmt|;
DECL|field|initialCapacity
name|int
name|initialCapacity
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|concurrencyLevel
name|int
name|concurrencyLevel
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumSize
name|long
name|maximumSize
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumWeight
name|long
name|maximumWeight
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|weigher
name|Weigher
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
DECL|field|keyStrength
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|expireAfterWriteNanos
name|long
name|expireAfterWriteNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|expireAfterAccessNanos
name|long
name|expireAfterAccessNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|keyEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|removalListener
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|ticker
name|Ticker
name|ticker
decl_stmt|;
comment|// TODO(fry): make constructor private and update tests to use newBuilder
DECL|method|CacheBuilder ()
name|CacheBuilder
parameter_list|()
block|{}
comment|/**    * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,    * strong values, and no automatic eviction of any kind.    */
DECL|method|newBuilder ()
specifier|public
specifier|static
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing keys.    *    *<p>By default, the cache uses {@link Equivalences#identity} to determine key equality when    * {@link #weakKeys} is specified, and {@link Equivalences#equals()} otherwise.    */
DECL|method|keyEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keyEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyEquivalence
operator|==
literal|null
argument_list|,
literal|"key equivalence was already set to %s"
argument_list|,
name|keyEquivalence
argument_list|)
expr_stmt|;
name|keyEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getKeyEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyEquivalence
argument_list|,
name|getKeyStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing values.    *    *<p>By default, the cache uses {@link Equivalences#identity} to determine value equality when    * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalences#equals()}    * otherwise.    */
DECL|method|valueEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueEquivalence
operator|==
literal|null
argument_list|,
literal|"value equivalence was already set to %s"
argument_list|,
name|valueEquivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getValueEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueEquivalence
argument_list|,
name|getValueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets the minimum total size for the internal hash tables. For example, if the initial capacity    * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each    * having a hash table of size eight. Providing a large enough estimate at construction time    * avoids the need for expensive resizing operations later, but setting this value unnecessarily    * high wastes memory.    *    * @throws IllegalArgumentException if {@code initialCapacity} is negative    * @throws IllegalStateException if an initial capacity was already set    */
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|initialCapacity
operator|==
name|UNSET_INT
argument_list|,
literal|"initial capacity was already set to %s"
argument_list|,
name|this
operator|.
name|initialCapacity
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|initialCapacity
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getInitialCapacity ()
name|int
name|getInitialCapacity
parameter_list|()
block|{
return|return
operator|(
name|initialCapacity
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_INITIAL_CAPACITY
else|:
name|initialCapacity
return|;
block|}
comment|/**    * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The    * table is internally partitioned to try to permit the indicated number of concurrent updates    * without contention. Because assignment of entries to these partitions is not necessarily    * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to    * accommodate as many threads as will ever concurrently modify the table. Using a significantly    * higher value than you need can waste space and time, and a significantly lower value can lead    * to thread contention. But overestimates and underestimates within an order of magnitude do not    * usually have much noticeable impact. A value of one permits only one thread to modify the cache    * at a time, but since read operations can proceed concurrently, this still yields higher    * concurrency than full synchronization. Defaults to 4.    *    *<p><b>Note:</b>The default may change in the future. If you care about this value, you should    * always choose it explicitly.    *    * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive    * @throws IllegalStateException if a concurrency level was already set    */
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|concurrencyLevel
operator|==
name|UNSET_INT
argument_list|,
literal|"concurrency level was already set to %s"
argument_list|,
name|this
operator|.
name|concurrencyLevel
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|concurrencyLevel
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getConcurrencyLevel ()
name|int
name|getConcurrencyLevel
parameter_list|()
block|{
return|return
operator|(
name|concurrencyLevel
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_CONCURRENCY_LEVEL
else|:
name|concurrencyLevel
return|;
block|}
comment|/**    * Specifies the maximum number of entries the cache may contain. Note that the cache<b>may evict    * an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the    * cache evicts entries that are less likely to be used again. For example, the cache may evict an    * entry because it hasn't been used recently or very often.    *    *<p>When {@code size} is zero, elements will be evicted immediately after being loaded into the    * cache. This can be useful in testing, or to disable caching temporarily without a code change.    *    * @param size the maximum size of the cache    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    */
DECL|method|maximumSize (long size)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum weight was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|weigher
operator|==
literal|null
argument_list|,
literal|"maximum size can not be combined with weigher"
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"maximum size must not be negative"
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies the maximum weight of entries the cache may contain. Weight is determined using the    * {@link Weigher} specified with {@link #weigher}, and use of this method requires a    * corresponding call to {@link #weigher} prior to calling {@link #build}.    *    *<p>Note that the cache<b>may evict an entry before this limit is exceeded</b>. As the cache    * size grows close to the maximum, the cache evicts entries that are less likely to be used    * again. For example, the cache may evict an entry because it hasn't been used recently or very    * often.    *    *<p>When {@code weight} is zero, elements will be evicted immediately after being loaded into    * cache. This can be useful in testing, or to disable caching temporarily without a code    * change.    *    * @param weight the maximum weight the cache may contain    * @param weigher the weigher to use in calculating the weight of cache entries    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    * @since 11.0    */
DECL|method|maximumWeight (long weight)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumWeight
parameter_list|(
name|long
name|weight
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum weight was already set to %s"
argument_list|,
name|this
operator|.
name|maximumWeight
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumWeight
operator|=
name|weight
expr_stmt|;
name|checkArgument
argument_list|(
name|weight
operator|>=
literal|0
argument_list|,
literal|"maximum weight must not be negative"
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies the weigher to use in determining the weight of entries. Entry weight is taken    * into consideration by {@link #maximumWeight} when determining which entries to evict, and    * use of this method requires a corresponding call to {@link #maximumWeight} prior to calling    * {@link #build}. Weights are measured and recorded when entries are inserted into the    * cache, and are thus effectively static during the lifetime of a cache entry.    *    *<p>When the weight of an entry is zero it will not be considered for size-based eviction    * (though it still may be evicted by other means).    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code CacheBuilder}    * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the    * original reference or the returned reference may be used to complete configuration and build    * the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from    * building caches whose key or value types are incompatible with the types accepted by the    * weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,    * simply use the standard method-chaining idiom, as illustrated in the documentation at top,    * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build    * a cache whose key or value type is incompatible with the weigher, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @param weight the maximum weight the cache may contain    * @param weigher the weigher to use in calculating the weight of cache entries    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    * @since 11.0    */
DECL|method|weigher ( Weigher<? super K1, ? super V1> weigher)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|weigher
parameter_list|(
name|Weigher
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|?
super|super
name|V1
argument_list|>
name|weigher
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|weigher
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|strictParsing
condition|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"weigher can not be combined with maximum size"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
block|}
comment|// safely limiting the kinds of caches this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|me
init|=
operator|(
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|weigher
operator|=
name|checkNotNull
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
return|return
name|me
return|;
block|}
DECL|method|getMaximumWeight ()
name|long
name|getMaximumWeight
parameter_list|()
block|{
if|if
condition|(
name|expireAfterWriteNanos
operator|==
literal|0
operator|||
name|expireAfterAccessNanos
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|weigher
operator|==
literal|null
operator|)
condition|?
name|maximumSize
else|:
name|maximumWeight
return|;
block|}
comment|// Make a safe contravariant cast now so we don't have to do it over and over.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getWeigher ()
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|Weigher
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|getWeigher
parameter_list|()
block|{
return|return
operator|(
name|Weigher
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|Objects
operator|.
name|firstNonNull
argument_list|(
name|weigher
argument_list|,
name|OneWeigher
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the cache should be strongly referenced.    *    * @throws IllegalStateException if the key strength was already set    */
DECL|method|strongKeys ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|strongKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the cache should be wrapped in a {@link    * WeakReference} (by default, strong references are used).    *    *<p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of keys.    *    *<p>Entries with keys that have been garbage collected may be counted by {@link Cache#size}, but    * will never be visible to read or write operations. Entries with garbage collected keys are    * cleaned up as part of the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the key strength was already set    */
DECL|method|weakKeys ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
DECL|method|setKeyStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setKeyStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyStrength
operator|==
literal|null
argument_list|,
literal|"Key strength was already set to %s"
argument_list|,
name|keyStrength
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyStrength ()
name|Strength
name|getKeyStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be strongly referenced.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|strongValues ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|strongValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link WeakReference} (by default, strong references are used).    *    *<p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor    * candidate for caching; consider {@link #softValues} instead.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    *<p>Entries with values that have been garbage collected may be counted by {@link Cache#size},    * but will never be visible to read or write operations. Entries with garbage collected keys are    * cleaned up as part of the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|weakValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will    * be garbage-collected in a<i>globally</i> least-recently-used manner, in response to memory    * demand.    *    *<p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain    * #maximumSize maximum size} instead of using soft references. You should only use this method if    * you are well familiar with the practical consequences of soft references.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    *<p>Entries with values that have been garbage collected may be counted by {@link Cache#size},    * but will never be visible to read or write operations. Entries with garbage collected values    * are cleaned up as part of the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|softValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|softValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setValueStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setValueStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueStrength
operator|==
literal|null
argument_list|,
literal|"Value strength was already set to %s"
argument_list|,
name|valueStrength
argument_list|)
expr_stmt|;
name|valueStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueStrength ()
name|Strength
name|getValueStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, or the most recent replacement of its value.    *    *<p>When {@code duration} is zero, this method hands off to    * {@link #maximumSize maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or    * weight. This can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>Expired entries may be counted by {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are cleaned up as part of the routine maintenance described    * in the class javadoc.    *    * @param duration the length of time after an entry is created that it should be automatically    *     removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to live or time to idle was already set    */
DECL|method|expireAfterWrite (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterWrite
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterWrite was already set to %s ns"
argument_list|,
name|expireAfterWriteNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterWriteNanos ()
name|long
name|getExpireAfterWriteNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterWriteNanos
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, the most recent replacement of its value, or its last    * access. Access time is reset by {@link Cache#get} and {@link Cache#getUnchecked}, but not by    * operations on the view returned by {@link Cache#asMap}.    *    *<p>When {@code duration} is zero, this method hands off to    * {@link #maximumSize maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or    * weight. This can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>Expired entries may be counted by {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are cleaned up as part of the routine maintenance described    * in the class javadoc.    *    * @param duration the length of time after an entry is last accessed that it should be    *     automatically removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to idle or time to live was already set    */
DECL|method|expireAfterAccess (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterAccess
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterAccess was already set to %s ns"
argument_list|,
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterAccessNanos ()
name|long
name|getExpireAfterAccessNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterAccessNanos
return|;
block|}
comment|/**    * Specifies a nanosecond-precision time source for use in determining when entries should be    * expired. By default, {@link System#nanoTime} is used.    *    *<p>The primary intent of this method is to facilitate testing of caches which have been    * configured with {@link #expireAfterWrite} or {@link #expireAfterAccess}.    *    * @throws IllegalStateException if a ticker was already set    */
DECL|method|ticker (Ticker ticker)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ticker
parameter_list|(
name|Ticker
name|ticker
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|ticker
operator|==
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|ticker
operator|=
name|checkNotNull
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getTicker (boolean recordsTime)
name|Ticker
name|getTicker
parameter_list|(
name|boolean
name|recordsTime
parameter_list|)
block|{
if|if
condition|(
name|ticker
operator|!=
literal|null
condition|)
block|{
return|return
name|ticker
return|;
block|}
return|return
name|recordsTime
condition|?
name|Ticker
operator|.
name|systemTicker
argument_list|()
else|:
name|NULL_TICKER
return|;
block|}
comment|/**    * Specifies a listener instance, which all caches built using this {@code CacheBuilder} will    * notify each time an entry is removed from the cache by any means.    *    *<p>Each cache built by this {@code CacheBuilder} after this method is called invokes the    * supplied listener after removing an element for any reason (see removal causes in {@link    * RemovalCause}). It will invoke the listener as part of the routine maintenance described    * in the class javadoc.    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code CacheBuilder}    * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the    * original reference or the returned reference may be used to complete configuration and build    * the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from    * building caches whose key or value types are incompatible with the types accepted by the    * listener already provided; the {@code CacheBuilder} type cannot do this. For best results,    * simply use the standard method-chaining idiom, as illustrated in the documentation at top,    * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build    * a cache whose key or value type is incompatible with the listener, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @throws IllegalStateException if a removal listener was already set    */
annotation|@
name|CheckReturnValue
DECL|method|removalListener ( RemovalListener<? super K1, ? super V1> listener)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|removalListener
parameter_list|(
name|RemovalListener
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|?
super|super
name|V1
argument_list|>
name|listener
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|removalListener
operator|==
literal|null
argument_list|)
expr_stmt|;
comment|// safely limiting the kinds of caches this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|me
init|=
operator|(
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|removalListener
operator|=
name|checkNotNull
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
name|me
return|;
block|}
comment|// Make a safe contravariant cast now so we don't have to do it over and over.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getRemovalListener ()
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|getRemovalListener
parameter_list|()
block|{
return|return
operator|(
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|Objects
operator|.
name|firstNonNull
argument_list|(
name|removalListener
argument_list|,
name|NullListener
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Builds a cache, which either returns an already-loaded value for a given key or atomically    * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently    * loading the value for this key, simply waits for that thread to finish and returns its    * loaded value. Note that multiple threads can concurrently load values for distinct keys.    *    *<p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be    * invoked again to create multiple independent caches.    *    * @param loader the cache loader used to obtain new values    * @return a cache having the requested features    */
DECL|method|build (CacheLoader<? super K1, V1> loader)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|Cache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|build
parameter_list|(
name|CacheLoader
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|V1
argument_list|>
name|loader
parameter_list|)
block|{
if|if
condition|(
name|strictParsing
condition|)
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
name|checkState
argument_list|(
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximumWeight requires weigher"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkState
argument_list|(
name|maximumWeight
operator|!=
name|UNSET_INT
argument_list|,
literal|"weigher requires maximumWeight"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|maximumWeight
operator|!=
name|UNSET_INT
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ignoring CacheBuilder.maximumWeight specified without CacheBuilder.weigher"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|maximumWeight
operator|==
name|UNSET_INT
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ignoring CacheBuilder.weigher specified without CacheBuilder.maximumWeight"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|LocalCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|(
name|this
argument_list|,
name|CACHE_STATS_COUNTER
argument_list|,
name|loader
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation for this CacheBuilder instance. The exact form of the returned    * string is not specified.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Objects
operator|.
name|ToStringHelper
name|s
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialCapacity
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"initialCapacity"
argument_list|,
name|initialCapacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"concurrencyLevel"
argument_list|,
name|concurrencyLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumWeight
operator|!=
name|UNSET_INT
condition|)
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumSize"
argument_list|,
name|maximumWeight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumWeight"
argument_list|,
name|maximumWeight
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expireAfterWriteNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterWrite"
argument_list|,
name|expireAfterWriteNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterAccess"
argument_list|,
name|expireAfterAccessNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"keyStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|keyStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"valueStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|valueStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"keyEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"valueEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removalListener
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"removalListener"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|class|CacheAsMap
specifier|static
specifier|final
class|class
name|CacheAsMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|delegate
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|CacheAsMap (ConcurrentMap<K, V> delegate)
name|CacheAsMap
parameter_list|(
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> map)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

