begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.cache
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
operator|.
name|firstNonNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ascii
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|SimpleStatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|StatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCache
operator|.
name|Strength
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_comment
comment|/**  *<p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the  * following features:  *  *<ul>  *<li>automatic loading of entries into the cache  *<li>least-recently-used eviction when a maximum size is exceeded  *<li>time-based expiration of entries, measured since last access or last write  *<li>keys automatically wrapped in {@linkplain WeakReference weak} references  *<li>values automatically wrapped in {@linkplain WeakReference weak} or  *     {@linkplain SoftReference soft} references  *<li>notification of evicted (or otherwise removed) entries  *<li>accumulation of cache access statistics  *</ul>  *  * These features are all optional; caches can be created using all or none of them. By default  * cache instances created by {@code CacheBuilder} will not perform any type of eviction.  *  *<p>Usage example:<pre>   {@code  *  *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()  *       .maximumSize(10000)  *       .expireAfterWrite(10, TimeUnit.MINUTES)  *       .removalListener(MY_LISTENER)  *       .build(  *           new CacheLoader<Key, Graph>() {  *             public Graph load(Key key) throws AnyException {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  * Or equivalently,<pre>   {@code  *  *   // In real life this would come from a command-line flag or config file  *   String spec = "maximumSize=10000,expireAfterWrite=10m";  *  *   LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)  *       .removalListener(MY_LISTENER)  *       .build(  *           new CacheLoader<Key, Graph>() {  *             public Graph load(Key key) throws AnyException {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  *<p>The returned cache is implemented as a hash table with similar performance characteristics to  * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and  * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have<i>weakly  * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads  * modify the cache after the iterator is created, it is undefined which of these changes, if any,  * are reflected in that iterator. These iterators never throw {@link  * ConcurrentModificationException}.  *  *<p><b>Note:</b> by default, the returned cache uses equality comparisons (the  * {@link Object#equals equals} method) to determine equality for keys or values. However, if  * {@link #weakKeys} was specified, the cache uses identity ({@code ==})  * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was  * specified, the cache uses identity comparisons for values.  *  *<p>Entries are automatically evicted from the cache when any of  * {@linkplain #maximumSize(long) maximumSize}, {@linkplain #maximumWeight(long) maximumWeight},  * {@linkplain #expireAfterWrite expireAfterWrite},  * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},  * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested.  *  *<p>If {@linkplain #maximumSize(long) maximumSize} or  * {@linkplain #maximumWeight(long) maximumWeight} is requested entries may be evicted on each cache  * modification.  *  *<p>If {@linkplain #expireAfterWrite expireAfterWrite} or  * {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each  * cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired  * entries may be counted in {@link Cache#size}, but will never be visible to read or write  * operations.  *  *<p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or  * {@linkplain #softValues softValues} are requested, it is possible for a key or value present in  * the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be  * removed from the cache on each cache modification, on occasional cache accesses, or on calls to  * {@link Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be  * visible to read or write operations.  *  *<p>Certain cache configurations will result in the accrual of periodic maintenance tasks which  * will be performed during write operations, or during occasional read operations in the absense of  * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but  * calling it should not be necessary with a high throughput cache. Only caches built with  * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},  * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},  * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic  * maintenance.  *  *<p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches  * retain all the configuration properties of the original cache. Note that the serialized form does  *<i>not</i> include cache contents, but only configuration.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CachesExplained">caching</a> for a higher-level  * explanation.  *  * @param<K> the base key type for all caches created by this builder  * @param<V> the base value type for all caches created by this builder  * @author Charles Fry  * @author Kevin Bourrillion  * @since 10.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|CacheBuilder
specifier|public
specifier|final
class|class
name|CacheBuilder
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|4
decl_stmt|;
DECL|field|DEFAULT_EXPIRATION_NANOS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_EXPIRATION_NANOS
init|=
literal|0
decl_stmt|;
DECL|field|DEFAULT_REFRESH_NANOS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_REFRESH_NANOS
init|=
literal|0
decl_stmt|;
DECL|field|NULL_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|NULL_STATS_COUNTER
init|=
name|Suppliers
operator|.
name|ofInstance
argument_list|(
operator|new
name|StatsCounter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|recordHits
parameter_list|(
name|int
name|count
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordMisses
parameter_list|(
name|int
name|count
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadSuccess
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadException
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordEviction
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|CacheStats
name|snapshot
parameter_list|()
block|{
return|return
name|EMPTY_STATS
return|;
block|}
block|}
argument_list|)
decl_stmt|;
DECL|field|EMPTY_STATS
specifier|static
specifier|final
name|CacheStats
name|EMPTY_STATS
init|=
operator|new
name|CacheStats
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|CACHE_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|StatsCounter
argument_list|>
name|CACHE_STATS_COUNTER
init|=
operator|new
name|Supplier
argument_list|<
name|StatsCounter
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StatsCounter
name|get
parameter_list|()
block|{
return|return
operator|new
name|SimpleStatsCounter
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|enum|NullListener
enum|enum
name|NullListener
implements|implements
name|RemovalListener
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|onRemoval (RemovalNotification<Object, Object> notification)
specifier|public
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|notification
parameter_list|)
block|{}
block|}
DECL|enum|OneWeigher
enum|enum
name|OneWeigher
implements|implements
name|Weigher
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|weigh (Object key, Object value)
specifier|public
name|int
name|weigh
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
block|}
DECL|field|NULL_TICKER
specifier|static
specifier|final
name|Ticker
name|NULL_TICKER
init|=
operator|new
name|Ticker
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|read
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CacheBuilder
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|UNSET_INT
specifier|static
specifier|final
name|int
name|UNSET_INT
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|strictParsing
name|boolean
name|strictParsing
init|=
literal|true
decl_stmt|;
DECL|field|initialCapacity
name|int
name|initialCapacity
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|concurrencyLevel
name|int
name|concurrencyLevel
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumSize
name|long
name|maximumSize
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumWeight
name|long
name|maximumWeight
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|weigher
name|Weigher
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
DECL|field|keyStrength
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|expireAfterWriteNanos
name|long
name|expireAfterWriteNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|expireAfterAccessNanos
name|long
name|expireAfterAccessNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|refreshNanos
name|long
name|refreshNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|keyEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|removalListener
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|ticker
name|Ticker
name|ticker
decl_stmt|;
DECL|field|statsCounterSupplier
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|statsCounterSupplier
init|=
name|NULL_STATS_COUNTER
decl_stmt|;
comment|// TODO(fry): make constructor private and update tests to use newBuilder
DECL|method|CacheBuilder ()
name|CacheBuilder
parameter_list|()
block|{}
comment|/**    * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,    * strong values, and no automatic eviction of any kind.    */
DECL|method|newBuilder ()
specifier|public
specifier|static
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.    *    * @since 12.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|from (CacheBuilderSpec spec)
specifier|public
specifier|static
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|from
parameter_list|(
name|CacheBuilderSpec
name|spec
parameter_list|)
block|{
return|return
name|spec
operator|.
name|toCacheBuilder
argument_list|()
operator|.
name|lenientParsing
argument_list|()
return|;
block|}
comment|/**    * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.    * This is especially useful for command-line configuration of a {@code CacheBuilder}.    *    * @param spec a String in the format specified by {@link CacheBuilderSpec}    * @since 12.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|from (String spec)
specifier|public
specifier|static
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|from
parameter_list|(
name|String
name|spec
parameter_list|)
block|{
return|return
name|from
argument_list|(
name|CacheBuilderSpec
operator|.
name|parse
argument_list|(
name|spec
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Enables lenient parsing. Useful for tests and spec parsing.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|lenientParsing ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lenientParsing
parameter_list|()
block|{
name|strictParsing
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing keys.    *    *<p>By default, the cache uses {@link Equivalence#identity} to determine key equality when    * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|keyEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keyEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyEquivalence
operator|==
literal|null
argument_list|,
literal|"key equivalence was already set to %s"
argument_list|,
name|keyEquivalence
argument_list|)
expr_stmt|;
name|keyEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getKeyEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyEquivalence
argument_list|,
name|getKeyStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing values.    *    *<p>By default, the cache uses {@link Equivalence#identity} to determine value equality when    * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalence#equals()}    * otherwise.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|valueEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueEquivalence
operator|==
literal|null
argument_list|,
literal|"value equivalence was already set to %s"
argument_list|,
name|valueEquivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getValueEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueEquivalence
argument_list|,
name|getValueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets the minimum total size for the internal hash tables. For example, if the initial capacity    * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each    * having a hash table of size eight. Providing a large enough estimate at construction time    * avoids the need for expensive resizing operations later, but setting this value unnecessarily    * high wastes memory.    *    * @throws IllegalArgumentException if {@code initialCapacity} is negative    * @throws IllegalStateException if an initial capacity was already set    */
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|initialCapacity
operator|==
name|UNSET_INT
argument_list|,
literal|"initial capacity was already set to %s"
argument_list|,
name|this
operator|.
name|initialCapacity
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|initialCapacity
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getInitialCapacity ()
name|int
name|getInitialCapacity
parameter_list|()
block|{
return|return
operator|(
name|initialCapacity
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_INITIAL_CAPACITY
else|:
name|initialCapacity
return|;
block|}
comment|/**    * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The    * table is internally partitioned to try to permit the indicated number of concurrent updates    * without contention. Because assignment of entries to these partitions is not necessarily    * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to    * accommodate as many threads as will ever concurrently modify the table. Using a significantly    * higher value than you need can waste space and time, and a significantly lower value can lead    * to thread contention. But overestimates and underestimates within an order of magnitude do not    * usually have much noticeable impact. A value of one permits only one thread to modify the cache    * at a time, but since read operations and cache loading computations can proceed concurrently,    * this still yields higher concurrency than full synchronization.    *    *<p> Defaults to 4.<b>Note:</b>The default may change in the future. If you care about this    * value, you should always choose it explicitly.    *    *<p>The current implementation uses the concurrency level to create a fixed number of hashtable    * segments, each governed by its own write lock. The segment lock is taken once for each explicit    * write, and twice for each cache loading computation (once prior to loading the new value,    * and once after loading completes). Much internal cache management is performed at the segment    * granularity. For example, access queues and write queues are kept per segment when they are    * required by the selected eviction algorithm. As such, when writing unit tests it is not    * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction    * behavior.    *    *<p>Note that future implementations may abandon segment locking in favor of more advanced    * concurrency controls.    *    * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive    * @throws IllegalStateException if a concurrency level was already set    */
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|concurrencyLevel
operator|==
name|UNSET_INT
argument_list|,
literal|"concurrency level was already set to %s"
argument_list|,
name|this
operator|.
name|concurrencyLevel
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|concurrencyLevel
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getConcurrencyLevel ()
name|int
name|getConcurrencyLevel
parameter_list|()
block|{
return|return
operator|(
name|concurrencyLevel
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_CONCURRENCY_LEVEL
else|:
name|concurrencyLevel
return|;
block|}
comment|/**    * Specifies the maximum number of entries the cache may contain. Note that the cache<b>may evict    * an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the    * cache evicts entries that are less likely to be used again. For example, the cache may evict an    * entry because it hasn't been used recently or very often.    *    *<p>When {@code size} is zero, elements will be evicted immediately after being loaded into the    * cache. This can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>This feature cannot be used in conjunction with {@link #maximumWeight}.    *    * @param size the maximum size of the cache    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size or weight was already set    */
DECL|method|maximumSize (long size)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum weight was already set to %s"
argument_list|,
name|this
operator|.
name|maximumWeight
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|weigher
operator|==
literal|null
argument_list|,
literal|"maximum size can not be combined with weigher"
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"maximum size must not be negative"
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies the maximum weight of entries the cache may contain. Weight is determined using the    * {@link Weigher} specified with {@link #weigher}, and use of this method requires a    * corresponding call to {@link #weigher} prior to calling {@link #build}.    *    *<p>Note that the cache<b>may evict an entry before this limit is exceeded</b>. As the cache    * size grows close to the maximum, the cache evicts entries that are less likely to be used    * again. For example, the cache may evict an entry because it hasn't been used recently or very    * often.    *    *<p>When {@code weight} is zero, elements will be evicted immediately after being loaded into    * cache. This can be useful in testing, or to disable caching temporarily without a code    * change.    *    *<p>Note that weight is only used to determine whether the cache is over capacity; it has no    * effect on selecting which entry should be evicted next.    *    *<p>This feature cannot be used in conjunction with {@link #maximumSize}.    *    * @param weight the maximum total weight of entries the cache may contain    * @throws IllegalArgumentException if {@code weight} is negative    * @throws IllegalStateException if a maximum weight or size was already set    * @since 11.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|maximumWeight (long weight)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumWeight
parameter_list|(
name|long
name|weight
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum weight was already set to %s"
argument_list|,
name|this
operator|.
name|maximumWeight
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumWeight
operator|=
name|weight
expr_stmt|;
name|checkArgument
argument_list|(
name|weight
operator|>=
literal|0
argument_list|,
literal|"maximum weight must not be negative"
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies the weigher to use in determining the weight of entries. Entry weight is taken    * into consideration by {@link #maximumWeight(long)} when determining which entries to evict, and    * use of this method requires a corresponding call to {@link #maximumWeight(long)} prior to    * calling {@link #build}. Weights are measured and recorded when entries are inserted into the    * cache, and are thus effectively static during the lifetime of a cache entry.    *    *<p>When the weight of an entry is zero it will not be considered for size-based eviction    * (though it still may be evicted by other means).    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code CacheBuilder}    * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the    * original reference or the returned reference may be used to complete configuration and build    * the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from    * building caches whose key or value types are incompatible with the types accepted by the    * weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,    * simply use the standard method-chaining idiom, as illustrated in the documentation at top,    * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build    * a cache whose key or value type is incompatible with the weigher, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @param weigher the weigher to use in calculating the weight of cache entries    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    * @since 11.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|weigher ( Weigher<? super K1, ? super V1> weigher)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|weigher
parameter_list|(
name|Weigher
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|?
super|super
name|V1
argument_list|>
name|weigher
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|weigher
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|strictParsing
condition|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"weigher can not be combined with maximum size"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
block|}
comment|// safely limiting the kinds of caches this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|me
init|=
operator|(
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|weigher
operator|=
name|checkNotNull
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
return|return
name|me
return|;
block|}
DECL|method|getMaximumWeight ()
name|long
name|getMaximumWeight
parameter_list|()
block|{
if|if
condition|(
name|expireAfterWriteNanos
operator|==
literal|0
operator|||
name|expireAfterAccessNanos
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|weigher
operator|==
literal|null
operator|)
condition|?
name|maximumSize
else|:
name|maximumWeight
return|;
block|}
comment|// Make a safe contravariant cast now so we don't have to do it over and over.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getWeigher ()
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|Weigher
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|getWeigher
parameter_list|()
block|{
return|return
operator|(
name|Weigher
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|Objects
operator|.
name|firstNonNull
argument_list|(
name|weigher
argument_list|,
name|OneWeigher
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the cache should be wrapped in a {@link    * WeakReference} (by default, strong references are used).    *    *<p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of keys.    *    *<p>Entries with keys that have been garbage collected may be counted in {@link Cache#size},    * but will never be visible to read or write operations; such entries are cleaned up as part of    * the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the key strength was already set    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
DECL|method|weakKeys ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
DECL|method|setKeyStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setKeyStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyStrength
operator|==
literal|null
argument_list|,
literal|"Key strength was already set to %s"
argument_list|,
name|keyStrength
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyStrength ()
name|Strength
name|getKeyStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link WeakReference} (by default, strong references are used).    *    *<p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor    * candidate for caching; consider {@link #softValues} instead.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    *<p>Entries with values that have been garbage collected may be counted in {@link Cache#size},    * but will never be visible to read or write operations; such entries are cleaned up as part of    * the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the value strength was already set    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
DECL|method|weakValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will    * be garbage-collected in a<i>globally</i> least-recently-used manner, in response to memory    * demand.    *    *<p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain    * #maximumSize(long) maximum size} instead of using soft references. You should only use this    * method if you are well familiar with the practical consequences of soft references.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    *<p>Entries with values that have been garbage collected may be counted in {@link Cache#size},    * but will never be visible to read or write operations; such entries are cleaned up as part of    * the routine maintenance described in the class javadoc.    *    * @throws IllegalStateException if the value strength was already set    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.SoftReference"
argument_list|)
DECL|method|softValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|softValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setValueStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setValueStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueStrength
operator|==
literal|null
argument_list|,
literal|"Value strength was already set to %s"
argument_list|,
name|valueStrength
argument_list|)
expr_stmt|;
name|valueStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueStrength ()
name|Strength
name|getValueStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, or the most recent replacement of its value.    *    *<p>When {@code duration} is zero, this method hands off to    * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum    * size or weight. This can be useful in testing, or to disable caching temporarily without a code    * change.    *    *<p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are cleaned up as part of the routine maintenance described    * in the class javadoc.    *    * @param duration the length of time after an entry is created that it should be automatically    *     removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to live or time to idle was already set    */
DECL|method|expireAfterWrite (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterWrite
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterWrite was already set to %s ns"
argument_list|,
name|expireAfterWriteNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterWriteNanos ()
name|long
name|getExpireAfterWriteNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterWriteNanos
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, the most recent replacement of its value, or its last    * access. Access time is reset by all cache read and write operations (including    * {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations    * on the collection-views of {@link Cache#asMap}.    *    *<p>When {@code duration} is zero, this method hands off to    * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum    * size or weight. This can be useful in testing, or to disable caching temporarily without a code    * change.    *    *<p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are cleaned up as part of the routine maintenance described    * in the class javadoc.    *    * @param duration the length of time after an entry is last accessed that it should be    *     automatically removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to idle or time to live was already set    */
DECL|method|expireAfterAccess (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterAccess
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterAccess was already set to %s ns"
argument_list|,
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterAccessNanos ()
name|long
name|getExpireAfterAccessNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterAccessNanos
return|;
block|}
comment|/**    * Specifies that active entries are eligible for automatic refresh once a fixed duration has    * elapsed after the entry's creation, or the most recent replacement of its value. The semantics    * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling    * {@link CacheLoader#reload}.    *    *<p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is    * recommended that users of this method override {@link CacheLoader#reload} with an asynchronous    * implementation; otherwise refreshes will be performed during unrelated cache read and write    * operations.    *    *<p>Currently automatic refreshes are performed when the first stale request for an entry    * occurs. The request triggering refresh will make a blocking call to {@link CacheLoader#reload}    * and immediately return the new value if the returned future is complete, and the old value    * otherwise.    *    *<p><b>Note:</b><i>all exceptions thrown during refresh will be logged and then swallowed</i>.    *    * @param duration the length of time after an entry is created that it should be considered    *     stale, and thus eligible for refresh    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the refresh interval was already set    * @since 11.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported (synchronously)."
argument_list|)
DECL|method|refreshAfterWrite (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|refreshAfterWrite
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|refreshNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"refresh was already set to %s ns"
argument_list|,
name|refreshNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>
literal|0
argument_list|,
literal|"duration must be positive: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|refreshNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getRefreshNanos ()
name|long
name|getRefreshNanos
parameter_list|()
block|{
return|return
operator|(
name|refreshNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_REFRESH_NANOS
else|:
name|refreshNanos
return|;
block|}
comment|/**    * Specifies a nanosecond-precision time source for use in determining when entries should be    * expired. By default, {@link System#nanoTime} is used.    *    *<p>The primary intent of this method is to facilitate testing of caches which have been    * configured with {@link #expireAfterWrite} or {@link #expireAfterAccess}.    *    * @throws IllegalStateException if a ticker was already set    */
DECL|method|ticker (Ticker ticker)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ticker
parameter_list|(
name|Ticker
name|ticker
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|ticker
operator|==
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|ticker
operator|=
name|checkNotNull
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getTicker (boolean recordsTime)
name|Ticker
name|getTicker
parameter_list|(
name|boolean
name|recordsTime
parameter_list|)
block|{
if|if
condition|(
name|ticker
operator|!=
literal|null
condition|)
block|{
return|return
name|ticker
return|;
block|}
return|return
name|recordsTime
condition|?
name|Ticker
operator|.
name|systemTicker
argument_list|()
else|:
name|NULL_TICKER
return|;
block|}
comment|/**    * Specifies a listener instance, which all caches built using this {@code CacheBuilder} will    * notify each time an entry is removed from the cache by any means.    *    *<p>Each cache built by this {@code CacheBuilder} after this method is called invokes the    * supplied listener after removing an element for any reason (see removal causes in {@link    * RemovalCause}). It will invoke the listener as part of the routine maintenance described    * in the class javadoc.    *    *<p><b>Note:</b><i>all exceptions thrown by {@code listener} will be logged (using    * {@link java.util.logging.Logger})and then swallowed</i>.    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code CacheBuilder}    * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the    * original reference or the returned reference may be used to complete configuration and build    * the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from    * building caches whose key or value types are incompatible with the types accepted by the    * listener already provided; the {@code CacheBuilder} type cannot do this. For best results,    * simply use the standard method-chaining idiom, as illustrated in the documentation at top,    * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build    * a cache whose key or value type is incompatible with the listener, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @throws IllegalStateException if a removal listener was already set    */
annotation|@
name|CheckReturnValue
DECL|method|removalListener ( RemovalListener<? super K1, ? super V1> listener)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|removalListener
parameter_list|(
name|RemovalListener
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|?
super|super
name|V1
argument_list|>
name|listener
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|removalListener
operator|==
literal|null
argument_list|)
expr_stmt|;
comment|// safely limiting the kinds of caches this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|me
init|=
operator|(
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|removalListener
operator|=
name|checkNotNull
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
name|me
return|;
block|}
comment|// Make a safe contravariant cast now so we don't have to do it over and over.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getRemovalListener ()
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|getRemovalListener
parameter_list|()
block|{
return|return
operator|(
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|Objects
operator|.
name|firstNonNull
argument_list|(
name|removalListener
argument_list|,
name|NullListener
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this    * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires    * bookkeeping to be performed with each operation, and thus imposes a performance penalty on    * cache operation.    *    * @since 12.0 (previously, stats collection was automatic)    */
DECL|method|recordStats ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|recordStats
parameter_list|()
block|{
name|statsCounterSupplier
operator|=
name|CACHE_STATS_COUNTER
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getStatsCounterSupplier ()
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|getStatsCounterSupplier
parameter_list|()
block|{
return|return
name|statsCounterSupplier
return|;
block|}
comment|/**    * Builds a cache, which either returns an already-loaded value for a given key or atomically    * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently    * loading the value for this key, simply waits for that thread to finish and returns its    * loaded value. Note that multiple threads can concurrently load values for distinct keys.    *    *<p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be    * invoked again to create multiple independent caches.    *    * @param loader the cache loader used to obtain new values    * @return a cache having the requested features    */
DECL|method|build ( CacheLoader<? super K1, V1> loader)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|LoadingCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|build
parameter_list|(
name|CacheLoader
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|V1
argument_list|>
name|loader
parameter_list|)
block|{
name|checkWeightWithWeigher
argument_list|()
expr_stmt|;
return|return
operator|new
name|LocalCache
operator|.
name|LocalLoadingCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|(
name|this
argument_list|,
name|loader
argument_list|)
return|;
block|}
comment|/**    * Builds a cache which does not automatically load values when keys are requested.    *    *<p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a    * {@code CacheLoader}.    *    *<p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be    * invoked again to create multiple independent caches.    *    * @return a cache having the requested features    * @since 11.0    */
DECL|method|build ()
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|Cache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|build
parameter_list|()
block|{
name|checkWeightWithWeigher
argument_list|()
expr_stmt|;
name|checkNonLoadingCache
argument_list|()
expr_stmt|;
return|return
operator|new
name|LocalCache
operator|.
name|LocalManualCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|checkNonLoadingCache ()
specifier|private
name|void
name|checkNonLoadingCache
parameter_list|()
block|{
name|checkState
argument_list|(
name|refreshNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"refreshAfterWrite requires a LoadingCache"
argument_list|)
expr_stmt|;
block|}
DECL|method|checkWeightWithWeigher ()
specifier|private
name|void
name|checkWeightWithWeigher
parameter_list|()
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
name|checkState
argument_list|(
name|maximumWeight
operator|==
name|UNSET_INT
argument_list|,
literal|"maximumWeight requires weigher"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strictParsing
condition|)
block|{
name|checkState
argument_list|(
name|maximumWeight
operator|!=
name|UNSET_INT
argument_list|,
literal|"weigher requires maximumWeight"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|maximumWeight
operator|==
name|UNSET_INT
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ignoring weigher specified without maximumWeight"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns a string representation for this CacheBuilder instance. The exact form of the returned    * string is not specified.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Objects
operator|.
name|ToStringHelper
name|s
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialCapacity
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"initialCapacity"
argument_list|,
name|initialCapacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"concurrencyLevel"
argument_list|,
name|concurrencyLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumSize
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumSize"
argument_list|,
name|maximumSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumWeight
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumWeight"
argument_list|,
name|maximumWeight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterWriteNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterWrite"
argument_list|,
name|expireAfterWriteNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterAccess"
argument_list|,
name|expireAfterAccessNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"keyStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|keyStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"valueStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|valueStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"keyEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"valueEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removalListener
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"removalListener"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

