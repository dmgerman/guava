begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.cache
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
operator|.
name|firstNonNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ascii
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|SimpleStatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|StatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CustomConcurrentHashMap
operator|.
name|Strength
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ForwardingConcurrentMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionError
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|UncheckedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  *<p>A builder of {@link Cache} instances having any combination of the following features:  *  *<ul>  *<li>least-recently-used eviction when a maximum size is exceeded  *<li>time-based expiration of entries, measured since last access or last write  *<li>keys automatically wrapped in {@linkplain WeakReference weak} references  *<li>values automatically wrapped in {@linkplain WeakReference weak} or  *     {@linkplain SoftReference soft} references  *<li>notification of evicted (or otherwise removed) entries  *</ul>  *  *<p>Usage example:<pre>   {@code  *  *   Cache<Key, Graph> graphs = CacheBuilder.newBuilder()  *       .concurrencyLevel(4)  *       .weakKeys()  *       .maximumSize(10000)  *       .expireAfterWrite(10, TimeUnit.MINUTES)  *       .build(  *           new CacheLoader<Key, Graph>() {  *             public Graph load(Key key) throws AnyException {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  *  * These features are all optional.  *  *<p>The returned cache is implemented as a hash table with similar performance characteristics to  * {@link ConcurrentHashMap}. It implements the optional operations {@link Cache#invalidate},  * {@link Cache#invalidateAll}, {@link Cache#size}, {@link Cache#stats}, and {@link Cache#asMap},  * with the following qualifications:  *  *<ul>  *<li>The {@code invalidateAll} method will invalidate all cached entries prior to returning, and  *     removal notifications will be issued for all invalidated entries.  *<li>The {@code asMap} view supports removal operations, but no other modifications.  *<li>The {@code asMap} view (and its collection views) have<i>weakly consistent iterators</i>.  *     This means that they are safe for concurrent use, but if other threads modify the cache after  *     the iterator is created, it is undefined which of these changes, if any, are reflected in  *     that iterator. These iterators never throw {@link ConcurrentModificationException}.  *</ul>  *  *<p><b>Note:</b> by default, the returned cache uses equality comparisons (the  * {@link Object#equals equals} method) to determine equality for keys or values. However, if  * {@link #weakKeys} was specified, the cache uses identity ({@code ==})  * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was  * specified, the cache uses identity comparisons for values.  *  *<p>If soft or weak references were requested, it is possible for a key or value present in the  * the cache to be reclaimed by the garbage collector. If this happens, the entry automatically  * disappears from the cache. A partially-reclaimed entry is never exposed to the user.  *  *<p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches  * retain all the configuration properties of the original cache.  *  * @param<K> the base key type for all caches created by this builder  * @param<V> the base value type for all caches created by this builder  * @author Charles Fry  * @author Kevin Bourrillion  * @since Guava release 10  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|CacheBuilder
specifier|public
specifier|final
class|class
name|CacheBuilder
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|4
decl_stmt|;
DECL|field|DEFAULT_EXPIRATION_NANOS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_EXPIRATION_NANOS
init|=
literal|0
decl_stmt|;
DECL|field|DEFAULT_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|DEFAULT_STATS_COUNTER
init|=
name|Suppliers
operator|.
name|ofInstance
argument_list|(
operator|new
name|StatsCounter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|recordHit
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadSuccess
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordLoadException
parameter_list|(
name|long
name|loadTime
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordConcurrentMiss
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|recordEviction
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|CacheStats
name|snapshot
parameter_list|()
block|{
return|return
name|EMPTY_STATS
return|;
block|}
block|}
argument_list|)
decl_stmt|;
DECL|field|EMPTY_STATS
specifier|static
specifier|final
name|CacheStats
name|EMPTY_STATS
init|=
operator|new
name|CacheStats
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|CACHE_STATS_COUNTER
specifier|static
specifier|final
name|Supplier
argument_list|<
name|SimpleStatsCounter
argument_list|>
name|CACHE_STATS_COUNTER
init|=
operator|new
name|Supplier
argument_list|<
name|SimpleStatsCounter
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SimpleStatsCounter
name|get
parameter_list|()
block|{
return|return
operator|new
name|SimpleStatsCounter
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|enum|NullListener
enum|enum
name|NullListener
implements|implements
name|RemovalListener
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|onRemoval (RemovalNotification<Object, Object> notification)
specifier|public
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|notification
parameter_list|)
block|{}
block|}
DECL|field|UNSET_INT
specifier|static
specifier|final
name|int
name|UNSET_INT
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|initialCapacity
name|int
name|initialCapacity
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|concurrencyLevel
name|int
name|concurrencyLevel
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumSize
name|int
name|maximumSize
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|keyStrength
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|expireAfterWriteNanos
name|long
name|expireAfterWriteNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|expireAfterAccessNanos
name|long
name|expireAfterAccessNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|nullRemovalCause
name|RemovalCause
name|nullRemovalCause
decl_stmt|;
DECL|field|keyEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|removalListener
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|cleanupExecutor
name|ScheduledExecutorService
name|cleanupExecutor
decl_stmt|;
DECL|field|ticker
name|Ticker
name|ticker
decl_stmt|;
comment|// TODO(user): make constructor private and update tests to use newBuilder
DECL|method|CacheBuilder ()
name|CacheBuilder
parameter_list|()
block|{}
comment|/**    * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,    * strong values, and no automatic eviction of any kind.    */
DECL|method|newBuilder ()
specifier|public
specifier|static
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|CacheBuilder
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
return|;
block|}
DECL|method|useNullCache ()
specifier|private
name|boolean
name|useNullCache
parameter_list|()
block|{
return|return
operator|(
name|nullRemovalCause
operator|==
literal|null
operator|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing keys.    *    *<p>By default, the cache uses {@link Equivalences#identity} to determine key equality when    * {@link #weakKeys} is specified, and {@link Equivalences#equals()} otherwise.    */
DECL|method|keyEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keyEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyEquivalence
operator|==
literal|null
argument_list|,
literal|"key equivalence was already set to %s"
argument_list|,
name|keyEquivalence
argument_list|)
expr_stmt|;
name|keyEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getKeyEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyEquivalence
argument_list|,
name|getKeyStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing values.    *    *<p>By default, the cache uses {@link Equivalences#identity} to determine value equality when    * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalences#equals()}    * otherwise.    */
DECL|method|valueEquivalence (Equivalence<Object> equivalence)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueEquivalence
operator|==
literal|null
argument_list|,
literal|"value equivalence was already set to %s"
argument_list|,
name|valueEquivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getValueEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueEquivalence
argument_list|,
name|getValueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets the minimum total size for the internal hash tables. For example, if the initial capacity    * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each    * having a hash table of size eight. Providing a large enough estimate at construction time    * avoids the need for expensive resizing operations later, but setting this value unnecessarily    * high wastes memory.    *    * @throws IllegalArgumentException if {@code initialCapacity} is negative    * @throws IllegalStateException if an initial capacity was already set    */
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|initialCapacity
operator|==
name|UNSET_INT
argument_list|,
literal|"initial capacity was already set to %s"
argument_list|,
name|this
operator|.
name|initialCapacity
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|initialCapacity
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getInitialCapacity ()
name|int
name|getInitialCapacity
parameter_list|()
block|{
return|return
operator|(
name|initialCapacity
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_INITIAL_CAPACITY
else|:
name|initialCapacity
return|;
block|}
comment|/**    * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The    * table is internally partitioned to try to permit the indicated number of concurrent updates    * without contention. Because assignment of entries to these partitions is not necessarily    * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to    * accommodate as many threads as will ever concurrently modify the table. Using a significantly    * higher value than you need can waste space and time, and a significantly lower value can lead    * to thread contention. But overestimates and underestimates within an order of magnitude do not    * usually have much noticeable impact. A value of one permits only one thread to modify the cache    * at a time, but since read operations can proceed concurrently, this still yields higher    * concurrency than full synchronization. Defaults to 4.    *    *<p><b>Note:</b>The default may change in the future. If you care about this value, you should    * always choose it explicitly.    *    * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive    * @throws IllegalStateException if a concurrency level was already set    */
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|concurrencyLevel
operator|==
name|UNSET_INT
argument_list|,
literal|"concurrency level was already set to %s"
argument_list|,
name|this
operator|.
name|concurrencyLevel
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|concurrencyLevel
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getConcurrencyLevel ()
name|int
name|getConcurrencyLevel
parameter_list|()
block|{
return|return
operator|(
name|concurrencyLevel
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_CONCURRENCY_LEVEL
else|:
name|concurrencyLevel
return|;
block|}
comment|/**    * Specifies the maximum number of entries the cache may contain. Note that the cache<b>may evict    * an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the    * cache evicts entries that are less likely to be used again. For example, the cache may evict an    * entry because it hasn't been used recently or very often.    *    *<p>When {@code size} is zero, elements will be evicted immediately after being loaded into the    * cache. This has the same effect as invoking {@link #expireAfterWrite    * expireAfterWrite}{@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0,    * unit)}. It can be useful in testing, or to disable caching temporarily without a code change.    *    * @param size the maximum size of the cache    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    */
DECL|method|maximumSize (int size)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"maximum size must not be negative"
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|maximumSize
operator|==
literal|0
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|SIZE
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the cache should be strongly referenced.    *    * @throws IllegalStateException if the key strength was already set    */
DECL|method|strongKeys ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|strongKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the cache should be wrapped in a {@link    * WeakReference} (by default, strong references are used).    *    *<p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of keys.    *    * @throws IllegalStateException if the key strength was already set    */
DECL|method|weakKeys ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
DECL|method|setKeyStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setKeyStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyStrength
operator|==
literal|null
argument_list|,
literal|"Key strength was already set to %s"
argument_list|,
name|keyStrength
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyStrength ()
name|Strength
name|getKeyStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be strongly referenced.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|strongValues ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|strongValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link WeakReference} (by default, strong references are used).    *    *<p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor    * candidate for caching; consider {@link #softValues} instead.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|weakValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weakValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the cache should be wrapped in a    * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will    * be garbage-collected in a<i>globally</i> least-recently-used manner, in response to memory    * demand.    *    *<p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain    * #maximumSize maximum size} instead of using soft references. You should only use this method if    * you are well familiar with the practical consequences of soft references.    *    *<p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})    * comparison to determine equality of values.    *    * @throws IllegalStateException if the value strength was already set    */
DECL|method|softValues ()
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|softValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setValueStrength (Strength strength)
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|setValueStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueStrength
operator|==
literal|null
argument_list|,
literal|"Value strength was already set to %s"
argument_list|,
name|valueStrength
argument_list|)
expr_stmt|;
name|valueStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueStrength ()
name|Strength
name|getValueStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, or the most recent replacement of its value.    *    *<p>When {@code duration} is zero, elements will be evicted immediately after being loaded into    * the cache. This has the same effect as invoking {@link #maximumSize maximumSize}{@code (0)}. It    * can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>Expired entries may be counted by {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are currently cleaned up during write operations, or during    * occasional read operations in the absense of writes; though this behavior may change in the    * future.    *    * @param duration the length of time after an entry is created that it should be automatically    *     removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to live or time to idle was already set    */
DECL|method|expireAfterWrite (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterWrite
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkExpiration
argument_list|(
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|==
literal|0
operator|&&
name|this
operator|.
name|nullRemovalCause
operator|==
literal|null
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|EXPIRED
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|checkExpiration (long duration, TimeUnit unit)
specifier|private
name|void
name|checkExpiration
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterWrite was already set to %s ns"
argument_list|,
name|expireAfterWriteNanos
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterAccess was already set to %s ns"
argument_list|,
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
DECL|method|getExpireAfterWriteNanos ()
name|long
name|getExpireAfterWriteNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterWriteNanos
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the cache once a fixed duration    * has elapsed after the entry's creation, or last access. Access time is reset by    * {@link Cache#get} and {@link Cache#getUnchecked}, but not by operations on the view returned by    * {@link Cache#asMap}.    *    *<p>When {@code duration} is zero, elements will be evicted immediately after being loaded into    * the cache. This has the same effect as invoking {@link #maximumSize maximumSize}{@code (0)}. It    * can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>Expired entries may be counted by {@link Cache#size}, but will never be visible to read or    * write operations. Expired entries are currently cleaned up during write operations, or during    * occasional read operations in the absense of writes; though this behavior may change in the    * future.    *    * @param duration the length of time after an entry is last accessed that it should be    *     automatically removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to idle or time to live was already set    */
DECL|method|expireAfterAccess (long duration, TimeUnit unit)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|expireAfterAccess
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkExpiration
argument_list|(
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|==
literal|0
operator|&&
name|this
operator|.
name|nullRemovalCause
operator|==
literal|null
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|EXPIRED
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterAccessNanos ()
name|long
name|getExpireAfterAccessNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterAccessNanos
return|;
block|}
DECL|method|getCleanupExecutor ()
name|ScheduledExecutorService
name|getCleanupExecutor
parameter_list|()
block|{
return|return
name|cleanupExecutor
return|;
block|}
comment|/**    * Specifies a nanosecond-precision time source for use in determining when entries should be    * expired. By default, {@link System#nanoTime} is used.    *    *<p>The primary intent of this method is to facilitate testing of caches which have been    * configured with {@link #expireAfterWrite} or {@link #expireAfterAccess}.    *    * @throws IllegalStateException if a ticker was already set    */
DECL|method|ticker (Ticker ticker)
specifier|public
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ticker
parameter_list|(
name|Ticker
name|ticker
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|ticker
operator|==
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|ticker
operator|=
name|checkNotNull
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getTicker ()
name|Ticker
name|getTicker
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|ticker
argument_list|,
name|Ticker
operator|.
name|systemTicker
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Specifies a listener instance, which all caches built using this {@code CacheBuilder} will    * notify each time an entry is removed from the cache by any means.    *    *<p>Each cache built by this {@code CacheBuilder} after this method is called invokes the    * supplied listener after removing an element for any reason (see removal causes in {@link    * RemovalCause}). It will invoke the listener during invocations of any of that cache's public    * methods (even read-only methods).    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code CacheBuilder}    * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the    * original reference or the returned reference may be used to complete configuration and build    * the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from    * building caches whose key or value types are incompatible with the types accepted by the    * listener already provided; the {@code CacheBuilder} type cannot do this. For best results,    * simply use the standard method-chaining idiom, as illustrated in the documentation at top,    * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build    * a cache whose key or value type is incompatible with the listener, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @throws IllegalStateException if a removal listener was already set    */
annotation|@
name|CheckReturnValue
DECL|method|removalListener ( RemovalListener<K1, V1> listener)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|removalListener
parameter_list|(
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|listener
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|removalListener
operator|==
literal|null
argument_list|)
expr_stmt|;
comment|// safely limiting the kinds of caches this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|me
init|=
operator|(
name|CacheBuilder
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|removalListener
operator|=
name|checkNotNull
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
name|me
return|;
block|}
comment|// Make a safe contravariant cast now so we don't have to do it over and over.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getRemovalListener ()
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|getRemovalListener
parameter_list|()
block|{
return|return
operator|(
name|RemovalListener
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
operator|)
name|Objects
operator|.
name|firstNonNull
argument_list|(
name|removalListener
argument_list|,
name|NullListener
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Builds a cache, which either returns an already-loaded value for a given key or atomically    * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently    * loading the value for this key, simply waits for that thread to finish and returns its    * loaded value. Note that multiple threads can concurrently load values for distinct keys.    *    *<p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be    * invoked again to create multiple independent caches.    *    * @param loader the cache loader used to obtain new values    * @return a cache having the requested features    */
DECL|method|build (CacheLoader<? super K1, V1> loader)
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|Cache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|build
parameter_list|(
name|CacheLoader
argument_list|<
name|?
super|super
name|K1
argument_list|,
name|V1
argument_list|>
name|loader
parameter_list|)
block|{
return|return
name|useNullCache
argument_list|()
condition|?
operator|new
name|ComputingCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|(
name|this
argument_list|,
name|CACHE_STATS_COUNTER
argument_list|,
name|loader
argument_list|)
else|:
operator|new
name|NullCache
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|(
name|this
argument_list|,
name|CACHE_STATS_COUNTER
argument_list|,
name|loader
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation for this CacheBuilder instance. The exact form of the returned    * string is not specificed.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Objects
operator|.
name|ToStringHelper
name|s
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialCapacity
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"initialCapacity"
argument_list|,
name|initialCapacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"concurrencyLevel"
argument_list|,
name|concurrencyLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumSize
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumSize"
argument_list|,
name|maximumSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterWriteNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterWrite"
argument_list|,
name|expireAfterWriteNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterAccess"
argument_list|,
name|expireAfterAccessNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"keyStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|keyStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"valueStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|valueStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"keyEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"valueEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removalListener
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"removalListener"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanupExecutor
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"cleanupExecutor"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** A map that is always empty and evicts on insertion. */
DECL|class|NullConcurrentMap
specifier|static
class|class
name|NullConcurrentMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|removalListener
specifier|private
specifier|final
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|removalCause
specifier|private
specifier|final
name|RemovalCause
name|removalCause
decl_stmt|;
DECL|method|NullConcurrentMap (CacheBuilder<? super K, ? super V> builder)
name|NullConcurrentMap
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|)
block|{
name|removalListener
operator|=
name|builder
operator|.
name|getRemovalListener
argument_list|()
expr_stmt|;
name|removalCause
operator|=
name|builder
operator|.
name|nullRemovalCause
expr_stmt|;
block|}
comment|// implements ConcurrentMap
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
DECL|method|notifyRemoval (K key, V value)
name|void
name|notifyRemoval
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
init|=
operator|new
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|removalCause
argument_list|)
decl_stmt|;
name|removalListener
operator|.
name|onRemoval
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|notifyRemoval
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
comment|// TODO(user): remove, as no code path can hit this
comment|/** Computes on retrieval and evicts the result. */
DECL|class|NullComputingConcurrentMap
specifier|static
specifier|final
class|class
name|NullComputingConcurrentMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|NullConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|loader
specifier|final
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|loader
decl_stmt|;
DECL|method|NullComputingConcurrentMap (CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, ? extends V> loader)
name|NullComputingConcurrentMap
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|checkNotNull
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, which is why Cache is preferred
annotation|@
name|Override
DECL|method|get (Object k)
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|k
decl_stmt|;
name|V
name|value
init|=
name|compute
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|,
name|loader
operator|+
literal|" returned null for key "
operator|+
name|key
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|notifyRemoval
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|compute (K key)
specifier|private
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Computes on retrieval and evicts the result. */
DECL|class|NullCache
specifier|static
specifier|final
class|class
name|NullCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|map
specifier|final
name|NullConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|loader
specifier|final
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
decl_stmt|;
DECL|field|statsCounter
specifier|final
name|StatsCounter
name|statsCounter
decl_stmt|;
DECL|method|NullCache (CacheBuilder<? super K, ? super V> builder, Supplier<? extends StatsCounter> statsCounterSupplier, CacheLoader<? super K, V> loader)
name|NullCache
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|StatsCounter
argument_list|>
name|statsCounterSupplier
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
operator|new
name|NullConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|this
operator|.
name|statsCounter
operator|=
name|statsCounterSupplier
operator|.
name|get
argument_list|()
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|checkNotNull
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get (K key)
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|V
name|value
init|=
name|compute
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|map
operator|.
name|notifyRemoval
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|compute (K key)
specifier|private
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|V
name|value
init|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|statsCounter
operator|.
name|recordLoadSuccess
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|statsCounter
operator|.
name|recordLoadException
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|statsCounter
operator|.
name|recordLoadException
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|statsCounter
operator|.
name|recordLoadException
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ExecutionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|statsCounter
operator|.
name|recordEviction
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|invalidate (Object key)
specifier|public
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|stats ()
specifier|public
name|CacheStats
name|stats
parameter_list|()
block|{
return|return
name|statsCounter
operator|.
name|snapshot
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|activeEntries (int limit)
specifier|public
name|ImmutableList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|activeEntries
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
DECL|field|asMap
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
decl_stmt|;
annotation|@
name|Override
DECL|method|asMap ()
specifier|public
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|()
block|{
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|am
init|=
name|asMap
decl_stmt|;
return|return
operator|(
name|am
operator|!=
literal|null
operator|)
condition|?
name|am
else|:
operator|(
name|asMap
operator|=
operator|new
name|CacheAsMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
operator|)
return|;
block|}
block|}
DECL|class|CacheAsMap
specifier|static
specifier|final
class|class
name|CacheAsMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|delegate
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|CacheAsMap (ConcurrentMap<K, V> delegate)
name|CacheAsMap
parameter_list|(
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> map)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

