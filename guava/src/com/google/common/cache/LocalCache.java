begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.cache
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
operator|.
name|NULL_TICKER
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
operator|.
name|UNSET_INT
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|getUninterruptibly
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|SimpleStatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|AbstractCache
operator|.
name|StatsCounter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
operator|.
name|NullListener
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
operator|.
name|OneWeigher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
operator|.
name|InvalidCacheLoadException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
operator|.
name|UnsupportedLoadingOperationException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|AbstractSequentialIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionError
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SettableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|UncheckedExecutionException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * The concurrent hash map implementation built by {@link CacheBuilder}.  *  *<p>This implementation is heavily derived from revision 1.96 of<a  * href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.  *  * @author Charles Fry  * @author Bob Lee ({@code com.google.common.collect.MapMaker})  * @author Doug Lea ({@code ConcurrentHashMap})  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|LocalCache
class|class
name|LocalCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/*    * The basic strategy is to subdivide the table among Segments, each of which itself is a    * concurrently readable hash table. The map supports non-blocking reads and concurrent writes    * across different segments.    *    * If a maximum size is specified, a best-effort bounding is performed per segment, using a    * page-replacement algorithm to determine which entries to evict when the capacity has been    * exceeded.    *    * The page replacement algorithm's data structures are kept casually consistent with the map. The    * ordering of writes to a segment is sequentially consistent. An update to the map and recording    * of reads may not be immediately reflected on the algorithm's data structures. These structures    * are guarded by a lock and operations are applied in batches to avoid lock contention. The    * penalty of applying the batches is spread across threads so that the amortized cost is slightly    * higher than performing just the operation without enforcing the capacity constraint.    *    * This implementation uses a per-segment queue to record a memento of the additions, removals,    * and accesses that were performed on the map. The queue is drained on writes and when it exceeds    * its capacity threshold.    *    * The Least Recently Used page replacement algorithm was chosen due to its simplicity, high hit    * rate, and ability to be implemented with O(1) time complexity. The initial LRU implementation    * operates per-segment rather than globally for increased implementation simplicity. We expect    * the cache hit rate to be similar to that of a global LRU algorithm.    */
comment|// Constants
comment|/**    * The maximum capacity, used if a higher value is implicitly specified by either of the    * constructors with arguments. MUST be a power of two<= 1<<30 to ensure that entries are    * indexable using ints.    */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/** The maximum number of segments to allow; used to bound constructor arguments. */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/** Number of (unsynchronized) retries in the containsValue method. */
DECL|field|CONTAINS_VALUE_RETRIES
specifier|static
specifier|final
name|int
name|CONTAINS_VALUE_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Number of cache access operations that can be buffered per segment before the cache's recency    * ordering information is updated. This is used to avoid lock contention by recording a memento    * of reads and delaying a lock acquisition until the threshold is crossed or a mutation occurs.    *    *<p>This must be a (2^n)-1 as it is used as a mask.    */
DECL|field|DRAIN_THRESHOLD
specifier|static
specifier|final
name|int
name|DRAIN_THRESHOLD
init|=
literal|0x3F
decl_stmt|;
comment|/**    * Maximum number of entries to be drained in a single cleanup run. This applies independently to    * the cleanup queue and both reference queues.    */
comment|// TODO(fry): empirically optimize this
DECL|field|DRAIN_MAX
specifier|static
specifier|final
name|int
name|DRAIN_MAX
init|=
literal|16
decl_stmt|;
comment|// Fields
DECL|field|logger
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|LocalCache
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|sameThreadExecutor
specifier|static
specifier|final
name|ListeningExecutorService
name|sameThreadExecutor
init|=
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
decl_stmt|;
comment|/**    * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose    * the segment.    */
DECL|field|segmentMask
specifier|final
name|int
name|segmentMask
decl_stmt|;
comment|/**    * Shift value for indexing within segments. Helps prevent entries that end up in the same segment    * from also ending up in the same bucket.    */
DECL|field|segmentShift
specifier|final
name|int
name|segmentShift
decl_stmt|;
comment|/** The segments, each of which is a specialized hash table. */
DECL|field|segments
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/** The concurrency level. */
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|/** Strategy for comparing keys. */
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
comment|/** Strategy for comparing values. */
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
comment|/** Strategy for referencing keys. */
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
comment|/** Strategy for referencing values. */
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
comment|/** The maximum weight of this map. UNSET_INT if there is no maximum. */
DECL|field|maxWeight
specifier|final
name|long
name|maxWeight
decl_stmt|;
comment|/** Weigher to weigh cache entries. */
DECL|field|weigher
specifier|final
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
decl_stmt|;
comment|/** How long after the last access to an entry the map will retain that entry. */
DECL|field|expireAfterAccessNanos
specifier|final
name|long
name|expireAfterAccessNanos
decl_stmt|;
comment|/** How long after the last write to an entry the map will retain that entry. */
DECL|field|expireAfterWriteNanos
specifier|final
name|long
name|expireAfterWriteNanos
decl_stmt|;
comment|/** How long after the last write an entry becomes a candidate for refresh. */
DECL|field|refreshNanos
specifier|final
name|long
name|refreshNanos
decl_stmt|;
comment|/** Entries waiting to be consumed by the removal listener. */
comment|// TODO(fry): define a new type which creates event objects and automates the clear logic
DECL|field|removalNotificationQueue
specifier|final
name|Queue
argument_list|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|removalNotificationQueue
decl_stmt|;
comment|/**    * A listener that is invoked when an entry is removed due to expiration or garbage collection of    * soft/weak entries.    */
DECL|field|removalListener
specifier|final
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
decl_stmt|;
comment|/** Measures time in a testable way. */
DECL|field|ticker
specifier|final
name|Ticker
name|ticker
decl_stmt|;
comment|/** Factory used to create new entries. */
DECL|field|entryFactory
specifier|final
name|EntryFactory
name|entryFactory
decl_stmt|;
comment|/**    * Accumulates global cache statistics. Note that there are also per-segments stats counters    * which must be aggregated to obtain a global stats view.    */
DECL|field|globalStatsCounter
specifier|final
name|StatsCounter
name|globalStatsCounter
decl_stmt|;
comment|/**    * The default cache loader to use on loading operations.    */
annotation|@
name|Nullable
DECL|field|defaultLoader
specifier|final
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|defaultLoader
decl_stmt|;
comment|/**    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.    */
DECL|method|LocalCache ( CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader)
name|LocalCache
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|,
annotation|@
name|Nullable
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|concurrencyLevel
operator|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|,
name|MAX_SEGMENTS
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|builder
operator|.
name|getKeyStrength
argument_list|()
expr_stmt|;
name|valueStrength
operator|=
name|builder
operator|.
name|getValueStrength
argument_list|()
expr_stmt|;
name|keyEquivalence
operator|=
name|builder
operator|.
name|getKeyEquivalence
argument_list|()
expr_stmt|;
name|valueEquivalence
operator|=
name|builder
operator|.
name|getValueEquivalence
argument_list|()
expr_stmt|;
name|maxWeight
operator|=
name|builder
operator|.
name|getMaximumWeight
argument_list|()
expr_stmt|;
name|weigher
operator|=
name|builder
operator|.
name|getWeigher
argument_list|()
expr_stmt|;
name|expireAfterAccessNanos
operator|=
name|builder
operator|.
name|getExpireAfterAccessNanos
argument_list|()
expr_stmt|;
name|expireAfterWriteNanos
operator|=
name|builder
operator|.
name|getExpireAfterWriteNanos
argument_list|()
expr_stmt|;
name|refreshNanos
operator|=
name|builder
operator|.
name|getRefreshNanos
argument_list|()
expr_stmt|;
name|removalListener
operator|=
name|builder
operator|.
name|getRemovalListener
argument_list|()
expr_stmt|;
name|removalNotificationQueue
operator|=
operator|(
name|removalListener
operator|==
name|NullListener
operator|.
name|INSTANCE
operator|)
condition|?
name|LocalCache
operator|.
expr|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
else|:
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|ticker
operator|=
name|builder
operator|.
name|getTicker
argument_list|(
name|recordsTime
argument_list|()
argument_list|)
expr_stmt|;
name|entryFactory
operator|=
name|EntryFactory
operator|.
name|getFactory
argument_list|(
name|keyStrength
argument_list|,
name|usesAccessEntries
argument_list|()
argument_list|,
name|usesWriteEntries
argument_list|()
argument_list|)
expr_stmt|;
name|globalStatsCounter
operator|=
name|builder
operator|.
name|getStatsCounterSupplier
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|defaultLoader
operator|=
name|loader
expr_stmt|;
name|int
name|initialCapacity
init|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getInitialCapacity
argument_list|()
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
decl_stmt|;
if|if
condition|(
name|evictsBySize
argument_list|()
operator|&&
operator|!
name|customWeigher
argument_list|()
condition|)
block|{
name|initialCapacity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|initialCapacity
argument_list|,
operator|(
name|int
operator|)
name|maxWeight
argument_list|)
expr_stmt|;
block|}
comment|// Find the lowest power-of-two segmentCount that exceeds concurrencyLevel, unless
comment|// maximumSize/Weight is specified in which case ensure that each segment gets at least 10
comment|// entries. The special casing for size-based eviction is only necessary because that eviction
comment|// happens per segment instead of globally, so too many segments compared to the maximum size
comment|// will result in random eviction behavior.
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
operator|&&
operator|(
operator|!
name|evictsBySize
argument_list|()
operator|||
name|segmentCount
operator|*
literal|20
operator|<=
name|maxWeight
operator|)
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|evictsBySize
argument_list|()
condition|)
block|{
comment|// Ensure sum of segment max weights = overall max weights
name|long
name|maxSegmentWeight
init|=
name|maxWeight
operator|/
name|segmentCount
operator|+
literal|1
decl_stmt|;
name|long
name|remainder
init|=
name|maxWeight
operator|%
name|segmentCount
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|remainder
condition|)
block|{
name|maxSegmentWeight
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|maxSegmentWeight
argument_list|,
name|builder
operator|.
name|getStatsCounterSupplier
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|UNSET_INT
argument_list|,
name|builder
operator|.
name|getStatsCounterSupplier
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|evictsBySize ()
name|boolean
name|evictsBySize
parameter_list|()
block|{
return|return
name|maxWeight
operator|>=
literal|0
return|;
block|}
DECL|method|customWeigher ()
name|boolean
name|customWeigher
parameter_list|()
block|{
return|return
name|weigher
operator|!=
name|OneWeigher
operator|.
name|INSTANCE
return|;
block|}
DECL|method|expires ()
name|boolean
name|expires
parameter_list|()
block|{
return|return
name|expiresAfterWrite
argument_list|()
operator|||
name|expiresAfterAccess
argument_list|()
return|;
block|}
DECL|method|expiresAfterWrite ()
name|boolean
name|expiresAfterWrite
parameter_list|()
block|{
return|return
name|expireAfterWriteNanos
operator|>
literal|0
return|;
block|}
DECL|method|expiresAfterAccess ()
name|boolean
name|expiresAfterAccess
parameter_list|()
block|{
return|return
name|expireAfterAccessNanos
operator|>
literal|0
return|;
block|}
DECL|method|refreshes ()
name|boolean
name|refreshes
parameter_list|()
block|{
return|return
name|refreshNanos
operator|>
literal|0
return|;
block|}
DECL|method|usesAccessQueue ()
name|boolean
name|usesAccessQueue
parameter_list|()
block|{
return|return
name|expiresAfterAccess
argument_list|()
operator|||
name|evictsBySize
argument_list|()
return|;
block|}
DECL|method|usesWriteQueue ()
name|boolean
name|usesWriteQueue
parameter_list|()
block|{
return|return
name|expiresAfterWrite
argument_list|()
return|;
block|}
DECL|method|recordsWrite ()
name|boolean
name|recordsWrite
parameter_list|()
block|{
return|return
name|expiresAfterWrite
argument_list|()
operator|||
name|refreshes
argument_list|()
return|;
block|}
DECL|method|recordsAccess ()
name|boolean
name|recordsAccess
parameter_list|()
block|{
return|return
name|expiresAfterAccess
argument_list|()
return|;
block|}
DECL|method|recordsTime ()
name|boolean
name|recordsTime
parameter_list|()
block|{
return|return
name|recordsWrite
argument_list|()
operator|||
name|recordsAccess
argument_list|()
return|;
block|}
DECL|method|usesWriteEntries ()
name|boolean
name|usesWriteEntries
parameter_list|()
block|{
return|return
name|usesWriteQueue
argument_list|()
operator|||
name|recordsWrite
argument_list|()
return|;
block|}
DECL|method|usesAccessEntries ()
name|boolean
name|usesAccessEntries
parameter_list|()
block|{
return|return
name|usesAccessQueue
argument_list|()
operator|||
name|recordsAccess
argument_list|()
return|;
block|}
DECL|method|usesKeyReferences ()
name|boolean
name|usesKeyReferences
parameter_list|()
block|{
return|return
name|keyStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|method|usesValueReferences ()
name|boolean
name|usesValueReferences
parameter_list|()
block|{
return|return
name|valueStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|enum|Strength
enum|enum
name|Strength
block|{
comment|/*      * TODO(kevinb): If we strongly reference the value and aren't loading, we needn't wrap the      * value. This could save ~8 bytes per entry.      */
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
return|return
operator|(
name|weight
operator|==
literal|1
operator|)
condition|?
operator|new
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
else|:
operator|new
name|WeightedStrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|,
name|weight
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|equals
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
return|return
operator|(
name|weight
operator|==
literal|1
operator|)
condition|?
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
else|:
operator|new
name|WeightedSoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|,
name|weight
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
return|return
operator|(
name|weight
operator|==
literal|1
operator|)
condition|?
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
else|:
operator|new
name|WeightedWeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|,
name|weight
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|;
comment|/**      * Creates a reference for the given value according to this value strength.      */
DECL|method|referenceValue ( Segment<K, V> segment, ReferenceEntry<K, V> entry, V value, int weight)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
function_decl|;
comment|/**      * Returns the default equivalence strategy used to compare and hash keys or values referenced      * at this strength. This strategy will be used unless the user explicitly specifies an      * alternate strategy.      */
DECL|method|defaultEquivalence ()
specifier|abstract
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
function_decl|;
block|}
comment|/**    * Creates new entries.    */
DECL|enum|EntryFactory
enum|enum
name|EntryFactory
block|{
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_ACCESS
name|STRONG_ACCESS
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongAccessEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyAccessEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_WRITE
name|STRONG_WRITE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongWriteEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyWriteEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_ACCESS_WRITE
name|STRONG_ACCESS_WRITE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongAccessWriteEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyAccessEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyWriteEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_ACCESS
name|WEAK_ACCESS
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakAccessEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyAccessEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_WRITE
name|WEAK_WRITE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakWriteEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyWriteEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_ACCESS_WRITE
name|WEAK_ACCESS_WRITE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakAccessWriteEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyAccessEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyWriteEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|;
comment|/**      * Masks used to compute indices in the following table.      */
DECL|field|ACCESS_MASK
specifier|static
specifier|final
name|int
name|ACCESS_MASK
init|=
literal|1
decl_stmt|;
DECL|field|WRITE_MASK
specifier|static
specifier|final
name|int
name|WRITE_MASK
init|=
literal|2
decl_stmt|;
DECL|field|WEAK_MASK
specifier|static
specifier|final
name|int
name|WEAK_MASK
init|=
literal|4
decl_stmt|;
comment|/**      * Look-up table for factories.      */
DECL|field|factories
specifier|static
specifier|final
name|EntryFactory
index|[]
name|factories
init|=
block|{
name|STRONG
block|,
name|STRONG_ACCESS
block|,
name|STRONG_WRITE
block|,
name|STRONG_ACCESS_WRITE
block|,
name|WEAK
block|,
name|WEAK_ACCESS
block|,
name|WEAK_WRITE
block|,
name|WEAK_ACCESS_WRITE
block|,     }
decl_stmt|;
DECL|method|getFactory (Strength keyStrength, boolean usesAccessQueue, boolean usesWriteQueue)
specifier|static
name|EntryFactory
name|getFactory
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|boolean
name|usesAccessQueue
parameter_list|,
name|boolean
name|usesWriteQueue
parameter_list|)
block|{
name|int
name|flags
init|=
operator|(
operator|(
name|keyStrength
operator|==
name|Strength
operator|.
name|WEAK
operator|)
condition|?
name|WEAK_MASK
else|:
literal|0
operator|)
operator||
operator|(
name|usesAccessQueue
condition|?
name|ACCESS_MASK
else|:
literal|0
operator|)
operator||
operator|(
name|usesWriteQueue
condition|?
name|WRITE_MASK
else|:
literal|0
operator|)
decl_stmt|;
return|return
name|factories
index|[
name|flags
index|]
return|;
block|}
comment|/**      * Creates a new entry.      *      * @param segment to create the entry for      * @param key of the entry      * @param hash of the key      * @param next entry in the same bucket      */
DECL|method|newEntry ( Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Copies an entry, assigning it a new {@code next} entry.      *      * @param original the entry to copy      * @param newNext entry in the same bucket      */
comment|// Guarded By Segment.this
DECL|method|copyEntry ( Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|newEntry
argument_list|(
name|segment
argument_list|,
name|original
operator|.
name|getKey
argument_list|()
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|// Guarded By Segment.this
DECL|method|copyAccessEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyAccessEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
comment|// TODO(fry): when we link values instead of entries this method can go
comment|// away, as can connectAccessOrder, nullifyAccessOrder.
name|newEntry
operator|.
name|setAccessTime
argument_list|(
name|original
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|connectAccessOrder
argument_list|(
name|original
operator|.
name|getPreviousInAccessQueue
argument_list|()
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|connectAccessOrder
argument_list|(
name|newEntry
argument_list|,
name|original
operator|.
name|getNextInAccessQueue
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyAccessOrder
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|method|copyWriteEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyWriteEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
comment|// TODO(fry): when we link values instead of entries this method can go
comment|// away, as can connectWriteOrder, nullifyWriteOrder.
name|newEntry
operator|.
name|setWriteTime
argument_list|(
name|original
operator|.
name|getWriteTime
argument_list|()
argument_list|)
expr_stmt|;
name|connectWriteOrder
argument_list|(
name|original
operator|.
name|getPreviousInWriteQueue
argument_list|()
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|connectWriteOrder
argument_list|(
name|newEntry
argument_list|,
name|original
operator|.
name|getNextInWriteQueue
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyWriteOrder
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A reference to a value.    */
DECL|interface|ValueReference
interface|interface
name|ValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Returns the value. Does not block or throw exceptions.      */
annotation|@
name|Nullable
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/**      * Waits for a value that may still be loading. Unlike get(), this method can block (in the      * case of FutureValueReference).      *      * @throws ExecutionException if the loading thread throws an exception      * @throws ExecutionError if the loading thread throws an error      */
DECL|method|waitForValue ()
name|V
name|waitForValue
parameter_list|()
throws|throws
name|ExecutionException
function_decl|;
comment|/**      * Returns the weight of this entry. This is assumed to be static between calls to setValue.      */
DECL|method|getWeight ()
name|int
name|getWeight
parameter_list|()
function_decl|;
comment|/**      * Returns the entry associated with this value reference, or {@code null} if this value      * reference is independent of any entry.      */
annotation|@
name|Nullable
DECL|method|getEntry ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
function_decl|;
comment|/**      * Creates a copy of this reference for the given entry.      *      *<p>{@code value} may be null only for a loading reference.      */
DECL|method|copyFor ( ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/**      * Notifify pending loads that a new value was set. This is only relevant to loading      * value references.      */
DECL|method|notifyNewValue (@ullable V newValue)
name|void
name|notifyNewValue
parameter_list|(
annotation|@
name|Nullable
name|V
name|newValue
parameter_list|)
function_decl|;
comment|/**      * Returns true if a new value is currently loading, regardless of whether or not there is an      * existing value. It is assumed that the return value of this method is constant for any given      * ValueReference instance.      */
DECL|method|isLoading ()
name|boolean
name|isLoading
parameter_list|()
function_decl|;
comment|/**      * Returns true if this reference contains an active value, meaning one that is still considered      * present in the cache. Active values consist of live values, which are returned by cache      * lookups, and dead values, which have been evicted but awaiting removal. Non-active values      * consist strictly of loading values, though during refresh a value may be both active and      * loading.      */
DECL|method|isActive ()
name|boolean
name|isActive
parameter_list|()
function_decl|;
block|}
comment|/**    * Placeholder. Indicates that the value hasn't been set yet.    */
DECL|field|UNSET
specifier|static
specifier|final
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|UNSET
init|=
operator|new
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
name|queue
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isLoading
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|waitForValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|notifyNewValue
parameter_list|(
name|Object
name|newValue
parameter_list|)
block|{}
block|}
decl_stmt|;
comment|/**    * Singleton placeholder that indicates a value is being loaded.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|unset ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unset
parameter_list|()
block|{
return|return
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|UNSET
return|;
block|}
comment|/**    * An entry in a reference map.    *    * Entries in the map can be in the following states:    *    * Valid:    * - Live: valid key/value are set    * - Loading: loading is pending    *    * Invalid:    * - Expired: time expired (key/value may still be set)    * - Collected: key/value was partially collected, but not yet cleaned up    * - Unset: marked as unset, awaiting cleanup or reuse    */
DECL|interface|ReferenceEntry
interface|interface
name|ReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Returns the value reference from this entry.      */
DECL|method|getValueReference ()
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Sets the value reference for this entry.      */
DECL|method|setValueReference (ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
function_decl|;
comment|/**      * Returns the next entry in the chain.      */
annotation|@
name|Nullable
DECL|method|getNext ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
function_decl|;
comment|/**      * Returns the entry's hash.      */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/**      * Returns the key for this entry.      */
annotation|@
name|Nullable
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
function_decl|;
comment|/*      * Used by entries that use access order. Access entries are maintained in a doubly-linked list.      * New entries are added at the tail of the list at write time; stale entries are expired from      * the head of the list.      */
comment|/**      * Returns the time that this entry was last accessed, in ns.      */
DECL|method|getAccessTime ()
name|long
name|getAccessTime
parameter_list|()
function_decl|;
comment|/**      * Sets the entry access time in ns.      */
DECL|method|setAccessTime (long time)
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
function_decl|;
comment|/**      * Returns the next entry in the access queue.      */
DECL|method|getNextInAccessQueue ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
function_decl|;
comment|/**      * Sets the next entry in the access queue.      */
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Returns the previous entry in the access queue.      */
DECL|method|getPreviousInAccessQueue ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
function_decl|;
comment|/**      * Sets the previous entry in the access queue.      */
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
function_decl|;
comment|/*      * Implemented by entries that use write order. Write entries are maintained in a      * doubly-linked list. New entries are added at the tail of the list at write time and stale      * entries are expired from the head of the list.      */
comment|/**      * Returns the time that this entry was last written, in ns.      */
DECL|method|getWriteTime ()
name|long
name|getWriteTime
parameter_list|()
function_decl|;
comment|/**      * Sets the entry write time in ns.      */
DECL|method|setWriteTime (long time)
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
function_decl|;
comment|/**      * Returns the next entry in the write queue.      */
DECL|method|getNextInWriteQueue ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
function_decl|;
comment|/**      * Sets the next entry in the write queue.      */
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Returns the previous entry in the write queue.      */
DECL|method|getPreviousInWriteQueue ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
function_decl|;
comment|/**      * Sets the previous entry in the write queue.      */
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
function_decl|;
block|}
DECL|enum|NullEntry
specifier|private
enum|enum
name|NullEntry
implements|implements
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<Object, Object> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|valueReference
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|Object
name|getKey
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<Object, Object> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|next
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<Object, Object> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|previous
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<Object, Object> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|next
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<Object, Object> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|previous
parameter_list|)
block|{}
block|}
DECL|class|AbstractReferenceEntry
specifier|static
specifier|abstract
class|class
name|AbstractReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|nullEntry ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
parameter_list|()
block|{
return|return
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
DECL|field|DISCARDING_QUEUE
specifier|static
specifier|final
name|Queue
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|DISCARDING_QUEUE
init|=
operator|new
name|AbstractQueue
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|offer
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|peek
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|poll
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Queue that discards all elements.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|discardingQueue ()
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Queue
argument_list|<
name|E
argument_list|>
name|discardingQueue
parameter_list|()
block|{
return|return
operator|(
name|Queue
operator|)
name|DISCARDING_QUEUE
return|;
block|}
comment|/*    * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!    * To maintain this code, make a change for the strong reference type. Then, cut and paste, and    * replace "Strong" with "Soft" or "Weak" within the pasted text. The primary difference is that    * strong entries store the key reference directly while soft and weak entries delegate to their    * respective superclasses.    */
comment|/**    * Used for strongly-referenced keys.    */
DECL|class|StrongEntry
specifier|static
class|class
name|StrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|method|StrongEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|StrongAccessEntry
specifier|static
specifier|final
class|class
name|StrongAccessEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongAccessEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongAccessEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each access entry type.
DECL|field|accessTime
specifier|volatile
name|long
name|accessTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|accessTime
return|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|accessTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|nextAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextAccess
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|previousAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousAccess
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|StrongWriteEntry
specifier|static
specifier|final
class|class
name|StrongWriteEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongWriteEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongWriteEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each write entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|nextWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextWrite
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|previousWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousWrite
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|StrongAccessWriteEntry
specifier|static
specifier|final
class|class
name|StrongAccessWriteEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongAccessWriteEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongAccessWriteEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each access entry type.
DECL|field|accessTime
specifier|volatile
name|long
name|accessTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|accessTime
return|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|accessTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|nextAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextAccess
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|previousAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousAccess
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each write entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|nextWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextWrite
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|previousWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousWrite
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/**    * Used for weakly-referenced keys.    */
DECL|class|WeakEntry
specifier|static
class|class
name|WeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEntry (ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
comment|/*      * It'd be nice to get these for free from AbstractReferenceEntry, but we're already extending      * WeakReference<K>.      */
comment|// null access
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// null write
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|WeakAccessEntry
specifier|static
specifier|final
class|class
name|WeakAccessEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakAccessEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakAccessEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each access entry type.
DECL|field|accessTime
specifier|volatile
name|long
name|accessTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|accessTime
return|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|accessTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|nextAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextAccess
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|previousAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousAccess
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|WeakWriteEntry
specifier|static
specifier|final
class|class
name|WeakWriteEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakWriteEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakWriteEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each write entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|nextWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextWrite
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|previousWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousWrite
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|WeakAccessWriteEntry
specifier|static
specifier|final
class|class
name|WeakAccessWriteEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakAccessWriteEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakAccessWriteEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each access entry type.
DECL|field|accessTime
specifier|volatile
name|long
name|accessTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getAccessTime ()
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|accessTime
return|;
block|}
annotation|@
name|Override
DECL|method|setAccessTime (long time)
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|accessTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|nextAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInAccessQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextAccess
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousAccess
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousAccess
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInAccessQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|previousAccess
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInAccessQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousAccess
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each write entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long time)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|time
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|nextWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|nextWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setNextInWriteQueue (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextWrite
operator|=
name|next
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|field|previousWrite
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousWrite
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousInWriteQueue ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|previousWrite
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousInWriteQueue (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousWrite
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/**    * References a weak value.    */
DECL|class|WeakValueReference
specifier|static
class|class
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|WeakValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry)
name|WeakValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|notifyNewValue (V newValue)
specifier|public
name|void
name|notifyNewValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isLoading ()
specifier|public
name|boolean
name|isLoading
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isActive ()
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * References a soft value.    */
DECL|class|SoftValueReference
specifier|static
class|class
name|SoftValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|SoftValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry)
name|SoftValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|notifyNewValue (V newValue)
specifier|public
name|void
name|notifyNewValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isLoading ()
specifier|public
name|boolean
name|isLoading
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isActive ()
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * References a strong value.    */
DECL|class|StrongValueReference
specifier|static
class|class
name|StrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|referent
specifier|final
name|V
name|referent
decl_stmt|;
DECL|method|StrongValueReference (V referent)
name|StrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|)
block|{
name|this
operator|.
name|referent
operator|=
name|referent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|referent
return|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|isLoading ()
specifier|public
name|boolean
name|isLoading
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isActive ()
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|notifyNewValue (V newValue)
specifier|public
name|void
name|notifyNewValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{}
block|}
comment|/**    * References a weak value.    */
DECL|class|WeightedWeakValueReference
specifier|static
specifier|final
class|class
name|WeightedWeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|weight
specifier|final
name|int
name|weight
decl_stmt|;
DECL|method|WeightedWeakValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry, int weight)
name|WeightedWeakValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|referent
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
name|weight
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeightedWeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|,
name|weight
argument_list|)
return|;
block|}
block|}
comment|/**    * References a soft value.    */
DECL|class|WeightedSoftValueReference
specifier|static
specifier|final
class|class
name|WeightedSoftValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|weight
specifier|final
name|int
name|weight
decl_stmt|;
DECL|method|WeightedSoftValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry, int weight)
name|WeightedSoftValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|referent
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
name|weight
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeightedSoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|,
name|weight
argument_list|)
return|;
block|}
block|}
comment|/**    * References a strong value.    */
DECL|class|WeightedStrongValueReference
specifier|static
specifier|final
class|class
name|WeightedStrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|weight
specifier|final
name|int
name|weight
decl_stmt|;
DECL|method|WeightedStrongValueReference (V referent, int weight)
name|WeightedStrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|)
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
name|weight
return|;
block|}
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends against poor quality    * hash functions. This is critical when the concurrent hash map uses power-of-two length hash    * tables, that otherwise encounter collisions for hash codes that do not differ in lower or    * upper bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
comment|// TODO(kevinb): use Hashing/move this to Hashing?
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.    */
annotation|@
name|VisibleForTesting
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|segmentFor
argument_list|(
name|hash
argument_list|)
decl_stmt|;
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|segment
operator|.
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
finally|finally
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|int
name|hash
init|=
name|original
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|copyEntry
argument_list|(
name|original
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#setValue} instead.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|newValueReference (ReferenceEntry<K, V> entry, V value, int weight)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|segmentFor
argument_list|(
name|hash
argument_list|)
argument_list|,
name|entry
argument_list|,
name|checkNotNull
argument_list|(
name|value
argument_list|)
argument_list|,
name|weight
argument_list|)
return|;
block|}
DECL|method|hash (@ullable Object key)
name|int
name|hash
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|keyEquivalence
operator|.
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|method|reclaimValue (ValueReference<K, V> valueReference)
name|void
name|reclaimValue
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|valueReference
operator|.
name|getEntry
argument_list|()
decl_stmt|;
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|)
expr_stmt|;
block|}
DECL|method|reclaimKey (ReferenceEntry<K, V> entry)
name|void
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}    * instead.    */
annotation|@
name|VisibleForTesting
DECL|method|isLive (ReferenceEntry<K, V> entry, long now)
name|boolean
name|isLive
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|entry
operator|.
name|getHash
argument_list|()
argument_list|)
operator|.
name|getLiveValue
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the segment that should be used for a key with the given hash.    *    * @param hash the hash code for the key    * @return the segment    */
DECL|method|segmentFor (int hash)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// TODO(fry): Lazily create segments?
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
DECL|method|createSegment ( int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|createSegment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|long
name|maxSegmentWeight
parameter_list|,
name|StatsCounter
name|statsCounter
parameter_list|)
block|{
return|return
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentWeight
argument_list|,
name|statsCounter
argument_list|)
return|;
block|}
comment|/**    * Gets the value from an entry. Returns null if the entry is invalid, partially-collected,    * loading, or expired. Unlike {@link Segment#getLiveValue} this method does not attempt to    * cleanup stale entries. As such it should only be called outside of a segment context, such as    * during iteration.    */
annotation|@
name|Nullable
DECL|method|getLiveValue (ReferenceEntry<K, V> entry, long now)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isExpired
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|// expiration
comment|/**    * Returns true if the entry has expired.    */
DECL|method|isExpired (ReferenceEntry<K, V> entry, long now)
name|boolean
name|isExpired
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|expiresAfterAccess
argument_list|()
operator|&&
operator|(
name|now
operator|-
name|entry
operator|.
name|getAccessTime
argument_list|()
operator|>=
name|expireAfterAccessNanos
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|expiresAfterWrite
argument_list|()
operator|&&
operator|(
name|now
operator|-
name|entry
operator|.
name|getWriteTime
argument_list|()
operator|>=
name|expireAfterWriteNanos
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// queues
comment|// Guarded By Segment.this
DECL|method|connectAccessOrder (ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|connectAccessOrder
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|previous
operator|.
name|setNextInAccessQueue
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPreviousInAccessQueue
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|method|nullifyAccessOrder (ReferenceEntry<K, V> nulled)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|nullifyAccessOrder
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nulled
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
init|=
name|nullEntry
argument_list|()
decl_stmt|;
name|nulled
operator|.
name|setNextInAccessQueue
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
name|nulled
operator|.
name|setPreviousInAccessQueue
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|method|connectWriteOrder (ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|connectWriteOrder
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|previous
operator|.
name|setNextInWriteQueue
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPreviousInWriteQueue
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
comment|// Guarded By Segment.this
DECL|method|nullifyWriteOrder (ReferenceEntry<K, V> nulled)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|nullifyWriteOrder
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nulled
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
init|=
name|nullEntry
argument_list|()
decl_stmt|;
name|nulled
operator|.
name|setNextInWriteQueue
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
name|nulled
operator|.
name|setPreviousInWriteQueue
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
block|}
comment|/**    * Notifies listeners that an entry has been automatically removed due to expiration, eviction,    * or eligibility for garbage collection. This should be called every time expireEntries or    * evictEntry is called (once the lock is released).    */
DECL|method|processPendingNotifications ()
name|void
name|processPendingNotifications
parameter_list|()
block|{
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
decl_stmt|;
while|while
condition|(
operator|(
name|notification
operator|=
name|removalNotificationQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|removalListener
operator|.
name|onRemoval
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Exception thrown by removal listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
return|return
operator|new
name|Segment
index|[
name|ssize
index|]
return|;
block|}
comment|// Inner Classes
comment|/**    * Segments are specialized versions of hash tables. This subclass inherits from ReentrantLock    * opportunistically, just to simplify some locking and avoid separate construction.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ReentrantLock
block|{
comment|/*      * TODO(fry): Consider copying variables (like evictsBySize) from outer class into this class.      * It will require more memory but will reduce indirection.      */
comment|/*      * Segments maintain a table of entry lists that are ALWAYS kept in a consistent state, so can      * be read without locking. Next fields of nodes are immutable (final). All list additions are      * performed at the front of each bin. This makes it easy to check changes, and also fast to      * traverse. When nodes would otherwise be changed, new nodes are created to replace them. This      * works well for hash tables since the bin lists tend to be short. (The average length is less      * than two.)      *      * Read operations can thus proceed without locking, but rely on selected uses of volatiles to      * ensure that completed write operations performed by other threads are noticed. For most      * purposes, the "count" field, tracking the number of elements, serves as that volatile      * variable ensuring visibility. This is convenient because this field needs to be read in many      * read operations anyway:      *      * - All (unsynchronized) read operations must first read the "count" field, and should not      * look at table entries if it is 0.      *      * - All (synchronized) write operations should write to the "count" field after structurally      * changing any bin. The operations must not take any action that could even momentarily      * cause a concurrent read operation to see inconsistent data. This is made easier by the      * nature of the read operations in Map. For example, no operation can reveal that the table      * has grown but the threshold has not yet been updated, so there are no atomicity requirements      * for this with respect to reads.      *      * As a guide, all critical volatile reads and writes to the count field are marked in code      * comments.      */
DECL|field|map
specifier|final
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
comment|/**      * The number of live elements in this segment's region.      */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**      * The weight of the live elements in this segment's region.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|field|totalWeight
name|long
name|totalWeight
decl_stmt|;
comment|/**      * Number of updates that alter the size of the table. This is used during bulk-read methods to      * make sure they see a consistent snapshot: If modCounts change during a traversal of segments      * loading size or checking containsValue, then we might have an inconsistent view of state      * so (usually) must retry.      */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**      * The table is expanded when its size exceeds this threshold. (The value of this field is      * always {@code (int) (capacity * 0.75)}.)      */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**      * The per-segment table.      */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
decl_stmt|;
comment|/**      * The maximum weight of this segment. UNSET_INT if there is no maximum.      */
DECL|field|maxSegmentWeight
specifier|final
name|long
name|maxSegmentWeight
decl_stmt|;
comment|/**      * The key reference queue contains entries whose keys have been garbage collected, and which      * need to be cleaned up internally.      */
DECL|field|keyReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|keyReferenceQueue
decl_stmt|;
comment|/**      * The value reference queue contains value references whose values have been garbage collected,      * and which need to be cleaned up internally.      */
DECL|field|valueReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|valueReferenceQueue
decl_stmt|;
comment|/**      * The recency queue is used to record which entries were accessed for updating the access      * list's ordering. It is drained as a batch operation when either the DRAIN_THRESHOLD is      * crossed or a write occurs on the segment.      */
DECL|field|recencyQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|recencyQueue
decl_stmt|;
comment|/**      * A counter of the number of reads since the last write, used to drain queues on a small      * fraction of read operations.      */
DECL|field|readCount
specifier|final
name|AtomicInteger
name|readCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * A queue of elements currently in the map, ordered by write time. Elements are added to the      * tail of the queue on write.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|field|writeQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|writeQueue
decl_stmt|;
comment|/**      * A queue of elements currently in the map, ordered by access time. Elements are added to the      * tail of the queue on access (note that writes count as accesses).      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|field|accessQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|accessQueue
decl_stmt|;
comment|/** Accumulates cache statistics. */
DECL|field|statsCounter
specifier|final
name|StatsCounter
name|statsCounter
decl_stmt|;
DECL|method|Segment (LocalCache<K, V> map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter)
name|Segment
parameter_list|(
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|long
name|maxSegmentWeight
parameter_list|,
name|StatsCounter
name|statsCounter
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|maxSegmentWeight
operator|=
name|maxSegmentWeight
expr_stmt|;
name|this
operator|.
name|statsCounter
operator|=
name|checkNotNull
argument_list|(
name|statsCounter
argument_list|)
expr_stmt|;
name|initTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
name|keyReferenceQueue
operator|=
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
name|valueReferenceQueue
operator|=
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
name|recencyQueue
operator|=
name|map
operator|.
name|usesAccessQueue
argument_list|()
condition|?
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
else|:
name|LocalCache
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
name|writeQueue
operator|=
name|map
operator|.
name|usesWriteQueue
argument_list|()
condition|?
operator|new
name|WriteQueue
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
else|:
name|LocalCache
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
name|accessQueue
operator|=
name|map
operator|.
name|usesAccessQueue
argument_list|()
condition|?
operator|new
name|AccessQueue
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
else|:
name|LocalCache
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
DECL|method|initTable (AtomicReferenceArray<ReferenceEntry<K, V>> newTable)
name|void
name|initTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
comment|// 0.75
if|if
condition|(
operator|!
name|map
operator|.
name|customWeigher
argument_list|()
operator|&&
name|this
operator|.
name|threshold
operator|==
name|maxSegmentWeight
condition|)
block|{
comment|// prevent spurious expansion before eviction
name|this
operator|.
name|threshold
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|map
operator|.
name|entryFactory
operator|.
name|newEntry
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|key
argument_list|)
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/**      * Copies {@code original} into a new entry chained to {@code newNext}. Returns the new entry,      * or {@code null} if {@code original} was already garbage collected.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|original
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// key collected
return|return
literal|null
return|;
block|}
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|original
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
literal|null
operator|)
operator|&&
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|// value collected
return|return
literal|null
return|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|map
operator|.
name|entryFactory
operator|.
name|copyEntry
argument_list|(
name|this
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|copyFor
argument_list|(
name|this
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
comment|/**      * Sets a new value of an entry. Adds newly created entries at the end of the access queue.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|setValue (ReferenceEntry<K, V> entry, K key, V value, long now)
name|void
name|setValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|int
name|weight
init|=
name|map
operator|.
name|weigher
operator|.
name|weigh
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|checkState
argument_list|(
name|weight
operator|>=
literal|0
argument_list|,
literal|"Weights must be non-negative"
argument_list|)
expr_stmt|;
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|map
operator|.
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|this
argument_list|,
name|entry
argument_list|,
name|value
argument_list|,
name|weight
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setValueReference
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
name|recordWrite
argument_list|(
name|entry
argument_list|,
name|weight
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|previous
operator|.
name|notifyNewValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|// loading
DECL|method|get (K key, int hash, CacheLoader<? super K, V> loader)
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|loader
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
comment|// don't call getLiveEntry, which would ignore loading values
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getLiveValue
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|recordRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|statsCounter
operator|.
name|recordHits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|scheduleRefresh
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|now
argument_list|,
name|loader
argument_list|)
return|;
block|}
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueReference
operator|.
name|isLoading
argument_list|()
condition|)
block|{
return|return
name|waitForLoadingValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|valueReference
argument_list|)
return|;
block|}
block|}
block|}
comment|// at this point e is either null or expired;
return|return
name|lockedGetOrLoad
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ee
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|ee
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|new
name|ExecutionError
argument_list|(
operator|(
name|Error
operator|)
name|cause
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
throw|throw
name|ee
throw|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|lockedGetOrLoad (K key, int hash, CacheLoader<? super K, V> loader)
name|V
name|lockedGetOrLoad
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
literal|null
decl_stmt|;
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
init|=
literal|null
decl_stmt|;
name|boolean
name|createNewEntry
init|=
literal|true
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// re-read ticker once inside the lock
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|valueReference
operator|=
name|e
operator|.
name|getValueReference
argument_list|()
expr_stmt|;
if|if
condition|(
name|valueReference
operator|.
name|isLoading
argument_list|()
condition|)
block|{
name|createNewEntry
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|V
name|value
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
condition|)
block|{
comment|// This is a duplicate check, as preWriteCleanup already purged expired
comment|// entries, but let's accomodate an incorrect expiration queue.
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|EXPIRED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|recordLockedRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|statsCounter
operator|.
name|recordHits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we were concurrent with loading; don't consider refresh
return|return
name|value
return|;
block|}
comment|// immediately reuse invalid entries
name|writeQueue
operator|.
name|remove
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|accessQueue
operator|.
name|remove
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
break|break;
block|}
block|}
if|if
condition|(
name|createNewEntry
condition|)
block|{
name|loadingValueReference
operator|=
operator|new
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|e
operator|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|e
operator|.
name|setValueReference
argument_list|(
name|loadingValueReference
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|.
name|setValueReference
argument_list|(
name|loadingValueReference
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|createNewEntry
condition|)
block|{
try|try
block|{
comment|// Synchronizes on the entry to allow failing fast when a recursive load is
comment|// detected. This may be circumvented when an entry is copied, but will fail fast most
comment|// of the time.
synchronized|synchronized
init|(
name|e
init|)
block|{
return|return
name|loadSync
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|,
name|loader
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|statsCounter
operator|.
name|recordMisses
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The entry already exists. Wait for loading.
return|return
name|waitForLoadingValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|valueReference
argument_list|)
return|;
block|}
block|}
DECL|method|waitForLoadingValue (ReferenceEntry<K, V> e, K key, ValueReference<K, V> valueReference)
name|V
name|waitForLoadingValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|,
name|K
name|key
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
throws|throws
name|ExecutionException
block|{
if|if
condition|(
operator|!
name|valueReference
operator|.
name|isLoading
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
name|checkState
argument_list|(
operator|!
name|Thread
operator|.
name|holdsLock
argument_list|(
name|e
argument_list|)
argument_list|,
literal|"Recursive load of: %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// don't consider expiration as we're concurrent with loading
try|try
block|{
name|V
name|value
init|=
name|valueReference
operator|.
name|waitForValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidCacheLoadException
argument_list|(
literal|"CacheLoader returned null for key "
operator|+
name|key
operator|+
literal|"."
argument_list|)
throw|;
block|}
comment|// re-read ticker now that loading has completed
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|recordRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
finally|finally
block|{
name|statsCounter
operator|.
name|recordMisses
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at most one of loadSync/loadAsync may be called for any given LoadingValueReference
DECL|method|loadSync (K key, int hash, LoadingValueReference<K, V> loadingValueReference, CacheLoader<? super K, V> loader)
name|V
name|loadSync
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|loadingFuture
init|=
name|loadingValueReference
operator|.
name|loadFuture
argument_list|(
name|key
argument_list|,
name|loader
argument_list|)
decl_stmt|;
return|return
name|getAndRecordStats
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|,
name|loadingFuture
argument_list|)
return|;
block|}
DECL|method|loadAsync (final K key, final int hash, final LoadingValueReference<K, V> loadingValueReference, CacheLoader<? super K, V> loader)
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|loadAsync
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|int
name|hash
parameter_list|,
specifier|final
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
specifier|final
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|loadingFuture
init|=
name|loadingValueReference
operator|.
name|loadFuture
argument_list|(
name|key
argument_list|,
name|loader
argument_list|)
decl_stmt|;
name|loadingFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|V
name|newValue
init|=
name|getAndRecordStats
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|,
name|loadingFuture
argument_list|)
decl_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Exception thrown during refresh"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|loadingValueReference
operator|.
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|sameThreadExecutor
argument_list|)
expr_stmt|;
return|return
name|loadingFuture
return|;
block|}
comment|/**      * Waits uninterruptibly for {@code newValue} to be loaded, and then records loading stats.      */
DECL|method|getAndRecordStats (K key, int hash, LoadingValueReference<K, V> loadingValueReference, ListenableFuture<V> newValue)
name|V
name|getAndRecordStats
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
parameter_list|,
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|newValue
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|V
name|value
init|=
literal|null
decl_stmt|;
try|try
block|{
name|value
operator|=
name|getUninterruptibly
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidCacheLoadException
argument_list|(
literal|"CacheLoader returned null for key "
operator|+
name|key
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|statsCounter
operator|.
name|recordLoadSuccess
argument_list|(
name|loadingValueReference
operator|.
name|elapsedNanos
argument_list|()
argument_list|)
expr_stmt|;
name|storeLoadedValue
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|statsCounter
operator|.
name|recordLoadException
argument_list|(
name|loadingValueReference
operator|.
name|elapsedNanos
argument_list|()
argument_list|)
expr_stmt|;
name|removeLoadingValue
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|scheduleRefresh (ReferenceEntry<K, V> entry, K key, int hash, V oldValue, long now, CacheLoader<? super K, V> loader)
name|V
name|scheduleRefresh
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|long
name|now
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|refreshes
argument_list|()
operator|&&
operator|(
name|now
operator|-
name|entry
operator|.
name|getWriteTime
argument_list|()
operator|>
name|map
operator|.
name|refreshNanos
operator|)
operator|&&
operator|!
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|isLoading
argument_list|()
condition|)
block|{
name|V
name|newValue
init|=
name|refresh
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|newValue
operator|!=
literal|null
condition|)
block|{
return|return
name|newValue
return|;
block|}
block|}
return|return
name|oldValue
return|;
block|}
comment|/**      * Refreshes the value associated with {@code key}, unless another thread is already doing so.      * Returns the newly refreshed value associated with {@code key} if it was refreshed inline, or      * {@code null} if another thread is performing the refresh or if an error occurs during      * refresh.      */
annotation|@
name|Nullable
DECL|method|refresh (K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime)
name|V
name|refresh
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|,
name|boolean
name|checkTime
parameter_list|)
block|{
specifier|final
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
init|=
name|insertLoadingValueReference
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|checkTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|loadingValueReference
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|result
init|=
name|loadAsync
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loadingValueReference
argument_list|,
name|loader
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isDone
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|Uninterruptibles
operator|.
name|getUninterruptibly
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// don't let refresh exceptions propagate; error was already logged
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns a newly inserted {@code LoadingValueReference}, or null if the live value reference      * is already loading.      */
annotation|@
name|Nullable
DECL|method|insertLoadingValueReference (final K key, final int hash, boolean checkTime)
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|insertLoadingValueReference
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|int
name|hash
parameter_list|,
name|boolean
name|checkTime
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
literal|null
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|e
operator|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueReference
operator|.
name|isLoading
argument_list|()
operator|||
operator|(
name|checkTime
operator|&&
operator|(
name|now
operator|-
name|e
operator|.
name|getWriteTime
argument_list|()
operator|<
name|map
operator|.
name|refreshNanos
operator|)
operator|)
condition|)
block|{
comment|// refresh is a no-op if loading is pending
comment|// if checkTime, we want to check *after* acquiring the lock if refresh still needs
comment|// to be scheduled
return|return
literal|null
return|;
block|}
comment|// continue returning old value while loading
operator|++
name|modCount
expr_stmt|;
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
init|=
operator|new
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|valueReference
argument_list|)
decl_stmt|;
name|e
operator|.
name|setValueReference
argument_list|(
name|loadingValueReference
argument_list|)
expr_stmt|;
return|return
name|loadingValueReference
return|;
block|}
block|}
operator|++
name|modCount
expr_stmt|;
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadingValueReference
init|=
operator|new
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
name|e
operator|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|e
operator|.
name|setValueReference
argument_list|(
name|loadingValueReference
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|loadingValueReference
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|// reference queues, for garbage collection cleanup
comment|/**      * Cleanup collected entries when the lock is available.      */
DECL|method|tryDrainReferenceQueues ()
name|void
name|tryDrainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Drain the key and value reference queues, cleaning up internal entries containing garbage      * collected keys or values.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainReferenceQueues ()
name|void
name|drainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|drainKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|drainValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainKeyReferenceQueue ()
name|void
name|drainKeyReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainValueReferenceQueue ()
name|void
name|drainValueReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimValue
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/**      * Clears all entries from the key and value reference queues.      */
DECL|method|clearReferenceQueues ()
name|void
name|clearReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|clearKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|clearValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clearKeyReferenceQueue ()
name|void
name|clearKeyReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
DECL|method|clearValueReferenceQueue ()
name|void
name|clearValueReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
comment|// recency queue, shared by expiration and eviction
comment|/**      * Records the relative order in which this read was performed by adding {@code entry} to the      * recency queue. At write-time, or when the queue is full past the threshold, the queue will      * be drained and the entries therein processed.      *      *<p>Note: locked reads should use {@link #recordLockedRead}.      */
DECL|method|recordRead (ReferenceEntry<K, V> entry, long now)
name|void
name|recordRead
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|recordsAccess
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setAccessTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|recencyQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Updates the eviction metadata that {@code entry} was just read. This currently amounts to      * adding {@code entry} to relevant eviction lists.      *      *<p>Note: this method should only be called under lock, as it directly manipulates the      * eviction queues. Unlocked reads should use {@link #recordRead}.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|recordLockedRead (ReferenceEntry<K, V> entry, long now)
name|void
name|recordLockedRead
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|recordsAccess
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setAccessTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|accessQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Updates eviction metadata that {@code entry} was just written. This currently amounts to      * adding {@code entry} to relevant eviction lists.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|recordWrite (ReferenceEntry<K, V> entry, int weight, long now)
name|void
name|recordWrite
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|weight
parameter_list|,
name|long
name|now
parameter_list|)
block|{
comment|// we are already under lock, so drain the recency queue immediately
name|drainRecencyQueue
argument_list|()
expr_stmt|;
name|totalWeight
operator|+=
name|weight
expr_stmt|;
if|if
condition|(
name|map
operator|.
name|recordsAccess
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setAccessTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|recordsWrite
argument_list|()
condition|)
block|{
name|entry
operator|.
name|setWriteTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|accessQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|writeQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Drains the recency queue, updating eviction metadata that the entries therein were read in      * the specified relative order. This currently amounts to adding them to relevant eviction      * lists (accounting for the fact that they could have been removed from the map since being      * added to the recency queue).      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainRecencyQueue ()
name|void
name|drainRecencyQueue
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|recencyQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// An entry may be in the recency queue despite it being removed from
comment|// the map . This can occur when the entry was concurrently read while a
comment|// writer is removing it from the segment or after a clear has removed
comment|// all of the segment's entries.
if|if
condition|(
name|accessQueue
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|accessQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// expiration
comment|/**      * Cleanup expired entries when the lock is available.      */
DECL|method|tryExpireEntries (long now)
name|void
name|tryExpireEntries
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|expireEntries
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
comment|// don't call postWriteCleanup as we're in a read
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|expireEntries (long now)
name|void
name|expireEntries
parameter_list|(
name|long
name|now
parameter_list|)
block|{
name|drainRecencyQueue
argument_list|()
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|writeQueue
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|removeEntry
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getHash
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|EXPIRED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
while|while
condition|(
operator|(
name|e
operator|=
name|accessQueue
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|removeEntry
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getHash
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|EXPIRED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
comment|// eviction
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|enqueueNotification (ReferenceEntry<K, V> entry, RemovalCause cause)
name|void
name|enqueueNotification
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|enqueueNotification
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getHash
argument_list|()
argument_list|,
name|entry
operator|.
name|getValueReference
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|enqueueNotification (@ullable K key, int hash, ValueReference<K, V> valueReference, RemovalCause cause)
name|void
name|enqueueNotification
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|totalWeight
operator|-=
name|valueReference
operator|.
name|getWeight
argument_list|()
expr_stmt|;
if|if
condition|(
name|cause
operator|.
name|wasEvicted
argument_list|()
condition|)
block|{
name|statsCounter
operator|.
name|recordEviction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|removalNotificationQueue
operator|!=
name|DISCARDING_QUEUE
condition|)
block|{
name|V
name|value
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
init|=
operator|new
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|cause
argument_list|)
decl_stmt|;
name|map
operator|.
name|removalNotificationQueue
operator|.
name|offer
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Performs eviction if the segment is full. This should only be called prior to adding a new      * entry and increasing {@code count}.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|evictEntries ()
name|void
name|evictEntries
parameter_list|()
block|{
if|if
condition|(
operator|!
name|map
operator|.
name|evictsBySize
argument_list|()
condition|)
block|{
return|return;
block|}
name|drainRecencyQueue
argument_list|()
expr_stmt|;
while|while
condition|(
name|totalWeight
operator|>
name|maxSegmentWeight
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getNextEvictable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|removeEntry
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getHash
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|SIZE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
comment|// TODO(fry): instead implement this with an eviction head
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|getNextEvictable ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
range|:
name|accessQueue
control|)
block|{
name|int
name|weight
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|getWeight
argument_list|()
decl_stmt|;
if|if
condition|(
name|weight
operator|>
literal|0
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**      * Returns first entry of bin for given hash.      */
DECL|method|getFirst (int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// read this volatile field only once
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|// Specialized implementations of map methods
annotation|@
name|Nullable
DECL|method|getEntry (Object key, int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Nullable
DECL|method|getLiveEntry (Object key, int hash, long now)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getLiveEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|tryExpireEntries
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|e
return|;
block|}
comment|/**      * Gets the value from an entry. Returns null if the entry is invalid, partially-collected,      * loading, or expired.      */
DECL|method|getLiveValue (ReferenceEntry<K, V> entry, long now)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|map
operator|.
name|isExpired
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|tryExpireEntries
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
annotation|@
name|Nullable
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|recordRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
name|scheduleRefresh
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|now
argument_list|,
name|map
operator|.
name|defaultLoader
argument_list|)
return|;
block|}
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method is a convenience for testing. Code should call {@link      * LocalCache#containsValue} directly.      */
annotation|@
name|VisibleForTesting
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|entryValue
init|=
name|getLiveValue
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Nullable
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
if|if
condition|(
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
expr_stmt|;
comment|// count remains unchanged
block|}
else|else
block|{
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
name|evictEntries
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|onlyIfAbsent
condition|)
block|{
comment|// Mimic
comment|// "if (!map.containsKey(key)) ...
comment|// else return map.get(key);
name|recordLockedRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
else|else
block|{
comment|// clobber existing entry, count remains unchanged
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|evictEntries
argument_list|()
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
name|evictEntries
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Expands the table if possible.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*        * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the        * elements from each bin must either stay at same index, or move with a power of two offset.        * We eliminate unnecessary node creation by catching cases where old nodes can be reused        * because their next fields won't change. Statistically, at the default threshold, only        * about one-sixth of them need cloning when a table doubles. The nodes they replace will be        * garbage collectable as soon as they are no longer referenced by any reader thread that may        * be in the midst of traversing table right now.        */
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
operator|++
name|oldIndex
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|int
name|headIndex
init|=
name|head
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|next
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFirst
operator|!=
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeCollectedEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|newCount
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected.
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|oldValue
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|newValue
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|evictEntries
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Mimic
comment|// "if (map.containsKey(key)&& map.get(key).equals(oldValue))..."
name|recordLockedRead
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Nullable
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected.
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|newValue
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|evictEntries
argument_list|()
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Nullable
DECL|method|remove (Object key, int hash)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|RemovalCause
name|cause
decl_stmt|;
if|if
condition|(
name|entryValue
operator|!=
literal|null
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|EXPLICIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|COLLECTED
expr_stmt|;
block|}
else|else
block|{
comment|// currently loading
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|cause
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|storeLoadedValue (K key, int hash, LoadingValueReference<K, V> oldValueReference, V newValue)
name|boolean
name|storeLoadedValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|oldValueReference
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// replace the old LoadingValueReference if it's live, otherwise
comment|// perform a putIfAbsent
if|if
condition|(
name|oldValueReference
operator|==
name|valueReference
operator|||
operator|(
name|entryValue
operator|==
literal|null
operator|&&
name|valueReference
operator|!=
name|UNSET
operator|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
if|if
condition|(
name|oldValueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|RemovalCause
name|cause
init|=
operator|(
name|entryValue
operator|==
literal|null
operator|)
condition|?
name|RemovalCause
operator|.
name|COLLECTED
else|:
name|RemovalCause
operator|.
name|REPLACED
decl_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValueReference
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|newCount
operator|--
expr_stmt|;
block|}
name|setValue
argument_list|(
name|e
argument_list|,
name|key
argument_list|,
name|newValue
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
name|evictEntries
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// the loaded value was already clobbered
name|valueReference
operator|=
operator|new
name|WeightedStrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|newValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|key
argument_list|,
name|newValue
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
name|evictEntries
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|preWriteCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|RemovalCause
name|cause
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|EXPLICIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entryValue
operator|==
literal|null
operator|&&
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|COLLECTED
expr_stmt|;
block|}
else|else
block|{
comment|// currently loading
return|return
literal|false
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|cause
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
operator|(
name|cause
operator|==
name|RemovalCause
operator|.
name|EXPLICIT
operator|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
comment|// Loading references aren't actually in the map yet.
if|if
condition|(
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|enqueueNotification
argument_list|(
name|e
argument_list|,
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|clearReferenceQueues
argument_list|()
expr_stmt|;
name|writeQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|accessQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
annotation|@
name|Nullable
DECL|method|removeValueFromChain (ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry, @Nullable K key, int hash, ValueReference<K, V> valueReference, RemovalCause cause)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeValueFromChain
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|writeQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|accessQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueReference
operator|.
name|isLoading
argument_list|()
condition|)
block|{
name|valueReference
operator|.
name|notifyNewValue
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
else|else
block|{
return|return
name|removeEntryFromChain
argument_list|(
name|first
argument_list|,
name|entry
argument_list|)
return|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
annotation|@
name|Nullable
DECL|method|removeEntryFromChain (ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeEntryFromChain
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|entry
operator|.
name|getNext
argument_list|()
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
name|entry
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newFirst
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|removeCollectedEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|newCount
operator|--
expr_stmt|;
block|}
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
return|return
name|newFirst
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeCollectedEntry (ReferenceEntry<K, V> entry)
name|void
name|removeCollectedEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|enqueueNotification
argument_list|(
name|entry
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|writeQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|accessQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes an entry whose key has been garbage collected.      */
DECL|method|reclaimKey (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|e
operator|.
name|getValueReference
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Removes an entry whose value has been garbage collected.      */
DECL|method|reclaimValue (K key, int hash, ValueReference<K, V> valueReference)
name|boolean
name|reclaimValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|entryKey
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isHeldByCurrentThread
argument_list|()
condition|)
block|{
comment|// don't cleanup inside of put
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|removeLoadingValue (K key, int hash, LoadingValueReference<K, V> valueReference)
name|boolean
name|removeLoadingValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|LoadingValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
if|if
condition|(
name|valueReference
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|e
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|getOldValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeEntryFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeEntry (ReferenceEntry<K, V> entry, int hash, RemovalCause cause)
name|boolean
name|removeEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeValueFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|e
operator|.
name|getValueReference
argument_list|()
argument_list|,
name|cause
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Performs routine cleanup following a read. Normally cleanup happens during writes. If cleanup      * is not observed after a sufficient number of reads, try cleaning up from the read thread.      */
DECL|method|postReadCleanup ()
name|void
name|postReadCleanup
parameter_list|()
block|{
if|if
condition|(
operator|(
name|readCount
operator|.
name|incrementAndGet
argument_list|()
operator|&
name|DRAIN_THRESHOLD
operator|)
operator|==
literal|0
condition|)
block|{
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs routine cleanup prior to executing a write. This should be called every time a      * write thread acquires the segment lock, immediately after acquiring the lock.      *      *<p>Post-condition: expireEntries has been run.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|preWriteCleanup (long now)
name|void
name|preWriteCleanup
parameter_list|(
name|long
name|now
parameter_list|)
block|{
name|runLockedCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs routine cleanup following a write.      */
DECL|method|postWriteCleanup ()
name|void
name|postWriteCleanup
parameter_list|()
block|{
name|runUnlockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|cleanUp ()
name|void
name|cleanUp
parameter_list|()
block|{
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|runLockedCleanup
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|runUnlockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runLockedCleanup (long now)
name|void
name|runLockedCleanup
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
name|expireEntries
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|// calls drainRecencyQueue
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|runUnlockedCleanup ()
name|void
name|runUnlockedCleanup
parameter_list|()
block|{
comment|// locked cleanup may generate notifications we can send unlocked
if|if
condition|(
operator|!
name|isHeldByCurrentThread
argument_list|()
condition|)
block|{
name|map
operator|.
name|processPendingNotifications
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|LoadingValueReference
specifier|static
class|class
name|LoadingValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|oldValue
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|oldValue
decl_stmt|;
comment|// TODO(fry): rename get, then extend AbstractFuture instead of containing SettableFuture
DECL|field|futureValue
specifier|final
name|SettableFuture
argument_list|<
name|V
argument_list|>
name|futureValue
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|stopwatch
specifier|final
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
DECL|method|LoadingValueReference ()
specifier|public
name|LoadingValueReference
parameter_list|()
block|{
name|this
argument_list|(
name|LocalCache
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|unset
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|LoadingValueReference (ValueReference<K, V> oldValue)
specifier|public
name|LoadingValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|oldValue
parameter_list|)
block|{
name|this
operator|.
name|oldValue
operator|=
name|oldValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isLoading ()
specifier|public
name|boolean
name|isLoading
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|isActive ()
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|oldValue
operator|.
name|isActive
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getWeight ()
specifier|public
name|int
name|getWeight
parameter_list|()
block|{
return|return
name|oldValue
operator|.
name|getWeight
argument_list|()
return|;
block|}
DECL|method|set (@ullable V newValue)
specifier|public
name|boolean
name|set
parameter_list|(
annotation|@
name|Nullable
name|V
name|newValue
parameter_list|)
block|{
return|return
name|futureValue
operator|.
name|set
argument_list|(
name|newValue
argument_list|)
return|;
block|}
DECL|method|setException (Throwable t)
specifier|public
name|boolean
name|setException
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|futureValue
operator|.
name|setException
argument_list|(
name|t
argument_list|)
return|;
block|}
DECL|method|fullyFailedFuture (Throwable t)
specifier|private
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|fullyFailedFuture
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|Futures
operator|.
name|immediateFailedFuture
argument_list|(
name|t
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|notifyNewValue (@ullable V newValue)
specifier|public
name|void
name|notifyNewValue
parameter_list|(
annotation|@
name|Nullable
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|newValue
operator|!=
literal|null
condition|)
block|{
comment|// The pending load was clobbered by a manual write.
comment|// Unblock all pending gets, and have them return the new value.
name|set
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The pending load was removed. Delay notifications until loading completes.
name|oldValue
operator|=
name|unset
argument_list|()
expr_stmt|;
block|}
comment|// TODO(fry): could also cancel loading if we had a handle on its future
block|}
DECL|method|loadFuture (K key, CacheLoader<? super K, V> loader)
specifier|public
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|loadFuture
parameter_list|(
name|K
name|key
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|stopwatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|V
name|previousValue
init|=
name|oldValue
operator|.
name|get
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|previousValue
operator|==
literal|null
condition|)
block|{
name|V
name|newValue
init|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|set
argument_list|(
name|newValue
argument_list|)
condition|?
name|futureValue
else|:
name|Futures
operator|.
name|immediateFuture
argument_list|(
name|newValue
argument_list|)
return|;
block|}
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|newValue
init|=
name|loader
operator|.
name|reload
argument_list|(
name|key
argument_list|,
name|previousValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|newValue
operator|==
literal|null
condition|)
block|{
return|return
name|Futures
operator|.
name|immediateFuture
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|// To avoid a race, make sure the refreshed value is set into loadingValueReference
comment|// *before* returning newValue from the cache query.
return|return
name|Futures
operator|.
name|transform
argument_list|(
name|newValue
argument_list|,
operator|new
name|Function
argument_list|<
name|V
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|apply
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|LoadingValueReference
operator|.
name|this
operator|.
name|set
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
return|return
name|newValue
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
return|return
name|setException
argument_list|(
name|t
argument_list|)
condition|?
name|futureValue
else|:
name|fullyFailedFuture
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
DECL|method|elapsedNanos ()
specifier|public
name|long
name|elapsedNanos
parameter_list|()
block|{
return|return
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|NANOSECONDS
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
throws|throws
name|ExecutionException
block|{
return|return
name|getUninterruptibly
argument_list|(
name|futureValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|oldValue
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getOldValue ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getOldValue
parameter_list|()
block|{
return|return
name|oldValue
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
block|}
comment|// Queues
comment|/**    * A custom queue for managing eviction order. Note that this is tightly integrated with {@code    * ReferenceEntry}, upon which it relies to perform its linking.    *    *<p>Note that this entire implementation makes the assumption that all elements which are in    * the map are also in this queue, and that all elements not in the queue are not in the map.    *    *<p>The benefits of creating our own queue are that (1) we can replace elements in the middle    * of the queue as part of copyWriteEntry, and (2) the contains method is highly optimized    * for the current model.    */
DECL|class|WriteQueue
specifier|static
specifier|final
class|class
name|WriteQueue
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|head
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
operator|new
name|AbstractReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextWrite
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInWriteQueue
parameter_list|()
block|{
return|return
name|nextWrite
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextWrite
operator|=
name|next
expr_stmt|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousWrite
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInWriteQueue
parameter_list|()
block|{
return|return
name|previousWrite
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPreviousInWriteQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousWrite
operator|=
name|previous
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// implements Queue
annotation|@
name|Override
DECL|method|offer (ReferenceEntry<K, V> entry)
specifier|public
name|boolean
name|offer
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
comment|// unlink
name|connectWriteOrder
argument_list|(
name|entry
operator|.
name|getPreviousInWriteQueue
argument_list|()
argument_list|,
name|entry
operator|.
name|getNextInWriteQueue
argument_list|()
argument_list|)
expr_stmt|;
comment|// add to tail
name|connectWriteOrder
argument_list|(
name|head
operator|.
name|getPreviousInWriteQueue
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|connectWriteOrder
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|peek
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
annotation|@
name|Override
DECL|method|poll ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|poll
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|head
condition|)
block|{
return|return
literal|null
return|;
block|}
name|remove
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|e
operator|.
name|getPreviousInWriteQueue
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
name|connectWriteOrder
argument_list|(
name|previous
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nullifyWriteOrder
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
return|return
name|e
operator|.
name|getNextInWriteQueue
argument_list|()
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|head
operator|.
name|getNextInWriteQueue
argument_list|()
operator|==
name|head
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextInWriteQueue
argument_list|()
init|;
name|e
operator|!=
name|head
condition|;
name|e
operator|=
name|e
operator|.
name|getNextInWriteQueue
argument_list|()
control|)
block|{
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|head
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
name|nullifyWriteOrder
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|.
name|setNextInWriteQueue
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|.
name|setPreviousInWriteQueue
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractSequentialIterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|peek
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|computeNext
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|previous
operator|.
name|getNextInWriteQueue
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * A custom queue for managing access order. Note that this is tightly integrated with    * {@code ReferenceEntry}, upon which it reliese to perform its linking.    *    *<p>Note that this entire implementation makes the assumption that all elements which are in    * the map are also in this queue, and that all elements not in the queue are not in the map.    *    *<p>The benefits of creating our own queue are that (1) we can replace elements in the middle    * of the queue as part of copyWriteEntry, and (2) the contains method is highly optimized    * for the current model.    */
DECL|class|AccessQueue
specifier|static
specifier|final
class|class
name|AccessQueue
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|head
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
operator|new
name|AbstractReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setAccessTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextAccess
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextInAccessQueue
parameter_list|()
block|{
return|return
name|nextAccess
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextAccess
operator|=
name|next
expr_stmt|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousAccess
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousInAccessQueue
parameter_list|()
block|{
return|return
name|previousAccess
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPreviousInAccessQueue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousAccess
operator|=
name|previous
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// implements Queue
annotation|@
name|Override
DECL|method|offer (ReferenceEntry<K, V> entry)
specifier|public
name|boolean
name|offer
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
comment|// unlink
name|connectAccessOrder
argument_list|(
name|entry
operator|.
name|getPreviousInAccessQueue
argument_list|()
argument_list|,
name|entry
operator|.
name|getNextInAccessQueue
argument_list|()
argument_list|)
expr_stmt|;
comment|// add to tail
name|connectAccessOrder
argument_list|(
name|head
operator|.
name|getPreviousInAccessQueue
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|connectAccessOrder
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|peek
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
annotation|@
name|Override
DECL|method|poll ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|poll
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|head
condition|)
block|{
return|return
literal|null
return|;
block|}
name|remove
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|e
operator|.
name|getPreviousInAccessQueue
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
name|connectAccessOrder
argument_list|(
name|previous
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nullifyAccessOrder
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
return|return
name|e
operator|.
name|getNextInAccessQueue
argument_list|()
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|head
operator|.
name|getNextInAccessQueue
argument_list|()
operator|==
name|head
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextInAccessQueue
argument_list|()
init|;
name|e
operator|!=
name|head
condition|;
name|e
operator|=
name|e
operator|.
name|getNextInAccessQueue
argument_list|()
control|)
block|{
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|head
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
name|nullifyAccessOrder
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|.
name|setNextInAccessQueue
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|.
name|setPreviousInAccessQueue
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractSequentialIterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|peek
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|computeNext
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|previous
operator|.
name|getNextInAccessQueue
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
block|}
return|;
block|}
block|}
comment|// Cache support
DECL|method|cleanUp ()
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ConcurrentMap methods
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
comment|/*      * Sum per-segment modCounts to avoid mis-reporting when elements are concurrently added and      * removed in one segment while checking another, in which case the table was never actually      * empty at any point. (The sum ensures accuracy up through at least 1<<31 per-segment      * modifications before recheck.)  Method containsValue() uses similar constructions for      * stability checks.      */
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
comment|// recheck unless no modifications
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|-=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|longSize ()
name|long
name|longSize
parameter_list|()
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|longSize
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Nullable
DECL|method|getIfPresent (Object key)
specifier|public
name|V
name|getIfPresent
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|checkNotNull
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|V
name|value
init|=
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|globalStatsCounter
operator|.
name|recordMisses
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|globalStatsCounter
operator|.
name|recordHits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
DECL|method|get (K key, CacheLoader<? super K, V> loader)
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|checkNotNull
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|)
return|;
block|}
DECL|method|getOrLoad (K key)
name|V
name|getOrLoad
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
return|return
name|get
argument_list|(
name|key
argument_list|,
name|defaultLoader
argument_list|)
return|;
block|}
DECL|method|getAllPresent (Iterable<?> keys)
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAllPresent
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
name|int
name|hits
init|=
literal|0
decl_stmt|;
name|int
name|misses
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|key
range|:
name|keys
control|)
block|{
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|misses
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// TODO(fry): store entry key instead of query key
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|castKey
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|castKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|hits
operator|++
expr_stmt|;
block|}
block|}
name|globalStatsCounter
operator|.
name|recordHits
argument_list|(
name|hits
argument_list|)
expr_stmt|;
name|globalStatsCounter
operator|.
name|recordMisses
argument_list|(
name|misses
argument_list|)
expr_stmt|;
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|method|getAll (Iterable<? extends K> keys)
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hits
init|=
literal|0
decl_stmt|;
name|int
name|misses
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|K
argument_list|>
name|keysToLoad
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|K
name|key
range|:
name|keys
control|)
block|{
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|misses
operator|++
expr_stmt|;
name|keysToLoad
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hits
operator|++
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
if|if
condition|(
operator|!
name|keysToLoad
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntries
init|=
name|loadAll
argument_list|(
name|keysToLoad
argument_list|,
name|defaultLoader
argument_list|)
decl_stmt|;
for|for
control|(
name|K
name|key
range|:
name|keysToLoad
control|)
block|{
name|V
name|value
init|=
name|newEntries
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidCacheLoadException
argument_list|(
literal|"loadAll failed to return a value for "
operator|+
name|key
argument_list|)
throw|;
block|}
name|result
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedLoadingOperationException
name|e
parameter_list|)
block|{
comment|// loadAll not implemented, fallback to load
for|for
control|(
name|K
name|key
range|:
name|keysToLoad
control|)
block|{
name|misses
operator|--
expr_stmt|;
comment|// get will count this miss
name|result
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|get
argument_list|(
name|key
argument_list|,
name|defaultLoader
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|result
argument_list|)
return|;
block|}
finally|finally
block|{
name|globalStatsCounter
operator|.
name|recordHits
argument_list|(
name|hits
argument_list|)
expr_stmt|;
name|globalStatsCounter
operator|.
name|recordMisses
argument_list|(
name|misses
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the result of calling {@link CacheLoader#loadAll}, or null if {@code loader} doesn't    * implement {@code loadAll}.    */
annotation|@
name|Nullable
DECL|method|loadAll (Set<? extends K> keys, CacheLoader<? super K, V> loader)
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loadAll
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|checkNotNull
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|keys
argument_list|)
expr_stmt|;
name|Stopwatch
name|stopwatch
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe since all keys extend K
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|loader
operator|.
name|loadAll
argument_list|(
name|keys
argument_list|)
decl_stmt|;
name|result
operator|=
name|map
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedLoadingOperationException
name|e
parameter_list|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|globalStatsCounter
operator|.
name|recordLoadException
argument_list|(
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|NANOSECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|globalStatsCounter
operator|.
name|recordLoadException
argument_list|(
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|NANOSECONDS
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InvalidCacheLoadException
argument_list|(
name|loader
operator|+
literal|" returned null map from loadAll"
argument_list|)
throw|;
block|}
name|stopwatch
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// TODO(fry): batch by segment
name|boolean
name|nullsPresent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|result
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
block|{
comment|// delay failure until non-null entries are stored
name|nullsPresent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nullsPresent
condition|)
block|{
name|globalStatsCounter
operator|.
name|recordLoadException
argument_list|(
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|NANOSECONDS
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InvalidCacheLoadException
argument_list|(
name|loader
operator|+
literal|" returned null keys or values from loadAll"
argument_list|)
throw|;
block|}
comment|// TODO(fry): record count of loaded entries
name|globalStatsCounter
operator|.
name|recordLoadSuccess
argument_list|(
name|stopwatch
operator|.
name|elapsed
argument_list|(
name|NANOSECONDS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the internal entry for the specified key. The entry may be loading, expired, or    * partially collected.    */
DECL|method|getEntry (@ullable Object key)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
comment|// does not impact recency ordering
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|refresh (K key)
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|checkNotNull
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|refresh
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|defaultLoader
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
comment|// does not impact recency ordering
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
comment|// does not impact recency ordering
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// This implementation is patterned after ConcurrentHashMap, but without the locking. The only
comment|// way for it to return a false negative would be for the target value to jump around in the map
comment|// such that none of the subsequent iterations observed it, despite the fact that at every point
comment|// in time it was present somewhere int the map. This becomes increasingly unlikely as
comment|// CONTAINS_VALUE_RETRIES increases, though without locking it is theoretically possible.
name|long
name|now
init|=
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONTAINS_VALUE_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
comment|// ensure visibility of most recent completed write
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"UnusedDeclaration"
block|,
literal|"unused"
block|}
argument_list|)
name|int
name|c
init|=
name|segment
operator|.
name|count
decl_stmt|;
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|j
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|segment
operator|.
name|getLiveValue
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
name|sum
operator|+=
name|segment
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
name|last
condition|)
block|{
break|break;
block|}
name|last
operator|=
name|sum
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|invalidateAll (Iterable<?> keys)
name|void
name|invalidateAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
comment|// TODO(fry): batch by segment
for|for
control|(
name|Object
name|key
range|:
name|keys
control|)
block|{
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
comment|// does not impact recency ordering
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
comment|// does not impact recency ordering
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
annotation|@
name|GwtIncompatible
argument_list|(
literal|"Not supported."
argument_list|)
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
comment|// does not impact recency ordering
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|// Iterator Support
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentSegment
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|currentSegment
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
specifier|abstract
name|T
name|next
parameter_list|()
function_decl|;
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|currentSegment
operator|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|currentSegment
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|currentSegment
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Finds the next entry in the current chain. Returns true if an entry was found.      */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Finds the next entry in the current table. Returns true if an entry was found.      */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Advances to the given entry. Returns true if the entry was valid, false if it should be      * skipped.      */
DECL|method|advanceTo (ReferenceEntry<K, V> entry)
name|boolean
name|advanceTo
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
try|try
block|{
name|long
name|now
init|=
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getLiveValue
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip stale entry.
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|currentSegment
operator|.
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|lastReturned
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|LocalCache
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the    * underlying map.    */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
implements|implements
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|value
name|V
name|value
decl_stmt|;
comment|// non-null
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Cannot use key and value equivalence
if|if
condition|(
name|object
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|key
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Cannot use key and value equivalence
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (V newValue)
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Returns a string representation of the form<code>{key}={value}</code>.      */
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getKey
argument_list|()
operator|+
literal|"="
operator|+
name|getValue
argument_list|()
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
DECL|class|AbstractCacheSet
specifier|abstract
class|class
name|AbstractCacheSet
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|T
argument_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
decl_stmt|;
DECL|method|AbstractCacheSet (ConcurrentMap<?, ?> map)
name|AbstractCacheSet
parameter_list|(
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractCacheSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|KeySet (ConcurrentMap<?, ?> map)
name|KeySet
parameter_list|(
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
block|}
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|map
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
decl_stmt|;
DECL|method|Values (ConcurrentMap<?, ?> map)
name|Values
parameter_list|(
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractCacheSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntrySet (ConcurrentMap<?, ?> map)
name|EntrySet
parameter_list|(
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|LocalCache
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|LocalCache
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// Serialization Support
comment|/**    * Serializes the configuration of a LocalCache, reconsitituting it as a Cache using    * CacheBuilder upon deserialization. An instance of this class is fit for use by the writeReplace    * of LocalManualCache.    *    * Unfortunately, readResolve() doesn't get called when a circular dependency is present, so the    * proxy must be able to behave as the cache itself.    */
DECL|class|ManualSerializationProxy
specifier|static
class|class
name|ManualSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|expireAfterWriteNanos
specifier|final
name|long
name|expireAfterWriteNanos
decl_stmt|;
DECL|field|expireAfterAccessNanos
specifier|final
name|long
name|expireAfterAccessNanos
decl_stmt|;
DECL|field|maxWeight
specifier|final
name|long
name|maxWeight
decl_stmt|;
DECL|field|weigher
specifier|final
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
decl_stmt|;
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
DECL|field|removalListener
specifier|final
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|ticker
specifier|final
name|Ticker
name|ticker
decl_stmt|;
DECL|field|loader
specifier|final
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
decl_stmt|;
DECL|field|delegate
specifier|transient
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|ManualSerializationProxy (LocalCache<K, V> cache)
name|ManualSerializationProxy
parameter_list|(
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|)
block|{
name|this
argument_list|(
name|cache
operator|.
name|keyStrength
argument_list|,
name|cache
operator|.
name|valueStrength
argument_list|,
name|cache
operator|.
name|keyEquivalence
argument_list|,
name|cache
operator|.
name|valueEquivalence
argument_list|,
name|cache
operator|.
name|expireAfterWriteNanos
argument_list|,
name|cache
operator|.
name|expireAfterAccessNanos
argument_list|,
name|cache
operator|.
name|maxWeight
argument_list|,
name|cache
operator|.
name|weigher
argument_list|,
name|cache
operator|.
name|concurrencyLevel
argument_list|,
name|cache
operator|.
name|removalListener
argument_list|,
name|cache
operator|.
name|ticker
argument_list|,
name|cache
operator|.
name|defaultLoader
argument_list|)
expr_stmt|;
block|}
DECL|method|ManualSerializationProxy ( Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, long expireAfterWriteNanos, long expireAfterAccessNanos, long maxWeight, Weigher<K, V> weigher, int concurrencyLevel, RemovalListener<? super K, ? super V> removalListener, Ticker ticker, CacheLoader<? super K, V> loader)
specifier|private
name|ManualSerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|long
name|expireAfterWriteNanos
parameter_list|,
name|long
name|expireAfterAccessNanos
parameter_list|,
name|long
name|maxWeight
parameter_list|,
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
parameter_list|,
name|Ticker
name|ticker
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|valueStrength
expr_stmt|;
name|this
operator|.
name|keyEquivalence
operator|=
name|keyEquivalence
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|valueEquivalence
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|expireAfterWriteNanos
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|expireAfterAccessNanos
expr_stmt|;
name|this
operator|.
name|maxWeight
operator|=
name|maxWeight
expr_stmt|;
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
name|this
operator|.
name|removalListener
operator|=
name|removalListener
expr_stmt|;
name|this
operator|.
name|ticker
operator|=
operator|(
name|ticker
operator|==
name|Ticker
operator|.
name|systemTicker
argument_list|()
operator|||
name|ticker
operator|==
name|NULL_TICKER
operator|)
condition|?
literal|null
else|:
name|ticker
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
block|}
DECL|method|recreateCacheBuilder ()
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|recreateCacheBuilder
parameter_list|()
block|{
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|setValueStrength
argument_list|(
name|valueStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|keyEquivalence
argument_list|)
operator|.
name|valueEquivalence
argument_list|(
name|valueEquivalence
argument_list|)
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
operator|.
name|removalListener
argument_list|(
name|removalListener
argument_list|)
decl_stmt|;
name|builder
operator|.
name|strictParsing
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|expireAfterWriteNanos
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|expireAfterWrite
argument_list|(
name|expireAfterWriteNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|expireAfterAccess
argument_list|(
name|expireAfterAccessNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|weigher
operator|!=
name|OneWeigher
operator|.
name|INSTANCE
condition|)
block|{
name|builder
operator|.
name|weigher
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxWeight
operator|!=
name|UNSET_INT
condition|)
block|{
name|builder
operator|.
name|maximumWeight
argument_list|(
name|maxWeight
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|maxWeight
operator|!=
name|UNSET_INT
condition|)
block|{
name|builder
operator|.
name|maximumSize
argument_list|(
name|maxWeight
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ticker
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|ticker
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|recreateCacheBuilder
argument_list|()
decl_stmt|;
name|this
operator|.
name|delegate
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
comment|/**    * Serializes the configuration of a LocalCache, reconsitituting it as an LoadingCache using    * CacheBuilder upon deserialization. An instance of this class is fit for use by the writeReplace    * of LocalLoadingCache.    *    * Unfortunately, readResolve() doesn't get called when a circular dependency is present, so the    * proxy must be able to behave as the cache itself.    */
DECL|class|LoadingSerializationProxy
specifier|static
specifier|final
class|class
name|LoadingSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ManualSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|LoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
DECL|field|autoDelegate
specifier|transient
name|LoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|autoDelegate
decl_stmt|;
DECL|method|LoadingSerializationProxy (LocalCache<K, V> cache)
name|LoadingSerializationProxy
parameter_list|(
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|)
block|{
name|super
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|CacheBuilder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|recreateCacheBuilder
argument_list|()
decl_stmt|;
name|this
operator|.
name|autoDelegate
operator|=
name|builder
operator|.
name|build
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get (K key)
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
return|return
name|autoDelegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getUnchecked (K key)
specifier|public
name|V
name|getUnchecked
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|autoDelegate
operator|.
name|getUnchecked
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getAll (Iterable<? extends K> keys)
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|)
throws|throws
name|ExecutionException
block|{
return|return
name|autoDelegate
operator|.
name|getAll
argument_list|(
name|keys
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|apply (K key)
specifier|public
specifier|final
name|V
name|apply
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|autoDelegate
operator|.
name|apply
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|refresh (K key)
specifier|public
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|autoDelegate
operator|.
name|refresh
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|autoDelegate
return|;
block|}
block|}
DECL|class|LocalManualCache
specifier|static
class|class
name|LocalManualCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|localCache
specifier|final
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|localCache
decl_stmt|;
DECL|method|LocalManualCache (CacheBuilder<? super K, ? super V> builder)
name|LocalManualCache
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|builder
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|LocalManualCache (LocalCache<K, V> localCache)
specifier|private
name|LocalManualCache
parameter_list|(
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|localCache
parameter_list|)
block|{
name|this
operator|.
name|localCache
operator|=
name|localCache
expr_stmt|;
block|}
comment|// Cache methods
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|getIfPresent (Object key)
specifier|public
name|V
name|getIfPresent
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|localCache
operator|.
name|getIfPresent
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (K key, final Callable<? extends V> valueLoader)
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
specifier|final
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|checkNotNull
argument_list|(
name|valueLoader
argument_list|)
expr_stmt|;
return|return
name|localCache
operator|.
name|get
argument_list|(
name|key
argument_list|,
operator|new
name|CacheLoader
argument_list|<
name|Object
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|load
parameter_list|(
name|Object
name|key
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|valueLoader
operator|.
name|call
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getAllPresent (Iterable<?> keys)
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAllPresent
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
return|return
name|localCache
operator|.
name|getAllPresent
argument_list|(
name|keys
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|localCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|localCache
operator|.
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|invalidate (Object key)
specifier|public
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|localCache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|invalidateAll (Iterable<?> keys)
specifier|public
name|void
name|invalidateAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
name|localCache
operator|.
name|invalidateAll
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|invalidateAll ()
specifier|public
name|void
name|invalidateAll
parameter_list|()
block|{
name|localCache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|localCache
operator|.
name|longSize
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|asMap ()
specifier|public
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|()
block|{
return|return
name|localCache
return|;
block|}
annotation|@
name|Override
DECL|method|stats ()
specifier|public
name|CacheStats
name|stats
parameter_list|()
block|{
name|SimpleStatsCounter
name|aggregator
init|=
operator|new
name|SimpleStatsCounter
argument_list|()
decl_stmt|;
name|aggregator
operator|.
name|incrementBy
argument_list|(
name|localCache
operator|.
name|globalStatsCounter
argument_list|)
expr_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|localCache
operator|.
name|segments
control|)
block|{
name|aggregator
operator|.
name|incrementBy
argument_list|(
name|segment
operator|.
name|statsCounter
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregator
operator|.
name|snapshot
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|cleanUp ()
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
name|localCache
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
block|}
comment|// Serialization Support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|ManualSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|localCache
argument_list|)
return|;
block|}
block|}
DECL|class|LocalLoadingCache
specifier|static
class|class
name|LocalLoadingCache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|LocalManualCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|LoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|LocalLoadingCache (CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader)
name|LocalLoadingCache
parameter_list|(
name|CacheBuilder
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|builder
parameter_list|,
name|CacheLoader
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|builder
argument_list|,
name|checkNotNull
argument_list|(
name|loader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// LoadingCache methods
annotation|@
name|Override
DECL|method|get (K key)
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
return|return
name|localCache
operator|.
name|getOrLoad
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getUnchecked (K key)
specifier|public
name|V
name|getUnchecked
parameter_list|(
name|K
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getAll (Iterable<? extends K> keys)
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|)
throws|throws
name|ExecutionException
block|{
return|return
name|localCache
operator|.
name|getAll
argument_list|(
name|keys
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|refresh (K key)
specifier|public
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|localCache
operator|.
name|refresh
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|apply (K key)
specifier|public
specifier|final
name|V
name|apply
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|getUnchecked
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// Serialization Support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
annotation|@
name|Override
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|LoadingSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|localCache
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

