begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.eventbus
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|eventbus
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Queues
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_comment
comment|/**  * Handler for dispatching events to subscribers, providing different event ordering guarantees that  * make sense for different situations.  *  *<p><b>Note:</b> The dispatcher is orthogonal to the subscriber's {@code Executor}. The dispatcher  * controls the order in which events are dispatched, while the executor controls how (i.e. on which  * thread) the subscriber is actually called when an event is dispatched to it.  *  * @author Colin Decker  */
end_comment

begin_class
DECL|class|Dispatcher
specifier|abstract
class|class
name|Dispatcher
block|{
comment|/**    * Returns a dispatcher that queues events that are posted reentrantly on a thread that is already    * dispatching an event, guaranteeing that all events posted on a single thread are dispatched to    * all subscribers in the order they are posted.    *    *<p>When all subscribers are dispatched to using a<i>direct</i> executor (which dispatches on    * the same thread that posts the event), this yields a breadth-first dispatch order on each    * thread. That is, all subscribers to a single event A will be called before any subscribers to    * any events B and C that are posted to the event bus by the subscribers to A.    */
DECL|method|perThreadDispatchQueue ()
specifier|static
name|Dispatcher
name|perThreadDispatchQueue
parameter_list|()
block|{
return|return
operator|new
name|PerThreadQueuedDispatcher
argument_list|()
return|;
block|}
comment|/**    * Returns a dispatcher that queues events that are posted in a single global queue. This    * behavior matches the original behavior of AsyncEventBus exactly, but is otherwise not    * especially useful. For async dispatch, an {@linkplain #immediate() immediate} dispatcher    * should generally be preferable.    */
DECL|method|legacyAsync ()
specifier|static
name|Dispatcher
name|legacyAsync
parameter_list|()
block|{
return|return
operator|new
name|LegacyAsyncDispatcher
argument_list|()
return|;
block|}
comment|/**    * Returns a dispatcher that dispatches events to subscribers immediately as they're posted    * without using an intermediate queue to change the dispatch order. This is effectively a    * depth-first dispatch order, vs. breadth-first when using a queue.    */
DECL|method|immediate ()
specifier|static
name|Dispatcher
name|immediate
parameter_list|()
block|{
return|return
name|ImmediateDispatcher
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Dispatches the given {@code event} to the given {@code subscribers}.    */
DECL|method|dispatch (Object event, Iterator<Subscriber> subscribers)
specifier|abstract
name|void
name|dispatch
parameter_list|(
name|Object
name|event
parameter_list|,
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
parameter_list|)
function_decl|;
comment|/**    * Implementation of a {@link #perThreadDispatchQueue()} dispatcher.    */
DECL|class|PerThreadQueuedDispatcher
specifier|private
specifier|static
specifier|final
class|class
name|PerThreadQueuedDispatcher
extends|extends
name|Dispatcher
block|{
comment|// This dispatcher matches the original dispatch behavior of EventBus.
comment|/**      * Per-thread queue of events to dispatch.      */
DECL|field|queue
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Queue
argument_list|<
name|Event
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Queue
argument_list|<
name|Event
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Queue
argument_list|<
name|Event
argument_list|>
name|initialValue
parameter_list|()
block|{
return|return
name|Queues
operator|.
name|newArrayDeque
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Per-thread dispatch state, used to avoid reentrant event dispatching.      */
DECL|field|dispatching
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Boolean
argument_list|>
name|dispatching
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Boolean
name|initialValue
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|dispatch (Object event, Iterator<Subscriber> subscribers)
name|void
name|dispatch
parameter_list|(
name|Object
name|event
parameter_list|,
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|subscribers
argument_list|)
expr_stmt|;
name|Queue
argument_list|<
name|Event
argument_list|>
name|queueForThread
init|=
name|queue
operator|.
name|get
argument_list|()
decl_stmt|;
name|queueForThread
operator|.
name|offer
argument_list|(
operator|new
name|Event
argument_list|(
name|event
argument_list|,
name|subscribers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dispatching
operator|.
name|get
argument_list|()
condition|)
block|{
name|dispatching
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Event
name|nextEvent
decl_stmt|;
while|while
condition|(
operator|(
name|nextEvent
operator|=
name|queueForThread
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|nextEvent
operator|.
name|subscribers
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|nextEvent
operator|.
name|subscribers
operator|.
name|next
argument_list|()
operator|.
name|dispatchEvent
argument_list|(
name|nextEvent
operator|.
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|dispatching
operator|.
name|remove
argument_list|()
expr_stmt|;
name|queue
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|Event
specifier|private
specifier|static
specifier|final
class|class
name|Event
block|{
DECL|field|event
specifier|private
specifier|final
name|Object
name|event
decl_stmt|;
DECL|field|subscribers
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
decl_stmt|;
DECL|method|Event (Object event, Iterator<Subscriber> subscribers)
specifier|private
name|Event
parameter_list|(
name|Object
name|event
parameter_list|,
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
parameter_list|)
block|{
name|this
operator|.
name|event
operator|=
name|event
expr_stmt|;
name|this
operator|.
name|subscribers
operator|=
name|subscribers
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Implementation of a {@link #legacyAsync()} dispatcher.    */
DECL|class|LegacyAsyncDispatcher
specifier|private
specifier|static
specifier|final
class|class
name|LegacyAsyncDispatcher
extends|extends
name|Dispatcher
block|{
comment|// This dispatcher matches the original dispatch behavior of AsyncEventBus.
comment|//
comment|// We can't really make any guarantees about the overall dispatch order for this dispatcher in
comment|// a multithreaded environment for a couple reasons:
comment|//
comment|// 1. Subscribers to events posted on different threads can be interleaved with each other
comment|//    freely. (A event on one thread, B event on another could yield any of
comment|//    [a1, a2, a3, b1, b2], [a1, b2, a2, a3, b2], [a1, b2, b3, a2, a3], etc.)
comment|// 2. It's possible for subscribers to actually be dispatched to in a different order than they
comment|//    were added to the queue. It's easily possible for one thread to take the head of the
comment|//    queue, immediately followed by another thread taking the next element in the queue. That
comment|//    second thread can then dispatch to the subscriber it took before the first thread does.
comment|//
comment|// All this makes me really wonder if there's any value in queueing here at all. A dispatcher
comment|// that simply loops through the subscribers and dispatches the event to each would actually
comment|// probably provide a stronger order guarantee, though that order would obviously be different
comment|// in some cases.
comment|/**      * Global event queue.      */
DECL|field|queue
specifier|private
specifier|final
name|ConcurrentLinkedQueue
argument_list|<
name|EventWithSubscriber
argument_list|>
name|queue
init|=
name|Queues
operator|.
name|newConcurrentLinkedQueue
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|dispatch (Object event, Iterator<Subscriber> subscribers)
name|void
name|dispatch
parameter_list|(
name|Object
name|event
parameter_list|,
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|event
argument_list|)
expr_stmt|;
while|while
condition|(
name|subscribers
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
operator|new
name|EventWithSubscriber
argument_list|(
name|event
argument_list|,
name|subscribers
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|EventWithSubscriber
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|queue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|subscriber
operator|.
name|dispatchEvent
argument_list|(
name|e
operator|.
name|event
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|EventWithSubscriber
specifier|private
specifier|static
specifier|final
class|class
name|EventWithSubscriber
block|{
DECL|field|event
specifier|private
specifier|final
name|Object
name|event
decl_stmt|;
DECL|field|subscriber
specifier|private
specifier|final
name|Subscriber
name|subscriber
decl_stmt|;
DECL|method|EventWithSubscriber (Object event, Subscriber subscriber)
specifier|private
name|EventWithSubscriber
parameter_list|(
name|Object
name|event
parameter_list|,
name|Subscriber
name|subscriber
parameter_list|)
block|{
name|this
operator|.
name|event
operator|=
name|event
expr_stmt|;
name|this
operator|.
name|subscriber
operator|=
name|subscriber
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Implementation of {@link #immediate()}.    */
DECL|class|ImmediateDispatcher
specifier|private
specifier|static
specifier|final
class|class
name|ImmediateDispatcher
extends|extends
name|Dispatcher
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|ImmediateDispatcher
name|INSTANCE
init|=
operator|new
name|ImmediateDispatcher
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|dispatch (Object event, Iterator<Subscriber> subscribers)
name|void
name|dispatch
parameter_list|(
name|Object
name|event
parameter_list|,
name|Iterator
argument_list|<
name|Subscriber
argument_list|>
name|subscribers
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|event
argument_list|)
expr_stmt|;
while|while
condition|(
name|subscribers
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|subscribers
operator|.
name|next
argument_list|()
operator|.
name|dispatchEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

