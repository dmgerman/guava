begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|ThreadSafe
import|;
end_import

begin_comment
comment|/**  * The {@code CycleDetectingLockFactory} creates {@link ReentrantLock} instances and  * {@link ReentrantReadWriteLock} instances that detect potential deadlock by checking  * for cycles in lock acquisition order.  *<p>  * Potential deadlocks detected when calling the {@code lock()},  * {@code lockInterruptibly()}, or {@code tryLock()} methods will result in the  * execution of the {@link Policy} specified when creating the factory. The  * currently available policies are:  *<ul>  *<li>DISABLED  *<li>WARN  *<li>THROW  *</ul>  *<p>The locks created by a factory instance will detect lock acquisition cycles  * with locks created by other {@code CycleDetectingLockFactory} instances  * (except those with {@code Policy.DISABLED}). A lock's behavior when a cycle  * is detected, however, is defined by the {@code Policy} of the factory that  * created it. This allows detection of cycles across components while  * delegating control over lock behavior to individual components.  *<p>  * Applications are encouraged to use a {@code CycleDetectingLockFactory} to  * create any locks for which external/unmanaged code is executed while the lock  * is held. (See caveats under<strong>Performance</strong>).  *<p>  *<strong>Cycle Detection</strong>  *<p>  * Deadlocks can arise when locks are acquired in an order that forms a cycle.  * In a simple example involving two locks and two threads, deadlock occurs  * when one thread acquires Lock A, and then Lock B, while another thread  * acquires Lock B, and then Lock A:  *<pre>  * Thread1: acquire(LockA) --X acquire(LockB)  * Thread2: acquire(LockB) --X acquire(LockA)  *</pre>  *<p>Neither thread will progress because each is waiting for the other. In more  * complex applications, cycles can arise from interactions among more than 2  * locks:  *<pre>  * Thread1: acquire(LockA) --X acquire(LockB)  * Thread2: acquire(LockB) --X acquire(LockC)  * ...  * ThreadN: acquire(LockN) --X acquire(LockA)  *</pre>  *<p>The implementation detects cycles by constructing a directed graph in which  * each lock represents a node and each edge represents an acquisition ordering  * between two locks.  *<ul>  *<li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired  *   locks when the Thread acquires its first hold (and releases its last  *   remaining hold).  *<li>Before the lock is acquired, the lock is checked against the current set  *   of acquired locks---to each of the acquired locks, an edge from the  *   soon-to-be-acquired lock is either verified or created.  *<li>If a new edge needs to be created, the outgoing edges of the acquired  *   locks are traversed to check for a cycle that reaches the lock to be  *   acquired. If no cycle is detected, a new "safe" edge is created.  *<li>If a cycle is detected, an "unsafe" (cyclic) edge is created to represent  *   a potential deadlock situation, and the appropriate Policy is executed.  *</ul>  *<p>Note that detection of potential deadlock does not necessarily indicate that  * deadlock will happen, as it is possible that higher level application logic  * prevents the cyclic lock acquisition from occurring. One example of a false  * positive is:  *<pre>  * LockA -&gt; LockB -&gt; LockC  * LockA -&gt; LockC -&gt; LockB  *</pre>  *  *<strong>ReadWriteLocks</strong>  *<p>  * While {@code ReadWriteLock} instances have different properties and can form cycles  * without potential deadlock, this class treats {@code ReadWriteLock} instances as  * equivalent to traditional exclusive locks. Although this increases the false  * positives that the locks detect (i.e. cycles that will not actually result in  * deadlock), it simplifies the algorithm and implementation considerably. The  * assumption is that a user of this factory wishes to eliminate any cyclic  * acquisition ordering.  *<p>  *<strong>Explicit Lock Acquisition Ordering</strong>  *<p>  * The {@link CycleDetectingLockFactory.WithExplicitOrdering} class can be used  * to enforce an application-specific ordering in addition to performing general  * cycle detection.  *<p>  *<strong>Garbage Collection</strong>  *<p>  * In order to allow proper garbage collection of unused locks, the edges of  * the lock graph are weak references.  *<p>  *<strong>Performance</strong>  *<p>  * The extra bookkeeping done by cycle detecting locks comes at some cost to  * performance. Benchmarks (as of December 2011) show that:  *  *<ul>  *<li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting  *   lock takes 38ns as opposed to the 24ns taken by a plain lock.  *<li>for nested locking, the cost increases with the depth of the nesting:  *<ul>  *<li> 2 levels: average of 64ns per lock()/unlock()  *<li> 3 levels: average of 77ns per lock()/unlock()  *<li> 4 levels: average of 99ns per lock()/unlock()  *<li> 5 levels: average of 103ns per lock()/unlock()  *<li>10 levels: average of 184ns per lock()/unlock()  *<li>20 levels: average of 393ns per lock()/unlock()  *</ul>  *</ul>  *  *<p>As such, the CycleDetectingLockFactory may not be suitable for  * performance-critical applications which involve tightly-looped or  * deeply-nested locking algorithms.  *  * @author Darick Tong  * @since 13.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|ThreadSafe
DECL|class|CycleDetectingLockFactory
specifier|public
class|class
name|CycleDetectingLockFactory
block|{
comment|/**    * Encapsulates the action to be taken when a potential deadlock is    * encountered. Clients can use one of the predefined {@link Policies} or    * specify a custom implementation. Implementations must be thread-safe.    *    * @since 13.0    */
annotation|@
name|Beta
annotation|@
name|ThreadSafe
DECL|interface|Policy
specifier|public
interface|interface
name|Policy
block|{
comment|/**      * Called when a potential deadlock is encountered. Implementations can      * throw the given {@code exception} and/or execute other desired logic.      *<p>      * Note that the method will be called even upon an invocation of      * {@code tryLock()}. Although {@code tryLock()} technically recovers from      * deadlock by eventually timing out, this behavior is chosen based on the      * assumption that it is the application's wish to prohibit any cyclical      * lock acquisitions.      */
DECL|method|handlePotentialDeadlock (PotentialDeadlockException exception)
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|exception
parameter_list|)
function_decl|;
block|}
comment|/**    * Pre-defined {@link Policy} implementations.    *    * @since 13.0    */
annotation|@
name|Beta
DECL|enum|Policies
specifier|public
enum|enum
name|Policies
implements|implements
name|Policy
block|{
comment|/**      * When potential deadlock is detected, this policy results in the throwing      * of the {@code PotentialDeadlockException} indicating the potential      * deadlock, which includes stack traces illustrating the cycle in lock      * acquisition order.      */
DECL|enumConstant|THROW
name|THROW
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|,
comment|/**      * When potential deadlock is detected, this policy results in the logging      * of a {@link Level#SEVERE} message indicating the potential deadlock,      * which includes stack traces illustrating the cycle in lock acquisition      * order.      */
DECL|enumConstant|WARN
name|WARN
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Detected potential deadlock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|,
comment|/**      * Disables cycle detection. This option causes the factory to return      * unmodified lock implementations provided by the JDK, and is provided to      * allow applications to easily parameterize when cycle detection is      * enabled.      *<p>      * Note that locks created by a factory with this policy will<em>not</em>      * participate the cycle detection performed by locks created by other      * factories.      */
DECL|enumConstant|DISABLED
name|DISABLED
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{       }
block|}
block|;   }
comment|/**    * Creates a new factory with the specified policy.    */
DECL|method|newInstance (Policy policy)
specifier|public
specifier|static
name|CycleDetectingLockFactory
name|newInstance
parameter_list|(
name|Policy
name|policy
parameter_list|)
block|{
return|return
operator|new
name|CycleDetectingLockFactory
argument_list|(
name|policy
argument_list|)
return|;
block|}
comment|/**    * Equivalent to {@code newReentrantLock(lockName, false)}.    */
DECL|method|newReentrantLock (String lockName)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
return|return
name|newReentrantLock
argument_list|(
name|lockName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link ReentrantLock} with the given fairness policy. The    * {@code lockName} is used in the warning or exception output to help    * identify the locks involved in the detected deadlock.    */
DECL|method|newReentrantLock (String lockName, boolean fair)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|String
name|lockName
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantLock
argument_list|(
operator|new
name|LockGraphNode
argument_list|(
name|lockName
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|/**    * Equivalent to {@code newReentrantReadWriteLock(lockName, false)}.    */
DECL|method|newReentrantReadWriteLock (String lockName)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
return|return
name|newReentrantReadWriteLock
argument_list|(
name|lockName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link ReentrantReadWriteLock} with the given fairness policy.    * The {@code lockName} is used in the warning or exception output to help    * identify the locks involved in the detected deadlock.    */
DECL|method|newReentrantReadWriteLock ( String lockName, boolean fair)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|String
name|lockName
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantReadWriteLock
argument_list|(
operator|new
name|LockGraphNode
argument_list|(
name|lockName
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|// A static mapping from an Enum type to its set of LockGraphNodes.
specifier|private
specifier|static
specifier|final
name|ConcurrentMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Enum
argument_list|>
argument_list|,
DECL|field|lockGraphNodesPerType
name|Map
argument_list|<
name|?
extends|extends
name|Enum
argument_list|,
name|LockGraphNode
argument_list|>
argument_list|>
name|lockGraphNodesPerType
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
comment|/**    * Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.    */
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|WithExplicitOrdering
argument_list|<
name|E
argument_list|>
DECL|method|newInstanceWithExplicitOrdering (Class<E> enumClass, Policy policy)
name|newInstanceWithExplicitOrdering
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|enumClass
parameter_list|,
name|Policy
name|policy
parameter_list|)
block|{
comment|// createNodes maps each enumClass to a Map with the corresponding enum key
comment|// type.
name|checkNotNull
argument_list|(
name|enumClass
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|policy
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
init|=
operator|(
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
operator|)
name|getOrCreateNodes
argument_list|(
name|enumClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|WithExplicitOrdering
argument_list|<
name|E
argument_list|>
argument_list|(
name|policy
argument_list|,
name|lockGraphNodes
argument_list|)
return|;
block|}
DECL|method|getOrCreateNodes ( Class<? extends Enum> clazz)
specifier|private
specifier|static
name|Map
argument_list|<
name|?
extends|extends
name|Enum
argument_list|,
name|LockGraphNode
argument_list|>
name|getOrCreateNodes
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Enum
argument_list|>
name|clazz
parameter_list|)
block|{
name|Map
argument_list|<
name|?
extends|extends
name|Enum
argument_list|,
name|LockGraphNode
argument_list|>
name|existing
init|=
name|lockGraphNodesPerType
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|Map
argument_list|<
name|?
extends|extends
name|Enum
argument_list|,
name|LockGraphNode
argument_list|>
name|created
init|=
name|createNodes
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|existing
operator|=
name|lockGraphNodesPerType
operator|.
name|putIfAbsent
argument_list|(
name|clazz
argument_list|,
name|created
argument_list|)
expr_stmt|;
return|return
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|existing
argument_list|,
name|created
argument_list|)
return|;
block|}
comment|/**    * For a given Enum type, creates an immutable map from each of the Enum's    * values to a corresponding LockGraphNode, with the    * {@code allowedPriorLocks} and {@code disallowedPriorLocks} prepopulated    * with nodes according to the natural ordering of the associated Enum values.    */
annotation|@
name|VisibleForTesting
DECL|method|createNodes (Class<E> clazz)
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|createNodes
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
name|EnumMap
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|E
index|[]
name|keys
init|=
name|clazz
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numKeys
init|=
name|keys
operator|.
name|length
decl_stmt|;
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|nodes
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|numKeys
argument_list|)
decl_stmt|;
comment|// Create a LockGraphNode for each enum value.
for|for
control|(
name|E
name|key
range|:
name|keys
control|)
block|{
name|LockGraphNode
name|node
init|=
operator|new
name|LockGraphNode
argument_list|(
name|getLockName
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Pre-populate all allowedPriorLocks with nodes of smaller ordinal.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numKeys
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|checkAcquiredLocks
argument_list|(
name|Policies
operator|.
name|THROW
argument_list|,
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Pre-populate all disallowedPriorLocks with nodes of larger ordinal.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numKeys
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|checkAcquiredLocks
argument_list|(
name|Policies
operator|.
name|DISABLED
argument_list|,
name|nodes
operator|.
name|subList
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|numKeys
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * For the given Enum value {@code rank}, returns the value's    * {@code "EnumClass.name"}, which is used in exception and warning    * output.    */
DECL|method|getLockName (Enum<?> rank)
specifier|private
specifier|static
name|String
name|getLockName
parameter_list|(
name|Enum
argument_list|<
name|?
argument_list|>
name|rank
parameter_list|)
block|{
return|return
name|rank
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
operator|+
name|rank
operator|.
name|name
argument_list|()
return|;
block|}
comment|/**    *<p>A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the    * additional enforcement of an application-specified ordering of lock    * acquisitions. The application defines the allowed ordering with an    * {@code Enum} whose values each correspond to a lock type. The order in    * which the values are declared dictates the allowed order of lock    * acquisition. In other words, locks corresponding to smaller values of    * {@link Enum#ordinal()} should only be acquired before locks with larger    * ordinals. Example:    *    *<pre>   {@code    * enum MyLockOrder {    *   FIRST, SECOND, THIRD;    * }    *    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW);    *    * Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST);    * Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND);    * Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD);    *    * lock1.lock();    * lock3.lock();    * lock2.lock();  // will throw an IllegalStateException}</pre>    *    *<p>As with all locks created by instances of {@code CycleDetectingLockFactory}    * explicitly ordered locks participate in general cycle detection with all    * other cycle detecting locks, and a lock's behavior when detecting a cyclic    * lock acquisition is defined by the {@code Policy} of the factory that    * created it.    *    *<p>Note, however, that although multiple locks can be created for a given Enum    * value, whether it be through separate factory instances or through multiple    * calls to the same factory, attempting to acquire multiple locks with the    * same Enum value (within the same thread) will result in an    * IllegalStateException regardless of the factory's policy. For example:    *    *<pre>   {@code    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);    *    * Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST);    * Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST);    * Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST);    *    * lockA.lock();    *    * lockB.lock();  // will throw an IllegalStateException    * lockC.lock();  // will throw an IllegalStateException    *    * lockA.lock();  // reentrant acquisition is okay}</pre>    *    *<p>It is the responsibility of the application to ensure that multiple lock    * instances with the same rank are never acquired in the same thread.    *    * @param<E> The Enum type representing the explicit lock ordering.    * @since 13.0    */
annotation|@
name|Beta
DECL|class|WithExplicitOrdering
specifier|public
specifier|static
specifier|final
class|class
name|WithExplicitOrdering
parameter_list|<
name|E
extends|extends
name|Enum
parameter_list|<
name|E
parameter_list|>
parameter_list|>
extends|extends
name|CycleDetectingLockFactory
block|{
DECL|field|lockGraphNodes
specifier|private
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|WithExplicitOrdering ( Policy policy, Map<E, LockGraphNode> lockGraphNodes)
name|WithExplicitOrdering
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
parameter_list|)
block|{
name|super
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNodes
operator|=
name|lockGraphNodes
expr_stmt|;
block|}
comment|/**      * Equivalent to {@code newReentrantLock(rank, false)}.      */
DECL|method|newReentrantLock (E rank)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|E
name|rank
parameter_list|)
block|{
return|return
name|newReentrantLock
argument_list|(
name|rank
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link ReentrantLock} with the given fairness policy and rank.      * The values returned by {@link Enum#getDeclaringClass()} and      * {@link Enum#name()} are used to describe the lock in warning or      * exception output.      *      * @throws IllegalStateException If the factory has already created a      *    {@code Lock} with the specified rank.      */
DECL|method|newReentrantLock (E rank, boolean fair)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|E
name|rank
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantLock
argument_list|(
name|lockGraphNodes
operator|.
name|get
argument_list|(
name|rank
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|/**      * Equivalent to {@code newReentrantReadWriteLock(rank, false)}.      */
DECL|method|newReentrantReadWriteLock (E rank)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|E
name|rank
parameter_list|)
block|{
return|return
name|newReentrantReadWriteLock
argument_list|(
name|rank
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link ReentrantReadWriteLock} with the given fairness policy      * and rank. The values returned by {@link Enum#getDeclaringClass()} and      * {@link Enum#name()} are used to describe the lock in warning or exception      * output.      *      * @throws IllegalStateException If the factory has already created a      *    {@code Lock} with the specified rank.      */
DECL|method|newReentrantReadWriteLock ( E rank, boolean fair)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|E
name|rank
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantReadWriteLock
argument_list|(
name|lockGraphNodes
operator|.
name|get
argument_list|(
name|rank
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
block|}
comment|//////// Implementation /////////
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CycleDetectingLockFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|policy
specifier|final
name|Policy
name|policy
decl_stmt|;
DECL|method|CycleDetectingLockFactory (Policy policy)
specifier|private
name|CycleDetectingLockFactory
parameter_list|(
name|Policy
name|policy
parameter_list|)
block|{
name|this
operator|.
name|policy
operator|=
name|checkNotNull
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tracks the currently acquired locks for each Thread, kept up to date by    * calls to {@link #aboutToAcquire(CycleDetectingLock)} and    * {@link #lockStateChanged(CycleDetectingLock)}.    */
comment|// This is logically a Set, but an ArrayList is used to minimize the amount
comment|// of allocation done on lock()/unlock().
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
argument_list|>
DECL|field|acquiredLocks
name|acquiredLocks
init|=
operator|new
name|ThreadLocal
argument_list|<
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|initialValue
parameter_list|()
block|{
return|return
name|Lists
operator|.
expr|<
name|LockGraphNode
operator|>
name|newArrayListWithCapacity
argument_list|(
literal|3
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A Throwable used to record a stack trace that illustrates an example of    * a specific lock acquisition ordering. The top of the stack trace is    * truncated such that it starts with the acquisition of the lock in    * question, e.g.    *    *<pre>    * com...ExampleStackTrace: LockB -&gt; LockC    *   at com...CycleDetectingReentrantLock.lock(CycleDetectingLockFactory.java:443)    *   at ...    *   at ...    *   at com...MyClass.someMethodThatAcquiresLockB(MyClass.java:123)    *</pre>    */
DECL|class|ExampleStackTrace
specifier|private
specifier|static
class|class
name|ExampleStackTrace
extends|extends
name|IllegalStateException
block|{
DECL|field|EMPTY_STACK_TRACE
specifier|static
specifier|final
name|StackTraceElement
index|[]
name|EMPTY_STACK_TRACE
init|=
operator|new
name|StackTraceElement
index|[
literal|0
index|]
decl_stmt|;
DECL|field|EXCLUDED_CLASS_NAMES
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|EXCLUDED_CLASS_NAMES
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|CycleDetectingLockFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|ExampleStackTrace
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LockGraphNode
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|ExampleStackTrace (LockGraphNode node1, LockGraphNode node2)
name|ExampleStackTrace
parameter_list|(
name|LockGraphNode
name|node1
parameter_list|,
name|LockGraphNode
name|node2
parameter_list|)
block|{
name|super
argument_list|(
name|node1
operator|.
name|getLockName
argument_list|()
operator|+
literal|" -> "
operator|+
name|node2
operator|.
name|getLockName
argument_list|()
argument_list|)
expr_stmt|;
name|StackTraceElement
index|[]
name|origStackTrace
init|=
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|origStackTrace
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|WithExplicitOrdering
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|origStackTrace
index|[
name|i
index|]
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
comment|// For pre-populated disallowedPriorLocks edges, omit the stack trace.
name|setStackTrace
argument_list|(
name|EMPTY_STACK_TRACE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|EXCLUDED_CLASS_NAMES
operator|.
name|contains
argument_list|(
name|origStackTrace
index|[
name|i
index|]
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
name|setStackTrace
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|origStackTrace
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**    * Represents a detected cycle in lock acquisition ordering. The exception    * includes a causal chain of {@code ExampleStackTrace} instances to illustrate the    * cycle, e.g.    *    *<pre>    * com....PotentialDeadlockException: Potential Deadlock from LockC -&gt; ReadWriteA    *   at ...    *   at ...    * Caused by: com...ExampleStackTrace: LockB -&gt; LockC    *   at ...    *   at ...    * Caused by: com...ExampleStackTrace: ReadWriteA -&gt; LockB    *   at ...    *   at ...    *</pre>    *    *<p>Instances are logged for the {@code Policies.WARN}, and thrown for    * {@code Policies.THROW}.    *    * @since 13.0    */
annotation|@
name|Beta
DECL|class|PotentialDeadlockException
specifier|public
specifier|static
specifier|final
class|class
name|PotentialDeadlockException
extends|extends
name|ExampleStackTrace
block|{
DECL|field|conflictingStackTrace
specifier|private
specifier|final
name|ExampleStackTrace
name|conflictingStackTrace
decl_stmt|;
DECL|method|PotentialDeadlockException ( LockGraphNode node1, LockGraphNode node2, ExampleStackTrace conflictingStackTrace)
specifier|private
name|PotentialDeadlockException
parameter_list|(
name|LockGraphNode
name|node1
parameter_list|,
name|LockGraphNode
name|node2
parameter_list|,
name|ExampleStackTrace
name|conflictingStackTrace
parameter_list|)
block|{
name|super
argument_list|(
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
name|this
operator|.
name|conflictingStackTrace
operator|=
name|conflictingStackTrace
expr_stmt|;
name|initCause
argument_list|(
name|conflictingStackTrace
argument_list|)
expr_stmt|;
block|}
DECL|method|getConflictingStackTrace ()
specifier|public
name|ExampleStackTrace
name|getConflictingStackTrace
parameter_list|()
block|{
return|return
name|conflictingStackTrace
return|;
block|}
comment|/**      * Appends the chain of messages from the {@code conflictingStackTrace} to      * the original {@code message}.      */
annotation|@
name|Override
DECL|method|getMessage ()
specifier|public
name|String
name|getMessage
parameter_list|()
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Throwable
name|t
init|=
name|conflictingStackTrace
init|;
name|t
operator|!=
literal|null
condition|;
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
control|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|message
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Internal Lock implementations implement the {@code CycleDetectingLock}    * interface, allowing the detection logic to treat all locks in the same    * manner.    */
DECL|interface|CycleDetectingLock
specifier|private
interface|interface
name|CycleDetectingLock
block|{
comment|/** @return the {@link LockGraphNode} associated with this lock. */
DECL|method|getLockGraphNode ()
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
function_decl|;
comment|/** @return {@code true} if the current thread has acquired this lock. */
DECL|method|isAcquiredByCurrentThread ()
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
function_decl|;
block|}
comment|/**    * A {@code LockGraphNode} associated with each lock instance keeps track of    * the directed edges in the lock acquisition graph.    */
DECL|class|LockGraphNode
specifier|private
specifier|static
class|class
name|LockGraphNode
block|{
comment|/**      * The map tracking the locks that are known to be acquired before this      * lock, each associated with an example stack trace. Locks are weakly keyed      * to allow proper garbage collection when they are no longer referenced.      */
DECL|field|allowedPriorLocks
specifier|final
name|Map
argument_list|<
name|LockGraphNode
argument_list|,
name|ExampleStackTrace
argument_list|>
name|allowedPriorLocks
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
comment|/**      * The map tracking lock nodes that can cause a lock acquisition cycle if      * acquired before this node.      */
specifier|final
name|Map
argument_list|<
name|LockGraphNode
argument_list|,
name|PotentialDeadlockException
argument_list|>
DECL|field|disallowedPriorLocks
name|disallowedPriorLocks
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
DECL|field|lockName
specifier|final
name|String
name|lockName
decl_stmt|;
DECL|method|LockGraphNode (String lockName)
name|LockGraphNode
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
name|this
operator|.
name|lockName
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
block|}
DECL|method|getLockName ()
name|String
name|getLockName
parameter_list|()
block|{
return|return
name|lockName
return|;
block|}
DECL|method|checkAcquiredLocks ( Policy policy, List<LockGraphNode> acquiredLocks)
name|void
name|checkAcquiredLocks
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|List
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLocks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|size
init|=
name|acquiredLocks
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|checkAcquiredLock
argument_list|(
name|policy
argument_list|,
name|acquiredLocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Checks the acquisition-ordering between {@code this}, which is about to      * be acquired, and the specified {@code acquiredLock}.      *<p>      * When this method returns, the {@code acquiredLock} should be in either      * the {@code preAcquireLocks} map, for the case in which it is safe to      * acquire {@code this} after the {@code acquiredLock}, or in the      * {@code disallowedPriorLocks} map, in which case it is not safe.      */
DECL|method|checkAcquiredLock (Policy policy, LockGraphNode acquiredLock)
name|void
name|checkAcquiredLock
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|LockGraphNode
name|acquiredLock
parameter_list|)
block|{
comment|// checkAcquiredLock() should never be invoked by a lock that has already
comment|// been acquired. For unordered locks, aboutToAcquire() ensures this by
comment|// checking isAcquiredByCurrentThread(). For ordered locks, however, this
comment|// can happen because multiple locks may share the same LockGraphNode. In
comment|// this situation, throw an IllegalStateException as defined by contract
comment|// described in the documentation of WithExplicitOrdering.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|!=
name|acquiredLock
argument_list|,
literal|"Attempted to acquire multiple locks with the same rank "
operator|+
name|acquiredLock
operator|.
name|getLockName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowedPriorLocks
operator|.
name|containsKey
argument_list|(
name|acquiredLock
argument_list|)
condition|)
block|{
comment|// The acquisition ordering from "acquiredLock" to "this" has already
comment|// been verified as safe. In a properly written application, this is
comment|// the common case.
return|return;
block|}
name|PotentialDeadlockException
name|previousDeadlockException
init|=
name|disallowedPriorLocks
operator|.
name|get
argument_list|(
name|acquiredLock
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousDeadlockException
operator|!=
literal|null
condition|)
block|{
comment|// Previously determined to be an unsafe lock acquisition.
comment|// Create a new PotentialDeadlockException with the same causal chain
comment|// (the example cycle) as that of the cached exception.
name|PotentialDeadlockException
name|exception
init|=
operator|new
name|PotentialDeadlockException
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|,
name|previousDeadlockException
operator|.
name|getConflictingStackTrace
argument_list|()
argument_list|)
decl_stmt|;
name|policy
operator|.
name|handlePotentialDeadlock
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Otherwise, it's the first time seeing this lock relationship. Look for
comment|// a path from the acquiredLock to this.
name|Set
argument_list|<
name|LockGraphNode
argument_list|>
name|seen
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
name|ExampleStackTrace
name|path
init|=
name|acquiredLock
operator|.
name|findPathTo
argument_list|(
name|this
argument_list|,
name|seen
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|// this can be safely acquired after the acquiredLock.
comment|//
comment|// Note that there is a race condition here which can result in missing
comment|// a cyclic edge: it's possible for two threads to simultaneous find
comment|// "safe" edges which together form a cycle. Preventing this race
comment|// condition efficiently without _introducing_ deadlock is probably
comment|// tricky. For now, just accept the race condition---missing a warning
comment|// now and then is still better than having no deadlock detection.
name|allowedPriorLocks
operator|.
name|put
argument_list|(
name|acquiredLock
argument_list|,
operator|new
name|ExampleStackTrace
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Unsafe acquisition order detected. Create and cache a
comment|// PotentialDeadlockException.
name|PotentialDeadlockException
name|exception
init|=
operator|new
name|PotentialDeadlockException
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|disallowedPriorLocks
operator|.
name|put
argument_list|(
name|acquiredLock
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|policy
operator|.
name|handlePotentialDeadlock
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Performs a depth-first traversal of the graph edges defined by each      * node's {@code allowedPriorLocks} to find a path between {@code this} and      * the specified {@code lock}.      *      * @return If a path was found, a chained {@link ExampleStackTrace}      *     illustrating the path to the {@code lock}, or {@code null} if no path      *     was found.      */
annotation|@
name|Nullable
DECL|method|findPathTo ( LockGraphNode node, Set<LockGraphNode> seen)
specifier|private
name|ExampleStackTrace
name|findPathTo
parameter_list|(
name|LockGraphNode
name|node
parameter_list|,
name|Set
argument_list|<
name|LockGraphNode
argument_list|>
name|seen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|seen
operator|.
name|add
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
comment|// Already traversed this node.
block|}
name|ExampleStackTrace
name|found
init|=
name|allowedPriorLocks
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
return|return
name|found
return|;
comment|// Found a path ending at the node!
block|}
comment|// Recurse the edges.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|LockGraphNode
argument_list|,
name|ExampleStackTrace
argument_list|>
name|entry
range|:
name|allowedPriorLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LockGraphNode
name|preAcquiredLock
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|found
operator|=
name|preAcquiredLock
operator|.
name|findPathTo
argument_list|(
name|node
argument_list|,
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
comment|// One of this node's allowedPriorLocks found a path. Prepend an
comment|// ExampleStackTrace(preAcquiredLock, this) to the returned chain of
comment|// ExampleStackTraces.
name|ExampleStackTrace
name|path
init|=
operator|new
name|ExampleStackTrace
argument_list|(
name|preAcquiredLock
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|path
operator|.
name|setStackTrace
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|initCause
argument_list|(
name|found
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * CycleDetectingLock implementations must call this method before attempting    * to acquire the lock.    */
DECL|method|aboutToAcquire (CycleDetectingLock lock)
specifier|private
name|void
name|aboutToAcquire
parameter_list|(
name|CycleDetectingLock
name|lock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lock
operator|.
name|isAcquiredByCurrentThread
argument_list|()
condition|)
block|{
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLockList
init|=
name|acquiredLocks
operator|.
name|get
argument_list|()
decl_stmt|;
name|LockGraphNode
name|node
init|=
name|lock
operator|.
name|getLockGraphNode
argument_list|()
decl_stmt|;
name|node
operator|.
name|checkAcquiredLocks
argument_list|(
name|policy
argument_list|,
name|acquiredLockList
argument_list|)
expr_stmt|;
name|acquiredLockList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * CycleDetectingLock implementations must call this method in a    * {@code finally} clause after any attempt to change the lock state,    * including both lock and unlock attempts. Failure to do so can result in    * corrupting the acquireLocks set.    */
DECL|method|lockStateChanged (CycleDetectingLock lock)
specifier|private
name|void
name|lockStateChanged
parameter_list|(
name|CycleDetectingLock
name|lock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lock
operator|.
name|isAcquiredByCurrentThread
argument_list|()
condition|)
block|{
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLockList
init|=
name|acquiredLocks
operator|.
name|get
argument_list|()
decl_stmt|;
name|LockGraphNode
name|node
init|=
name|lock
operator|.
name|getLockGraphNode
argument_list|()
decl_stmt|;
comment|// Iterate in reverse because locks are usually locked/unlocked in a
comment|// LIFO order.
for|for
control|(
name|int
name|i
init|=
name|acquiredLockList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|acquiredLockList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
name|node
condition|)
block|{
name|acquiredLockList
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantLock
specifier|final
class|class
name|CycleDetectingReentrantLock
extends|extends
name|ReentrantLock
implements|implements
name|CycleDetectingLock
block|{
DECL|field|lockGraphNode
specifier|private
specifier|final
name|LockGraphNode
name|lockGraphNode
decl_stmt|;
DECL|method|CycleDetectingReentrantLock ( LockGraphNode lockGraphNode, boolean fair)
specifier|private
name|CycleDetectingReentrantLock
parameter_list|(
name|LockGraphNode
name|lockGraphNode
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
name|super
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNode
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockGraphNode
argument_list|)
expr_stmt|;
block|}
comment|///// CycleDetectingLock methods. /////
annotation|@
name|Override
DECL|method|getLockGraphNode ()
specifier|public
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
block|{
return|return
name|lockGraphNode
return|;
block|}
annotation|@
name|Override
DECL|method|isAcquiredByCurrentThread ()
specifier|public
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
block|{
return|return
name|isHeldByCurrentThread
argument_list|()
return|;
block|}
comment|///// Overridden ReentrantLock methods. /////
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantReadWriteLock
specifier|final
class|class
name|CycleDetectingReentrantReadWriteLock
extends|extends
name|ReentrantReadWriteLock
implements|implements
name|CycleDetectingLock
block|{
comment|// These ReadLock/WriteLock implementations shadow those in the
comment|// ReentrantReadWriteLock superclass. They are simply wrappers around the
comment|// internal Sync object, so this is safe since the shadowed locks are never
comment|// exposed or used.
DECL|field|readLock
specifier|private
specifier|final
name|CycleDetectingReentrantReadLock
name|readLock
decl_stmt|;
DECL|field|writeLock
specifier|private
specifier|final
name|CycleDetectingReentrantWriteLock
name|writeLock
decl_stmt|;
DECL|field|lockGraphNode
specifier|private
specifier|final
name|LockGraphNode
name|lockGraphNode
decl_stmt|;
DECL|method|CycleDetectingReentrantReadWriteLock ( LockGraphNode lockGraphNode, boolean fair)
specifier|private
name|CycleDetectingReentrantReadWriteLock
parameter_list|(
name|LockGraphNode
name|lockGraphNode
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
name|super
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|this
operator|.
name|readLock
operator|=
operator|new
name|CycleDetectingReentrantReadLock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
operator|new
name|CycleDetectingReentrantWriteLock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNode
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockGraphNode
argument_list|)
expr_stmt|;
block|}
comment|///// Overridden ReentrantReadWriteLock methods. /////
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|ReadLock
name|readLock
parameter_list|()
block|{
return|return
name|readLock
return|;
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|WriteLock
name|writeLock
parameter_list|()
block|{
return|return
name|writeLock
return|;
block|}
comment|///// CycleDetectingLock methods. /////
annotation|@
name|Override
DECL|method|getLockGraphNode ()
specifier|public
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
block|{
return|return
name|lockGraphNode
return|;
block|}
annotation|@
name|Override
DECL|method|isAcquiredByCurrentThread ()
specifier|public
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
block|{
return|return
name|isWriteLockedByCurrentThread
argument_list|()
operator|||
name|getReadHoldCount
argument_list|()
operator|>
literal|0
return|;
block|}
block|}
DECL|class|CycleDetectingReentrantReadLock
specifier|private
class|class
name|CycleDetectingReentrantReadLock
extends|extends
name|ReentrantReadWriteLock
operator|.
name|ReadLock
block|{
DECL|field|readWriteLock
specifier|final
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
decl_stmt|;
DECL|method|CycleDetectingReentrantReadLock ( CycleDetectingReentrantReadWriteLock readWriteLock)
name|CycleDetectingReentrantReadLock
parameter_list|(
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
parameter_list|)
block|{
name|super
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
name|this
operator|.
name|readWriteLock
operator|=
name|readWriteLock
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantWriteLock
specifier|private
class|class
name|CycleDetectingReentrantWriteLock
extends|extends
name|ReentrantReadWriteLock
operator|.
name|WriteLock
block|{
DECL|field|readWriteLock
specifier|final
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
decl_stmt|;
DECL|method|CycleDetectingReentrantWriteLock ( CycleDetectingReentrantReadWriteLock readWriteLock)
name|CycleDetectingReentrantWriteLock
parameter_list|(
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
parameter_list|)
block|{
name|super
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
name|this
operator|.
name|readWriteLock
operator|=
name|readWriteLock
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

