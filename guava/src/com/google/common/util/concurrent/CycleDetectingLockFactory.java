begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * The {@code CycleDetectingLockFactory} creates {@link ReentrantLock} instances and {@link  * ReentrantReadWriteLock} instances that detect potential deadlock by checking for cycles in lock  * acquisition order.  *  *<p>Potential deadlocks detected when calling the {@code lock()}, {@code lockInterruptibly()}, or  * {@code tryLock()} methods will result in the execution of the {@link Policy} specified when  * creating the factory. The currently available policies are:  *  *<ul>  *<li>DISABLED  *<li>WARN  *<li>THROW  *</ul>  *  *<p>The locks created by a factory instance will detect lock acquisition cycles with locks created  * by other {@code CycleDetectingLockFactory} instances (except those with {@code Policy.DISABLED}).  * A lock's behavior when a cycle is detected, however, is defined by the {@code Policy} of the  * factory that created it. This allows detection of cycles across components while delegating  * control over lock behavior to individual components.  *  *<p>Applications are encouraged to use a {@code CycleDetectingLockFactory} to create any locks for  * which external/unmanaged code is executed while the lock is held. (See caveats under  *<strong>Performance</strong>).  *  *<p><strong>Cycle Detection</strong>  *  *<p>Deadlocks can arise when locks are acquired in an order that forms a cycle. In a simple  * example involving two locks and two threads, deadlock occurs when one thread acquires Lock A, and  * then Lock B, while another thread acquires Lock B, and then Lock A:  *  *<pre>  * Thread1: acquire(LockA) --X acquire(LockB)  * Thread2: acquire(LockB) --X acquire(LockA)  *</pre>  *  *<p>Neither thread will progress because each is waiting for the other. In more complex  * applications, cycles can arise from interactions among more than 2 locks:  *  *<pre>  * Thread1: acquire(LockA) --X acquire(LockB)  * Thread2: acquire(LockB) --X acquire(LockC)  * ...  * ThreadN: acquire(LockN) --X acquire(LockA)  *</pre>  *  *<p>The implementation detects cycles by constructing a directed graph in which each lock  * represents a node and each edge represents an acquisition ordering between two locks.  *  *<ul>  *<li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the  *       Thread acquires its first hold (and releases its last remaining hold).  *<li>Before the lock is acquired, the lock is checked against the current set of acquired  *       locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either  *       verified or created.  *<li>If a new edge needs to be created, the outgoing edges of the acquired locks are traversed  *       to check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new  *       "safe" edge is created.  *<li>If a cycle is detected, an "unsafe" (cyclic) edge is created to represent a potential  *       deadlock situation, and the appropriate Policy is executed.  *</ul>  *  *<p>Note that detection of potential deadlock does not necessarily indicate that deadlock will  * happen, as it is possible that higher level application logic prevents the cyclic lock  * acquisition from occurring. One example of a false positive is:  *  *<pre>  * LockA -&gt; LockB -&gt; LockC  * LockA -&gt; LockC -&gt; LockB  *</pre>  *  *<p><strong>ReadWriteLocks</strong>  *  *<p>While {@code ReadWriteLock} instances have different properties and can form cycles without  * potential deadlock, this class treats {@code ReadWriteLock} instances as equivalent to  * traditional exclusive locks. Although this increases the false positives that the locks detect  * (i.e. cycles that will not actually result in deadlock), it simplifies the algorithm and  * implementation considerably. The assumption is that a user of this factory wishes to eliminate  * any cyclic acquisition ordering.  *  *<p><strong>Explicit Lock Acquisition Ordering</strong>  *  *<p>The {@link CycleDetectingLockFactory.WithExplicitOrdering} class can be used to enforce an  * application-specific ordering in addition to performing general cycle detection.  *  *<p><strong>Garbage Collection</strong>  *  *<p>In order to allow proper garbage collection of unused locks, the edges of the lock graph are  * weak references.  *  *<p><strong>Performance</strong>  *  *<p>The extra bookkeeping done by cycle detecting locks comes at some cost to performance.  * Benchmarks (as of December 2011) show that:  *  *<ul>  *<li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting lock takes 38ns as  *       opposed to the 24ns taken by a plain lock.  *<li>for nested locking, the cost increases with the depth of the nesting:  *<ul>  *<li>2 levels: average of 64ns per lock()/unlock()  *<li>3 levels: average of 77ns per lock()/unlock()  *<li>4 levels: average of 99ns per lock()/unlock()  *<li>5 levels: average of 103ns per lock()/unlock()  *<li>10 levels: average of 184ns per lock()/unlock()  *<li>20 levels: average of 393ns per lock()/unlock()  *</ul>  *</ul>  *  *<p>As such, the CycleDetectingLockFactory may not be suitable for performance-critical  * applications which involve tightly-looped or deeply-nested locking algorithms.  *  * @author Darick Tong  * @since 13.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
comment|// TODO(cpovirk): Consider being more strict.
annotation|@
name|GwtIncompatible
DECL|class|CycleDetectingLockFactory
specifier|public
class|class
name|CycleDetectingLockFactory
block|{
comment|/**    * Encapsulates the action to be taken when a potential deadlock is encountered. Clients can use    * one of the predefined {@link Policies} or specify a custom implementation. Implementations must    * be thread-safe.    *    * @since 13.0    */
annotation|@
name|Beta
DECL|interface|Policy
specifier|public
interface|interface
name|Policy
block|{
comment|/**      * Called when a potential deadlock is encountered. Implementations can throw the given {@code      * exception} and/or execute other desired logic.      *      *<p>Note that the method will be called even upon an invocation of {@code tryLock()}. Although      * {@code tryLock()} technically recovers from deadlock by eventually timing out, this behavior      * is chosen based on the assumption that it is the application's wish to prohibit any cyclical      * lock acquisitions.      */
DECL|method|handlePotentialDeadlock (PotentialDeadlockException exception)
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|exception
parameter_list|)
function_decl|;
block|}
comment|/**    * Pre-defined {@link Policy} implementations.    *    * @since 13.0    */
annotation|@
name|Beta
DECL|enum|Policies
specifier|public
enum|enum
name|Policies
implements|implements
name|Policy
block|{
comment|/**      * When potential deadlock is detected, this policy results in the throwing of the {@code      * PotentialDeadlockException} indicating the potential deadlock, which includes stack traces      * illustrating the cycle in lock acquisition order.      */
DECL|enumConstant|THROW
name|THROW
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|,
comment|/**      * When potential deadlock is detected, this policy results in the logging of a {@link      * Level#SEVERE} message indicating the potential deadlock, which includes stack traces      * illustrating the cycle in lock acquisition order.      */
DECL|enumConstant|WARN
name|WARN
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Detected potential deadlock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|,
comment|/**      * Disables cycle detection. This option causes the factory to return unmodified lock      * implementations provided by the JDK, and is provided to allow applications to easily      * parameterize when cycle detection is enabled.      *      *<p>Note that locks created by a factory with this policy will<em>not</em> participate the      * cycle detection performed by locks created by other factories.      */
DECL|enumConstant|DISABLED
name|DISABLED
block|{
annotation|@
name|Override
specifier|public
name|void
name|handlePotentialDeadlock
parameter_list|(
name|PotentialDeadlockException
name|e
parameter_list|)
block|{}
block|}
block|;   }
comment|/** Creates a new factory with the specified policy. */
DECL|method|newInstance (Policy policy)
specifier|public
specifier|static
name|CycleDetectingLockFactory
name|newInstance
parameter_list|(
name|Policy
name|policy
parameter_list|)
block|{
return|return
operator|new
name|CycleDetectingLockFactory
argument_list|(
name|policy
argument_list|)
return|;
block|}
comment|/** Equivalent to {@code newReentrantLock(lockName, false)}. */
DECL|method|newReentrantLock (String lockName)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
return|return
name|newReentrantLock
argument_list|(
name|lockName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link ReentrantLock} with the given fairness policy. The {@code lockName} is used in    * the warning or exception output to help identify the locks involved in the detected deadlock.    */
DECL|method|newReentrantLock (String lockName, boolean fair)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|String
name|lockName
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantLock
argument_list|(
operator|new
name|LockGraphNode
argument_list|(
name|lockName
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|/** Equivalent to {@code newReentrantReadWriteLock(lockName, false)}. */
DECL|method|newReentrantReadWriteLock (String lockName)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
return|return
name|newReentrantReadWriteLock
argument_list|(
name|lockName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link ReentrantReadWriteLock} with the given fairness policy. The {@code lockName}    * is used in the warning or exception output to help identify the locks involved in the detected    * deadlock.    */
DECL|method|newReentrantReadWriteLock (String lockName, boolean fair)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|String
name|lockName
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantReadWriteLock
argument_list|(
operator|new
name|LockGraphNode
argument_list|(
name|lockName
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|// A static mapping from an Enum type to its set of LockGraphNodes.
specifier|private
specifier|static
specifier|final
name|ConcurrentMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|,
name|Map
argument_list|<
name|?
extends|extends
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|LockGraphNode
argument_list|>
argument_list|>
DECL|field|lockGraphNodesPerType
name|lockGraphNodesPerType
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
comment|/** Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}. */
DECL|method|newInstanceWithExplicitOrdering ( Class<E> enumClass, Policy policy)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|WithExplicitOrdering
argument_list|<
name|E
argument_list|>
name|newInstanceWithExplicitOrdering
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|enumClass
parameter_list|,
name|Policy
name|policy
parameter_list|)
block|{
comment|// createNodes maps each enumClass to a Map with the corresponding enum key
comment|// type.
name|checkNotNull
argument_list|(
name|enumClass
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|policy
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
init|=
operator|(
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
operator|)
name|getOrCreateNodes
argument_list|(
name|enumClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|WithExplicitOrdering
argument_list|<
name|E
argument_list|>
argument_list|(
name|policy
argument_list|,
name|lockGraphNodes
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getOrCreateNodes ( Class<E> clazz)
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|?
extends|extends
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|getOrCreateNodes
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|existing
init|=
operator|(
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
operator|)
name|lockGraphNodesPerType
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|created
init|=
name|createNodes
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|existing
operator|=
operator|(
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
operator|)
name|lockGraphNodesPerType
operator|.
name|putIfAbsent
argument_list|(
name|clazz
argument_list|,
name|created
argument_list|)
expr_stmt|;
return|return
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|existing
argument_list|,
name|created
argument_list|)
return|;
block|}
comment|/**    * For a given Enum type, creates an immutable map from each of the Enum's values to a    * corresponding LockGraphNode, with the {@code allowedPriorLocks} and {@code    * disallowedPriorLocks} prepopulated with nodes according to the natural ordering of the    * associated Enum values.    */
annotation|@
name|VisibleForTesting
DECL|method|createNodes (Class<E> clazz)
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|createNodes
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
name|EnumMap
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|E
index|[]
name|keys
init|=
name|clazz
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numKeys
init|=
name|keys
operator|.
name|length
decl_stmt|;
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|nodes
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|numKeys
argument_list|)
decl_stmt|;
comment|// Create a LockGraphNode for each enum value.
for|for
control|(
name|E
name|key
range|:
name|keys
control|)
block|{
name|LockGraphNode
name|node
init|=
operator|new
name|LockGraphNode
argument_list|(
name|getLockName
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Pre-populate all allowedPriorLocks with nodes of smaller ordinal.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numKeys
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|checkAcquiredLocks
argument_list|(
name|Policies
operator|.
name|THROW
argument_list|,
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Pre-populate all disallowedPriorLocks with nodes of larger ordinal.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numKeys
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|checkAcquiredLocks
argument_list|(
name|Policies
operator|.
name|DISABLED
argument_list|,
name|nodes
operator|.
name|subList
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|numKeys
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * For the given Enum value {@code rank}, returns the value's {@code "EnumClass.name"}, which is    * used in exception and warning output.    */
DECL|method|getLockName (Enum<?> rank)
specifier|private
specifier|static
name|String
name|getLockName
parameter_list|(
name|Enum
argument_list|<
name|?
argument_list|>
name|rank
parameter_list|)
block|{
return|return
name|rank
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
operator|+
name|rank
operator|.
name|name
argument_list|()
return|;
block|}
comment|/**    * A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the additional enforcement of    * an application-specified ordering of lock acquisitions. The application defines the allowed    * ordering with an {@code Enum} whose values each correspond to a lock type. The order in which    * the values are declared dictates the allowed order of lock acquisition. In other words, locks    * corresponding to smaller values of {@link Enum#ordinal()} should only be acquired before locks    * with larger ordinals. Example:    *    *<pre>{@code    * enum MyLockOrder {    *   FIRST, SECOND, THIRD;    * }    *    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW);    *    * Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST);    * Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND);    * Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD);    *    * lock1.lock();    * lock3.lock();    * lock2.lock();  // will throw an IllegalStateException    * }</pre>    *    *<p>As with all locks created by instances of {@code CycleDetectingLockFactory} explicitly    * ordered locks participate in general cycle detection with all other cycle detecting locks, and    * a lock's behavior when detecting a cyclic lock acquisition is defined by the {@code Policy} of    * the factory that created it.    *    *<p>Note, however, that although multiple locks can be created for a given Enum value, whether    * it be through separate factory instances or through multiple calls to the same factory,    * attempting to acquire multiple locks with the same Enum value (within the same thread) will    * result in an IllegalStateException regardless of the factory's policy. For example:    *    *<pre>{@code    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);    * CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 =    *   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);    *    * Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST);    * Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST);    * Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST);    *    * lockA.lock();    *    * lockB.lock();  // will throw an IllegalStateException    * lockC.lock();  // will throw an IllegalStateException    *    * lockA.lock();  // reentrant acquisition is okay    * }</pre>    *    *<p>It is the responsibility of the application to ensure that multiple lock instances with the    * same rank are never acquired in the same thread.    *    * @param<E> The Enum type representing the explicit lock ordering.    * @since 13.0    */
annotation|@
name|Beta
DECL|class|WithExplicitOrdering
specifier|public
specifier|static
specifier|final
class|class
name|WithExplicitOrdering
parameter_list|<
name|E
extends|extends
name|Enum
parameter_list|<
name|E
parameter_list|>
parameter_list|>
extends|extends
name|CycleDetectingLockFactory
block|{
DECL|field|lockGraphNodes
specifier|private
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|WithExplicitOrdering (Policy policy, Map<E, LockGraphNode> lockGraphNodes)
name|WithExplicitOrdering
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|Map
argument_list|<
name|E
argument_list|,
name|LockGraphNode
argument_list|>
name|lockGraphNodes
parameter_list|)
block|{
name|super
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNodes
operator|=
name|lockGraphNodes
expr_stmt|;
block|}
comment|/** Equivalent to {@code newReentrantLock(rank, false)}. */
DECL|method|newReentrantLock (E rank)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|E
name|rank
parameter_list|)
block|{
return|return
name|newReentrantLock
argument_list|(
name|rank
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link ReentrantLock} with the given fairness policy and rank. The values returned      * by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the lock in      * warning or exception output.      *      * @throws IllegalStateException If the factory has already created a {@code Lock} with the      *     specified rank.      */
DECL|method|newReentrantLock (E rank, boolean fair)
specifier|public
name|ReentrantLock
name|newReentrantLock
parameter_list|(
name|E
name|rank
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantLock
argument_list|(
name|lockGraphNodes
operator|.
name|get
argument_list|(
name|rank
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
comment|/** Equivalent to {@code newReentrantReadWriteLock(rank, false)}. */
DECL|method|newReentrantReadWriteLock (E rank)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|E
name|rank
parameter_list|)
block|{
return|return
name|newReentrantReadWriteLock
argument_list|(
name|rank
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link ReentrantReadWriteLock} with the given fairness policy and rank. The values      * returned by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the      * lock in warning or exception output.      *      * @throws IllegalStateException If the factory has already created a {@code Lock} with the      *     specified rank.      */
DECL|method|newReentrantReadWriteLock (E rank, boolean fair)
specifier|public
name|ReentrantReadWriteLock
name|newReentrantReadWriteLock
parameter_list|(
name|E
name|rank
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
return|return
name|policy
operator|==
name|Policies
operator|.
name|DISABLED
condition|?
operator|new
name|ReentrantReadWriteLock
argument_list|(
name|fair
argument_list|)
else|:
operator|new
name|CycleDetectingReentrantReadWriteLock
argument_list|(
name|lockGraphNodes
operator|.
name|get
argument_list|(
name|rank
argument_list|)
argument_list|,
name|fair
argument_list|)
return|;
block|}
block|}
comment|//////// Implementation /////////
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CycleDetectingLockFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|policy
specifier|final
name|Policy
name|policy
decl_stmt|;
DECL|method|CycleDetectingLockFactory (Policy policy)
specifier|private
name|CycleDetectingLockFactory
parameter_list|(
name|Policy
name|policy
parameter_list|)
block|{
name|this
operator|.
name|policy
operator|=
name|checkNotNull
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tracks the currently acquired locks for each Thread, kept up to date by calls to {@link    * #aboutToAcquire(CycleDetectingLock)} and {@link #lockStateChanged(CycleDetectingLock)}.    */
comment|// This is logically a Set, but an ArrayList is used to minimize the amount
comment|// of allocation done on lock()/unlock().
DECL|field|acquiredLocks
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
argument_list|>
name|acquiredLocks
init|=
operator|new
name|ThreadLocal
argument_list|<
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|initialValue
parameter_list|()
block|{
return|return
name|Lists
operator|.
expr|<
name|LockGraphNode
operator|>
name|newArrayListWithCapacity
argument_list|(
literal|3
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A Throwable used to record a stack trace that illustrates an example of a specific lock    * acquisition ordering. The top of the stack trace is truncated such that it starts with the    * acquisition of the lock in question, e.g.    *    *<pre>    * com...ExampleStackTrace: LockB -&gt; LockC    *   at com...CycleDetectingReentrantLock.lock(CycleDetectingLockFactory.java:443)    *   at ...    *   at ...    *   at com...MyClass.someMethodThatAcquiresLockB(MyClass.java:123)    *</pre>    */
DECL|class|ExampleStackTrace
specifier|private
specifier|static
class|class
name|ExampleStackTrace
extends|extends
name|IllegalStateException
block|{
DECL|field|EMPTY_STACK_TRACE
specifier|static
specifier|final
name|StackTraceElement
index|[]
name|EMPTY_STACK_TRACE
init|=
operator|new
name|StackTraceElement
index|[
literal|0
index|]
decl_stmt|;
DECL|field|EXCLUDED_CLASS_NAMES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|EXCLUDED_CLASS_NAMES
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|CycleDetectingLockFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|ExampleStackTrace
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LockGraphNode
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|ExampleStackTrace (LockGraphNode node1, LockGraphNode node2)
name|ExampleStackTrace
parameter_list|(
name|LockGraphNode
name|node1
parameter_list|,
name|LockGraphNode
name|node2
parameter_list|)
block|{
name|super
argument_list|(
name|node1
operator|.
name|getLockName
argument_list|()
operator|+
literal|" -> "
operator|+
name|node2
operator|.
name|getLockName
argument_list|()
argument_list|)
expr_stmt|;
name|StackTraceElement
index|[]
name|origStackTrace
init|=
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|origStackTrace
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|WithExplicitOrdering
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|origStackTrace
index|[
name|i
index|]
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
comment|// For pre-populated disallowedPriorLocks edges, omit the stack trace.
name|setStackTrace
argument_list|(
name|EMPTY_STACK_TRACE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|EXCLUDED_CLASS_NAMES
operator|.
name|contains
argument_list|(
name|origStackTrace
index|[
name|i
index|]
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
name|setStackTrace
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|origStackTrace
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**    * Represents a detected cycle in lock acquisition ordering. The exception includes a causal chain    * of {@code ExampleStackTrace} instances to illustrate the cycle, e.g.    *    *<pre>    * com....PotentialDeadlockException: Potential Deadlock from LockC -&gt; ReadWriteA    *   at ...    *   at ...    * Caused by: com...ExampleStackTrace: LockB -&gt; LockC    *   at ...    *   at ...    * Caused by: com...ExampleStackTrace: ReadWriteA -&gt; LockB    *   at ...    *   at ...    *</pre>    *    *<p>Instances are logged for the {@code Policies.WARN}, and thrown for {@code Policies.THROW}.    *    * @since 13.0    */
annotation|@
name|Beta
DECL|class|PotentialDeadlockException
specifier|public
specifier|static
specifier|final
class|class
name|PotentialDeadlockException
extends|extends
name|ExampleStackTrace
block|{
DECL|field|conflictingStackTrace
specifier|private
specifier|final
name|ExampleStackTrace
name|conflictingStackTrace
decl_stmt|;
DECL|method|PotentialDeadlockException ( LockGraphNode node1, LockGraphNode node2, ExampleStackTrace conflictingStackTrace)
specifier|private
name|PotentialDeadlockException
parameter_list|(
name|LockGraphNode
name|node1
parameter_list|,
name|LockGraphNode
name|node2
parameter_list|,
name|ExampleStackTrace
name|conflictingStackTrace
parameter_list|)
block|{
name|super
argument_list|(
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
name|this
operator|.
name|conflictingStackTrace
operator|=
name|conflictingStackTrace
expr_stmt|;
name|initCause
argument_list|(
name|conflictingStackTrace
argument_list|)
expr_stmt|;
block|}
DECL|method|getConflictingStackTrace ()
specifier|public
name|ExampleStackTrace
name|getConflictingStackTrace
parameter_list|()
block|{
return|return
name|conflictingStackTrace
return|;
block|}
comment|/**      * Appends the chain of messages from the {@code conflictingStackTrace} to the original {@code      * message}.      */
annotation|@
name|Override
DECL|method|getMessage ()
specifier|public
name|String
name|getMessage
parameter_list|()
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Throwable
name|t
init|=
name|conflictingStackTrace
init|;
name|t
operator|!=
literal|null
condition|;
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
control|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|message
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Internal Lock implementations implement the {@code CycleDetectingLock} interface, allowing the    * detection logic to treat all locks in the same manner.    */
DECL|interface|CycleDetectingLock
specifier|private
interface|interface
name|CycleDetectingLock
block|{
comment|/** @return the {@link LockGraphNode} associated with this lock. */
DECL|method|getLockGraphNode ()
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
function_decl|;
comment|/** @return {@code true} if the current thread has acquired this lock. */
DECL|method|isAcquiredByCurrentThread ()
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
function_decl|;
block|}
comment|/**    * A {@code LockGraphNode} associated with each lock instance keeps track of the directed edges in    * the lock acquisition graph.    */
DECL|class|LockGraphNode
specifier|private
specifier|static
class|class
name|LockGraphNode
block|{
comment|/**      * The map tracking the locks that are known to be acquired before this lock, each associated      * with an example stack trace. Locks are weakly keyed to allow proper garbage collection when      * they are no longer referenced.      */
DECL|field|allowedPriorLocks
specifier|final
name|Map
argument_list|<
name|LockGraphNode
argument_list|,
name|ExampleStackTrace
argument_list|>
name|allowedPriorLocks
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
comment|/**      * The map tracking lock nodes that can cause a lock acquisition cycle if acquired before this      * node.      */
DECL|field|disallowedPriorLocks
specifier|final
name|Map
argument_list|<
name|LockGraphNode
argument_list|,
name|PotentialDeadlockException
argument_list|>
name|disallowedPriorLocks
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
DECL|field|lockName
specifier|final
name|String
name|lockName
decl_stmt|;
DECL|method|LockGraphNode (String lockName)
name|LockGraphNode
parameter_list|(
name|String
name|lockName
parameter_list|)
block|{
name|this
operator|.
name|lockName
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
block|}
DECL|method|getLockName ()
name|String
name|getLockName
parameter_list|()
block|{
return|return
name|lockName
return|;
block|}
DECL|method|checkAcquiredLocks (Policy policy, List<LockGraphNode> acquiredLocks)
name|void
name|checkAcquiredLocks
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|List
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLocks
parameter_list|)
block|{
for|for
control|(
name|LockGraphNode
name|acquiredLock
range|:
name|acquiredLocks
control|)
block|{
name|checkAcquiredLock
argument_list|(
name|policy
argument_list|,
name|acquiredLock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Checks the acquisition-ordering between {@code this}, which is about to be acquired, and the      * specified {@code acquiredLock}.      *      *<p>When this method returns, the {@code acquiredLock} should be in either the {@code      * preAcquireLocks} map, for the case in which it is safe to acquire {@code this} after the      * {@code acquiredLock}, or in the {@code disallowedPriorLocks} map, in which case it is not      * safe.      */
DECL|method|checkAcquiredLock (Policy policy, LockGraphNode acquiredLock)
name|void
name|checkAcquiredLock
parameter_list|(
name|Policy
name|policy
parameter_list|,
name|LockGraphNode
name|acquiredLock
parameter_list|)
block|{
comment|// checkAcquiredLock() should never be invoked by a lock that has already
comment|// been acquired. For unordered locks, aboutToAcquire() ensures this by
comment|// checking isAcquiredByCurrentThread(). For ordered locks, however, this
comment|// can happen because multiple locks may share the same LockGraphNode. In
comment|// this situation, throw an IllegalStateException as defined by contract
comment|// described in the documentation of WithExplicitOrdering.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|!=
name|acquiredLock
argument_list|,
literal|"Attempted to acquire multiple locks with the same rank %s"
argument_list|,
name|acquiredLock
operator|.
name|getLockName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowedPriorLocks
operator|.
name|containsKey
argument_list|(
name|acquiredLock
argument_list|)
condition|)
block|{
comment|// The acquisition ordering from "acquiredLock" to "this" has already
comment|// been verified as safe. In a properly written application, this is
comment|// the common case.
return|return;
block|}
name|PotentialDeadlockException
name|previousDeadlockException
init|=
name|disallowedPriorLocks
operator|.
name|get
argument_list|(
name|acquiredLock
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousDeadlockException
operator|!=
literal|null
condition|)
block|{
comment|// Previously determined to be an unsafe lock acquisition.
comment|// Create a new PotentialDeadlockException with the same causal chain
comment|// (the example cycle) as that of the cached exception.
name|PotentialDeadlockException
name|exception
init|=
operator|new
name|PotentialDeadlockException
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|,
name|previousDeadlockException
operator|.
name|getConflictingStackTrace
argument_list|()
argument_list|)
decl_stmt|;
name|policy
operator|.
name|handlePotentialDeadlock
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Otherwise, it's the first time seeing this lock relationship. Look for
comment|// a path from the acquiredLock to this.
name|Set
argument_list|<
name|LockGraphNode
argument_list|>
name|seen
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
name|ExampleStackTrace
name|path
init|=
name|acquiredLock
operator|.
name|findPathTo
argument_list|(
name|this
argument_list|,
name|seen
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|// this can be safely acquired after the acquiredLock.
comment|//
comment|// Note that there is a race condition here which can result in missing
comment|// a cyclic edge: it's possible for two threads to simultaneous find
comment|// "safe" edges which together form a cycle. Preventing this race
comment|// condition efficiently without _introducing_ deadlock is probably
comment|// tricky. For now, just accept the race condition---missing a warning
comment|// now and then is still better than having no deadlock detection.
name|allowedPriorLocks
operator|.
name|put
argument_list|(
name|acquiredLock
argument_list|,
operator|new
name|ExampleStackTrace
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Unsafe acquisition order detected. Create and cache a
comment|// PotentialDeadlockException.
name|PotentialDeadlockException
name|exception
init|=
operator|new
name|PotentialDeadlockException
argument_list|(
name|acquiredLock
argument_list|,
name|this
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|disallowedPriorLocks
operator|.
name|put
argument_list|(
name|acquiredLock
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|policy
operator|.
name|handlePotentialDeadlock
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Performs a depth-first traversal of the graph edges defined by each node's {@code      * allowedPriorLocks} to find a path between {@code this} and the specified {@code lock}.      *      * @return If a path was found, a chained {@link ExampleStackTrace} illustrating the path to the      *     {@code lock}, or {@code null} if no path was found.      */
DECL|method|findPathTo (LockGraphNode node, Set<LockGraphNode> seen)
specifier|private
annotation|@
name|Nullable
name|ExampleStackTrace
name|findPathTo
parameter_list|(
name|LockGraphNode
name|node
parameter_list|,
name|Set
argument_list|<
name|LockGraphNode
argument_list|>
name|seen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|seen
operator|.
name|add
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
comment|// Already traversed this node.
block|}
name|ExampleStackTrace
name|found
init|=
name|allowedPriorLocks
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
return|return
name|found
return|;
comment|// Found a path ending at the node!
block|}
comment|// Recurse the edges.
for|for
control|(
name|Entry
argument_list|<
name|LockGraphNode
argument_list|,
name|ExampleStackTrace
argument_list|>
name|entry
range|:
name|allowedPriorLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LockGraphNode
name|preAcquiredLock
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|found
operator|=
name|preAcquiredLock
operator|.
name|findPathTo
argument_list|(
name|node
argument_list|,
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
comment|// One of this node's allowedPriorLocks found a path. Prepend an
comment|// ExampleStackTrace(preAcquiredLock, this) to the returned chain of
comment|// ExampleStackTraces.
name|ExampleStackTrace
name|path
init|=
operator|new
name|ExampleStackTrace
argument_list|(
name|preAcquiredLock
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|path
operator|.
name|setStackTrace
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|initCause
argument_list|(
name|found
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * CycleDetectingLock implementations must call this method before attempting to acquire the lock.    */
DECL|method|aboutToAcquire (CycleDetectingLock lock)
specifier|private
name|void
name|aboutToAcquire
parameter_list|(
name|CycleDetectingLock
name|lock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lock
operator|.
name|isAcquiredByCurrentThread
argument_list|()
condition|)
block|{
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLockList
init|=
name|acquiredLocks
operator|.
name|get
argument_list|()
decl_stmt|;
name|LockGraphNode
name|node
init|=
name|lock
operator|.
name|getLockGraphNode
argument_list|()
decl_stmt|;
name|node
operator|.
name|checkAcquiredLocks
argument_list|(
name|policy
argument_list|,
name|acquiredLockList
argument_list|)
expr_stmt|;
name|acquiredLockList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * CycleDetectingLock implementations must call this method in a {@code finally} clause after any    * attempt to change the lock state, including both lock and unlock attempts. Failure to do so can    * result in corrupting the acquireLocks set.    */
DECL|method|lockStateChanged (CycleDetectingLock lock)
specifier|private
specifier|static
name|void
name|lockStateChanged
parameter_list|(
name|CycleDetectingLock
name|lock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lock
operator|.
name|isAcquiredByCurrentThread
argument_list|()
condition|)
block|{
name|ArrayList
argument_list|<
name|LockGraphNode
argument_list|>
name|acquiredLockList
init|=
name|acquiredLocks
operator|.
name|get
argument_list|()
decl_stmt|;
name|LockGraphNode
name|node
init|=
name|lock
operator|.
name|getLockGraphNode
argument_list|()
decl_stmt|;
comment|// Iterate in reverse because locks are usually locked/unlocked in a
comment|// LIFO order.
for|for
control|(
name|int
name|i
init|=
name|acquiredLockList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|acquiredLockList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
name|node
condition|)
block|{
name|acquiredLockList
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantLock
specifier|final
class|class
name|CycleDetectingReentrantLock
extends|extends
name|ReentrantLock
implements|implements
name|CycleDetectingLock
block|{
DECL|field|lockGraphNode
specifier|private
specifier|final
name|LockGraphNode
name|lockGraphNode
decl_stmt|;
DECL|method|CycleDetectingReentrantLock (LockGraphNode lockGraphNode, boolean fair)
specifier|private
name|CycleDetectingReentrantLock
parameter_list|(
name|LockGraphNode
name|lockGraphNode
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
name|super
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNode
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockGraphNode
argument_list|)
expr_stmt|;
block|}
comment|///// CycleDetectingLock methods. /////
annotation|@
name|Override
DECL|method|getLockGraphNode ()
specifier|public
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
block|{
return|return
name|lockGraphNode
return|;
block|}
annotation|@
name|Override
DECL|method|isAcquiredByCurrentThread ()
specifier|public
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
block|{
return|return
name|isHeldByCurrentThread
argument_list|()
return|;
block|}
comment|///// Overridden ReentrantLock methods. /////
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantReadWriteLock
specifier|final
class|class
name|CycleDetectingReentrantReadWriteLock
extends|extends
name|ReentrantReadWriteLock
implements|implements
name|CycleDetectingLock
block|{
comment|// These ReadLock/WriteLock implementations shadow those in the
comment|// ReentrantReadWriteLock superclass. They are simply wrappers around the
comment|// internal Sync object, so this is safe since the shadowed locks are never
comment|// exposed or used.
DECL|field|readLock
specifier|private
specifier|final
name|CycleDetectingReentrantReadLock
name|readLock
decl_stmt|;
DECL|field|writeLock
specifier|private
specifier|final
name|CycleDetectingReentrantWriteLock
name|writeLock
decl_stmt|;
DECL|field|lockGraphNode
specifier|private
specifier|final
name|LockGraphNode
name|lockGraphNode
decl_stmt|;
DECL|method|CycleDetectingReentrantReadWriteLock (LockGraphNode lockGraphNode, boolean fair)
specifier|private
name|CycleDetectingReentrantReadWriteLock
parameter_list|(
name|LockGraphNode
name|lockGraphNode
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
name|super
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|this
operator|.
name|readLock
operator|=
operator|new
name|CycleDetectingReentrantReadLock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
operator|new
name|CycleDetectingReentrantWriteLock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|lockGraphNode
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lockGraphNode
argument_list|)
expr_stmt|;
block|}
comment|///// Overridden ReentrantReadWriteLock methods. /////
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|ReadLock
name|readLock
parameter_list|()
block|{
return|return
name|readLock
return|;
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|WriteLock
name|writeLock
parameter_list|()
block|{
return|return
name|writeLock
return|;
block|}
comment|///// CycleDetectingLock methods. /////
annotation|@
name|Override
DECL|method|getLockGraphNode ()
specifier|public
name|LockGraphNode
name|getLockGraphNode
parameter_list|()
block|{
return|return
name|lockGraphNode
return|;
block|}
annotation|@
name|Override
DECL|method|isAcquiredByCurrentThread ()
specifier|public
name|boolean
name|isAcquiredByCurrentThread
parameter_list|()
block|{
return|return
name|isWriteLockedByCurrentThread
argument_list|()
operator|||
name|getReadHoldCount
argument_list|()
operator|>
literal|0
return|;
block|}
block|}
DECL|class|CycleDetectingReentrantReadLock
specifier|private
class|class
name|CycleDetectingReentrantReadLock
extends|extends
name|ReentrantReadWriteLock
operator|.
name|ReadLock
block|{
DECL|field|readWriteLock
annotation|@
name|Weak
specifier|final
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
decl_stmt|;
DECL|method|CycleDetectingReentrantReadLock (CycleDetectingReentrantReadWriteLock readWriteLock)
name|CycleDetectingReentrantReadLock
parameter_list|(
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
parameter_list|)
block|{
name|super
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
name|this
operator|.
name|readWriteLock
operator|=
name|readWriteLock
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CycleDetectingReentrantWriteLock
specifier|private
class|class
name|CycleDetectingReentrantWriteLock
extends|extends
name|ReentrantReadWriteLock
operator|.
name|WriteLock
block|{
DECL|field|readWriteLock
annotation|@
name|Weak
specifier|final
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
decl_stmt|;
DECL|method|CycleDetectingReentrantWriteLock (CycleDetectingReentrantReadWriteLock readWriteLock)
name|CycleDetectingReentrantWriteLock
parameter_list|(
name|CycleDetectingReentrantReadWriteLock
name|readWriteLock
parameter_list|)
block|{
name|super
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
name|this
operator|.
name|readWriteLock
operator|=
name|readWriteLock
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|lockInterruptibly ()
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock ()
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|()
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|tryLock (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|aboutToAcquire
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|tryLock
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
block|{
try|try
block|{
name|super
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lockStateChanged
argument_list|(
name|readWriteLock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

