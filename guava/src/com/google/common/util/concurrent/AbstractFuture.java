begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
operator|.
name|newUpdater
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An abstract implementation of {@link ListenableFuture}, intended for advanced users only. More  * common ways to create a {@code ListenableFuture} include instantiating a {@link SettableFuture},  * submitting a task to a {@link ListeningExecutorService}, and deriving a {@code Future} from an  * existing one, typically using methods like {@link Futures#transform(ListenableFuture, Function)  * Futures.transform} and {@link Futures#catching(ListenableFuture, Class, Function)  * Futures.catching}.  *  *<p>This class implements all methods in {@code ListenableFuture}. Subclasses should provide a way  * to set the result of the computation through the protected methods {@link #set(Object)}, {@link  * #setFuture(ListenableFuture)} and {@link #setException(Throwable)}. Subclasses may also override  * {@link #interruptTask()}, which will be invoked automatically if a call to {@link  * #cancel(boolean) cancel(true)} succeeds in canceling the future. Subclasses should rarely  * override other methods.  *  * @author Sven Mawson  * @author Luke Sandberg  * @since 1.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|AbstractFuture
specifier|public
specifier|abstract
class|class
name|AbstractFuture
parameter_list|<
name|V
parameter_list|>
implements|implements
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|GENERATE_CANCELLATION_CAUSES
specifier|private
specifier|static
specifier|final
name|boolean
name|GENERATE_CANCELLATION_CAUSES
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"guava.concurrent.generate_cancellation_cause"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * A less abstract subclass of AbstractFuture.  This can be used to optimize setFuture by ensuring    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.    */
DECL|class|TrustedFuture
specifier|abstract
specifier|static
class|class
name|TrustedFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractFuture
argument_list|<
name|V
argument_list|>
block|{
comment|// N.B. cancel is not overridden to be final, because many future utilities need to override
comment|// cancel in order to propagate cancellation to other futures.
comment|// TODO(lukes): with maybePropagateCancellation this is no longer really true.  Track down the
comment|// final few cases and eliminate their overrides of cancel()
annotation|@
name|Override
DECL|method|get ()
specifier|public
specifier|final
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|super
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
specifier|final
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|super
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isDone ()
specifier|public
specifier|final
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|super
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
specifier|final
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|super
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor executor)
specifier|public
specifier|final
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|super
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Logger to log exceptions caught when running listeners.
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|AbstractFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// A heuristic for timed gets.  If the remaining timeout is less than this, spin instead of
comment|// blocking.  This value is what AbstractQueuedSynchronizer uses.
DECL|field|SPIN_THRESHOLD_NANOS
specifier|private
specifier|static
specifier|final
name|long
name|SPIN_THRESHOLD_NANOS
init|=
literal|1000L
decl_stmt|;
DECL|field|ATOMIC_HELPER
specifier|private
specifier|static
specifier|final
name|AtomicHelper
name|ATOMIC_HELPER
decl_stmt|;
DECL|field|WAITER_THREAD_UPDATER
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Thread
argument_list|>
name|WAITER_THREAD_UPDATER
decl_stmt|;
DECL|field|WAITER_NEXT_UPDATER
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|Waiter
argument_list|,
name|Waiter
argument_list|>
name|WAITER_NEXT_UPDATER
decl_stmt|;
DECL|field|WAITERS_UPDATER
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Waiter
argument_list|>
name|WAITERS_UPDATER
decl_stmt|;
DECL|field|LISTENERS_UPDATER
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Listener
argument_list|>
name|LISTENERS_UPDATER
decl_stmt|;
DECL|field|VALUE_UPDATER
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|AbstractFuture
argument_list|,
name|Object
argument_list|>
name|VALUE_UPDATER
decl_stmt|;
static|static
block|{
name|AtomicHelper
name|helper
init|=
literal|null
decl_stmt|;
try|try
block|{
name|helper
operator|=
operator|new
name|UnsafeAtomicHelper
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// catch absolutely everything and fall through
block|}
if|if
condition|(
name|helper
operator|==
literal|null
condition|)
block|{
comment|// The access control checks that ARFU does means the caller class has to be AbstractFuture
comment|// instead of SafeAtomicHelper, so we annoyingly define these here
name|WAITER_THREAD_UPDATER
operator|=
name|newUpdater
argument_list|(
name|Waiter
operator|.
name|class
argument_list|,
name|Thread
operator|.
name|class
argument_list|,
literal|"thread"
argument_list|)
expr_stmt|;
name|WAITER_NEXT_UPDATER
operator|=
name|newUpdater
argument_list|(
name|Waiter
operator|.
name|class
argument_list|,
name|Waiter
operator|.
name|class
argument_list|,
literal|"next"
argument_list|)
expr_stmt|;
name|WAITERS_UPDATER
operator|=
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Waiter
operator|.
name|class
argument_list|,
literal|"waiters"
argument_list|)
expr_stmt|;
name|LISTENERS_UPDATER
operator|=
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Listener
operator|.
name|class
argument_list|,
literal|"listeners"
argument_list|)
expr_stmt|;
name|VALUE_UPDATER
operator|=
name|newUpdater
argument_list|(
name|AbstractFuture
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
name|helper
operator|=
operator|new
name|SafeAtomicHelper
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|WAITER_THREAD_UPDATER
operator|=
literal|null
expr_stmt|;
name|WAITER_NEXT_UPDATER
operator|=
literal|null
expr_stmt|;
name|WAITERS_UPDATER
operator|=
literal|null
expr_stmt|;
name|LISTENERS_UPDATER
operator|=
literal|null
expr_stmt|;
name|VALUE_UPDATER
operator|=
literal|null
expr_stmt|;
block|}
name|ATOMIC_HELPER
operator|=
name|helper
expr_stmt|;
comment|// Prevent rare disastrous classloading in first call to LockSupport.park.
comment|// See: https://bugs.openjdk.java.net/browse/JDK-8074773
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|Class
argument_list|<
name|?
argument_list|>
name|ensureLoaded
init|=
name|LockSupport
operator|.
name|class
decl_stmt|;
block|}
comment|/**    * Waiter links form a Treiber stack, in the {@link #waiters} field.    */
DECL|class|Waiter
specifier|private
specifier|static
specifier|final
class|class
name|Waiter
block|{
DECL|field|TOMBSTONE
specifier|static
specifier|final
name|Waiter
name|TOMBSTONE
init|=
operator|new
name|Waiter
argument_list|(
literal|false
comment|/* ignored param */
argument_list|)
decl_stmt|;
DECL|field|thread
annotation|@
name|Nullable
specifier|volatile
name|Thread
name|thread
decl_stmt|;
DECL|field|next
annotation|@
name|Nullable
specifier|volatile
name|Waiter
name|next
decl_stmt|;
comment|/**      * Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded      * before the ATOMIC_HELPER. Apparently this is possible on some android platforms.      */
DECL|method|Waiter (boolean unused)
name|Waiter
parameter_list|(
name|boolean
name|unused
parameter_list|)
block|{}
DECL|method|Waiter ()
name|Waiter
parameter_list|()
block|{
comment|// avoid volatile write, write is made visible by subsequent CAS on waiters field
name|ATOMIC_HELPER
operator|.
name|putThread
argument_list|(
name|this
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// non-volatile write to the next field. Should be made visible by subsequent CAS on waiters
comment|// field.
DECL|method|setNext (Waiter next)
name|void
name|setNext
parameter_list|(
name|Waiter
name|next
parameter_list|)
block|{
name|ATOMIC_HELPER
operator|.
name|putNext
argument_list|(
name|this
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
DECL|method|unpark ()
name|void
name|unpark
parameter_list|()
block|{
comment|// This is racy with removeWaiter.  The consequence of the race is that we may spuriously
comment|// call unpark even though the thread has already removed itself from the list.  But even if
comment|// we did use a CAS, that race would still exist (it would just be ever so slightly smaller).
name|Thread
name|w
init|=
name|thread
decl_stmt|;
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Marks the given node as 'deleted' (null waiter) and then scans the list to unlink all deleted    * nodes.  This is an O(n) operation in the common case (and O(n^2) in the worst), but we are    * saved by two things.    *<ul>    *<li>This is only called when a waiting thread times out or is interrupted.  Both of which    *       should be rare.    *<li>The waiters list should be very short.    *</ul>    */
DECL|method|removeWaiter (Waiter node)
specifier|private
name|void
name|removeWaiter
parameter_list|(
name|Waiter
name|node
parameter_list|)
block|{
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
comment|// mark as 'deleted'
name|restart
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|Waiter
name|pred
init|=
literal|null
decl_stmt|;
name|Waiter
name|curr
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|curr
operator|==
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
return|return;
comment|// give up if someone is calling complete
block|}
name|Waiter
name|succ
decl_stmt|;
while|while
condition|(
name|curr
operator|!=
literal|null
condition|)
block|{
name|succ
operator|=
name|curr
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|.
name|thread
operator|!=
literal|null
condition|)
block|{
comment|// we aren't unlinking this node, update pred.
name|pred
operator|=
name|curr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
block|{
comment|// We are unlinking this node and it has a predecessor.
name|pred
operator|.
name|next
operator|=
name|succ
expr_stmt|;
if|if
condition|(
name|pred
operator|.
name|thread
operator|==
literal|null
condition|)
block|{
comment|// We raced with another node that unlinked pred. Restart.
continue|continue
name|restart
continue|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|curr
argument_list|,
name|succ
argument_list|)
condition|)
block|{
comment|// We are unlinking head
continue|continue
name|restart
continue|;
comment|// We raced with an add or complete
block|}
name|curr
operator|=
name|succ
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/** Listeners also form a stack through the {@link #listeners} field. */
DECL|class|Listener
specifier|private
specifier|static
specifier|final
class|class
name|Listener
block|{
DECL|field|TOMBSTONE
specifier|static
specifier|final
name|Listener
name|TOMBSTONE
init|=
operator|new
name|Listener
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
DECL|field|task
specifier|final
name|Runnable
name|task
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
comment|// writes to next are made visible by subsequent CAS's on the listeners field
DECL|field|next
annotation|@
name|Nullable
name|Listener
name|next
decl_stmt|;
DECL|method|Listener (Runnable task, Executor executor)
name|Listener
parameter_list|(
name|Runnable
name|task
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
block|}
comment|/** A special value to represent {@code null}. */
DECL|field|NULL
specifier|private
specifier|static
specifier|final
name|Object
name|NULL
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/** A special value to represent failure, when {@link #setException} is called successfully. */
DECL|class|Failure
specifier|private
specifier|static
specifier|final
class|class
name|Failure
block|{
DECL|field|FALLBACK_INSTANCE
specifier|static
specifier|final
name|Failure
name|FALLBACK_INSTANCE
init|=
operator|new
name|Failure
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"Failure occurred while trying to finish a future."
argument_list|)
block|{
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Throwable
name|fillInStackTrace
parameter_list|()
block|{
return|return
name|this
return|;
comment|// no stack trace
block|}
block|}
argument_list|)
decl_stmt|;
DECL|field|exception
specifier|final
name|Throwable
name|exception
decl_stmt|;
DECL|method|Failure (Throwable exception)
name|Failure
parameter_list|(
name|Throwable
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|checkNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** A special value to represent cancellation and the 'wasInterrupted' bit. */
DECL|class|Cancellation
specifier|private
specifier|static
specifier|final
class|class
name|Cancellation
block|{
DECL|field|wasInterrupted
specifier|final
name|boolean
name|wasInterrupted
decl_stmt|;
DECL|field|cause
annotation|@
name|Nullable
specifier|final
name|Throwable
name|cause
decl_stmt|;
DECL|method|Cancellation (boolean wasInterrupted, @Nullable Throwable cause)
name|Cancellation
parameter_list|(
name|boolean
name|wasInterrupted
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|cause
parameter_list|)
block|{
name|this
operator|.
name|wasInterrupted
operator|=
name|wasInterrupted
expr_stmt|;
name|this
operator|.
name|cause
operator|=
name|cause
expr_stmt|;
block|}
block|}
comment|/** A special value that encodes the 'setFuture' state. */
DECL|class|SetFuture
specifier|private
specifier|final
class|class
name|SetFuture
implements|implements
name|Runnable
block|{
DECL|field|future
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
decl_stmt|;
DECL|method|SetFuture (ListenableFuture<? extends V> future)
name|SetFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|value
operator|!=
name|this
condition|)
block|{
comment|// nothing to do, we must have been cancelled
return|return;
block|}
name|completeWithFuture
argument_list|(
name|future
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO(lukes): investigate using the @Contended annotation on these fields when jdk8 is
comment|// available.
comment|/**    * This field encodes the current state of the future.    *    *<p>The valid values are:    *<ul>    *<li>{@code null} initial state, nothing has happened.    *<li>{@link Cancellation} terminal state, {@code cancel} was called.    *<li>{@link Failure} terminal state, {@code setException} was called.    *<li>{@link SetFuture} intermediate state, {@code setFuture} was called.    *<li>{@link #NULL} terminal state, {@code set(null)} was called.    *<li>Any other non-null value, terminal state, {@code set} was called with a non-null    *       argument.    *</ul>    */
DECL|field|value
specifier|private
specifier|volatile
name|Object
name|value
decl_stmt|;
comment|/** All listeners. */
DECL|field|listeners
specifier|private
specifier|volatile
name|Listener
name|listeners
decl_stmt|;
comment|/** All waiting threads. */
DECL|field|waiters
specifier|private
specifier|volatile
name|Waiter
name|waiters
decl_stmt|;
comment|/**    * Constructor for use by subclasses.    */
DECL|method|AbstractFuture ()
specifier|protected
name|AbstractFuture
parameter_list|()
block|{}
comment|// Gets and Timed Gets
comment|//
comment|// * Be responsive to interruption
comment|// * Don't create Waiter nodes if you aren't going to park, this helps reduce contention on the
comment|//   waiters field.
comment|// * Future completion is defined by when #value becomes non-null/non SetFuture
comment|// * Future completion can be observed if the waiters field contains a TOMBSTONE
comment|// Timed Get
comment|// There are a few design constraints to consider
comment|// * We want to be responsive to small timeouts, unpark() has non trivial latency overheads (I
comment|//   have observed 12 micros on 64 bit linux systems to wake up a parked thread).  So if the
comment|//   timeout is small we shouldn't park().  This needs to be traded off with the cpu overhead of
comment|//   spinning, so we use SPIN_THRESHOLD_NANOS which is what AbstractQueuedSynchronizer uses for
comment|//   similar purposes.
comment|// * We want to behave reasonably for timeouts of 0
comment|// * We are more responsive to completion than timeouts.  This is because parkNanos depends on
comment|//   system scheduling and as such we could either miss our deadline, or unpark() could be delayed
comment|//   so that it looks like we timed out even though we didn't.  For comparison FutureTask respects
comment|//   completion preferably and AQS is non-deterministic (depends on where in the queue the waiter
comment|//   is).  If we wanted to be strict about it, we could store the unpark() time in the Waiter
comment|//   node and we could use that to make a decision about whether or not we timed out prior to
comment|//   being unparked.
comment|/*    * Improve the documentation of when InterruptedException is thrown. Our behavior matches the    * JDK's, but the JDK's documentation is misleading.    */
comment|/**    * {@inheritDoc}    *    *<p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the    * current thread is interrupted before or during the call, even if the value is already    * available.    *    * @throws InterruptedException if the current thread was interrupted before or during the call    *     (optional but recommended).    * @throws CancellationException {@inheritDoc}    */
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
throws|,
name|ExecutionException
block|{
comment|// NOTE: if timeout< 0, remainingNanos will be< 0 and we will fall into the while(true) loop
comment|// at the bottom and throw a timeoutexception.
name|long
name|remainingNanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
comment|// we rely on the implicit null check on unit.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
comment|// we delay calling nanoTime until we know we will need to either park or spin
specifier|final
name|long
name|endNanos
init|=
name|remainingNanos
operator|>
literal|0
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|remainingNanos
else|:
literal|0
decl_stmt|;
name|long_wait_loop
label|:
if|if
condition|(
name|remainingNanos
operator|>=
name|SPIN_THRESHOLD_NANOS
condition|)
block|{
name|Waiter
name|oldHead
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
name|Waiter
name|node
init|=
operator|new
name|Waiter
argument_list|()
decl_stmt|;
do|do
block|{
name|node
operator|.
name|setNext
argument_list|(
name|oldHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|node
argument_list|)
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|remainingNanos
argument_list|)
expr_stmt|;
comment|// Check interruption first, if we woke up due to interruption we need to honor that.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|// Otherwise re-read and check doneness.  If we loop then it must have been a spurious
comment|// wakeup
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
comment|// timed out?
name|remainingNanos
operator|=
name|endNanos
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|remainingNanos
operator|<
name|SPIN_THRESHOLD_NANOS
condition|)
block|{
comment|// Remove the waiter, one way or another we are done parking this thread.
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break
name|long_wait_loop
break|;
comment|// jump down to the busy wait loop
block|}
block|}
block|}
name|oldHead
operator|=
name|waiters
expr_stmt|;
comment|// re-read and loop.
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
comment|// re-read value, if we get here then we must have observed a TOMBSTONE while trying to add a
comment|// waiter.
return|return
name|getDoneValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|// If we get here then we have remainingNanos< SPIN_THRESHOLD_NANOS and there is no node on the
comment|// waiters list
while|while
condition|(
name|remainingNanos
operator|>
literal|0
condition|)
block|{
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|remainingNanos
operator|=
name|endNanos
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
comment|/*    * Improve the documentation of when InterruptedException is thrown. Our behavior matches the    * JDK's, but the JDK's documentation is misleading.    */
comment|/**    * {@inheritDoc}    *    *<p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the    * current thread is interrupted before or during the call, even if the value is already    * available.    *    * @throws InterruptedException if the current thread was interrupted before or during the call    *     (optional but recommended).    * @throws CancellationException {@inheritDoc}    */
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
name|Waiter
name|oldHead
init|=
name|waiters
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
block|{
name|Waiter
name|node
init|=
operator|new
name|Waiter
argument_list|()
decl_stmt|;
do|do
block|{
name|node
operator|.
name|setNext
argument_list|(
name|oldHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|node
argument_list|)
condition|)
block|{
comment|// we are on the stack, now wait for completion.
while|while
condition|(
literal|true
condition|)
block|{
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Check interruption first, if we woke up due to interruption we need to honor that.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|removeWaiter
argument_list|(
name|node
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|// Otherwise re-read and check doneness.  If we loop then it must have been a spurious
comment|// wakeup
name|localValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
condition|)
block|{
return|return
name|getDoneValue
argument_list|(
name|localValue
argument_list|)
return|;
block|}
block|}
block|}
name|oldHead
operator|=
name|waiters
expr_stmt|;
comment|// re-read and loop.
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Waiter
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
comment|// re-read value, if we get here then we must have observed a TOMBSTONE while trying to add a
comment|// waiter.
return|return
name|getDoneValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Unboxes {@code obj}.  Assumes that obj is not {@code null} or a {@link SetFuture}.    */
DECL|method|getDoneValue (Object obj)
specifier|private
name|V
name|getDoneValue
parameter_list|(
name|Object
name|obj
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|// While this seems like it might be too branch-y, simple benchmarking proves it to be
comment|// unmeasurable (comparing done AbstractFutures with immediateFuture)
if|if
condition|(
name|obj
operator|instanceof
name|Cancellation
condition|)
block|{
throw|throw
name|cancellationExceptionWithCause
argument_list|(
literal|"Task was cancelled."
argument_list|,
operator|(
operator|(
name|Cancellation
operator|)
name|obj
operator|)
operator|.
name|cause
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Failure
condition|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
operator|(
operator|(
name|Failure
operator|)
name|obj
operator|)
operator|.
name|exception
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// this is the only other option
name|V
name|asV
init|=
operator|(
name|V
operator|)
name|obj
decl_stmt|;
return|return
name|asV
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|isDone ()
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
name|localValue
operator|!=
literal|null
operator|&
operator|!
operator|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
name|localValue
operator|instanceof
name|Cancellation
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>If a cancellation attempt succeeds on a {@code Future} that had previously been {@linkplain    * #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate    * {@code Future} that was supplied in the {@code setFuture} call.    */
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|==
literal|null
operator||
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
condition|)
block|{
comment|// Try to delay allocating the exception.  At this point we may still lose the CAS, but it is
comment|// certainly less likely.
comment|// TODO(lukes): this exception actually makes cancellation significantly more expensive :(
comment|// I wonder if we should consider removing it or providing a mechanism to not do it.
name|Throwable
name|cause
init|=
name|GENERATE_CANCELLATION_CAUSES
condition|?
operator|new
name|CancellationException
argument_list|(
literal|"Future.cancel() was called."
argument_list|)
else|:
literal|null
decl_stmt|;
name|Object
name|valueToSet
init|=
operator|new
name|Cancellation
argument_list|(
name|mayInterruptIfRunning
argument_list|,
name|cause
argument_list|)
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
name|localValue
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
comment|// We call interuptTask before calling complete(), first which is consistent with
comment|// FutureTask
if|if
condition|(
name|mayInterruptIfRunning
condition|)
block|{
name|interruptTask
argument_list|()
expr_stmt|;
block|}
name|complete
argument_list|()
expr_stmt|;
if|if
condition|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
condition|)
block|{
comment|// propagate cancellation to the future set in setfuture, this is racy, and we don't
comment|// care if we are successful or not.
operator|(
operator|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
operator|.
name|SetFuture
operator|)
name|localValue
operator|)
operator|.
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// obj changed, reread
name|localValue
operator|=
name|value
expr_stmt|;
comment|// obj cannot be null at this point, because value can only change from null to non-null. So
comment|// if value changed (and it did since we lost the CAS), then it cannot be null.
block|}
do|while
condition|(
name|localValue
operator|instanceof
name|AbstractFuture
operator|.
name|SetFuture
condition|)
do|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Subclasses can override this method to implement interruption of the future's computation. The    * method is invoked automatically by a successful call to {@link #cancel(boolean) cancel(true)}.    *    *<p>The default implementation does nothing.    *    * @since 10.0    */
DECL|method|interruptTask ()
specifier|protected
name|void
name|interruptTask
parameter_list|()
block|{}
comment|/**    * Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code    * true}.    *    * @since 14.0    */
DECL|method|wasInterrupted ()
specifier|protected
specifier|final
name|boolean
name|wasInterrupted
parameter_list|()
block|{
specifier|final
name|Object
name|localValue
init|=
name|value
decl_stmt|;
return|return
operator|(
name|localValue
operator|instanceof
name|Cancellation
operator|)
operator|&&
operator|(
operator|(
name|Cancellation
operator|)
name|localValue
operator|)
operator|.
name|wasInterrupted
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @since 10.0    */
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|,
literal|"Runnable was null."
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|executor
argument_list|,
literal|"Executor was null."
argument_list|)
expr_stmt|;
name|Listener
name|oldHead
init|=
name|listeners
decl_stmt|;
if|if
condition|(
name|oldHead
operator|!=
name|Listener
operator|.
name|TOMBSTONE
condition|)
block|{
name|Listener
name|newNode
init|=
operator|new
name|Listener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
decl_stmt|;
do|do
block|{
name|newNode
operator|.
name|next
operator|=
name|oldHead
expr_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casListeners
argument_list|(
name|this
argument_list|,
name|oldHead
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
return|return;
block|}
name|oldHead
operator|=
name|listeners
expr_stmt|;
comment|// re-read
block|}
do|while
condition|(
name|oldHead
operator|!=
name|Listener
operator|.
name|TOMBSTONE
condition|)
do|;
block|}
comment|// If we get here then the Listener TOMBSTONE was set, which means the future is done, call
comment|// the listener.
name|executeListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the result of this {@code Future} unless this {@code Future} has already been cancelled or    * set (including {@linkplain #setFuture set asynchronously}). When a call to this method returns,    * the {@code Future} is guaranteed to be {@linkplain #isDone done}<b>only if</b> the call was    * accepted (in which case it returns {@code true}). If it returns {@code false}, the {@code    * Future} may have previously been set asynchronously, in which case its result may not be known    * yet. That result, though not yet known, cannot by overridden by a call to a {@code set*}    * method, only by a call to {@link #cancel}.    *    * @param value the value to be used as the result    * @return true if the attempt was accepted, completing the {@code Future}    */
DECL|method|set (@ullable V value)
specifier|protected
name|boolean
name|set
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|Object
name|valueToSet
init|=
name|value
operator|==
literal|null
condition|?
name|NULL
else|:
name|value
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Sets the failed result of this {@code Future} unless this {@code Future} has already been    * cancelled or set (including {@linkplain #setFuture set asynchronously}). When a call to this    * method returns, the {@code Future} is guaranteed to be {@linkplain #isDone done}<b>only if</b>    * the call was accepted (in which case it returns {@code true}). If it returns {@code false}, the    * {@code Future} may have previously been set asynchronously, in which case its result may not be    * known yet. That result, though not yet known, cannot by overridden by a call to a {@code set*}    * method, only by a call to {@link #cancel}.    *    * @param throwable the exception to be used as the failed result    * @return true if the attempt was accepted, completing the {@code Future}    */
DECL|method|setException (Throwable throwable)
specifier|protected
name|boolean
name|setException
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|Object
name|valueToSet
init|=
operator|new
name|Failure
argument_list|(
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Sets the result of this {@code Future} to match the supplied input {@code Future} once the    * supplied {@code Future} is done, unless this {@code Future} has already been cancelled or set    * (including "set asynchronously," defined below).    *    *<p>If the supplied future is {@linkplain #isDone done} when this method is called and the call    * is accepted, then this future is guaranteed to have been completed with the supplied future by    * the time this method returns. If the supplied future is not done and the call is accepted, then    * the future will be<i>set asynchronously</i>. Note that such a result, though not yet known,    * cannot by overridden by a call to a {@code set*} method, only by a call to {@link #cancel}.    *    *<p>If the call {@code setFuture(delegate)} is accepted and this {@code Future} is later    * cancelled, cancellation will be propagated to {@code delegate}. Additionally, any call to    * {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code    * Future}.    *    * @param future the future to delegate to    * @return true if the attempt was accepted, indicating that the {@code Future} was not previously    *     cancelled or set.    * @since 19.0    */
annotation|@
name|Beta
DECL|method|setFuture (ListenableFuture<? extends V> future)
specifier|protected
name|boolean
name|setFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|Object
name|localValue
init|=
name|value
decl_stmt|;
if|if
condition|(
name|localValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
return|return
name|completeWithFuture
argument_list|(
name|future
argument_list|,
literal|null
argument_list|)
return|;
block|}
name|SetFuture
name|valueToSet
init|=
operator|new
name|SetFuture
argument_list|(
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
comment|// the listener is responsible for calling completeWithFuture, directExecutor is appropriate
comment|// since all we are doing is unpacking a completed future which should be fast.
try|try
block|{
name|future
operator|.
name|addListener
argument_list|(
name|valueToSet
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// addListener has thrown an exception!  SetFuture.run can't throw any exceptions so this
comment|// must have been caused by addListener itself.  The most likely explanation is a
comment|// misconfigured mock.  Try to switch to Failure.
name|Failure
name|failure
decl_stmt|;
try|try
block|{
name|failure
operator|=
operator|new
name|Failure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|oomMostLikely
parameter_list|)
block|{
name|failure
operator|=
name|Failure
operator|.
name|FALLBACK_INSTANCE
expr_stmt|;
block|}
comment|// Note: The only way this CAS could fail is if cancel() has raced with us. That is ok.
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|this
argument_list|,
name|valueToSet
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|localValue
operator|=
name|value
expr_stmt|;
comment|// we lost the cas, fall through and maybe cancel
block|}
comment|// The future has already been set to something.  If it is cancellation we should cancel the
comment|// incoming future.
if|if
condition|(
name|localValue
operator|instanceof
name|Cancellation
condition|)
block|{
comment|// we don't care if it fails, this is best-effort.
name|future
operator|.
name|cancel
argument_list|(
operator|(
operator|(
name|Cancellation
operator|)
name|localValue
operator|)
operator|.
name|wasInterrupted
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Called when a future passed via setFuture has completed.    *    * @param future the done future to complete this future with.    * @param expected the expected value of the {@link #value} field.    */
DECL|method|completeWithFuture (ListenableFuture<? extends V> future, Object expected)
specifier|private
name|boolean
name|completeWithFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|,
name|Object
name|expected
parameter_list|)
block|{
name|Object
name|valueToSet
decl_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|TrustedFuture
condition|)
block|{
comment|// Break encapsulation for TrustedFuture instances since we know that subclasses cannot
comment|// override .get() (since it is final) and therefore this is equivalent to calling .get()
comment|// and unpacking the exceptions like we do below (just much faster because it is a single
comment|// field read instead of a read, several branches and possibly creating exceptions).
name|valueToSet
operator|=
operator|(
operator|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
operator|)
name|future
operator|)
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise calculate valueToSet by calling .get()
try|try
block|{
name|V
name|v
init|=
name|Uninterruptibles
operator|.
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
decl_stmt|;
name|valueToSet
operator|=
name|v
operator|==
literal|null
condition|?
name|NULL
else|:
name|v
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|exception
parameter_list|)
block|{
name|valueToSet
operator|=
operator|new
name|Failure
argument_list|(
name|exception
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|cancellation
parameter_list|)
block|{
name|valueToSet
operator|=
operator|new
name|Cancellation
argument_list|(
literal|false
argument_list|,
name|cancellation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|valueToSet
operator|=
operator|new
name|Failure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The only way this can fail is if we raced with another thread calling cancel(). If we lost
comment|// that race then there is nothing to do.
if|if
condition|(
name|ATOMIC_HELPER
operator|.
name|casValue
argument_list|(
name|AbstractFuture
operator|.
name|this
argument_list|,
name|expected
argument_list|,
name|valueToSet
argument_list|)
condition|)
block|{
name|complete
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Unblocks all threads and runs all listeners. */
DECL|method|complete ()
specifier|private
name|void
name|complete
parameter_list|()
block|{
for|for
control|(
name|Waiter
name|currentWaiter
init|=
name|clearWaiters
argument_list|()
init|;
name|currentWaiter
operator|!=
literal|null
condition|;
name|currentWaiter
operator|=
name|currentWaiter
operator|.
name|next
control|)
block|{
name|currentWaiter
operator|.
name|unpark
argument_list|()
expr_stmt|;
block|}
comment|// We need to reverse the list to handle buggy listeners that depend on ordering.
name|Listener
name|currentListener
init|=
name|clearListeners
argument_list|()
decl_stmt|;
name|Listener
name|reversedList
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|currentListener
operator|!=
literal|null
condition|)
block|{
name|Listener
name|tmp
init|=
name|currentListener
decl_stmt|;
name|currentListener
operator|=
name|currentListener
operator|.
name|next
expr_stmt|;
name|tmp
operator|.
name|next
operator|=
name|reversedList
expr_stmt|;
name|reversedList
operator|=
name|tmp
expr_stmt|;
block|}
for|for
control|(
init|;
name|reversedList
operator|!=
literal|null
condition|;
name|reversedList
operator|=
name|reversedList
operator|.
name|next
control|)
block|{
name|executeListener
argument_list|(
name|reversedList
operator|.
name|task
argument_list|,
name|reversedList
operator|.
name|executor
argument_list|)
expr_stmt|;
block|}
comment|// We call this after the listeners on the theory that done() will only be used for 'cleanup'
comment|// oriented tasks (e.g. clearing fields) and so can wait behind listeners which may be executing
comment|// more important work.  A counter argument would be that done() is trusted code and therefore
comment|// it would be safe to run before potentially slow or poorly behaved listeners.  Reevaluate this
comment|// once we have more examples of done() implementations.
name|done
argument_list|()
expr_stmt|;
block|}
comment|/**     * Callback method that is called immediately after the future is completed.    *     *<p>This is called exactly once, after all listeners have executed.  By default it does nothing.    */
comment|// TODO(cpovirk): @ForOverride https://github.com/google/error-prone/issues/342
DECL|method|done ()
name|void
name|done
parameter_list|()
block|{}
comment|/**    * Returns the exception that this {@code Future} completed with. This includes completion through    * a call to {@link setException} or {@link setFuture}{@code (failedFuture)} but not cancellation.    *    * @throws RuntimeException if the {@code Future} has not failed    */
DECL|method|trustedGetException ()
specifier|final
name|Throwable
name|trustedGetException
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Failure
operator|)
name|value
operator|)
operator|.
name|exception
return|;
block|}
comment|/**    * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)    * the given future (if available).    *    *<p>This method should be used only when this future is completed. It is designed to be called    * from {@code done}.    */
DECL|method|maybePropagateCancellation (@ullable Future<?> related)
specifier|final
name|void
name|maybePropagateCancellation
parameter_list|(
annotation|@
name|Nullable
name|Future
argument_list|<
name|?
argument_list|>
name|related
parameter_list|)
block|{
if|if
condition|(
name|related
operator|!=
literal|null
operator|&
name|isCancelled
argument_list|()
condition|)
block|{
name|related
operator|.
name|cancel
argument_list|(
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Clears the {@link #waiters} list and returns the most recently added value. */
DECL|method|clearWaiters ()
specifier|private
name|Waiter
name|clearWaiters
parameter_list|()
block|{
name|Waiter
name|head
decl_stmt|;
do|do
block|{
name|head
operator|=
name|waiters
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casWaiters
argument_list|(
name|this
argument_list|,
name|head
argument_list|,
name|Waiter
operator|.
name|TOMBSTONE
argument_list|)
condition|)
do|;
return|return
name|head
return|;
block|}
comment|/** Clears the {@link #listeners} list and returns the most recently added value. */
DECL|method|clearListeners ()
specifier|private
name|Listener
name|clearListeners
parameter_list|()
block|{
name|Listener
name|head
decl_stmt|;
do|do
block|{
name|head
operator|=
name|listeners
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ATOMIC_HELPER
operator|.
name|casListeners
argument_list|(
name|this
argument_list|,
name|head
argument_list|,
name|Listener
operator|.
name|TOMBSTONE
argument_list|)
condition|)
do|;
return|return
name|head
return|;
block|}
comment|/**    * Submits the given runnable to the given {@link Executor} catching and logging all    * {@linkplain RuntimeException runtime exceptions} thrown by the executor.    */
DECL|method|executeListener (Runnable runnable, Executor executor)
specifier|private
specifier|static
name|void
name|executeListener
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Log it and keep going, bad runnable and/or executor.  Don't
comment|// punish the other runnables if we're given a bad one.  We only
comment|// catch RuntimeException because we want Errors to propagate up.
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"RuntimeException while executing runnable "
operator|+
name|runnable
operator|+
literal|" with executor "
operator|+
name|executor
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cancellationExceptionWithCause ( @ullable String message, @Nullable Throwable cause)
specifier|static
specifier|final
name|CancellationException
name|cancellationExceptionWithCause
parameter_list|(
annotation|@
name|Nullable
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|cause
parameter_list|)
block|{
name|CancellationException
name|exception
init|=
operator|new
name|CancellationException
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|exception
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return
name|exception
return|;
block|}
DECL|class|AtomicHelper
specifier|private
specifier|abstract
specifier|static
class|class
name|AtomicHelper
block|{
comment|/** Non volatile write of the thread to the {@link Waiter#thread} field. */
DECL|method|putThread (Waiter waiter, Thread thread)
specifier|abstract
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|thread
parameter_list|)
function_decl|;
comment|/** Non volatile write of the waiter to the {@link Waiter#next} field. */
DECL|method|putNext (Waiter waiter, Waiter next)
specifier|abstract
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|next
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #waiters} field. */
DECL|method|casWaiters (AbstractFuture future, Waiter curr, Waiter next)
specifier|abstract
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Waiter
name|curr
parameter_list|,
name|Waiter
name|next
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #listeners} field. */
DECL|method|casListeners (AbstractFuture future, Listener curr, Listener next)
specifier|abstract
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Listener
name|curr
parameter_list|,
name|Listener
name|next
parameter_list|)
function_decl|;
comment|/** Performs a CAS operation on the {@link #value} field. */
DECL|method|casValue (AbstractFuture future, Object expected, Object v)
specifier|abstract
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Object
name|expected
parameter_list|,
name|Object
name|v
parameter_list|)
function_decl|;
block|}
comment|/**    * {@link AtomicHelper} based on {@link sun.misc.Unsafe}.      *     *<p>Static initialization of this class will fail if the {@link sun.misc.Unsafe} object cannot    * be accessed.     */
DECL|class|UnsafeAtomicHelper
specifier|private
specifier|static
specifier|final
class|class
name|UnsafeAtomicHelper
extends|extends
name|AtomicHelper
block|{
DECL|field|UNSAFE
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|LISTENERS_OFFSET
specifier|static
specifier|final
name|long
name|LISTENERS_OFFSET
decl_stmt|;
DECL|field|WAITERS_OFFSET
specifier|static
specifier|final
name|long
name|WAITERS_OFFSET
decl_stmt|;
DECL|field|VALUE_OFFSET
specifier|static
specifier|final
name|long
name|VALUE_OFFSET
decl_stmt|;
DECL|field|WAITER_THREAD_OFFSET
specifier|static
specifier|final
name|long
name|WAITER_THREAD_OFFSET
decl_stmt|;
DECL|field|WAITER_NEXT_OFFSET
specifier|static
specifier|final
name|long
name|WAITER_NEXT_OFFSET
decl_stmt|;
static|static
block|{
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|unsafe
init|=
literal|null
decl_stmt|;
try|try
block|{
name|unsafe
operator|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{
try|try
block|{
name|unsafe
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|abstractFuture
init|=
name|AbstractFuture
operator|.
name|class
decl_stmt|;
name|WAITERS_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"waiters"
argument_list|)
argument_list|)
expr_stmt|;
name|LISTENERS_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"listeners"
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|abstractFuture
operator|.
name|getDeclaredField
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITER_THREAD_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|Waiter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"thread"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITER_NEXT_OFFSET
operator|=
name|unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|Waiter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
name|UNSAFE
operator|=
name|unsafe
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|Throwables
operator|.
name|propagate
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|putThread (Waiter waiter, Thread thread)
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|thread
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|waiter
argument_list|,
name|WAITER_THREAD_OFFSET
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putNext (Waiter waiter, Waiter next)
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|next
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|waiter
argument_list|,
name|WAITER_NEXT_OFFSET
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/** Performs a CAS operation on the {@link #waiters} field. */
annotation|@
name|Override
DECL|method|casWaiters (AbstractFuture future, Waiter curr, Waiter next)
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Waiter
name|curr
parameter_list|,
name|Waiter
name|next
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|WAITERS_OFFSET
argument_list|,
name|curr
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/** Performs a CAS operation on the {@link #listeners} field. */
annotation|@
name|Override
DECL|method|casListeners (AbstractFuture future, Listener curr, Listener next)
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Listener
name|curr
parameter_list|,
name|Listener
name|next
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|LISTENERS_OFFSET
argument_list|,
name|curr
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/** Performs a CAS operation on the {@link #value} field. */
annotation|@
name|Override
DECL|method|casValue (AbstractFuture future, Object expected, Object v)
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Object
name|expected
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|future
argument_list|,
name|VALUE_OFFSET
argument_list|,
name|expected
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
comment|/** {@link AtomicHelper} based on {@link AtomicReferenceFieldUpdater}. */
DECL|class|SafeAtomicHelper
specifier|private
specifier|static
specifier|final
class|class
name|SafeAtomicHelper
extends|extends
name|AtomicHelper
block|{
annotation|@
name|Override
DECL|method|putThread (Waiter waiter, Thread thread)
name|void
name|putThread
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Thread
name|thread
parameter_list|)
block|{
name|WAITER_THREAD_UPDATER
operator|.
name|lazySet
argument_list|(
name|waiter
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putNext (Waiter waiter, Waiter next)
name|void
name|putNext
parameter_list|(
name|Waiter
name|waiter
parameter_list|,
name|Waiter
name|next
parameter_list|)
block|{
name|WAITER_NEXT_UPDATER
operator|.
name|lazySet
argument_list|(
name|waiter
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|casWaiters (AbstractFuture future, Waiter curr, Waiter next)
name|boolean
name|casWaiters
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Waiter
name|curr
parameter_list|,
name|Waiter
name|next
parameter_list|)
block|{
return|return
name|WAITERS_UPDATER
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|curr
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|casListeners (AbstractFuture future, Listener curr, Listener next)
name|boolean
name|casListeners
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Listener
name|curr
parameter_list|,
name|Listener
name|next
parameter_list|)
block|{
return|return
name|LISTENERS_UPDATER
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|curr
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|casValue (AbstractFuture future, Object expected, Object v)
name|boolean
name|casValue
parameter_list|(
name|AbstractFuture
name|future
parameter_list|,
name|Object
name|expected
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
return|return
name|VALUE_UPDATER
operator|.
name|compareAndSet
argument_list|(
name|future
argument_list|,
name|expected
argument_list|,
name|v
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

