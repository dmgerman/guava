begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2017 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
operator|.
name|constant
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
operator|.
name|toStringHelper
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|asList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|CLOSED
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|CLOSING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|OPEN
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|SUBSUMED
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|WILL_CLOSE
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|State
operator|.
name|WILL_CREATE_VALUE_AND_CLOSER
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|getDone
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|nonCancellationPropagating
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
operator|.
name|FINER
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
operator|.
name|SEVERE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
operator|.
name|WARNING
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|FluentIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|Combiner
operator|.
name|AsyncCombiningCallable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ClosingFuture
operator|.
name|Combiner
operator|.
name|CombiningCallable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|FutureCombiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|DoNotMock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|RetainedWith
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A step in a pipeline of an asynchronous computation. When the last step in the computation is  * complete, some objects captured during the computation are closed.  *  *<p>A pipeline of {@code ClosingFuture}s is a tree of steps. Each step represents either an  * asynchronously-computed intermediate value, or else an exception that indicates the failure or  * cancellation of the operation so far. The only way to extract the value or exception from a step  * is by declaring that step to be the last step of the pipeline. Nevertheless, we refer to the  * "value" of a successful step or the "result" (value or exception) of any step.  *  *<ol>  *<li>A pipeline starts at its leaf step (or steps), which is created from either a callable  *       block or a {@link ListenableFuture}.  *<li>Each other step is derived from one or more input steps. At each step, zero or more objects  *       can be captured for later closing.  *<li>There is one last step (the root of the tree), from which you can extract the final result  *       of the computation. After that result is available (or the computation fails), all objects  *       captured by any of the steps in the pipeline are closed.  *</ol>  *  *<h3>Starting a pipeline</h3>  *  * Start a {@code ClosingFuture} pipeline {@linkplain #submit(ClosingCallable, Executor) from a  * callable block} that may capture objects for later closing. To start a pipeline from a {@link  * ListenableFuture} that doesn't create resources that should be closed later, you can use {@link  * #from(ListenableFuture)} instead.  *  *<h3>Derived steps</h3>  *  * A {@code ClosingFuture} step can be derived from one or more input {@code ClosingFuture} steps in  * ways similar to {@link FluentFuture}s:  *  *<ul>  *<li>by transforming the value from a successful input step,  *<li>by catching the exception from a failed input step, or  *<li>by combining the results of several input steps.  *</ul>  *  * Each derivation can capture the next value or any intermediate objects for later closing.  *  *<p>A step can be the input to at most one derived step. Once you transform its value, catch its  * exception, or combine it with others, you cannot do anything else with it, including declare it  * to be the last step of the pipeline.  *  *<h4>Transforming</h4>  *  * To derive the next step by asynchronously applying a function to an input step's value, call  * {@link #transform(ClosingFunction, Executor)} or {@link #transformAsync(AsyncClosingFunction,  * Executor)} on the input step.  *  *<h4>Catching</h4>  *  * To derive the next step from a failed input step, call {@link #catching(Class, ClosingFunction,  * Executor)} or {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} on the input step.  *  *<h4>Combining</h4>  *  * To derive a {@code ClosingFuture} from two or more input steps, pass the input steps to {@link  * #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)} or its overloads.  *  *<h3>Cancelling</h3>  *  * Any step in a pipeline can be {@linkplain #cancel(boolean) cancelled}, even after another step  * has been derived, with the same semantics as cancelling a {@link Future}. In addition, a  * successfully cancelled step will immediately start closing all objects captured for later closing  * by it and by its input steps.  *  *<h3>Ending a pipeline</h3>  *  * Each {@code ClosingFuture} pipeline must be ended. To end a pipeline, decide whether you want to  * close the captured objects automatically or manually.  *  *<h4>Automatically closing</h4>  *  * You can extract a {@link Future} that represents the result of the last step in the pipeline by  * calling {@link #finishToFuture()}. When that final {@link Future} is done, all objects captured  * by all steps in the pipeline will be closed.  *  *<pre>{@code  * FluentFuture<UserName> userName =  *     ClosingFuture.submit(  *             closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),  *             executor)  *         .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)  *         .transform((closer, result) -> result.get("userName"), directExecutor())  *         .catching(DBException.class, e -> "no user", directExecutor())  *         .finishToFuture();  * }</pre>  *  * In this example, when the {@code userName} {@link Future} is done, the transaction and the query  * result cursor will both be closed, even if the operation is cancelled or fails.  *  *<h4>Manually closing</h4>  *  * If you want to close the captured objects manually, after you've used the final result, call  * {@link #finishToValueAndCloser(ValueAndCloserConsumer, Executor)} to get an object that holds the  * final result. You then call {@link ValueAndCloser#closeAsync()} to close the captured objects.  *  *<pre>{@code  *     ClosingFuture.submit(  *             closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),  *             executor)  *     .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)  *     .transform((closer, result) -> result.get("userName"), directExecutor())  *     .catching(DBException.class, e -> "no user", directExecutor())  *     .finishToValueAndCloser(  *         valueAndCloser -> this.userNameValueAndCloser = valueAndCloser, executor);  *  * // later  * try { // get() will throw if the operation failed or was cancelled.  *   UserName userName = userNameValueAndCloser.get();  *   // do something with userName  * } finally {  *   userNameValueAndCloser.closeAsync();  * }  * }</pre>  *  * In this example, when {@code userNameValueAndCloser.closeAsync()} is called, the transaction and  * the query result cursor will both be closed, even if the operation is cancelled or fails.  *  *<p>Note that if you don't call {@code closeAsync()}, the captured objects will not be closed. The  * automatic-closing approach described above is safer.  *  * @param<V> the type of the value of this step  * @since 30.0  */
end_comment

begin_comment
comment|// TODO(dpb): Consider reusing one CloseableList for the entire pipeline, modulo combinations.
end_comment

begin_class
annotation|@
name|Beta
comment|// @Beta for one release.
annotation|@
name|DoNotMock
argument_list|(
literal|"Use ClosingFuture.from(Futures.immediate*Future)"
argument_list|)
comment|// TODO(dpb): GWT compatibility.
DECL|class|ClosingFuture
specifier|public
specifier|final
class|class
name|ClosingFuture
parameter_list|<
name|V
parameter_list|>
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ClosingFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * An object that can capture objects to be closed later, when a {@link ClosingFuture} pipeline is    * done.    */
DECL|class|DeferredCloser
specifier|public
specifier|static
specifier|final
class|class
name|DeferredCloser
block|{
DECL|field|list
annotation|@
name|RetainedWith
specifier|private
specifier|final
name|CloseableList
name|list
decl_stmt|;
DECL|method|DeferredCloser (CloseableList list)
name|DeferredCloser
parameter_list|(
name|CloseableList
name|list
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
block|}
comment|/**      * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.      *      *<p>For users of the {@code -jre} flavor of Guava, the object can be any {@code      * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code      * Closeable}. (For more about the flavors, see<a      * href="https://github.com/google/guava#adding-guava-to-your-build">Adding Guava to your      * build</a>.)      *      *<p>Be careful when targeting an older SDK than you are building against (most commonly when      * building for Android): Ensure that any object you pass implements the interface not just in      * your current SDK version but also at the oldest version you support. For example,<a      * href="https://developer.android.com/sdk/api_diff/16/">API Level 16</a> is the first version      * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper      * {@code Closeable} with a method reference like {@code cursor::close}.      *      *<p>Note that this method is still binary-compatible between flavors because the erasure of      * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.      *      * @param closeable the object to be closed (see notes above)      * @param closingExecutor the object will be closed on this executor      * @return the first argument      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|eventuallyClose ( C closeable, Executor closingExecutor)
specifier|public
operator|<
name|C
expr|extends @
name|Nullable
name|Object
operator|&
expr|@
name|Nullable
name|AutoCloseable
operator|>
name|C
name|eventuallyClose
argument_list|(
name|C
name|closeable
argument_list|,
name|Executor
name|closingExecutor
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|closingExecutor
argument_list|)
block|;
if|if
condition|(
name|closeable
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|closeable
argument_list|,
name|closingExecutor
argument_list|)
expr_stmt|;
block|}
return|return
name|closeable
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * An operation that computes a result.    *    * @param<V> the type of the result    */
end_comment

begin_annotation
annotation|@
name|FunctionalInterface
end_annotation

begin_expr_stmt
DECL|interface|ClosingCallable
specifier|public
expr|interface
name|ClosingCallable
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**      * Computes a result, or throws an exception if unable to do so.      *      *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)      * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but      * not before this method completes), even if this method throws or the pipeline is cancelled.      */
DECL|method|call (DeferredCloser closer)
name|V
name|call
argument_list|(
name|DeferredCloser
name|closer
argument_list|)
throws|throws
name|Exception
block|;   }
comment|/**    * A function from an input to a result.    *    * @param<T> the type of the input to the function    * @param<U> the type of the result of the function    */
expr|@
name|FunctionalInterface
DECL|interface|ClosingFunction
specifier|public
expr|interface
name|ClosingFunction
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**      * Applies this function to an input, or throws an exception if unable to do so.      *      *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)      * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but      * not before this method completes), even if this method throws or the pipeline is cancelled.      */
DECL|method|apply (DeferredCloser closer, T input)
name|U
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|T
name|input
argument_list|)
throws|throws
name|Exception
block|;   }
comment|/**    * A function from an input to a {@link ClosingFuture} of a result.    *    * @param<T> the type of the input to the function    * @param<U> the type of the result of the function    */
expr|@
name|FunctionalInterface
DECL|interface|AsyncClosingFunction
specifier|public
expr|interface
name|AsyncClosingFunction
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**      * Applies this function to an input, or throws an exception if unable to do so.      *      *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable, Executor)      * closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but      * not before this method completes), even if this method throws or the pipeline is cancelled.      */
DECL|method|apply (DeferredCloser closer, T input)
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|T
name|input
argument_list|)
throws|throws
name|Exception
block|;   }
comment|/**    * An object that holds the final result of an asynchronous {@link ClosingFuture} operation and    * allows the user to close all the closeable objects that were captured during it for later    * closing.    *    *<p>The asynchronous operation will have completed before this object is created.    *    * @param<V> the type of the value of a successful operation    * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)    */
DECL|class|ValueAndCloser
specifier|public
specifier|static
name|final
name|class
name|ValueAndCloser
argument_list|<
name|V
argument_list|>
block|{
DECL|field|closingFuture
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|closingFuture
block|;
DECL|method|ValueAndCloser (ClosingFuture<? extends V> closingFuture)
name|ValueAndCloser
argument_list|(
name|ClosingFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|closingFuture
argument_list|)
block|{
name|this
operator|.
name|closingFuture
operator|=
name|checkNotNull
argument_list|(
name|closingFuture
argument_list|)
block|;     }
comment|/**      * Returns the final value of the associated {@link ClosingFuture}, or throws an exception as      * {@link Future#get()} would.      *      *<p>Because the asynchronous operation has already completed, this method is synchronous and      * returns immediately.      *      * @throws CancellationException if the computation was cancelled      * @throws ExecutionException if the computation threw an exception      */
expr|@
name|Nullable
DECL|method|get ()
specifier|public
name|V
name|get
argument_list|()
throws|throws
name|ExecutionException
block|{
return|return
name|getDone
argument_list|(
name|closingFuture
operator|.
name|future
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      * Starts closing all closeable objects captured during the {@link ClosingFuture}'s asynchronous      * operation on the {@link Executor}s specified by calls to {@link      * DeferredCloser#eventuallyClose(Closeable, Executor)}.      *      *<p>If any such calls specified {@link MoreExecutors#directExecutor()}, those objects will be      * closed synchronously.      *      *<p>Idempotent: objects will be closed at most once.      */
end_comment

begin_function
DECL|method|closeAsync ()
specifier|public
name|void
name|closeAsync
parameter_list|()
block|{
name|closingFuture
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/**    * Represents an operation that accepts a {@link ValueAndCloser} for the last step in a {@link    * ClosingFuture} pipeline.    *    * @param<V> the type of the final value of a successful pipeline    * @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)    */
end_comment

begin_expr_stmt
unit|@
name|FunctionalInterface
DECL|interface|ValueAndCloserConsumer
specifier|public
expr|interface
name|ValueAndCloserConsumer
argument_list|<
name|V
argument_list|>
block|{
comment|/** Accepts a {@link ValueAndCloser} for the last step in a {@link ClosingFuture} pipeline. */
DECL|method|accept (ValueAndCloser<V> valueAndCloser)
name|void
name|accept
argument_list|(
name|ValueAndCloser
argument_list|<
name|V
argument_list|>
name|valueAndCloser
argument_list|)
block|;   }
comment|/**    * Starts a {@link ClosingFuture} pipeline by submitting a callable block to an executor.    *    * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for    *     execution    */
DECL|method|submit (ClosingCallable<V> callable, Executor executor)
specifier|public
specifier|static
operator|<
name|V
operator|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|submit
argument_list|(
name|ClosingCallable
argument_list|<
name|V
argument_list|>
name|callable
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
operator|new
name|ClosingFuture
argument_list|<>
argument_list|(
name|callable
argument_list|,
name|executor
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// TODO(dpb, cpovirk): Do we need submitAsync?
end_comment

begin_comment
comment|/**    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.    *    *<p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}    * implements {@link Closeable}. In order to start a pipeline with a value that will be closed    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.    */
end_comment

begin_function
DECL|method|from (ListenableFuture<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|from
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
return|return
operator|new
name|ClosingFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.    *    *<p>If {@code future} succeeds, its value will be closed (using {@code closingExecutor)} when    * the pipeline is done, even if the pipeline is canceled or fails.    *    *<p>Cancelling the pipeline will not cancel {@code future}, so that the pipeline can access its    * value in order to close it.    *    * @param future the future to create the {@code ClosingFuture} from. For discussion of the    *     future's result type {@code C}, see {@link DeferredCloser#eventuallyClose(Closeable,    *     Executor)}.    * @param closingExecutor the future's result will be closed on this executor    * @deprecated Creating {@link Future}s of closeable types is dangerous in general because the    *     underlying value may never be closed if the {@link Future} is canceled after its operation    *     begins. Consider replacing code that creates {@link ListenableFuture}s of closeable types,    *     including those that pass them to this method, with {@link #submit(ClosingCallable,    *     Executor)} in order to ensure that resources do not leak. Or, to start a pipeline with a    *     {@link ListenableFuture} that doesn't create values that should be closed, use {@link    *     ClosingFuture#from}.    */
end_comment

begin_annotation
annotation|@
name|Deprecated
end_annotation

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|C
expr|extends @
name|Nullable
name|Object
operator|&
expr|@
name|Nullable
name|AutoCloseable
operator|>
DECL|method|eventuallyClosing ( ListenableFuture<C> future, final Executor closingExecutor)
name|ClosingFuture
argument_list|<
name|C
argument_list|>
name|eventuallyClosing
argument_list|(
name|ListenableFuture
argument_list|<
name|C
argument_list|>
name|future
argument_list|,
name|final
name|Executor
name|closingExecutor
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|closingExecutor
argument_list|)
block|;
name|final
name|ClosingFuture
argument_list|<
name|C
argument_list|>
name|closingFuture
operator|=
operator|new
name|ClosingFuture
argument_list|<>
argument_list|(
name|nonCancellationPropagating
argument_list|(
name|future
argument_list|)
argument_list|)
block|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
operator|new
name|FutureCallback
argument_list|<
annotation|@
name|Nullable
name|AutoCloseable
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
annotation|@
name|Nullable
name|AutoCloseable
name|result
parameter_list|)
block|{
name|closingFuture
operator|.
name|closeables
operator|.
name|closer
operator|.
name|eventuallyClose
argument_list|(
name|result
argument_list|,
name|closingExecutor
argument_list|)
expr_stmt|;
block|}
expr|@
name|Override
specifier|public
name|void
name|onFailure
argument_list|(
name|Throwable
name|t
argument_list|)
block|{}
end_expr_stmt

begin_expr_stmt
unit|},
name|directExecutor
argument_list|()
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_return
return|return
name|closingFuture
return|;
end_return

begin_comment
unit|}
comment|/**    * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllComplete (Iterable<? extends ClosingFuture<?>> futures)
unit|public
specifier|static
name|Combiner
name|whenAllComplete
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|Combiner
argument_list|(
literal|false
argument_list|,
name|futures
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllComplete ( ClosingFuture<?> future1, ClosingFuture<?>... moreFutures)
specifier|public
specifier|static
name|Combiner
name|whenAllComplete
parameter_list|(
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
modifier|...
name|moreFutures
parameter_list|)
block|{
return|return
name|whenAllComplete
argument_list|(
name|asList
argument_list|(
name|future1
argument_list|,
name|moreFutures
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they    * all succeed. If any fail, the resulting pipeline will fail.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed (Iterable<? extends ClosingFuture<?>> futures)
specifier|public
specifier|static
name|Combiner
name|whenAllSucceed
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|Combiner
argument_list|(
literal|true
argument_list|,
name|futures
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine two {@link ClosingFuture}s into a single pipeline, assuming    * they all succeed. If any fail, the resulting pipeline will fail.    *    *<p>Calling this method allows you to use lambdas or method references typed with the types of    * the input {@link ClosingFuture}s.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed ( ClosingFuture<V1> future1, ClosingFuture<V2> future2)
specifier|public
specifier|static
parameter_list|<
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Combiner2
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
name|whenAllSucceed
parameter_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
parameter_list|)
block|{
return|return
operator|new
name|Combiner2
argument_list|<>
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine three {@link ClosingFuture}s into a single pipeline, assuming    * they all succeed. If any fail, the resulting pipeline will fail.    *    *<p>Calling this method allows you to use lambdas or method references typed with the types of    * the input {@link ClosingFuture}s.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3)
specifier|public
specifier|static
parameter_list|<
name|V1
parameter_list|,
name|V2
parameter_list|,
name|V3
parameter_list|>
name|Combiner3
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|>
name|whenAllSucceed
parameter_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
parameter_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
parameter_list|)
block|{
return|return
operator|new
name|Combiner3
argument_list|<>
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine four {@link ClosingFuture}s into a single pipeline, assuming    * they all succeed. If any fail, the resulting pipeline will fail.    *    *<p>Calling this method allows you to use lambdas or method references typed with the types of    * the input {@link ClosingFuture}s.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4)
specifier|public
specifier|static
parameter_list|<
name|V1
parameter_list|,
name|V2
parameter_list|,
name|V3
parameter_list|,
name|V4
parameter_list|>
name|Combiner4
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|>
name|whenAllSucceed
parameter_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
parameter_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
parameter_list|,
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
parameter_list|)
block|{
return|return
operator|new
name|Combiner4
argument_list|<>
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine five {@link ClosingFuture}s into a single pipeline, assuming    * they all succeed. If any fail, the resulting pipeline will fail.    *    *<p>Calling this method allows you to use lambdas or method references typed with the types of    * the input {@link ClosingFuture}s.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4, ClosingFuture<V5> future5)
specifier|public
specifier|static
parameter_list|<
name|V1
parameter_list|,
name|V2
parameter_list|,
name|V3
parameter_list|,
name|V4
parameter_list|,
name|V5
parameter_list|>
name|Combiner5
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|,
name|V5
argument_list|>
name|whenAllSucceed
parameter_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
parameter_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
parameter_list|,
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
parameter_list|,
name|ClosingFuture
argument_list|<
name|V5
argument_list|>
name|future5
parameter_list|)
block|{
return|return
operator|new
name|Combiner5
argument_list|<>
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they    * all succeed. If any fail, the resulting pipeline will fail.    *    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of    *     the arguments, or if any has already been {@linkplain #finishToFuture() finished}    */
end_comment

begin_function
DECL|method|whenAllSucceed ( ClosingFuture<?> future1, ClosingFuture<?> future2, ClosingFuture<?> future3, ClosingFuture<?> future4, ClosingFuture<?> future5, ClosingFuture<?> future6, ClosingFuture<?>... moreFutures)
specifier|public
specifier|static
name|Combiner
name|whenAllSucceed
parameter_list|(
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future1
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future2
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future3
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future4
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future5
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future6
parameter_list|,
name|ClosingFuture
argument_list|<
name|?
argument_list|>
modifier|...
name|moreFutures
parameter_list|)
block|{
return|return
name|whenAllSucceed
argument_list|(
name|FluentIterable
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|,
name|future6
argument_list|)
operator|.
name|append
argument_list|(
name|moreFutures
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|field|state
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|State
argument_list|>
name|state
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
name|OPEN
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|closeables
specifier|private
specifier|final
name|CloseableList
name|closeables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|future
specifier|private
specifier|final
name|FluentFuture
argument_list|<
name|V
argument_list|>
name|future
decl_stmt|;
end_decl_stmt

begin_constructor
DECL|method|ClosingFuture (ListenableFuture<V> future)
specifier|private
name|ClosingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|FluentFuture
operator|.
name|from
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_constructor
DECL|method|ClosingFuture (final ClosingCallable<V> callable, Executor executor)
specifier|private
name|ClosingFuture
parameter_list|(
specifier|final
name|ClosingCallable
argument_list|<
name|V
argument_list|>
name|callable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|callable
argument_list|)
expr_stmt|;
name|TrustedListenableFutureTask
argument_list|<
name|V
argument_list|>
name|task
init|=
name|TrustedListenableFutureTask
operator|.
name|create
argument_list|(
operator|new
name|Callable
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|callable
operator|.
name|call
argument_list|(
name|closeables
operator|.
name|closer
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|callable
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|task
expr_stmt|;
block|}
end_constructor

begin_comment
comment|/**    * Returns a future that finishes when this step does. Calling {@code get()} on the returned    * future returns {@code null} if the step is successful or throws the same exception that would    * be thrown by calling {@code finishToFuture().get()} if this were the last step. Calling {@code    * cancel()} on the returned future has no effect on the {@code ClosingFuture} pipeline.    *    *<p>{@code statusFuture} differs from most methods on {@code ClosingFuture}: You can make calls    * to {@code statusFuture}<i>in addition to</i> the call you make to {@link #finishToFuture()} or    * a derivation method<i>on the same instance</i>. This is important because calling {@code    * statusFuture} alone does not provide a way to close the pipeline.    */
end_comment

begin_function
DECL|method|statusFuture ()
specifier|public
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|statusFuture
parameter_list|()
block|{
return|return
name|nonCancellationPropagating
argument_list|(
name|future
operator|.
name|transform
argument_list|(
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function    * to its value. The function can use a {@link DeferredCloser} to capture objects to be closed    * when the pipeline is done.    *    *<p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code    * ClosingFuture} will be equivalent to this one.    *    *<p>If the function throws an exception, that exception is used as the result of the derived    * {@code ClosingFuture}.    *    *<p>Example usage:    *    *<pre>{@code    * ClosingFuture<List<Row>> rowsFuture =    *     queryFuture.transform((closer, result) -> result.getRows(), executor);    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings    * about heavyweight listeners are also applicable to heavyweight functions passed to this method.    *    *<p>After calling this method, you may not call {@link #finishToFuture()}, {@link    * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on    * this {@code ClosingFuture}.    *    * @param function transforms the value of this step to the value of the derived step    * @param executor executor to run the function in    * @return the derived step    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this    *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()    *     finished}    */
end_comment

begin_function
DECL|method|transform ( final ClosingFunction<? super V, U> function, Executor executor)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|transform
parameter_list|(
specifier|final
name|ClosingFunction
argument_list|<
name|?
super|super
name|V
argument_list|,
name|U
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|applyFunction
init|=
operator|new
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|U
argument_list|>
name|apply
parameter_list|(
name|V
name|input
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|closeables
operator|.
name|applyClosingFunction
argument_list|(
name|function
argument_list|,
name|input
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// TODO(dpb): Switch to future.transformSync when that exists (passing a throwing function).
return|return
name|derive
argument_list|(
name|future
operator|.
name|transformAsync
argument_list|(
name|applyFunction
argument_list|,
name|executor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function    * that returns a {@code ClosingFuture} to its value. The function can use a {@link    * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those    * captured by the returned {@link ClosingFuture}).    *    *<p>If this {@code ClosingFuture} succeeds, the derived one will be equivalent to the one    * returned by the function.    *    *<p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code    * ClosingFuture} will be equivalent to this one.    *    *<p>If the function throws an exception, that exception is used as the result of the derived    * {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code    * ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be    * closed.    *    *<p>Usage guidelines for this method:    *    *<ul>    *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a    *       {@code ClosingFuture}. If possible, prefer calling {@link #transform(ClosingFunction,    *       Executor)} instead, with a function that returns the next value directly.    *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor) closer.eventuallyClose()}    *       for every closeable object this step creates in order to capture it for later closing.    *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code    *       ClosingFuture} call {@link #from(ListenableFuture)}.    *<li>In case this step doesn't create new closeables, you can adapt an API that returns a    *       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to    *       {@link #withoutCloser(AsyncFunction)}    *</ul>    *    *<p>Example usage:    *    *<pre>{@code    * // Result.getRowsClosingFuture() returns a ClosingFuture.    * ClosingFuture<List<Row>> rowsFuture =    *     queryFuture.transformAsync((closer, result) -> result.getRowsClosingFuture(), executor);    *    * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the    * // number of written rows. openOutputFile() returns a FileOutputStream (which implements    * // Closeable).    * ClosingFuture<Integer> rowsFuture2 =    *     queryFuture.transformAsync(    *         (closer, result) -> {    *           FileOutputStream fos = closer.eventuallyClose(openOutputFile(), closingExecutor);    *           return ClosingFuture.from(result.writeRowsToOutputStreamFuture(fos));    *      },    *      executor);    *    * // Result.getRowsFuture() returns a ListenableFuture (no new closeables are created).    * ClosingFuture<List<Row>> rowsFuture3 =    *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);    *    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings    * about heavyweight listeners are also applicable to heavyweight functions passed to this method.    * (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside    * {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads    * responsible for completing the returned {@code ClosingFuture}.)    *    *<p>After calling this method, you may not call {@link #finishToFuture()}, {@link    * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on    * this {@code ClosingFuture}.    *    * @param function transforms the value of this step to a {@code ClosingFuture} with the value of    *     the derived step    * @param executor executor to run the function in    * @return the derived step    * @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this    *     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()    *     finished}    */
end_comment

begin_function
DECL|method|transformAsync ( final AsyncClosingFunction<? super V, U> function, Executor executor)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|transformAsync
parameter_list|(
specifier|final
name|AsyncClosingFunction
argument_list|<
name|?
super|super
name|V
argument_list|,
name|U
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|applyFunction
init|=
operator|new
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|U
argument_list|>
name|apply
parameter_list|(
name|V
name|input
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|closeables
operator|.
name|applyAsyncClosingFunction
argument_list|(
name|function
argument_list|,
name|input
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
return|return
name|derive
argument_list|(
name|future
operator|.
name|transformAsync
argument_list|(
name|applyFunction
argument_list|,
name|executor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an {@link AsyncClosingFunction} that applies an {@link AsyncFunction} to an input,    * ignoring the DeferredCloser and returning a {@code ClosingFuture} derived from the returned    * {@link ListenableFuture}.    *    *<p>Use this method to pass a transformation to {@link #transformAsync(AsyncClosingFunction,    * Executor)} or to {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} as long as it    * meets these conditions:    *    *<ul>    *<li>It does not need to capture any {@link Closeable} objects by calling {@link    *       DeferredCloser#eventuallyClose(Closeable, Executor)}.    *<li>It returns a {@link ListenableFuture}.    *</ul>    *    *<p>Example usage:    *    *<pre>{@code    * // Result.getRowsFuture() returns a ListenableFuture.    * ClosingFuture<List<Row>> rowsFuture =    *     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);    * }</pre>    *    * @param function transforms the value of a {@code ClosingFuture} step to a {@link    *     ListenableFuture} with the value of a derived step    */
end_comment

begin_function
DECL|method|withoutCloser ( final AsyncFunction<V, U> function)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|U
parameter_list|>
name|AsyncClosingFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|withoutCloser
parameter_list|(
specifier|final
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|AsyncClosingFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|V
name|input
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|ClosingFuture
operator|.
name|from
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function    * to its exception if it is an instance of a given exception type. The function can use a {@link    * DeferredCloser} to capture objects to be closed when the pipeline is done.    *    *<p>If this {@code ClosingFuture} succeeds or fails with a different exception type, the    * function will not be called, and the derived {@code ClosingFuture} will be equivalent to this    * one.    *    *<p>If the function throws an exception, that exception is used as the result of the derived    * {@code ClosingFuture}.    *    *<p>Example usage:    *    *<pre>{@code    * ClosingFuture<QueryResult> queryFuture =    *     queryFuture.catching(    *         QueryException.class, (closer, x) -> Query.emptyQueryResult(), executor);    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings    * about heavyweight listeners are also applicable to heavyweight functions passed to this method.    *    *<p>After calling this method, you may not call {@link #finishToFuture()}, {@link    * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on    * this {@code ClosingFuture}.    *    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception    *     type is matched against this step's exception. "This step's exception" means the cause of    *     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}    *     underlying this step or, if {@code get()} throws a different kind of exception, that    *     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should    *     prefer more specific types, avoiding {@code Throwable.class} in particular.    * @param fallback the function to be called if this step fails with the expected exception type.    *     The function's argument is this step's exception. "This step's exception" means the cause    *     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}    *     underlying this step or, if {@code get()} throws a different kind of exception, that    *     exception itself.    * @param executor the executor that runs {@code fallback} if the input fails    */
end_comment

begin_function
DECL|method|catching ( Class<X> exceptionType, ClosingFunction<? super X, ? extends V> fallback, Executor executor)
specifier|public
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|catching
parameter_list|(
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|ClosingFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|catchingMoreGeneric
argument_list|(
name|exceptionType
argument_list|,
name|fallback
argument_list|,
name|executor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.
end_comment

begin_function
DECL|method|catchingMoreGeneric ( Class<X> exceptionType, final ClosingFunction<? super X, W> fallback, Executor executor)
specifier|private
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|W
extends|extends
name|V
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|catchingMoreGeneric
parameter_list|(
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
specifier|final
name|ClosingFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|W
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fallback
argument_list|)
expr_stmt|;
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|W
argument_list|>
name|applyFallback
init|=
operator|new
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|W
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|W
argument_list|>
name|apply
parameter_list|(
name|X
name|exception
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|closeables
operator|.
name|applyClosingFunction
argument_list|(
name|fallback
argument_list|,
name|exception
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|fallback
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// TODO(dpb): Switch to future.catchingSync when that exists (passing a throwing function).
return|return
name|derive
argument_list|(
name|future
operator|.
name|catchingAsync
argument_list|(
name|exceptionType
argument_list|,
name|applyFallback
argument_list|,
name|executor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function    * that returns a {@code ClosingFuture} to its exception if it is an instance of a given exception    * type. The function can use a {@link DeferredCloser} to capture objects to be closed when the    * pipeline is done (other than those captured by the returned {@link ClosingFuture}).    *    *<p>If this {@code ClosingFuture} fails with an exception of the given type, the derived {@code    * ClosingFuture} will be equivalent to the one returned by the function.    *    *<p>If this {@code ClosingFuture} succeeds or fails with a different exception type, the    * function will not be called, and the derived {@code ClosingFuture} will be equivalent to this    * one.    *    *<p>If the function throws an exception, that exception is used as the result of the derived    * {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code    * ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be    * closed.    *    *<p>Usage guidelines for this method:    *    *<ul>    *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a    *       {@code ClosingFuture}. If possible, prefer calling {@link #catching(Class,    *       ClosingFunction, Executor)} instead, with a function that returns the next value    *       directly.    *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor) closer.eventuallyClose()}    *       for every closeable object this step creates in order to capture it for later closing.    *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code    *       ClosingFuture} call {@link #from(ListenableFuture)}.    *<li>In case this step doesn't create new closeables, you can adapt an API that returns a    *       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to    *       {@link #withoutCloser(AsyncFunction)}    *</ul>    *    *<p>Example usage:    *    *<pre>{@code    * // Fall back to a secondary input stream in case of IOException.    * ClosingFuture<InputStream> inputFuture =    *     firstInputFuture.catchingAsync(    *         IOException.class, (closer, x) -> secondaryInputStreamClosingFuture(), executor);    * }    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings    * about heavyweight listeners are also applicable to heavyweight functions passed to this method.    * (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside    * {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads    * responsible for completing the returned {@code ClosingFuture}.)    *    *<p>After calling this method, you may not call {@link #finishToFuture()}, {@link    * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on    * this {@code ClosingFuture}.    *    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception    *     type is matched against this step's exception. "This step's exception" means the cause of    *     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}    *     underlying this step or, if {@code get()} throws a different kind of exception, that    *     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should    *     prefer more specific types, avoiding {@code Throwable.class} in particular.    * @param fallback the function to be called if this step fails with the expected exception type.    *     The function's argument is this step's exception. "This step's exception" means the cause    *     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}    *     underlying this step or, if {@code get()} throws a different kind of exception, that    *     exception itself.    * @param executor the executor that runs {@code fallback} if the input fails    */
end_comment

begin_comment
comment|// TODO(dpb): Should this do something special if the function throws CancellationException or
end_comment

begin_comment
comment|// ExecutionException?
end_comment

begin_function
DECL|method|catchingAsync ( Class<X> exceptionType, AsyncClosingFunction<? super X, ? extends V> fallback, Executor executor)
specifier|public
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|catchingAsync
parameter_list|(
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|AsyncClosingFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|catchingAsyncMoreGeneric
argument_list|(
name|exceptionType
argument_list|,
name|fallback
argument_list|,
name|executor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.
end_comment

begin_function
DECL|method|catchingAsyncMoreGeneric ( Class<X> exceptionType, final AsyncClosingFunction<? super X, W> fallback, Executor executor)
specifier|private
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|W
extends|extends
name|V
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|catchingAsyncMoreGeneric
parameter_list|(
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
specifier|final
name|AsyncClosingFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|W
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fallback
argument_list|)
expr_stmt|;
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|W
argument_list|>
name|asyncFunction
init|=
operator|new
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|W
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|W
argument_list|>
name|apply
parameter_list|(
name|X
name|exception
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|closeables
operator|.
name|applyAsyncClosingFunction
argument_list|(
name|fallback
argument_list|,
name|exception
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|fallback
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
return|return
name|derive
argument_list|(
name|future
operator|.
name|catchingAsync
argument_list|(
name|exceptionType
argument_list|,
name|asyncFunction
argument_list|,
name|executor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Marks this step as the last step in the {@code ClosingFuture} pipeline. When the returned    * {@link Future} is done, all objects captured for closing during the pipeline's computation will    * be closed.    *    *<p>After calling this method, you may not call {@link    * #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, this method, or any other    * derivation method on this {@code ClosingFuture}.    *    * @return a {@link Future} that represents the final value or exception of the pipeline    */
end_comment

begin_function
DECL|method|finishToFuture ()
specifier|public
name|FluentFuture
argument_list|<
name|V
argument_list|>
name|finishToFuture
parameter_list|()
block|{
if|if
condition|(
name|compareAndUpdateState
argument_list|(
name|OPEN
argument_list|,
name|WILL_CLOSE
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|FINER
argument_list|,
literal|"will close {0}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|future
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|checkAndUpdateState
argument_list|(
name|WILL_CLOSE
argument_list|,
name|CLOSING
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|checkAndUpdateState
argument_list|(
name|CLOSING
argument_list|,
name|CLOSED
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|state
operator|.
name|get
argument_list|()
condition|)
block|{
case|case
name|SUBSUMED
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToFuture() after deriving another step"
argument_list|)
throw|;
case|case
name|WILL_CREATE_VALUE_AND_CLOSER
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToFuture() after calling finishToValueAndCloser()"
argument_list|)
throw|;
case|case
name|WILL_CLOSE
case|:
case|case
name|CLOSING
case|:
case|case
name|CLOSED
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToFuture() twice"
argument_list|)
throw|;
case|case
name|OPEN
case|:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
return|return
name|future
return|;
block|}
end_function

begin_comment
comment|/**    * Marks this step as the last step in the {@code ClosingFuture} pipeline. When this step is done,    * {@code receiver} will be called with an object that contains the result of the operation. The    * receiver can store the {@link ValueAndCloser} outside the receiver for later synchronous use.    *    *<p>After calling this method, you may not call {@link #finishToFuture()}, this method again, or    * any other derivation method on this {@code ClosingFuture}.    *    * @param consumer a callback whose method will be called (using {@code executor}) when this    *     operation is done    */
end_comment

begin_function
DECL|method|finishToValueAndCloser ( final ValueAndCloserConsumer<? super V> consumer, Executor executor)
specifier|public
name|void
name|finishToValueAndCloser
parameter_list|(
specifier|final
name|ValueAndCloserConsumer
argument_list|<
name|?
super|super
name|V
argument_list|>
name|consumer
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compareAndUpdateState
argument_list|(
name|OPEN
argument_list|,
name|WILL_CREATE_VALUE_AND_CLOSER
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|state
operator|.
name|get
argument_list|()
condition|)
block|{
case|case
name|SUBSUMED
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToValueAndCloser() after deriving another step"
argument_list|)
throw|;
case|case
name|WILL_CLOSE
case|:
case|case
name|CLOSING
case|:
case|case
name|CLOSED
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToValueAndCloser() after calling finishToFuture()"
argument_list|)
throw|;
case|case
name|WILL_CREATE_VALUE_AND_CLOSER
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot call finishToValueAndCloser() twice"
argument_list|)
throw|;
case|case
name|OPEN
case|:
break|break;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
name|state
argument_list|)
throw|;
block|}
name|future
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|provideValueAndCloser
argument_list|(
name|consumer
argument_list|,
name|ClosingFuture
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|provideValueAndCloser ( ValueAndCloserConsumer<C> consumer, ClosingFuture<V> closingFuture)
specifier|private
specifier|static
parameter_list|<
name|C
parameter_list|,
name|V
extends|extends
name|C
parameter_list|>
name|void
name|provideValueAndCloser
parameter_list|(
name|ValueAndCloserConsumer
argument_list|<
name|C
argument_list|>
name|consumer
parameter_list|,
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|closingFuture
parameter_list|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
operator|new
name|ValueAndCloser
argument_list|<
name|C
argument_list|>
argument_list|(
name|closingFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Attempts to cancel execution of this step. This attempt will fail if the step has already    * completed, has already been cancelled, or could not be cancelled for some other reason. If    * successful, and this step has not started when {@code cancel} is called, this step should never    * run.    *    *<p>If successful, causes the objects captured by this step (if already started) and its input    * step(s) for later closing to be closed on their respective {@link Executor}s. If any such calls    * specified {@link MoreExecutors#directExecutor()}, those objects will be closed synchronously.    *    * @param mayInterruptIfRunning {@code true} if the thread executing this task should be    *     interrupted; otherwise, in-progress tasks are allowed to complete, but the step will be    *     cancelled regardless    * @return {@code false} if the step could not be cancelled, typically because it has already    *     completed normally; {@code true} otherwise    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|FINER
argument_list|,
literal|"cancelling {0}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|boolean
name|cancelled
init|=
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
decl_stmt|;
if|if
condition|(
name|cancelled
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|cancelled
return|;
block|}
end_function

begin_function
DECL|method|close ()
specifier|private
name|void
name|close
parameter_list|()
block|{
name|logger
operator|.
name|log
argument_list|(
name|FINER
argument_list|,
literal|"closing {0}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|closeables
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
DECL|method|derive (FluentFuture<U> future)
specifier|private
parameter_list|<
name|U
parameter_list|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|derive
parameter_list|(
name|FluentFuture
argument_list|<
name|U
argument_list|>
name|future
parameter_list|)
block|{
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|derived
init|=
operator|new
name|ClosingFuture
argument_list|<>
argument_list|(
name|future
argument_list|)
decl_stmt|;
name|becomeSubsumedInto
argument_list|(
name|derived
operator|.
name|closeables
argument_list|)
expr_stmt|;
return|return
name|derived
return|;
block|}
end_function

begin_function
DECL|method|becomeSubsumedInto (CloseableList otherCloseables)
specifier|private
name|void
name|becomeSubsumedInto
parameter_list|(
name|CloseableList
name|otherCloseables
parameter_list|)
block|{
name|checkAndUpdateState
argument_list|(
name|OPEN
argument_list|,
name|SUBSUMED
argument_list|)
expr_stmt|;
name|otherCloseables
operator|.
name|add
argument_list|(
name|closeables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * An object that can return the value of the {@link ClosingFuture}s that are passed to {@link    * #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)}.    *    *<p>Only for use by a {@link CombiningCallable} or {@link AsyncCombiningCallable} object.    */
end_comment

begin_class
DECL|class|Peeker
specifier|public
specifier|static
specifier|final
class|class
name|Peeker
block|{
DECL|field|futures
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|futures
decl_stmt|;
DECL|field|beingCalled
specifier|private
specifier|volatile
name|boolean
name|beingCalled
decl_stmt|;
DECL|method|Peeker (ImmutableList<ClosingFuture<?>> futures)
specifier|private
name|Peeker
parameter_list|(
name|ImmutableList
argument_list|<
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
name|this
operator|.
name|futures
operator|=
name|checkNotNull
argument_list|(
name|futures
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the value of {@code closingFuture}.      *      * @throws ExecutionException if {@code closingFuture} is a failed step      * @throws CancellationException if the {@code closingFuture}'s future was cancelled      * @throws IllegalArgumentException if {@code closingFuture} is not one of the futures passed to      *     {@link #whenAllComplete(Iterable)} or {@link #whenAllComplete(Iterable)}      * @throws IllegalStateException if called outside of a call to {@link      *     CombiningCallable#call(DeferredCloser, Peeker)} or {@link      *     AsyncCombiningCallable#call(DeferredCloser, Peeker)}      */
DECL|method|getDone (ClosingFuture<D> closingFuture)
specifier|public
name|final
operator|<
name|D
expr|extends @
name|Nullable
name|Object
operator|>
name|D
name|getDone
argument_list|(
name|ClosingFuture
argument_list|<
name|D
argument_list|>
name|closingFuture
argument_list|)
throws|throws
name|ExecutionException
block|{
name|checkState
argument_list|(
name|beingCalled
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|futures
operator|.
name|contains
argument_list|(
name|closingFuture
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Futures
operator|.
name|getDone
argument_list|(
name|closingFuture
operator|.
name|future
argument_list|)
return|;
block|}
end_class

begin_expr_stmt
DECL|method|call ( CombiningCallable<V> combiner, CloseableList closeables)
specifier|private
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|V
name|call
argument_list|(
name|CombiningCallable
argument_list|<
name|V
argument_list|>
name|combiner
argument_list|,
name|CloseableList
name|closeables
argument_list|)
throws|throws
name|Exception
block|{
name|beingCalled
operator|=
literal|true
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|CloseableList
name|newCloseables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
end_decl_stmt

begin_try
try|try
block|{
return|return
name|combiner
operator|.
name|call
argument_list|(
name|newCloseables
operator|.
name|closer
argument_list|,
name|this
argument_list|)
return|;
block|}
finally|finally
block|{
name|closeables
operator|.
name|add
argument_list|(
name|newCloseables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|beingCalled
operator|=
literal|false
expr_stmt|;
block|}
end_try

begin_expr_stmt
unit|}      private
DECL|method|callAsync ( AsyncCombiningCallable<V> combiner, CloseableList closeables)
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|FluentFuture
argument_list|<
name|V
argument_list|>
name|callAsync
argument_list|(
name|AsyncCombiningCallable
argument_list|<
name|V
argument_list|>
name|combiner
argument_list|,
name|CloseableList
name|closeables
argument_list|)
throws|throws
name|Exception
block|{
name|beingCalled
operator|=
literal|true
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|CloseableList
name|newCloseables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
end_decl_stmt

begin_try
try|try
block|{
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|closingFuture
init|=
name|combiner
operator|.
name|call
argument_list|(
name|newCloseables
operator|.
name|closer
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|closingFuture
operator|.
name|becomeSubsumedInto
argument_list|(
name|closeables
argument_list|)
expr_stmt|;
return|return
name|closingFuture
operator|.
name|future
return|;
block|}
finally|finally
block|{
name|closeables
operator|.
name|add
argument_list|(
name|newCloseables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|beingCalled
operator|=
literal|false
expr_stmt|;
block|}
end_try

begin_comment
unit|}   }
comment|/**    * A builder of a {@link ClosingFuture} step that is derived from more than one input step.    *    *<p>See {@link #whenAllComplete(Iterable)} and {@link #whenAllSucceed(Iterable)} for how to    * instantiate this class.    *    *<p>Example:    *    *<pre>{@code    * final ClosingFuture<BufferedReader> file1ReaderFuture = ...;    * final ClosingFuture<BufferedReader> file2ReaderFuture = ...;    * ListenableFuture<Integer> numberOfDifferentLines =    *       ClosingFuture.whenAllSucceed(file1ReaderFuture, file2ReaderFuture)    *           .call(    *               (closer, peeker) -> {    *                 BufferedReader file1Reader = peeker.getDone(file1ReaderFuture);    *                 BufferedReader file2Reader = peeker.getDone(file2ReaderFuture);    *                 return countDifferentLines(file1Reader, file2Reader);    *               },    *               executor)    *           .closing(executor);    * }</pre>    */
end_comment

begin_comment
comment|// TODO(cpovirk): Use simple name instead of fully qualified after we stop building with JDK 8.
end_comment

begin_class
annotation|@
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|DoNotMock
argument_list|(
literal|"Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead."
argument_list|)
DECL|class|Combiner
specifier|public
specifier|static
class|class
name|Combiner
block|{
DECL|field|closeables
specifier|private
specifier|final
name|CloseableList
name|closeables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
comment|/**      * An operation that returns a result and may throw an exception.      *      * @param<V> the type of the result      */
annotation|@
name|FunctionalInterface
DECL|interface|CombiningCallable
specifier|public
expr|interface
name|CombiningCallable
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Computes a result, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        *        * @param peeker used to get the value of any of the input futures        */
DECL|method|call (DeferredCloser closer, Peeker peeker)
name|V
name|call
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|Peeker
name|peeker
argument_list|)
throws|throws
name|Exception
block|;     }
comment|/**      * An operation that returns a {@link ClosingFuture} result and may throw an exception.      *      * @param<V> the type of the result      */
expr|@
name|FunctionalInterface
DECL|interface|AsyncCombiningCallable
specifier|public
expr|interface
name|AsyncCombiningCallable
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Computes a {@link ClosingFuture} result, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        *        * @param peeker used to get the value of any of the input futures        */
DECL|method|call (DeferredCloser closer, Peeker peeker)
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|call
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|Peeker
name|peeker
argument_list|)
throws|throws
name|Exception
block|;     }
DECL|field|allMustSucceed
specifier|private
name|final
name|boolean
name|allMustSucceed
expr_stmt|;
DECL|field|inputs
specifier|protected
specifier|final
name|ImmutableList
argument_list|<
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputs
decl_stmt|;
DECL|method|Combiner (boolean allMustSucceed, Iterable<? extends ClosingFuture<?>> inputs)
specifier|private
name|Combiner
parameter_list|(
name|boolean
name|allMustSucceed
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputs
parameter_list|)
block|{
name|this
operator|.
name|allMustSucceed
operator|=
name|allMustSucceed
expr_stmt|;
name|this
operator|.
name|inputs
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|inputs
argument_list|)
expr_stmt|;
for|for
control|(
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|input
range|:
name|inputs
control|)
block|{
name|input
operator|.
name|becomeSubsumedInto
argument_list|(
name|closeables
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * combining function to their values. The function can use a {@link DeferredCloser} to capture      * objects to be closed when the pipeline is done.      *      *<p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs      * fail, so will the returned step.      *      *<p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be      * cancelled.      *      *<p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown      * {@code ExecutionException} will be extracted and used as the failure of the derived step.      */
DECL|method|call ( final CombiningCallable<V> combiningCallable, Executor executor)
specifier|public
parameter_list|<
name|V
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|call
parameter_list|(
specifier|final
name|CombiningCallable
argument_list|<
name|V
argument_list|>
name|combiningCallable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|Callable
argument_list|<
name|V
argument_list|>
name|callable
init|=
operator|new
name|Callable
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|Peeker
argument_list|(
name|inputs
argument_list|)
operator|.
name|call
argument_list|(
name|combiningCallable
argument_list|,
name|closeables
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|combiningCallable
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|derived
init|=
operator|new
name|ClosingFuture
argument_list|<>
argument_list|(
name|futureCombiner
argument_list|()
operator|.
name|call
argument_list|(
name|callable
argument_list|,
name|executor
argument_list|)
argument_list|)
decl_stmt|;
name|derived
operator|.
name|closeables
operator|.
name|add
argument_list|(
name|closeables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|derived
return|;
block|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * {@code ClosingFuture}-returning function to their values. The function can use a {@link      * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those      * captured by the returned {@link ClosingFuture}).      *      *<p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs      * fail, so will the returned step.      *      *<p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be      * cancelled.      *      *<p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown      * {@code ExecutionException} will be extracted and used as the failure of the derived step.      *      *<p>If the combiningCallable throws any other exception, it will be used as the failure of the      * derived step.      *      *<p>If an exception is thrown after the combiningCallable creates a {@code ClosingFuture},      * then none of the closeable objects in that {@code ClosingFuture} will be closed.      *      *<p>Usage guidelines for this method:      *      *<ul>      *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a      *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,      *       Executor)} instead, with a function that returns the next value directly.      *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)      *       closer.eventuallyClose()} for every closeable object this step creates in order to      *       capture it for later closing.      *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code      *       ClosingFuture} call {@link #from(ListenableFuture)}.      *</ul>      *      *<p>The same warnings about doing heavyweight operations within {@link      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.      */
DECL|method|callAsync ( final AsyncCombiningCallable<V> combiningCallable, Executor executor)
specifier|public
parameter_list|<
name|V
parameter_list|>
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|callAsync
parameter_list|(
specifier|final
name|AsyncCombiningCallable
argument_list|<
name|V
argument_list|>
name|combiningCallable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|AsyncCallable
argument_list|<
name|V
argument_list|>
name|asyncCallable
init|=
operator|new
name|AsyncCallable
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|Peeker
argument_list|(
name|inputs
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiningCallable
argument_list|,
name|closeables
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|combiningCallable
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|ClosingFuture
argument_list|<
name|V
argument_list|>
name|derived
init|=
operator|new
name|ClosingFuture
argument_list|<>
argument_list|(
name|futureCombiner
argument_list|()
operator|.
name|callAsync
argument_list|(
name|asyncCallable
argument_list|,
name|executor
argument_list|)
argument_list|)
decl_stmt|;
name|derived
operator|.
name|closeables
operator|.
name|add
argument_list|(
name|closeables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|derived
return|;
block|}
DECL|method|futureCombiner ()
specifier|private
name|FutureCombiner
argument_list|<
name|Object
argument_list|>
name|futureCombiner
parameter_list|()
block|{
return|return
name|allMustSucceed
condition|?
name|Futures
operator|.
name|whenAllSucceed
argument_list|(
name|inputFutures
argument_list|()
argument_list|)
else|:
name|Futures
operator|.
name|whenAllComplete
argument_list|(
name|inputFutures
argument_list|()
argument_list|)
return|;
block|}
DECL|field|INNER_FUTURE
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|,
name|FluentFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|INNER_FUTURE
init|=
operator|new
name|Function
argument_list|<
name|ClosingFuture
argument_list|<
name|?
argument_list|>
argument_list|,
name|FluentFuture
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FluentFuture
argument_list|<
name|?
argument_list|>
name|apply
parameter_list|(
name|ClosingFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
return|return
name|future
operator|.
name|future
return|;
block|}
block|}
empty_stmt|;
DECL|method|inputFutures ()
specifier|private
name|ImmutableList
argument_list|<
name|FluentFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputFutures
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|inputs
argument_list|)
operator|.
name|transform
argument_list|(
name|INNER_FUTURE
argument_list|)
operator|.
name|toList
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * A generic {@link Combiner} that lets you use a lambda or method reference to combine two {@link    * ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} to start this    * combination.    *    * @param<V1> the type returned by the first future    * @param<V2> the type returned by the second future    */
end_comment

begin_expr_stmt
DECL|class|Combiner2
specifier|public
specifier|static
name|final
name|class
name|Combiner2
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|Combiner
block|{
comment|/**      * A function that returns a value when applied to the values of the two futures passed to      * {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<U> the type returned by the function      */
block|@
name|FunctionalInterface
DECL|interface|ClosingFunction2
specifier|public
expr|interface
name|ClosingFunction2
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to two inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2)
name|U
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|)
throws|throws
name|Exception
block|;     }
comment|/**      * A function that returns a {@link ClosingFuture} when applied to the values of the two futures      * passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<U> the type returned by the function      */
expr|@
name|FunctionalInterface
DECL|interface|AsyncClosingFunction2
specifier|public
expr|interface
name|AsyncClosingFunction2
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to two inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2)
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|)
throws|throws
name|Exception
block|;     }
DECL|field|future1
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
block|;
DECL|field|future2
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
block|;
DECL|method|Combiner2 (ClosingFuture<V1> future1, ClosingFuture<V2> future2)
specifier|private
name|Combiner2
argument_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
argument_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
argument_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
argument_list|)
block|;
name|this
operator|.
name|future1
operator|=
name|future1
block|;
name|this
operator|.
name|future2
operator|=
name|future2
block|;     }
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * combining function to their values. The function can use a {@link DeferredCloser} to capture      * objects to be closed when the pipeline is done.      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and      * any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      */
DECL|method|call ( final ClosingFunction2<V1, V2, U> function, Executor executor)
specifier|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
argument_list|(
name|final
name|ClosingFunction2
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|call
argument_list|(
operator|new
name|CombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|U
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * {@code ClosingFuture}-returning function to their values. The function can use a {@link      * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those      * captured by the returned {@link ClosingFuture}).      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and      * any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      *      *<p>If the function throws any other exception, it will be used as the failure of the derived      * step.      *      *<p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of      * the closeable objects in that {@code ClosingFuture} will be closed.      *      *<p>Usage guidelines for this method:      *      *<ul>      *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a      *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,      *       Executor)} instead, with a function that returns the next value directly.      *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)      *       closer.eventuallyClose()} for every closeable object this step creates in order to      *       capture it for later closing.      *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code      *       ClosingFuture} call {@link #from(ListenableFuture)}.      *</ul>      *      *<p>The same warnings about doing heavyweight operations within {@link      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.      */
end_comment

begin_expr_stmt
DECL|method|callAsync ( final AsyncClosingFunction2<V1, V2, U> function, Executor executor)
unit|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|callAsync
argument_list|(
name|final
name|AsyncClosingFunction2
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|callAsync
argument_list|(
operator|new
name|AsyncCombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}   }
comment|/**    * A generic {@link Combiner} that lets you use a lambda or method reference to combine three    * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture,    * ClosingFuture)} to start this combination.    *    * @param<V1> the type returned by the first future    * @param<V2> the type returned by the second future    * @param<V3> the type returned by the third future    */
end_comment

begin_expr_stmt
DECL|class|Combiner3
specifier|public
specifier|static
name|final
name|class
name|Combiner3
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|,
name|V3
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|Combiner
block|{
comment|/**      * A function that returns a value when applied to the values of the three futures passed to      * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<U> the type returned by the function      */
block|@
name|FunctionalInterface
DECL|interface|ClosingFunction3
specifier|public
expr|interface
name|ClosingFunction3
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to three inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2, V3 v3)
name|U
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|v3
argument_list|)
throws|throws
name|Exception
block|;     }
comment|/**      * A function that returns a {@link ClosingFuture} when applied to the values of the three      * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<U> the type returned by the function      */
expr|@
name|FunctionalInterface
DECL|interface|AsyncClosingFunction3
specifier|public
expr|interface
name|AsyncClosingFunction3
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to three inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2, V3 value3)
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|value3
argument_list|)
throws|throws
name|Exception
block|;     }
DECL|field|future1
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
block|;
DECL|field|future2
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
block|;
DECL|field|future3
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
block|;
DECL|method|Combiner3 ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3)
specifier|private
name|Combiner3
argument_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
argument_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
argument_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
argument_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
argument_list|)
block|;
name|this
operator|.
name|future1
operator|=
name|future1
block|;
name|this
operator|.
name|future2
operator|=
name|future2
block|;
name|this
operator|.
name|future3
operator|=
name|future3
block|;     }
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * combining function to their values. The function can use a {@link DeferredCloser} to capture      * objects to be closed when the pipeline is done.      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture)} and any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      */
DECL|method|call ( final ClosingFunction3<V1, V2, V3, U> function, Executor executor)
specifier|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
argument_list|(
name|final
name|ClosingFunction3
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|call
argument_list|(
operator|new
name|CombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|U
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * {@code ClosingFuture}-returning function to their values. The function can use a {@link      * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those      * captured by the returned {@link ClosingFuture}).      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture)} and any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      *      *<p>If the function throws any other exception, it will be used as the failure of the derived      * step.      *      *<p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of      * the closeable objects in that {@code ClosingFuture} will be closed.      *      *<p>Usage guidelines for this method:      *      *<ul>      *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a      *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,      *       Executor)} instead, with a function that returns the next value directly.      *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)      *       closer.eventuallyClose()} for every closeable object this step creates in order to      *       capture it for later closing.      *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code      *       ClosingFuture} call {@link #from(ListenableFuture)}.      *</ul>      *      *<p>The same warnings about doing heavyweight operations within {@link      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.      */
end_comment

begin_expr_stmt
DECL|method|callAsync ( final AsyncClosingFunction3<V1, V2, V3, U> function, Executor executor)
unit|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|callAsync
argument_list|(
name|final
name|AsyncClosingFunction3
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|callAsync
argument_list|(
operator|new
name|AsyncCombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}   }
comment|/**    * A generic {@link Combiner} that lets you use a lambda or method reference to combine four    * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,    * ClosingFuture)} to start this combination.    *    * @param<V1> the type returned by the first future    * @param<V2> the type returned by the second future    * @param<V3> the type returned by the third future    * @param<V4> the type returned by the fourth future    */
end_comment

begin_expr_stmt
DECL|class|Combiner4
specifier|public
specifier|static
name|final
name|class
name|Combiner4
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|,
name|V3
expr|extends @
name|Nullable
name|Object
operator|,
name|V4
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|Combiner
block|{
comment|/**      * A function that returns a value when applied to the values of the four futures passed to      * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<V4> the type returned by the fourth future      * @param<U> the type returned by the function      */
block|@
name|FunctionalInterface
DECL|interface|ClosingFunction4
specifier|public
expr|interface
name|ClosingFunction4
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|V4
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to four inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2, V3 value3, V4 value4)
name|U
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|value3
argument_list|,
name|V4
name|value4
argument_list|)
throws|throws
name|Exception
block|;     }
comment|/**      * A function that returns a {@link ClosingFuture} when applied to the values of the four      * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,      * ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<V4> the type returned by the fourth future      * @param<U> the type returned by the function      */
expr|@
name|FunctionalInterface
DECL|interface|AsyncClosingFunction4
specifier|public
expr|interface
name|AsyncClosingFunction4
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|V4
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to four inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2, V3 value3, V4 value4)
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|value3
argument_list|,
name|V4
name|value4
argument_list|)
throws|throws
name|Exception
block|;     }
DECL|field|future1
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
block|;
DECL|field|future2
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
block|;
DECL|field|future3
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
block|;
DECL|field|future4
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
block|;
DECL|method|Combiner4 ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4)
specifier|private
name|Combiner4
argument_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
argument_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
argument_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
argument_list|,
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
argument_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|)
argument_list|)
block|;
name|this
operator|.
name|future1
operator|=
name|future1
block|;
name|this
operator|.
name|future2
operator|=
name|future2
block|;
name|this
operator|.
name|future3
operator|=
name|future3
block|;
name|this
operator|.
name|future4
operator|=
name|future4
block|;     }
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * combining function to their values. The function can use a {@link DeferredCloser} to capture      * objects to be closed when the pipeline is done.      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      */
DECL|method|call ( final ClosingFunction4<V1, V2, V3, V4, U> function, Executor executor)
specifier|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
argument_list|(
name|final
name|ClosingFunction4
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|call
argument_list|(
operator|new
name|CombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|U
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future4
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * {@code ClosingFuture}-returning function to their values. The function can use a {@link      * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those      * captured by the returned {@link ClosingFuture}).      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      *      *<p>If the function throws any other exception, it will be used as the failure of the derived      * step.      *      *<p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of      * the closeable objects in that {@code ClosingFuture} will be closed.      *      *<p>Usage guidelines for this method:      *      *<ul>      *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a      *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,      *       Executor)} instead, with a function that returns the next value directly.      *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)      *       closer.eventuallyClose()} for every closeable object this step creates in order to      *       capture it for later closing.      *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code      *       ClosingFuture} call {@link #from(ListenableFuture)}.      *</ul>      *      *<p>The same warnings about doing heavyweight operations within {@link      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.      */
end_comment

begin_expr_stmt
DECL|method|callAsync ( final AsyncClosingFunction4<V1, V2, V3, V4, U> function, Executor executor)
unit|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|callAsync
argument_list|(
name|final
name|AsyncClosingFunction4
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|callAsync
argument_list|(
operator|new
name|AsyncCombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future4
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}   }
comment|/**    * A generic {@link Combiner} that lets you use a lambda or method reference to combine five    * {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,    * ClosingFuture, ClosingFuture)} to start this combination.    *    * @param<V1> the type returned by the first future    * @param<V2> the type returned by the second future    * @param<V3> the type returned by the third future    * @param<V4> the type returned by the fourth future    * @param<V5> the type returned by the fifth future    */
end_comment

begin_expr_stmt
DECL|class|Combiner5
specifier|public
specifier|static
name|final
name|class
name|Combiner5
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|,
name|V3
expr|extends @
name|Nullable
name|Object
operator|,
name|V4
expr|extends @
name|Nullable
name|Object
operator|,
name|V5
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|Combiner
block|{
comment|/**      * A function that returns a value when applied to the values of the five futures passed to      * {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture,      * ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<V4> the type returned by the fourth future      * @param<V5> the type returned by the fifth future      * @param<U> the type returned by the function      */
block|@
name|FunctionalInterface
DECL|interface|ClosingFunction5
specifier|public
expr|interface
name|ClosingFunction5
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|V4
expr|extends @
name|Nullable
name|Object
block|,
name|V5
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to five inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply (DeferredCloser closer, V1 value1, V2 value2, V3 value3, V4 value4, V5 value5)
name|U
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|value3
argument_list|,
name|V4
name|value4
argument_list|,
name|V5
name|value5
argument_list|)
throws|throws
name|Exception
block|;     }
comment|/**      * A function that returns a {@link ClosingFuture} when applied to the values of the five      * futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,      * ClosingFuture, ClosingFuture)}.      *      * @param<V1> the type returned by the first future      * @param<V2> the type returned by the second future      * @param<V3> the type returned by the third future      * @param<V4> the type returned by the fourth future      * @param<V5> the type returned by the fifth future      * @param<U> the type returned by the function      */
expr|@
name|FunctionalInterface
DECL|interface|AsyncClosingFunction5
specifier|public
expr|interface
name|AsyncClosingFunction5
operator|<
name|V1
expr|extends @
name|Nullable
name|Object
block|,
name|V2
expr|extends @
name|Nullable
name|Object
block|,
name|V3
expr|extends @
name|Nullable
name|Object
block|,
name|V4
expr|extends @
name|Nullable
name|Object
block|,
name|V5
expr|extends @
name|Nullable
name|Object
block|,
name|U
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/**        * Applies this function to five inputs, or throws an exception if unable to do so.        *        *<p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Closeable,        * Executor) closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline        * is done (but not before this method completes), even if this method throws or the pipeline        * is cancelled.        */
DECL|method|apply ( DeferredCloser closer, V1 value1, V2 value2, V3 value3, V4 value4, V5 value5)
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|apply
argument_list|(
name|DeferredCloser
name|closer
argument_list|,
name|V1
name|value1
argument_list|,
name|V2
name|value2
argument_list|,
name|V3
name|value3
argument_list|,
name|V4
name|value4
argument_list|,
name|V5
name|value5
argument_list|)
throws|throws
name|Exception
block|;     }
DECL|field|future1
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
block|;
DECL|field|future2
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
block|;
DECL|field|future3
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
block|;
DECL|field|future4
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
block|;
DECL|field|future5
specifier|private
name|final
name|ClosingFuture
argument_list|<
name|V5
argument_list|>
name|future5
block|;
DECL|method|Combiner5 ( ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4, ClosingFuture<V5> future5)
specifier|private
name|Combiner5
argument_list|(
name|ClosingFuture
argument_list|<
name|V1
argument_list|>
name|future1
argument_list|,
name|ClosingFuture
argument_list|<
name|V2
argument_list|>
name|future2
argument_list|,
name|ClosingFuture
argument_list|<
name|V3
argument_list|>
name|future3
argument_list|,
name|ClosingFuture
argument_list|<
name|V4
argument_list|>
name|future4
argument_list|,
name|ClosingFuture
argument_list|<
name|V5
argument_list|>
name|future5
argument_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|)
argument_list|)
block|;
name|this
operator|.
name|future1
operator|=
name|future1
block|;
name|this
operator|.
name|future2
operator|=
name|future2
block|;
name|this
operator|.
name|future3
operator|=
name|future3
block|;
name|this
operator|.
name|future4
operator|=
name|future4
block|;
name|this
operator|.
name|future5
operator|=
name|future5
block|;     }
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * combining function to their values. The function can use a {@link DeferredCloser} to capture      * objects to be closed when the pipeline is done.      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the      * returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      */
DECL|method|call ( final ClosingFunction5<V1, V2, V3, V4, V5, U> function, Executor executor)
specifier|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
argument_list|(
name|final
name|ClosingFunction5
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|,
name|V5
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|call
argument_list|(
operator|new
name|CombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|U
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future4
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future5
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**      * Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a      * {@code ClosingFuture}-returning function to their values. The function can use a {@link      * DeferredCloser} to capture objects to be closed when the pipeline is done (other than those      * captured by the returned {@link ClosingFuture}).      *      *<p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,      * ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the      * returned step.      *      *<p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.      *      *<p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and used as the failure of the derived step.      *      *<p>If the function throws any other exception, it will be used as the failure of the derived      * step.      *      *<p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of      * the closeable objects in that {@code ClosingFuture} will be closed.      *      *<p>Usage guidelines for this method:      *      *<ul>      *<li>Use this method only when calling an API that returns a {@link ListenableFuture} or a      *       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,      *       Executor)} instead, with a function that returns the next value directly.      *<li>Call {@link DeferredCloser#eventuallyClose(Closeable, Executor)      *       closer.eventuallyClose()} for every closeable object this step creates in order to      *       capture it for later closing.      *<li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code      *       ClosingFuture} call {@link #from(ListenableFuture)}.      *</ul>      *      *<p>The same warnings about doing heavyweight operations within {@link      * ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.      */
end_comment

begin_expr_stmt
DECL|method|callAsync ( final AsyncClosingFunction5<V1, V2, V3, V4, V5, U> function, Executor executor)
unit|public
operator|<
name|U
expr|extends @
name|Nullable
name|Object
operator|>
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|callAsync
argument_list|(
name|final
name|AsyncClosingFunction5
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|,
name|V3
argument_list|,
name|V4
argument_list|,
name|V5
argument_list|,
name|U
argument_list|>
name|function
argument_list|,
name|Executor
name|executor
argument_list|)
block|{
return|return
name|callAsync
argument_list|(
operator|new
name|AsyncCombiningCallable
argument_list|<
name|U
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|call
parameter_list|(
name|DeferredCloser
name|closer
parameter_list|,
name|Peeker
name|peeker
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|closer
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future1
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future3
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future4
argument_list|)
argument_list|,
name|peeker
operator|.
name|getDone
argument_list|(
name|future5
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
name|function
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
name|executor
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
unit|}   }
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// TODO(dpb): Better toString, in the style of Futures.transform etc.
return|return
name|toStringHelper
argument_list|(
name|this
argument_list|)
operator|.
name|add
argument_list|(
literal|"state"
argument_list|,
name|state
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|addValue
argument_list|(
name|future
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|finalize ()
specifier|protected
name|void
name|finalize
parameter_list|()
block|{
if|if
condition|(
name|state
operator|.
name|get
argument_list|()
operator|.
name|equals
argument_list|(
name|OPEN
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|SEVERE
argument_list|,
literal|"Uh oh! An open ClosingFuture has leaked and will close: {0}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|FluentFuture
argument_list|<
name|V
argument_list|>
name|unused
init|=
name|finishToFuture
argument_list|()
decl_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|closeQuietly (final AutoCloseable closeable, Executor executor)
specifier|private
specifier|static
name|void
name|closeQuietly
parameter_list|(
specifier|final
name|AutoCloseable
name|closeable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|closeable
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|closeable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|WARNING
argument_list|,
literal|"thrown by close()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|.
name|isLoggable
argument_list|(
name|WARNING
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|WARNING
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"while submitting close to %s; will close inline"
argument_list|,
name|executor
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|closeQuietly
argument_list|(
name|closeable
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|checkAndUpdateState (State oldState, State newState)
specifier|private
name|void
name|checkAndUpdateState
parameter_list|(
name|State
name|oldState
parameter_list|,
name|State
name|newState
parameter_list|)
block|{
name|checkState
argument_list|(
name|compareAndUpdateState
argument_list|(
name|oldState
argument_list|,
name|newState
argument_list|)
argument_list|,
literal|"Expected state to be %s, but it was %s"
argument_list|,
name|oldState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|compareAndUpdateState (State oldState, State newState)
specifier|private
name|boolean
name|compareAndUpdateState
parameter_list|(
name|State
name|oldState
parameter_list|,
name|State
name|newState
parameter_list|)
block|{
return|return
name|state
operator|.
name|compareAndSet
argument_list|(
name|oldState
argument_list|,
name|newState
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?
end_comment

begin_class
DECL|class|CloseableList
specifier|private
specifier|static
specifier|final
class|class
name|CloseableList
extends|extends
name|IdentityHashMap
argument_list|<
name|AutoCloseable
argument_list|,
name|Executor
argument_list|>
implements|implements
name|Closeable
block|{
DECL|field|closer
specifier|private
specifier|final
name|DeferredCloser
name|closer
init|=
operator|new
name|DeferredCloser
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
DECL|field|whenClosed
specifier|private
specifier|volatile
name|CountDownLatch
name|whenClosed
decl_stmt|;
DECL|method|applyClosingFunction ( ClosingFunction<? super V, U> transformation, V input)
parameter_list|<
name|V
parameter_list|,
name|U
parameter_list|>
name|ListenableFuture
argument_list|<
name|U
argument_list|>
name|applyClosingFunction
parameter_list|(
name|ClosingFunction
argument_list|<
name|?
super|super
name|V
argument_list|,
name|U
argument_list|>
name|transformation
parameter_list|,
name|V
name|input
parameter_list|)
throws|throws
name|Exception
block|{
comment|// TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
name|CloseableList
name|newCloseables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|immediateFuture
argument_list|(
name|transformation
operator|.
name|apply
argument_list|(
name|newCloseables
operator|.
name|closer
argument_list|,
name|input
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|add
argument_list|(
name|newCloseables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyAsyncClosingFunction ( AsyncClosingFunction<V, U> transformation, V input)
parameter_list|<
name|V
parameter_list|,
name|U
parameter_list|>
name|FluentFuture
argument_list|<
name|U
argument_list|>
name|applyAsyncClosingFunction
parameter_list|(
name|AsyncClosingFunction
argument_list|<
name|V
argument_list|,
name|U
argument_list|>
name|transformation
parameter_list|,
name|V
name|input
parameter_list|)
throws|throws
name|Exception
block|{
comment|// TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
name|CloseableList
name|newCloseables
init|=
operator|new
name|CloseableList
argument_list|()
decl_stmt|;
try|try
block|{
name|ClosingFuture
argument_list|<
name|U
argument_list|>
name|closingFuture
init|=
name|transformation
operator|.
name|apply
argument_list|(
name|newCloseables
operator|.
name|closer
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|closingFuture
operator|.
name|becomeSubsumedInto
argument_list|(
name|newCloseables
argument_list|)
expr_stmt|;
return|return
name|closingFuture
operator|.
name|future
return|;
block|}
finally|finally
block|{
name|add
argument_list|(
name|newCloseables
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|AutoCloseable
argument_list|,
name|Executor
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
name|closeQuietly
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|whenClosed
operator|!=
literal|null
condition|)
block|{
name|whenClosed
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|add (@ullable AutoCloseable closeable, Executor executor)
name|void
name|add
parameter_list|(
annotation|@
name|Nullable
name|AutoCloseable
name|closeable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeable
operator|==
literal|null
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|put
argument_list|(
name|closeable
argument_list|,
name|executor
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|closeQuietly
argument_list|(
name|closeable
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a latch that reaches zero when this objects' deferred closeables have been closed.      */
DECL|method|whenClosedCountDown ()
name|CountDownLatch
name|whenClosedCountDown
parameter_list|()
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return
operator|new
name|CountDownLatch
argument_list|(
literal|0
argument_list|)
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return
operator|new
name|CountDownLatch
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|checkState
argument_list|(
name|whenClosed
operator|==
literal|null
argument_list|)
expr_stmt|;
return|return
name|whenClosed
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Returns an object that can be used to wait until this objects' deferred closeables have all had    * {@link Runnable}s that close them submitted to each one's closing {@link Executor}.    */
end_comment

begin_function
annotation|@
name|VisibleForTesting
DECL|method|whenClosedCountDown ()
name|CountDownLatch
name|whenClosedCountDown
parameter_list|()
block|{
return|return
name|closeables
operator|.
name|whenClosedCountDown
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** The state of a {@link CloseableList}. */
end_comment

begin_enum
DECL|enum|State
enum|enum
name|State
block|{
comment|/** The {@link CloseableList} has not been subsumed or closed. */
DECL|enumConstant|OPEN
name|OPEN
block|,
comment|/**      * The {@link CloseableList} has been subsumed into another. It may not be closed or subsumed      * into any other.      */
DECL|enumConstant|SUBSUMED
name|SUBSUMED
block|,
comment|/**      * Some {@link ListenableFuture} has a callback attached that will close the {@link      * CloseableList}, but it has not yet run. The {@link CloseableList} may not be subsumed.      */
DECL|enumConstant|WILL_CLOSE
name|WILL_CLOSE
block|,
comment|/**      * The callback that closes the {@link CloseableList} is running, but it has not completed. The      * {@link CloseableList} may not be subsumed.      */
DECL|enumConstant|CLOSING
name|CLOSING
block|,
comment|/** The {@link CloseableList} has been closed. It may not be further subsumed. */
DECL|enumConstant|CLOSED
name|CLOSED
block|,
comment|/**      * {@link ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)} has been      * called. The step may not be further subsumed, nor may {@link #finishToFuture()} be called.      */
DECL|enumConstant|WILL_CREATE_VALUE_AND_CLOSER
name|WILL_CREATE_VALUE_AND_CLOSER
block|,   }
end_enum

unit|}
end_unit

