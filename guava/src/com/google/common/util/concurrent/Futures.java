begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|getUninterruptibly
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|currentThread
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to the {@link Future} interface.  *  * @author Kevin Bourrillion  * @author Nishant Thakkar  * @author Sven Mawson  * @since Guava release 01  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|Futures
specifier|public
specifier|final
class|class
name|Futures
block|{
DECL|method|Futures ()
specifier|private
name|Futures
parameter_list|()
block|{}
comment|/**    *<b>Soon to be removed (for Guava release 11), use    * {@link Uninterruptibles#getUninterruptibly(Future) getUninterruptibly}</b>    * Returns an uninterruptible view of a {@code Future}. If a thread is    * interrupted during an attempt to {@code get()} from the returned future, it    * continues to wait on the result until it is available or the timeout    * elapses, and only then re-interrupts the thread.    */
comment|// TODO(user): Make this package-private internally
annotation|@
name|Deprecated
DECL|method|makeUninterruptible ( final Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
name|makeUninterruptible
parameter_list|(
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|UninterruptibleFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|ExecutionException
block|{
return|return
name|Uninterruptibles
operator|.
name|getUninterruptibly
argument_list|(
name|future
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|ExecutionException
block|{
return|return
name|Uninterruptibles
operator|.
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    *    *<p>Creates a {@link ListenableFuture} out of a normal {@link Future}. The    * returned future will create a thread to wait for the source future to    * complete before executing the listeners.    *    *<p><b>Warning:</b> If the input future does not already implement {@link    * ListenableFuture}, the returned future will emulate {@link    * ListenableFuture#addListener} by taking a thread from an internal,    * unbounded pool at the first call to {@code addListener} and holding it    * until the future is {@linkplain Future#isDone() done}.    * @deprecated Prefer to create {@code ListenableFuture} instances with {@link    *     SettableFuture}, {@link MoreExecutors#listeningDecorator(    *     java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},    *     {@link AbstractFuture}, and other utilities over creating plain {@code    *     Future} instances to be upgraded to {@code ListenableFuture} after the    *     fact.<b>This method is scheduled for deletion in Guava release 11.</b>    */
annotation|@
name|Deprecated
specifier|public
DECL|method|makeListenable ( Future<V> future)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|makeListenable
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|ListenableFutureAdapter
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|)
return|;
block|}
DECL|method|makeListenable ( Future<V> future, Executor executor)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|makeListenable
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|ListenableFutureAdapter
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link CheckedFuture} out of a normal {@link Future} and a    * {@link Function} that maps from {@link Exception} instances into the    * appropriate checked type.    *    *<p><b>Warning:</b> If the input future does not implement {@link    * ListenableFuture}, the returned future will emulate {@link    * ListenableFuture#addListener} by taking a thread from an internal,    * unbounded pool at the first call to {@code addListener} and holding it    * until the future is {@linkplain Future#isDone() done}.    *    *<p>The given mapping function will be applied to an    * {@link InterruptedException}, a {@link CancellationException}, or an    * {@link ExecutionException} with the actual cause of the exception.    * See {@link Future#get()} for details on the exceptions thrown.    *    * @deprecated Use {@link #makeChecked(ListenableFuture, Function)} by    *     ensuring that your input implements {@code ListenableFuture} by    *     creating it with {@link SettableFuture}, {@link    *     MoreExecutors#listeningDecorator(    *     java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},    *     {@link AbstractFuture}, and other utilities instead of creating plain    *     {@code Future} instances to be upgraded to {@code ListenableFuture}    *     after the fact.<b>This method is scheduled for deletion in Guava    *     release 11.</b>    */
annotation|@
name|Deprecated
specifier|public
DECL|method|makeChecked ( Future<V> future, Function<Exception, X> mapper)
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
name|makeChecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
parameter_list|)
block|{
return|return
operator|new
name|MappingCheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
argument_list|(
name|makeListenable
argument_list|(
name|future
argument_list|)
argument_list|,
name|mapper
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link CheckedFuture} out of a normal {@link ListenableFuture}    * and a {@link Function} that maps from {@link Exception} instances into the    * appropriate checked type.    *    *<p>The given mapping function will be applied to an    * {@link InterruptedException}, a {@link CancellationException}, or an    * {@link ExecutionException} with the actual cause of the exception.    * See {@link Future#get()} for details on the exceptions thrown.    *    * @since Guava release 09 (source-compatible since release 01)    */
DECL|method|makeChecked ( ListenableFuture<V> future, Function<Exception, X> mapper)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
name|makeChecked
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
parameter_list|)
block|{
return|return
operator|new
name|MappingCheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|future
argument_list|)
argument_list|,
name|mapper
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code ListenableFuture} which has its value set immediately upon    * construction. The getters just return the value. This {@code Future} can't    * be canceled or timed out and its {@code isDone()} method always returns    * {@code true}.    */
DECL|method|immediateFuture (@ullable V value)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Returns a {@code CheckedFuture} which has its value set immediately upon    * construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} or {@code    * checkedGet()} will immediately return the provided value.    */
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
DECL|method|immediateCheckedFuture (@ullable V value)
name|immediateCheckedFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|Futures
operator|.
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|X
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"impossible"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code ListenableFuture} which has an exception set immediately    * upon construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} will immediately    * throw the provided {@code Throwable} wrapped in an {@code    * ExecutionException}.    *    * @throws Error if the throwable is an {@link Error}.    */
DECL|method|immediateFailedFuture ( Throwable throwable)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFailedFuture
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
name|SettableFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Returns a {@code CheckedFuture} which has an exception set immediately upon    * construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} will immediately    * throw the provided {@code Throwable} wrapped in an {@code    * ExecutionException}, and calling {@code checkedGet()} will throw the    * provided exception itself.    *    * @throws Error if the throwable is an {@link Error}.    */
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
DECL|method|immediateFailedCheckedFuture (final X exception)
name|immediateFailedCheckedFuture
parameter_list|(
specifier|final
name|X
name|exception
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return
name|makeChecked
argument_list|(
name|Futures
operator|.
expr|<
name|V
operator|>
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|X
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|exception
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code Function} to the result of the original {@code    * Future}. Example:    *    *<pre><code>    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   Function<RowKey, ListenableFuture<QueryResult>> queryFunction =    *       new Function<RowKey, ListenableFuture<QueryResult>>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       chain(queryFuture, queryFunction);    *</code></pre>    *    *<p>Note: This overload of {@code chain} is designed for cases in which the    * work of creating the derived future is fast and lightweight, as the method    * does not accept an {@code Executor} to perform the the work in. For heavier    * derivations, this overload carries some caveats: First, the thread that the    * derivation runs in depends on whether the input {@code Future} is done at    * the time {@code chain} is called. In particular, if called late, {@code    * chain} will run the derivation in the thread that calls {@code chain}.    * Second, derivations may run in an internal thread of the system responsible    * for the input {@code Future}, such as an RPC network thread. Finally,    * during the execution of a derivation, the thread cannot submit any    * listeners for execution, even if those listeners are to run in other    * executors.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future and that of the future returned by the    * chain function. That is, if the returned {@code Future} is cancelled, it    * will attempt to cancel the other two, and if either of the other two is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>The typical use for this method would be when a RPC call is dependent on    * the results of another RPC.  One would call the first RPC (input), create a    * function that calls another RPC based on input's result, and then call    * chain on input and that function to get a {@code ListenableFuture} of    * the result.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|chain
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code Function} to the result of the original {@code    * Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   Function<RowKey, ListenableFuture<QueryResult>> queryFunction =    *       new Function<RowKey, ListenableFuture<QueryResult>>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       chain(queryFuture, queryFunction, executor);    * }</pre>    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future and that of the future returned by the    * chain function. That is, if the returned {@code Future} is cancelled, it    * will attempt to cancel the other two, and if either of the other two is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>Note: For cases in which the work of creating the derived future is fast    * and lightweight, consider {@linkplain Futures#chain(ListenableFuture,    * Function) the other overload} or explicit use of {@link    * MoreExecutors#sameThreadExecutor}. For heavier derivations, this choice    * carries some caveats: First, the thread that the derivation runs in depends    * on whether the input {@code Future} is done at the time {@code chain} is    * called. In particular, if called late, {@code chain} will run the    * derivation in the thread that calls {@code chain}. Second, derivations may    * run in an internal thread of the system responsible for the input {@code    * Future}, such as an RPC network thread. Finally, during the execution of a    * derivation, the thread cannot submit any listeners for execution, even if    * those listeners are to run in other executors.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|chain
init|=
operator|new
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|function
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|chain
argument_list|,
name|exec
argument_list|)
expr_stmt|;
return|return
name|chain
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<QueryResult> queryFuture = ...;    *   Function<QueryResult, List<Row>> rowsFunction =    *       new Function<QueryResult, List<Row>>() {    *         public List<Row> apply(QueryResult queryResult) {    *           return queryResult.getRows();    *         }    *       };    *   ListenableFuture<List<Row>> rowsFuture =    *       transform(queryFuture, rowsFunction);    * }</pre>    *    *<p>Note: This overload of {@code transform} is designed for cases in which    * the transformation is fast and lightweight, as the method does not accept    * an {@code Executor} to perform the the work in. For heavier    * transformations, this overload carries some caveats: First, the thread that    * the transformation runs in depends on whether the input {@code Future} is    * done at the time {@code transform} is called. In particular, if called    * late, {@code transform} will perform the transformation in the thread that    * calls {@code transform}. Second, transformations may run in an internal    * thread of the system responsible for the input {@code Future}, such as an    * RPC network thread. Finally, during the execution of a transformation, the    * thread cannot submit any listeners for execution, even if those listeners    * are to run in other executors.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future. That is, if the returned {@code Future}    * is cancelled, it will attempt to cancel the input, and if the input is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    * @param future The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the transformation.    * @since Guava release 09 (in release 01 as {@code compose})    */
DECL|method|transform (ListenableFuture<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|future
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<QueryResult> queryFuture = ...;    *   Function<QueryResult, List<Row>> rowsFunction =    *       new Function<QueryResult, List<Row>>() {    *         public List<Row> apply(QueryResult queryResult) {    *           return queryResult.getRows();    *         }    *       };    *   ListenableFuture<List<Row>> rowsFuture =    *       transform(queryFuture, rowsFunction, executor);    * }</pre>    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future. That is, if the returned {@code Future}    * is cancelled, it will attempt to cancel the input, and if the input is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    *<p>Note: For cases in which the transformation is fast and lightweight,    * consider {@linkplain Futures#transform(ListenableFuture, Function) the    * other overload} or explicit use of {@link    * MoreExecutors#sameThreadExecutor}. For heavier transformations, this choice    * carries some caveats: First, the thread that the transformation runs in    * depends on whether the input {@code Future} is done at the time {@code    * transform} is called. In particular, if called late, {@code transform} will    * perform the transformation in the thread that calls {@code transform}.    * Second, transformations may run in an internal thread of the system    * responsible for the input {@code Future}, such as an RPC network thread.    * Finally, during the execution of a transformation, the thread cannot submit    * any listeners for execution, even if those listeners are to run in other    * executors.    *    * @param future The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the transformation.    * @since Guava release 09 (in release 02 as {@code compose})    */
DECL|method|transform (ListenableFuture<I> future, final Function<? super I, ? extends O> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
name|wrapperFunction
init|=
operator|new
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|apply
parameter_list|(
name|I
name|input
parameter_list|)
block|{
name|O
name|output
init|=
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|immediateFuture
argument_list|(
name|output
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|chain
argument_list|(
name|future
argument_list|,
name|wrapperFunction
argument_list|,
name|exec
argument_list|)
return|;
block|}
comment|/**    * Like {@link #transform(ListenableFuture, Function)} except that the    * transformation {@code function} is invoked on each call to    * {@link Future#get() get()} on the returned future.    *    *<p>The returned {@code Future} reflects the input's cancellation    * state directly, and any attempt to cancel the returned Future is likewise    * passed through to the input Future.    *    *<p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get}    * only apply the timeout to the execution of the underlying {@code Future},    *<em>not</em> to the execution of the transformation function.    *    *<p>The primary audience of this method is callers of {@code transform}    * who don't have a {@code ListenableFuture} available and    * do not mind repeated, lazy function evaluation.    *    * @param future The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.    * @return A future that returns the result of the transformation.    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|lazyTransform (final Future<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|Future
argument_list|<
name|O
argument_list|>
name|lazyTransform
parameter_list|(
specifier|final
name|Future
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|Future
argument_list|<
name|O
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|applyTransformation
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|applyTransformation
argument_list|(
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|O
name|applyTransformation
parameter_list|(
name|I
name|input
parameter_list|)
throws|throws
name|ExecutionException
block|{
try|try
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * Returns a new {@code Future} whose result is the product of applying the    * given {@code Function} to the result of the given {@code Future}. Example:    *    *<pre>   {@code    *   Future<QueryResult> queryFuture = ...;    *   Function<QueryResult, List<Row>> rowsFunction =    *       new Function<QueryResult, List<Row>>() {    *         public List<Row> apply(QueryResult queryResult) {    *           return queryResult.getRows();    *         }    *       };    *   Future<List<Row>> rowsFuture = transform(queryFuture, rowsFunction);    * }</pre>    *    *<p>Each call to {@code Future<O>.get(*)} results in a call to    * {@code Future<I>.get(*)}, but {@code function} is only applied once, so it    * is assumed that {@code Future<I>.get(*)} is idempotent.    *    *<p>When calling {@link Future#get(long, TimeUnit)} on the returned    * future, the timeout only applies to the future passed in to this method.    * Any additional time taken by applying {@code function} is not considered.    * (Exception: If the input future is a {@link ListenableFuture}, timeouts    * will be strictly enforced.)    *    * @param future The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that calls one of the varieties of {@code get()}.    * @return A future that computes result of the transformation    * @since Guava release 09 (in release 01 as {@code compose})    */
DECL|method|transform (final Future<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|Future
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Future
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
condition|)
block|{
return|return
name|transform
argument_list|(
operator|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
operator|)
name|future
argument_list|,
name|function
argument_list|)
return|;
block|}
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|Future
argument_list|<
name|O
argument_list|>
argument_list|()
block|{
comment|/*        * Concurrency detail:        *        *<p>To preserve the idempotency of calls to this.get(*) calls to the        * function are only applied once. A lock is required to prevent multiple        * applications of the function. The calls to future.get(*) are performed        * outside the lock, as is required to prevent calls to        * get(long, TimeUnit) to persist beyond their timeout.        *        *<p>Calls to future.get(*) on every call to this.get(*) also provide        * the cancellation behavior for this.        *        *<p>(Consider: in thread A, call get(), in thread B call get(long,        * TimeUnit). Thread B may have to wait for Thread A to finish, which        * would be unacceptable.)        *        *<p>Note that each call to Future<O>.get(*) results in a call to        * Future<I>.get(*), but the function is only applied once, so        * Future<I>.get(*) is assumed to be idempotent.        */
specifier|private
specifier|final
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|set
init|=
literal|false
decl_stmt|;
specifier|private
name|O
name|value
init|=
literal|null
decl_stmt|;
specifier|private
name|ExecutionException
name|exception
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|O
name|apply
parameter_list|(
name|I
name|raw
parameter_list|)
throws|throws
name|ExecutionException
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|set
condition|)
block|{
try|try
block|{
name|value
operator|=
name|function
operator|.
name|apply
argument_list|(
name|raw
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|exception
operator|=
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|exception
operator|=
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
return|return
name|value
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * An implementation of {@code ListenableFuture} that also implements    * {@code Runnable} so that it can be used to nest ListenableFutures.    * Once the passed-in {@code ListenableFuture} is complete, it calls the    * passed-in {@code Function} to generate the result.    *    *<p>If the function throws any checked exceptions, they should be wrapped    * in a {@code UndeclaredThrowableException} so that this class can get    * access to the cause.    */
DECL|class|ChainingListenableFuture
specifier|private
specifier|static
class|class
name|ChainingListenableFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
extends|extends
name|AbstractFuture
argument_list|<
name|O
argument_list|>
implements|implements
name|Runnable
block|{
specifier|private
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
DECL|field|function
name|function
decl_stmt|;
DECL|field|inputFuture
specifier|private
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
decl_stmt|;
DECL|field|outputFuture
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
decl_stmt|;
DECL|field|mayInterruptIfRunningChannel
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Boolean
argument_list|>
name|mayInterruptIfRunningChannel
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Boolean
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|outputCreated
specifier|private
specifier|final
name|CountDownLatch
name|outputCreated
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|ChainingListenableFuture ( Function<? super I, ? extends ListenableFuture<? extends O>> function, ListenableFuture<? extends I> inputFuture)
specifier|private
name|ChainingListenableFuture
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputFuture
operator|=
name|checkNotNull
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
block|}
comment|/**      * Delegate the get() to the input and output futures, in case      * their implementations defer starting computation until their      * own get() is invoked.      */
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
comment|// Invoking get on the inputFuture will ensure our own run()
comment|// method below is invoked as a listener when inputFuture sets
comment|// its value.  Therefore when get() returns we should then see
comment|// the outputFuture be created.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
init|=
name|this
operator|.
name|inputFuture
decl_stmt|;
if|if
condition|(
name|inputFuture
operator|!=
literal|null
condition|)
block|{
name|inputFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
comment|// If our listener was scheduled to run on an executor we may
comment|// need to wait for our listener to finish running before the
comment|// outputFuture has been constructed by the function.
name|outputCreated
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// Like above with the inputFuture, we have a listener on
comment|// the outputFuture that will set our own value when its
comment|// value is set.  Invoking get will ensure the output can
comment|// complete and invoke our listener, so that we can later
comment|// get the result.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
decl_stmt|;
if|if
condition|(
name|outputFuture
operator|!=
literal|null
condition|)
block|{
name|outputFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Delegate the get() to the input and output futures, in case      * their implementations defer starting computation until their      * own get() is invoked.      */
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|ExecutionException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
comment|// Use a single time unit so we can decrease remaining timeout
comment|// as we wait for various phases to complete.
if|if
condition|(
name|unit
operator|!=
name|NANOSECONDS
condition|)
block|{
name|timeout
operator|=
name|NANOSECONDS
operator|.
name|convert
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|NANOSECONDS
expr_stmt|;
block|}
comment|// Invoking get on the inputFuture will ensure our own run()
comment|// method below is invoked as a listener when inputFuture sets
comment|// its value.  Therefore when get() returns we should then see
comment|// the outputFuture be created.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
init|=
name|this
operator|.
name|inputFuture
decl_stmt|;
if|if
condition|(
name|inputFuture
operator|!=
literal|null
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|inputFuture
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|timeout
operator|-=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
comment|// If our listener was scheduled to run on an executor we may
comment|// need to wait for our listener to finish running before the
comment|// outputFuture has been constructed by the function.
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|outputCreated
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
name|timeout
operator|-=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
comment|// Like above with the inputFuture, we have a listener on
comment|// the outputFuture that will set our own value when its
comment|// value is set.  Invoking get will ensure the output can
comment|// complete and invoke our listener, so that we can later
comment|// get the result.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
decl_stmt|;
if|if
condition|(
name|outputFuture
operator|!=
literal|null
condition|)
block|{
name|outputFuture
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
comment|/*        * Our additional cancellation work needs to occur even if        * !mayInterruptIfRunning, so we can't move it into interruptTask().        */
if|if
condition|(
name|super
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
condition|)
block|{
try|try
block|{
comment|// This should never block since only one thread is allowed to cancel
comment|// this Future.
name|mayInterruptIfRunningChannel
operator|.
name|put
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|cancel
argument_list|(
name|inputFuture
argument_list|,
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
name|cancel
argument_list|(
name|outputFuture
argument_list|,
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|cancel (@ullable Future<?> future, boolean mayInterruptIfRunning)
specifier|private
name|void
name|cancel
parameter_list|(
annotation|@
name|Nullable
name|Future
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|I
name|sourceResult
decl_stmt|;
try|try
block|{
name|sourceResult
operator|=
name|getUninterruptibly
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
comment|// At this point, inputFuture is cancelled and outputFuture doesn't
comment|// exist, so the value of mayInterruptIfRunning is irrelevant.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
operator|=
name|function
operator|.
name|apply
argument_list|(
name|sourceResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCancelled
argument_list|()
condition|)
block|{
comment|// Handles the case where cancel was called while the function was
comment|// being applied.
try|try
block|{
comment|// There is a gap in cancel(boolean) between calling sync.cancel()
comment|// and storing the value of mayInterruptIfRunning, so this thread
comment|// needs to block, waiting for that value.
name|outputFuture
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunningChannel
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|outputFuture
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|outputFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Here it would have been nice to have had an
comment|// UninterruptibleListenableFuture, but we don't want to start a
comment|// combinatorial explosion of interfaces, so we have to make do.
name|set
argument_list|(
name|getUninterruptibly
argument_list|(
name|outputFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
comment|// At this point, inputFuture and outputFuture are done, so the
comment|// value of mayInterruptIfRunning is irrelevant.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Don't pin inputs beyond completion
name|ChainingListenableFuture
operator|.
name|this
operator|.
name|outputFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// This exception is irrelevant in this thread, but useful for the
comment|// client
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
comment|// Propagate errors up ASAP - our superclass will rethrow the error
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Don't pin inputs beyond completion
name|function
operator|=
literal|null
expr_stmt|;
name|inputFuture
operator|=
literal|null
expr_stmt|;
comment|// Allow our get routines to examine outputFuture now.
name|outputCreated
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its input futures, if all succeed. If any input fails, the    * returned future fails.    *    *<p>The list of results is in the same order as the input list.    *    *<p>Canceling this future does not cancel any of the component futures;    * however, if any of the provided futures fails or is canceled, this one is,    * too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|allAsList ( ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its input futures, if all succeed. If any input fails, the    * returned future fails.    *    *<p>The list of results is in the same order as the input list.    *    *<p>Canceling this future does not cancel any of the component futures;    * however, if any of the provided futures fails or is canceled, this one is,    * too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|allAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its successful input futures. The list of results is in the    * same order as the input list, and if any of the provided futures fails or    * is canceled, its corresponding position will contain {@code null} (which is    * indistinguishable from the future having a successful value of    * {@code null}).    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|successfulAsList ( ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its successful input futures. The list of results is in the    * same order as the input list, and if any of the provided futures fails or    * is canceled, its corresponding position will contain {@code null} (which is    * indistinguishable from the future having a successful value of    * {@code null}).    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|successfulAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the result of {@link Future#get()}, converting most exceptions to a    * new instance of the given checked exception type. This reduces boilerplate    * for a common use of {@code Future} in which it is unnecessary to    * programmatically distinguish between exception types or to extract other    * information from the exception instance.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *<ul>    *<li>Any {@link InterruptedException} is wrapped in an {@code X} (after    *     restoring the interrupt).    *<li>Any {@link CancellationException} is propagated untouched.    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an    *     {@code X}.    *<li>Any {@link RuntimeException} other than {@code CancellationException}    *     ({@code get} implementations are discouraged from throwing such    *     exceptions) is wrapped in an {@code X}.    *</ul>    *    * The overall principle is to wrap any checked exception (or its cause) in a    * checked exception, to pass through {@code CancellationException}, and to    * treat any other {@code RuntimeException} as a checked exception. (Throwing    * any other {@code RuntimeException} is questionable behavior for a {@code    * Future}, and the class documentation does not specify how such an exception    * should be interpreted. The policy of this method is to treat it as an    * exception during computation that would, under a stricter {@code Future}    * implementation, have been wrapped in an {@code ExecutionException}.)    *    *<p>Instances of {@code exceptionClass} are created by choosing an arbitrary    * public constructor that accepts zero or more arguments, all of type {@code    * String} or {@code Throwable} (preferring constructors with at least one    * {@code String}) and calling the constructor via reflection. If the    * exception did not already have a cause, one is set by calling {@link    * Throwable#initCause(Throwable)} on it. If no such constructor exists, an    * {@code IllegalArgumentException} is thrown.    *    * @throws X if {@code get} throws a checked exception or a {@code    *         RuntimeException} other than {@code CancellationException}    * @throws CancellationException if {@code get} throws a {@code    *         CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} extends {@code    *         RuntimeException} or does not have a suitable constructor    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|get ( Future<V> future, Class<X> exceptionClass)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|V
name|get
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|)
throws|throws
name|X
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
operator|!
name|RuntimeException
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|exceptionClass
argument_list|)
argument_list|,
literal|"Futures.get exception type (%s) must not be a RuntimeException"
argument_list|,
name|exceptionClass
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the result of {@link Future#get(long, TimeUnit)}, converting most    * exceptions to a new instance of the given checked exception type. This    * reduces boilerplate for a common use of {@code Future} in which it is    * unnecessary to programmatically distinguish between exception types or to    * extract other information from the exception instance.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *<ul>    *<li>Any {@link InterruptedException} is wrapped in an {@code X} (after    *     restoring the interrupt).    *<li>Any {@link TimeoutException} is wrapped in an {@code X}.    *<li>Any {@link CancellationException} is propagated untouched.    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an    *     {@code X}.    *<li>Any {@link RuntimeException} other than {@code CancellationException}    *     ({@code get} implementations are discouraged from throwing such    *     exceptions) is wrapped in an {@code X}.    *</ul>    *    * The overall principle is to wrap any checked exception (or its cause) in a    * checked exception, to pass through {@code CancellationException}, and to    * treat any other {@code RuntimeException} as a checked exception. (Throwing    * any other {@code RuntimeException} is questionable behavior for a {@code    * Future}, and the class documentation does not specify how such an exception    * should be interpreted. The policy of this method is to treat it as an    * exception during computation that would, under a stricter {@code Future}    * implementation, have been wrapped in an {@code ExecutionException}.)    *    *<p>Instances of {@code exceptionClass} are created by choosing an arbitrary    * public constructor that accepts zero or more arguments, all of type {@code    * String} or {@code Throwable} (preferring constructors with at least one    * {@code String}) and calling the constructor via reflection. If the    * exception did not already have a cause, one is set by calling {@link    * Throwable#initCause(Throwable)} on it. If no such constructor exists, an    * {@code IllegalArgumentException} is thrown.    *    * @throws X if {@code get} throws a checked exception or a {@code    *         RuntimeException} other than {@code CancellationException}    * @throws CancellationException if {@code get} throws a {@code    *         CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} extends {@code    *         RuntimeException} or does not have a suitable constructor    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|get ( Future<V> future, long timeout, TimeUnit unit, Class<X> exceptionClass)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|V
name|get
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|)
throws|throws
name|X
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
operator|!
name|RuntimeException
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|exceptionClass
argument_list|)
argument_list|,
literal|"Futures.get exception type (%s) must not be a RuntimeException"
argument_list|,
name|exceptionClass
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|newWithCause
argument_list|(
name|exceptionClass
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the result of calling {@link Future#get()} uninterruptibly on a    * task known not to throw a checked exception. This makes {@code Future} more    * suitable for lightweight, fast-running tasks that, barring bugs in the    * code, will not fail.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *<ul>    *<li>Any {@link InterruptedException} causes a retry of the {@code get}    *     call. The interrupt is restored before {@code getUnchecked} returns.    *<li>Any {@link CancellationException} is propagated untouched.    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an    *     {@link UncheckedExecutionException}.    *<li>Any {@link RuntimeException} other than {@code CancellationException}    *     ({@code get} implementations are discouraged from throwing such    *     exceptions) is wrapped in an {@code UncheckedExecutionException}.    *</ul>    *    * The overall principle is to eliminate all checked exceptions: to loop to    * avoid {@code InterruptedException}, to pass through {@code    * CancellationException}, and to wrap any exception from the underlying    * computation in an {@code UncheckedExecutionException}. (This primarily    * means wrapping the cause of any {@code ExecutionException} but also    * wrapping any {@code RuntimeException} other than {@code    * CancellationException}. Throwing any other {@code RuntimeException} is    * questionable behavior for a {@code Future}, and the class documentation    * does not specify how such an exception should be interpreted. The policy of    * this method is to treat it as an exception during computation that would,    * under a stricter {@code Future} implementation, have been wrapped in an    * {@code ExecutionException}.)    *    * @throws UncheckedExecutionException if {@code get} throws a checked    *         exception or a {@code RuntimeException} other than {@code    *         CancellationException}    * @throws CancellationException if {@code get} throws a {@code    *         CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} does not have a    *         suitable constructor    * @since Guava release 10    */
annotation|@
name|Beta
DECL|method|getUnchecked (Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|getUnchecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/*    * TODO(user): FutureChecker interface for these to be static methods on? If    * so, refer to it in the (static-method) Futures.get documentation    */
comment|/*    * Arguably we don't need a timed getUnchecked because any operation slow    * enough to require a timeout is heavyweight enough to throw a checked    * exception and therefore be inappropriate to use with getUnchecked. Further,    * it's not clear that converting the checked TimeoutException to a    * RuntimeException -- especially to an UncheckedExecutionException, since it    * wasn't thrown by the computation -- makes sense, and if we don't convert    * it, the user still has to write a try-catch block.    *    * If you think you would use this method, let us know.    */
DECL|method|newWithCause ( Class<X> exceptionClass, Throwable cause)
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Exception
parameter_list|>
name|X
name|newWithCause
parameter_list|(
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
comment|// getConstructors() guarantees this as long as we don't modify the array.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Constructor
argument_list|<
name|X
argument_list|>
argument_list|>
name|constructors
init|=
operator|(
name|List
operator|)
name|Arrays
operator|.
name|asList
argument_list|(
name|exceptionClass
operator|.
name|getConstructors
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|X
argument_list|>
name|constructor
range|:
name|preferringStrings
argument_list|(
name|constructors
argument_list|)
control|)
block|{
annotation|@
name|Nullable
name|X
name|instance
init|=
name|newFromConstructor
argument_list|(
name|constructor
argument_list|,
name|cause
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|instance
operator|.
name|getCause
argument_list|()
operator|==
literal|null
condition|)
block|{
name|instance
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
return|return
name|instance
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No appropriate constructor for exception of type "
operator|+
name|exceptionClass
operator|+
literal|" in response to chained exception"
argument_list|,
name|cause
argument_list|)
throw|;
block|}
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Exception
parameter_list|>
name|List
argument_list|<
name|Constructor
argument_list|<
name|X
argument_list|>
argument_list|>
DECL|method|preferringStrings (List<Constructor<X>> constructors)
name|preferringStrings
parameter_list|(
name|List
argument_list|<
name|Constructor
argument_list|<
name|X
argument_list|>
argument_list|>
name|constructors
parameter_list|)
block|{
return|return
name|WITH_STRING_PARAM_FIRST
operator|.
name|sortedCopy
argument_list|(
name|constructors
argument_list|)
return|;
block|}
DECL|field|WITH_STRING_PARAM_FIRST
specifier|private
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
name|WITH_STRING_PARAM_FIRST
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|,
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|apply
parameter_list|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|asList
argument_list|(
name|input
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|String
operator|.
name|class
argument_list|)
return|;
block|}
block|}
block|)
operator|.
name|reverse
argument_list|()
expr_stmt|;
end_class

begin_function
DECL|method|newFromConstructor ( Constructor<X> constructor, Throwable cause)
annotation|@
name|Nullable
specifier|private
specifier|static
parameter_list|<
name|X
parameter_list|>
name|X
name|newFromConstructor
parameter_list|(
name|Constructor
argument_list|<
name|X
argument_list|>
name|constructor
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|paramTypes
init|=
name|constructor
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
name|Object
index|[]
name|params
init|=
operator|new
name|Object
index|[
name|paramTypes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|paramType
init|=
name|paramTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|paramType
operator|.
name|equals
argument_list|(
name|String
operator|.
name|class
argument_list|)
condition|)
block|{
name|params
index|[
name|i
index|]
operator|=
name|cause
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paramType
operator|.
name|equals
argument_list|(
name|Throwable
operator|.
name|class
argument_list|)
condition|)
block|{
name|params
index|[
name|i
index|]
operator|=
name|cause
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
try|try
block|{
return|return
name|constructor
operator|.
name|newInstance
argument_list|(
name|params
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Class that implements {@link #allAsList} and {@link #successfulAsList}.    * The idea is to create a (null-filled) List and register a listener with    * each component future to fill out the value in the List when that future    * completes.    */
end_comment

begin_class
DECL|class|ListFuture
specifier|private
specifier|static
class|class
name|ListFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|field|futures
name|ImmutableList
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
decl_stmt|;
DECL|field|allMustSucceed
specifier|final
name|boolean
name|allMustSucceed
decl_stmt|;
DECL|field|remaining
specifier|final
name|AtomicInteger
name|remaining
decl_stmt|;
DECL|field|values
name|List
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
comment|/**      * Constructor.      *      * @param futures all the futures to build the list from      * @param allMustSucceed whether a single failure or cancellation should      *        propagate to this future      * @param listenerExecutor used to run listeners on all the passed in      *        futures.      */
DECL|method|ListFuture ( final ImmutableList<? extends ListenableFuture<? extends V>> futures, final boolean allMustSucceed, final Executor listenerExecutor)
name|ListFuture
parameter_list|(
specifier|final
name|ImmutableList
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|,
specifier|final
name|boolean
name|allMustSucceed
parameter_list|,
specifier|final
name|Executor
name|listenerExecutor
parameter_list|)
block|{
name|this
operator|.
name|futures
operator|=
name|futures
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|futures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|allMustSucceed
operator|=
name|allMustSucceed
expr_stmt|;
name|this
operator|.
name|remaining
operator|=
operator|new
name|AtomicInteger
argument_list|(
name|futures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|listenerExecutor
argument_list|)
expr_stmt|;
block|}
DECL|method|init (final Executor listenerExecutor)
specifier|private
name|void
name|init
parameter_list|(
specifier|final
name|Executor
name|listenerExecutor
parameter_list|)
block|{
comment|// First, schedule cleanup to execute when the Future is done.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// By now the values array has either been set as the Future's value,
comment|// or (in case of failure) is no longer useful.
name|ListFuture
operator|.
name|this
operator|.
name|values
operator|=
literal|null
expr_stmt|;
comment|// Let go of the memory held by other futures
name|ListFuture
operator|.
name|this
operator|.
name|futures
operator|=
literal|null
expr_stmt|;
block|}
block|}
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now begin the "real" initialization.
comment|// Corner case: List is empty.
if|if
condition|(
name|futures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|set
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Populate the results list with null initially.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|futures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|values
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Register a listener on each Future in the list to update
comment|// the state of this future.
comment|// Note that if all the futures on the list are done prior to completing
comment|// this loop, the last call to addListener() will callback to
comment|// setOneValue(), transitively call our cleanup listener, and set
comment|// this.futures to null.
comment|// We store a reference to futures to avoid the NPE.
name|ImmutableList
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|localFutures
init|=
name|futures
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localFutures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|listenable
init|=
name|localFutures
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|i
decl_stmt|;
name|listenable
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|setOneValue
argument_list|(
name|index
argument_list|,
name|listenable
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|listenerExecutor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets the value at the given index to that of the given future.      */
DECL|method|setOneValue (int index, Future<? extends V> future)
specifier|private
name|void
name|setOneValue
parameter_list|(
name|int
name|index
parameter_list|,
name|Future
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|List
argument_list|<
name|V
argument_list|>
name|localValues
init|=
name|values
decl_stmt|;
if|if
condition|(
name|isDone
argument_list|()
operator|||
name|localValues
operator|==
literal|null
condition|)
block|{
comment|// Some other future failed or has been cancelled, causing this one to
comment|// also be cancelled or have an exception set. This should only happen
comment|// if allMustSucceed is true.
name|checkState
argument_list|(
name|allMustSucceed
argument_list|,
literal|"Future was done before all dependencies completed"
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|checkState
argument_list|(
name|future
operator|.
name|isDone
argument_list|()
argument_list|,
literal|"Tried to set value from future which is not done"
argument_list|)
expr_stmt|;
name|localValues
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
if|if
condition|(
name|allMustSucceed
condition|)
block|{
comment|// Set ourselves as cancelled. Let the input futures keep running
comment|// as some of them may be used elsewhere.
comment|// (Currently we don't override interruptTask, so
comment|// mayInterruptIfRunning==false isn't technically necessary.)
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|allMustSucceed
condition|)
block|{
comment|// As soon as the first one fails, throw the exception up.
comment|// The result of all other inputs is then ignored.
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
if|if
condition|(
name|allMustSucceed
condition|)
block|{
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
comment|// Propagate errors up ASAP - our superclass will rethrow the error
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|int
name|newRemaining
init|=
name|remaining
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|newRemaining
operator|>=
literal|0
argument_list|,
literal|"Less than 0 remaining futures"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newRemaining
operator|==
literal|0
condition|)
block|{
name|localValues
operator|=
name|values
expr_stmt|;
if|if
condition|(
name|localValues
operator|!=
literal|null
condition|)
block|{
name|set
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|localValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkState
argument_list|(
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|callAllGets
argument_list|()
expr_stmt|;
comment|// This may still block in spite of the calls above, as the listeners may
comment|// be scheduled for execution in other threads.
return|return
name|super
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Calls the get method of all dependency futures to work around a bug in      * some ListenableFutures where the listeners aren't called until get() is      * called.      */
DECL|method|callAllGets ()
specifier|private
name|void
name|callAllGets
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|List
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|oldFutures
init|=
name|futures
decl_stmt|;
if|if
condition|(
name|oldFutures
operator|!=
literal|null
operator|&&
operator|!
name|isDone
argument_list|()
condition|)
block|{
for|for
control|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|future
range|:
name|oldFutures
control|)
block|{
comment|// We wait for a little while for the future, but if it's not done,
comment|// we check that no other futures caused a cancellation or failure.
comment|// This can introduce a delay of up to 10ms in reporting an exception.
while|while
condition|(
operator|!
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// ExecutionException / CancellationException / RuntimeException
if|if
condition|(
name|allMustSucceed
condition|)
block|{
return|return;
block|}
else|else
block|{
continue|continue;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * A checked future that uses a function to map from exceptions to the    * appropriate checked type.    */
end_comment

begin_class
DECL|class|MappingCheckedFuture
specifier|private
specifier|static
class|class
name|MappingCheckedFuture
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
extends|extends
name|AbstractCheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
block|{
DECL|field|mapper
specifier|final
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
decl_stmt|;
DECL|method|MappingCheckedFuture (ListenableFuture<V> delegate, Function<Exception, X> mapper)
name|MappingCheckedFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapper
operator|=
name|checkNotNull
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mapException (Exception e)
specifier|protected
name|X
name|mapException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|mapper
operator|.
name|apply
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * An adapter to turn a {@link Future} into a {@link ListenableFuture}.  This    * will wait on the future to finish, and when it completes, run the    * listeners.  This implementation will wait on the source future    * indefinitely, so if the source future never completes, the adapter will    * never complete either.    *    *<p>If the delegate future is interrupted or throws an unexpected unchecked    * exception, the listeners will not be invoked.    */
end_comment

begin_class
DECL|class|ListenableFutureAdapter
specifier|private
specifier|static
class|class
name|ListenableFutureAdapter
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ForwardingFuture
argument_list|<
name|V
argument_list|>
implements|implements
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|threadFactory
specifier|private
specifier|static
specifier|final
name|ThreadFactory
name|threadFactory
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"ListenableFutureAdapter-thread-%d"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|defaultAdapterExecutor
specifier|private
specifier|static
specifier|final
name|Executor
name|defaultAdapterExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
name|threadFactory
argument_list|)
decl_stmt|;
DECL|field|adapterExecutor
specifier|private
specifier|final
name|Executor
name|adapterExecutor
decl_stmt|;
comment|// The execution list to hold our listeners.
DECL|field|executionList
specifier|private
specifier|final
name|ExecutionList
name|executionList
init|=
operator|new
name|ExecutionList
argument_list|()
decl_stmt|;
comment|// This allows us to only start up a thread waiting on the delegate future
comment|// when the first listener is added.
DECL|field|hasListeners
specifier|private
specifier|final
name|AtomicBoolean
name|hasListeners
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// The delegate future.
DECL|field|delegate
specifier|private
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|ListenableFutureAdapter (Future<V> delegate)
name|ListenableFutureAdapter
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
argument_list|(
name|delegate
argument_list|,
name|defaultAdapterExecutor
argument_list|)
expr_stmt|;
block|}
DECL|method|ListenableFutureAdapter (Future<V> delegate, Executor adapterExecutor)
name|ListenableFutureAdapter
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|Executor
name|adapterExecutor
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|adapterExecutor
operator|=
name|checkNotNull
argument_list|(
name|adapterExecutor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor exec)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|executionList
operator|.
name|add
argument_list|(
name|listener
argument_list|,
name|exec
argument_list|)
expr_stmt|;
comment|// When a listener is first added, we run a task that will wait for
comment|// the delegate to finish, and when it is done will run the listeners.
if|if
condition|(
name|hasListeners
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|delegate
operator|.
name|isDone
argument_list|()
condition|)
block|{
comment|// If the delegate is already done, run the execution list
comment|// immediately on the current thread.
name|executionList
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return;
block|}
name|adapterExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delegate
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// Threads from our private pool are never interrupted.
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// ExecutionException / CancellationException / RuntimeException
comment|// The task is done, run the listeners.
block|}
name|executionList
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

unit|}
end_unit

