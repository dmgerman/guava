begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Internal
operator|.
name|toNanosSaturated
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|getUninterruptibly
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CollectionFuture
operator|.
name|ListFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ImmediateFuture
operator|.
name|ImmediateCancelledFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ImmediateFuture
operator|.
name|ImmediateFailedFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|internal
operator|.
name|InternalFutureFailureAccess
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|internal
operator|.
name|InternalFutures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to the {@link Future} interface.  *  *<p>Many of these methods use the {@link ListenableFuture} API; consult the Guava User Guide  * article on<a href="https://github.com/google/guava/wiki/ListenableFutureExplained">{@code  * ListenableFuture}</a>.  *  *<p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of  * asynchronous operations. You can chain them together manually with calls to methods like {@link  * Futures#transform(ListenableFuture, Function, Executor) Futures.transform}, but you will often  * find it easier to use a framework. Frameworks automate the process, often adding features like  * monitoring, debugging, and cancellation. Examples of frameworks include:  *  *<ul>  *<li><a href="https://dagger.dev/producers.html">Dagger Producers</a>  *</ul>  *  *<p>If you do chain your operations manually, you may want to use {@link FluentFuture}.  *  * @author Kevin Bourrillion  * @author Nishant Thakkar  * @author Sven Mawson  * @since 1.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Futures
specifier|public
specifier|final
class|class
name|Futures
extends|extends
name|GwtFuturesCatchingSpecialization
block|{
comment|// A note on memory visibility.
comment|// Many of the utilities in this class (transform, withFallback, withTimeout, asList, combine)
comment|// have two requirements that significantly complicate their design.
comment|// 1. Cancellation should propagate from the returned future to the input future(s).
comment|// 2. The returned futures shouldn't unnecessarily 'pin' their inputs after completion.
comment|//
comment|// A consequence of these requirements is that the delegate futures cannot be stored in
comment|// final fields.
comment|//
comment|// For simplicity the rest of this description will discuss Futures.catching since it is the
comment|// simplest instance, though very similar descriptions apply to many other classes in this file.
comment|//
comment|// In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field
comment|// 'inputFuture'. That field is non-final and non-volatile. There are 2 places where the
comment|// 'inputFuture' field is read and where we will have to consider visibility of the write
comment|// operation in the constructor.
comment|//
comment|// 1. In the listener that performs the callback. In this case it is fine since inputFuture is
comment|//    assigned prior to calling addListener, and addListener happens-before any invocation of the
comment|//    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible
comment|//    to the listener.
comment|//
comment|// 2. In done() where we may propagate cancellation to the input. In this case it is _not_ fine.
comment|//    There is currently nothing that enforces that the write to inputFuture in the constructor is
comment|//    visible to done(). This is because there is no happens before edge between the write and a
comment|//    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,
comment|//    it would just add an edge such that if done() observed non-null, then it would also
comment|//    definitely observe all earlier writes, but we still have no guarantee that done() would see
comment|//    the inital write (just stronger guarantees if it does).
comment|//
comment|// See: http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013800.html
comment|// For a (long) discussion about this specific issue and the general futility of life.
comment|//
comment|// For the time being we are OK with the problem discussed above since it requires a caller to
comment|// introduce a very specific kind of data-race. And given the other operations performed by these
comment|// methods that involve volatile read/write operations, in practice there is no issue. Also, the
comment|// way in such a visibility issue would surface is most likely as a failure of cancel() to
comment|// propagate to the input. Cancellation propagation is fundamentally racy so this is fine.
comment|//
comment|// Future versions of the JMM may revise safe construction semantics in such a way that we can
comment|// safely publish these objects and we won't need this whole discussion.
comment|// TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs
comment|// that should resolve the issue. This comes at the cost of adding more write barriers to the
comment|// implementations.
DECL|method|Futures ()
specifier|private
name|Futures
parameter_list|()
block|{}
comment|/**    * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The    * getters just return the value. This {@code Future} can't be canceled or timed out and its    * {@code isDone()} method always returns {@code true}.    */
DECL|method|immediateFuture (@ullable V value)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// This cast is safe because null is assignable to V for all V (i.e. it is bivariant)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|typedNull
init|=
operator|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
operator|)
name|ImmediateFuture
operator|.
name|NULL
decl_stmt|;
return|return
name|typedNull
return|;
block|}
return|return
operator|new
name|ImmediateFuture
argument_list|<>
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Returns a successful {@code ListenableFuture<Void>}. This method is equivalent to {@code    * immediateFuture(null)} except that it is restricted to produce futures of type {@code Void}.    *    * @since 29.0    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|immediateVoidFuture ()
specifier|public
specifier|static
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|immediateVoidFuture
parameter_list|()
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
operator|)
name|ImmediateFuture
operator|.
name|NULL
return|;
block|}
comment|/**    * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always    * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code    * Throwable} wrapped in an {@code ExecutionException}.    */
DECL|method|immediateFailedFuture (Throwable throwable)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFailedFuture
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmediateFailedFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|throwable
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code ListenableFuture} which is cancelled immediately upon construction, so that    * {@code isCancelled()} always returns {@code true}.    *    * @since 14.0    */
DECL|method|immediateCancelledFuture ()
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateCancelledFuture
parameter_list|()
block|{
return|return
operator|new
name|ImmediateCancelledFuture
argument_list|<
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.    *    * @throws RejectedExecutionException if the task cannot be scheduled for execution    * @since 28.2    */
annotation|@
name|Beta
DECL|method|submit (Callable<O> callable, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|submit
parameter_list|(
name|Callable
argument_list|<
name|O
argument_list|>
name|callable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|TrustedListenableFutureTask
argument_list|<
name|O
argument_list|>
name|task
init|=
name|TrustedListenableFutureTask
operator|.
name|create
argument_list|(
name|callable
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**    * Executes {@code runnable} on the specified {@code executor}, returning a {@code Future} that    * will complete after execution.    *    * @throws RejectedExecutionException if the task cannot be scheduled for execution    * @since 28.2    */
annotation|@
name|Beta
DECL|method|submit (Runnable runnable, Executor executor)
specifier|public
specifier|static
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|TrustedListenableFutureTask
argument_list|<
name|Void
argument_list|>
name|task
init|=
name|TrustedListenableFutureTask
operator|.
name|create
argument_list|(
name|runnable
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**    * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.    *    * @throws RejectedExecutionException if the task cannot be scheduled for execution    * @since 23.0    */
annotation|@
name|Beta
DECL|method|submitAsync (AsyncCallable<O> callable, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|submitAsync
parameter_list|(
name|AsyncCallable
argument_list|<
name|O
argument_list|>
name|callable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|TrustedListenableFutureTask
argument_list|<
name|O
argument_list|>
name|task
init|=
name|TrustedListenableFutureTask
operator|.
name|create
argument_list|(
name|callable
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**    * Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.    *    * @throws RejectedExecutionException if the task cannot be scheduled for execution    * @since 28.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// java.util.concurrent.ScheduledExecutorService
DECL|method|scheduleAsync ( AsyncCallable<O> callable, Duration delay, ScheduledExecutorService executorService)
specifier|public
specifier|static
parameter_list|<
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|scheduleAsync
parameter_list|(
name|AsyncCallable
argument_list|<
name|O
argument_list|>
name|callable
parameter_list|,
name|Duration
name|delay
parameter_list|,
name|ScheduledExecutorService
name|executorService
parameter_list|)
block|{
return|return
name|scheduleAsync
argument_list|(
name|callable
argument_list|,
name|toNanosSaturated
argument_list|(
name|delay
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|,
name|executorService
argument_list|)
return|;
block|}
comment|/**    * Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.    *    * @throws RejectedExecutionException if the task cannot be scheduled for execution    * @since 23.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// java.util.concurrent.ScheduledExecutorService
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// should accept a java.time.Duration
DECL|method|scheduleAsync ( AsyncCallable<O> callable, long delay, TimeUnit timeUnit, ScheduledExecutorService executorService)
specifier|public
specifier|static
parameter_list|<
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|scheduleAsync
parameter_list|(
name|AsyncCallable
argument_list|<
name|O
argument_list|>
name|callable
parameter_list|,
name|long
name|delay
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|,
name|ScheduledExecutorService
name|executorService
parameter_list|)
block|{
name|TrustedListenableFutureTask
argument_list|<
name|O
argument_list|>
name|task
init|=
name|TrustedListenableFutureTask
operator|.
name|create
argument_list|(
name|callable
argument_list|)
decl_stmt|;
specifier|final
name|Future
argument_list|<
name|?
argument_list|>
name|scheduled
init|=
name|executorService
operator|.
name|schedule
argument_list|(
name|task
argument_list|,
name|delay
argument_list|,
name|timeUnit
argument_list|)
decl_stmt|;
name|task
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Don't want to interrupt twice
name|scheduled
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**    * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the    * primary input fails with the given {@code exceptionType}, from the result provided by the    * {@code fallback}. {@link Function#apply} is not invoked until the primary input has failed, so    * if the primary input succeeds, it is never invoked. If, during the invocation of {@code    * fallback}, an exception is thrown, this exception is used as the result of the output {@code    * Future}.    *    *<p>Usage example:    *    *<pre>{@code    * ListenableFuture<Integer> fetchCounterFuture = ...;    *    * // Falling back to a zero counter in case an exception happens when    * // processing the RPC to fetch counters.    * ListenableFuture<Integer> faultTolerantFuture = Futures.catching(    *     fetchCounterFuture, FetchException.class, x -> 0, directExecutor());    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the warnings the {@link MoreExecutors#directExecutor} documentation.    *    * @param input the primary input {@code Future}    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception    *     type is matched against the input's exception. "The input's exception" means the cause of    *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a    *     different kind of exception, that exception itself. To avoid hiding bugs and other    *     unrecoverable errors, callers should prefer more specific types, avoiding {@code    *     Throwable.class} in particular.    * @param fallback the {@link Function} to be called if {@code input} fails with the expected    *     exception type. The function's argument is the input's exception. "The input's exception"    *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if    *     {@code get()} throws a different kind of exception, that exception itself.    * @param executor the executor that runs {@code fallback} if {@code input} fails    * @since 19.0    */
annotation|@
name|Beta
annotation|@
name|Partially
operator|.
name|GwtIncompatible
argument_list|(
literal|"AVAILABLE but requires exceptionType to be Throwable.class"
argument_list|)
DECL|method|catching ( ListenableFuture<? extends V> input, Class<X> exceptionType, Function<? super X, ? extends V> fallback, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Throwable
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|catching
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|AbstractCatchingFuture
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|exceptionType
argument_list|,
name|fallback
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the    * primary input fails with the given {@code exceptionType}, from the result provided by the    * {@code fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has    * failed, so if the primary input succeeds, it is never invoked. If, during the invocation of    * {@code fallback}, an exception is thrown, this exception is used as the result of the output    * {@code Future}.    *    *<p>Usage examples:    *    *<pre>{@code    * ListenableFuture<Integer> fetchCounterFuture = ...;    *    * // Falling back to a zero counter in case an exception happens when    * // processing the RPC to fetch counters.    * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(    *     fetchCounterFuture, FetchException.class, x -> immediateFuture(0), directExecutor());    * }</pre>    *    *<p>The fallback can also choose to propagate the original exception when desired:    *    *<pre>{@code    * ListenableFuture<Integer> fetchCounterFuture = ...;    *    * // Falling back to a zero counter only in case the exception was a    * // TimeoutException.    * ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(    *     fetchCounterFuture,    *     FetchException.class,    *     e -> {    *       if (omitDataOnFetchFailure) {    *         return immediateFuture(0);    *       }    *       throw e;    *     },    *     directExecutor());    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the warnings the {@link MoreExecutors#directExecutor} documentation.    *    * @param input the primary input {@code Future}    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception    *     type is matched against the input's exception. "The input's exception" means the cause of    *     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a    *     different kind of exception, that exception itself. To avoid hiding bugs and other    *     unrecoverable errors, callers should prefer more specific types, avoiding {@code    *     Throwable.class} in particular.    * @param fallback the {@link AsyncFunction} to be called if {@code input} fails with the expected    *     exception type. The function's argument is the input's exception. "The input's exception"    *     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if    *     {@code get()} throws a different kind of exception, that exception itself.    * @param executor the executor that runs {@code fallback} if {@code input} fails    * @since 19.0 (similar functionality in 14.0 as {@code withFallback})    */
annotation|@
name|Beta
annotation|@
name|Partially
operator|.
name|GwtIncompatible
argument_list|(
literal|"AVAILABLE but requires exceptionType to be Throwable.class"
argument_list|)
DECL|method|catchingAsync ( ListenableFuture<? extends V> input, Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Throwable
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|catchingAsync
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|AbstractCatchingFuture
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|exceptionType
argument_list|,
name|fallback
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Returns a future that delegates to another but will finish early (via a {@link    * TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.    *    *<p>The delegate future is interrupted and cancelled if it times out.    *    * @param delegate The future to delegate to.    * @param time when to timeout the future    * @param scheduledExecutor The executor service to enforce the timeout.    * @since 28.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// java.util.concurrent.ScheduledExecutorService
DECL|method|withTimeout ( ListenableFuture<V> delegate, Duration time, ScheduledExecutorService scheduledExecutor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|withTimeout
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|Duration
name|time
parameter_list|,
name|ScheduledExecutorService
name|scheduledExecutor
parameter_list|)
block|{
return|return
name|withTimeout
argument_list|(
name|delegate
argument_list|,
name|toNanosSaturated
argument_list|(
name|time
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|,
name|scheduledExecutor
argument_list|)
return|;
block|}
comment|/**    * Returns a future that delegates to another but will finish early (via a {@link    * TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.    *    *<p>The delegate future is interrupted and cancelled if it times out.    *    * @param delegate The future to delegate to.    * @param time when to timeout the future    * @param unit the time unit of the time parameter    * @param scheduledExecutor The executor service to enforce the timeout.    * @since 19.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// java.util.concurrent.ScheduledExecutorService
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// should accept a java.time.Duration
DECL|method|withTimeout ( ListenableFuture<V> delegate, long time, TimeUnit unit, ScheduledExecutorService scheduledExecutor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|withTimeout
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|ScheduledExecutorService
name|scheduledExecutor
parameter_list|)
block|{
if|if
condition|(
name|delegate
operator|.
name|isDone
argument_list|()
condition|)
block|{
return|return
name|delegate
return|;
block|}
return|return
name|TimeoutFuture
operator|.
name|create
argument_list|(
name|delegate
argument_list|,
name|time
argument_list|,
name|unit
argument_list|,
name|scheduledExecutor
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code Future} whose result is asynchronously derived from the result of the    * given {@code Future}. If the given {@code Future} fails, the returned {@code Future} fails with    * the same exception (and the function is not invoked).    *    *<p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced    * by applying the given {@code AsyncFunction} to the result of the original {@code Future}.    * Example usage:    *    *<pre>{@code    * ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    * ListenableFuture<QueryResult> queryFuture =    *     transformAsync(rowKeyFuture, dataService::readFuture, executor);    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the warnings the {@link MoreExecutors#directExecutor} documentation.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the    * input future and that of the future returned by the chain function. That is, if the returned    * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the    * other two is cancelled, the returned {@code Future} will receive a callback in which it will    * attempt to cancel itself.    *    * @param input The future to transform    * @param function A function to transform the result of the input future to the result of the    *     output future    * @param executor Executor to run the function in.    * @return A future that holds result of the function (if the input succeeded) or the original    *     input's failure (if not)    * @since 19.0 (in 11.0 as {@code transform})    */
annotation|@
name|Beta
DECL|method|transformAsync ( ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transformAsync
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|AbstractTransformFuture
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code Future} whose result is derived from the result of the given {@code    * Future}. If {@code input} fails, the returned {@code Future} fails with the same exception (and    * the function is not invoked). Example usage:    *    *<pre>{@code    * ListenableFuture<QueryResult> queryFuture = ...;    * ListenableFuture<List<Row>> rowsFuture =    *     transform(queryFuture, QueryResult::getRows, executor);    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the warnings the {@link MoreExecutors#directExecutor} documentation.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the    * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel    * the input, and if the input is cancelled, the returned {@code Future} will receive a callback    * in which it will attempt to cancel itself.    *    *<p>An example use of this method is to convert a serializable object returned from an RPC into    * a POJO.    *    * @param input The future to transform    * @param function A Function to transform the results of the provided future to the results of    *     the returned future.    * @param executor Executor to run the function in.    * @return A future that holds result of the transformation.    * @since 9.0 (in 2.0 as {@code compose})    */
annotation|@
name|Beta
DECL|method|transform ( ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|AbstractTransformFuture
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation    * {@code function} is invoked on each call to {@link Future#get() get()} on the returned future.    *    *<p>The returned {@code Future} reflects the input's cancellation state directly, and any    * attempt to cancel the returned Future is likewise passed through to the input Future.    *    *<p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get} only apply the timeout    * to the execution of the underlying {@code Future},<em>not</em> to the execution of the    * transformation function.    *    *<p>The primary audience of this method is callers of {@code transform} who don't have a {@code    * ListenableFuture} available and do not mind repeated, lazy function evaluation.    *    * @param input The future to transform    * @param function A Function to transform the results of the provided future to the results of    *     the returned future.    * @return A future that returns the result of the transformation.    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// TODO
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ShouldNotSubclass"
argument_list|)
DECL|method|lazyTransform ( final Future<I> input, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|Future
argument_list|<
name|O
argument_list|>
name|lazyTransform
parameter_list|(
specifier|final
name|Future
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|Future
argument_list|<
name|O
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|input
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|input
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|input
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|applyTransformation
argument_list|(
name|input
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|applyTransformation
argument_list|(
name|input
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|O
name|applyTransformation
parameter_list|(
name|I
name|input
parameter_list|)
throws|throws
name|ExecutionException
block|{
try|try
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its    * input futures, if all succeed.    *    *<p>The list of results is in the same order as the input list.    *    *<p>This differs from {@link #successfulAsList(ListenableFuture[])} in that it will return a    * failed future if any of the items fails.    *    *<p>Canceling this future will attempt to cancel all the component futures, and if any of the    * provided futures fails or is canceled, this one is, too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
DECL|method|allAsList (ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its    * input futures, if all succeed.    *    *<p>The list of results is in the same order as the input list.    *    *<p>This differs from {@link #successfulAsList(Iterable)} in that it will return a failed future    * if any of the items fails.    *    *<p>Canceling this future will attempt to cancel all the component futures, and if any of the    * provided futures fails or is canceled, this one is, too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component futures    * @since 10.0    */
annotation|@
name|Beta
DECL|method|allAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're    * successful.    *    *<p>Any failures from the input futures will not be propagated to the returned future.    *    * @since 20.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
DECL|method|whenAllComplete (ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|FutureCombiner
argument_list|<
name|V
argument_list|>
name|whenAllComplete
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|FutureCombiner
argument_list|<
name|V
argument_list|>
argument_list|(
literal|false
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're    * successful.    *    *<p>Any failures from the input futures will not be propagated to the returned future.    *    * @since 20.0    */
annotation|@
name|Beta
DECL|method|whenAllComplete ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|FutureCombiner
argument_list|<
name|V
argument_list|>
name|whenAllComplete
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|FutureCombiner
argument_list|<
name|V
argument_list|>
argument_list|(
literal|false
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link FutureCombiner} requiring that all passed in futures are successful.    *    *<p>If any input fails, the returned future fails immediately.    *    * @since 20.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
DECL|method|whenAllSucceed (ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|FutureCombiner
argument_list|<
name|V
argument_list|>
name|whenAllSucceed
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|FutureCombiner
argument_list|<
name|V
argument_list|>
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link FutureCombiner} requiring that all passed in futures are successful.    *    *<p>If any input fails, the returned future fails immediately.    *    * @since 20.0    */
annotation|@
name|Beta
DECL|method|whenAllSucceed ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|FutureCombiner
argument_list|<
name|V
argument_list|>
name|whenAllSucceed
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|FutureCombiner
argument_list|<
name|V
argument_list|>
argument_list|(
literal|true
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * A helper to create a new {@code ListenableFuture} whose result is generated from a combination    * of input futures.    *    *<p>See {@link #whenAllComplete} and {@link #whenAllSucceed} for how to instantiate this class.    *    *<p>Example:    *    *<pre>{@code    * final ListenableFuture<Instant> loginDateFuture =    *     loginService.findLastLoginDate(username);    * final ListenableFuture<List<String>> recentCommandsFuture =    *     recentCommandsService.findRecentCommands(username);    * ListenableFuture<UsageHistory> usageFuture =    *     Futures.whenAllSucceed(loginDateFuture, recentCommandsFuture)    *         .call(    *             () ->    *                 new UsageHistory(    *                     username,    *                     Futures.getDone(loginDateFuture),    *                     Futures.getDone(recentCommandsFuture)),    *             executor);    * }</pre>    *    * @since 20.0    */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
comment|// TODO(cpovirk): Consider removing, especially if we provide run(Runnable)
annotation|@
name|GwtCompatible
DECL|class|FutureCombiner
specifier|public
specifier|static
specifier|final
class|class
name|FutureCombiner
parameter_list|<
name|V
parameter_list|>
block|{
DECL|field|allMustSucceed
specifier|private
specifier|final
name|boolean
name|allMustSucceed
decl_stmt|;
DECL|field|futures
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
decl_stmt|;
DECL|method|FutureCombiner ( boolean allMustSucceed, ImmutableList<ListenableFuture<? extends V>> futures)
specifier|private
name|FutureCombiner
parameter_list|(
name|boolean
name|allMustSucceed
parameter_list|,
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
name|this
operator|.
name|allMustSucceed
operator|=
name|allMustSucceed
expr_stmt|;
name|this
operator|.
name|futures
operator|=
name|futures
expr_stmt|;
block|}
comment|/**      * Creates the {@link ListenableFuture} which will return the result of calling {@link      * AsyncCallable#call} in {@code combiner} when all futures complete, using the specified {@code      * executor}.      *      *<p>If the combiner throws a {@code CancellationException}, the returned future will be      * cancelled.      *      *<p>If the combiner throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and returned as the cause of the new {@code      * ExecutionException} that gets thrown by the returned combined future.      *      *<p>Canceling this future will attempt to cancel all the component futures.      */
DECL|method|callAsync (AsyncCallable<C> combiner, Executor executor)
specifier|public
parameter_list|<
name|C
parameter_list|>
name|ListenableFuture
argument_list|<
name|C
argument_list|>
name|callAsync
parameter_list|(
name|AsyncCallable
argument_list|<
name|C
argument_list|>
name|combiner
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
operator|new
name|CombinedFuture
argument_list|<
name|C
argument_list|>
argument_list|(
name|futures
argument_list|,
name|allMustSucceed
argument_list|,
name|executor
argument_list|,
name|combiner
argument_list|)
return|;
block|}
comment|/**      * Creates the {@link ListenableFuture} which will return the result of calling {@link      * Callable#call} in {@code combiner} when all futures complete, using the specified {@code      * executor}.      *      *<p>If the combiner throws a {@code CancellationException}, the returned future will be      * cancelled.      *      *<p>If the combiner throws an {@code ExecutionException}, the cause of the thrown {@code      * ExecutionException} will be extracted and returned as the cause of the new {@code      * ExecutionException} that gets thrown by the returned combined future.      *      *<p>Canceling this future will attempt to cancel all the component futures.      */
annotation|@
name|CanIgnoreReturnValue
comment|// TODO(cpovirk): Remove this
DECL|method|call (Callable<C> combiner, Executor executor)
specifier|public
parameter_list|<
name|C
parameter_list|>
name|ListenableFuture
argument_list|<
name|C
argument_list|>
name|call
parameter_list|(
name|Callable
argument_list|<
name|C
argument_list|>
name|combiner
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
operator|new
name|CombinedFuture
argument_list|<
name|C
argument_list|>
argument_list|(
name|futures
argument_list|,
name|allMustSucceed
argument_list|,
name|executor
argument_list|,
name|combiner
argument_list|)
return|;
block|}
comment|/**      * Creates the {@link ListenableFuture} which will return the result of running {@code combiner}      * when all Futures complete. {@code combiner} will run using {@code executor}.      *      *<p>If the combiner throws a {@code CancellationException}, the returned future will be      * cancelled.      *      *<p>Canceling this Future will attempt to cancel all the component futures.      *      * @since 23.6      */
DECL|method|run (final Runnable combiner, Executor executor)
specifier|public
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|run
parameter_list|(
specifier|final
name|Runnable
name|combiner
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|call
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|combiner
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|,
name|executor
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@code ListenableFuture} whose result is set from the supplied future when it    * completes. Cancelling the supplied future will also cancel the returned future, but cancelling    * the returned future will have no effect on the supplied future.    *    * @since 15.0    */
annotation|@
name|Beta
DECL|method|nonCancellationPropagating (ListenableFuture<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|nonCancellationPropagating
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
if|if
condition|(
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
return|return
name|future
return|;
block|}
name|NonCancellationPropagatingFuture
argument_list|<
name|V
argument_list|>
name|output
init|=
operator|new
name|NonCancellationPropagatingFuture
argument_list|<>
argument_list|(
name|future
argument_list|)
decl_stmt|;
name|future
operator|.
name|addListener
argument_list|(
name|output
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/** A wrapped future that does not propagate cancellation to its delegate. */
DECL|class|NonCancellationPropagatingFuture
specifier|private
specifier|static
specifier|final
class|class
name|NonCancellationPropagatingFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractFuture
operator|.
name|TrustedFuture
argument_list|<
name|V
argument_list|>
implements|implements
name|Runnable
block|{
DECL|field|delegate
specifier|private
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|NonCancellationPropagatingFuture (final ListenableFuture<V> delegate)
name|NonCancellationPropagatingFuture
parameter_list|(
specifier|final
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// This prevents cancellation from propagating because we don't call setFuture(delegate) until
comment|// delegate is already done, so calling cancel() on this future won't affect it.
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|localDelegate
init|=
name|delegate
decl_stmt|;
if|if
condition|(
name|localDelegate
operator|!=
literal|null
condition|)
block|{
name|setFuture
argument_list|(
name|localDelegate
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|pendingToString ()
specifier|protected
name|String
name|pendingToString
parameter_list|()
block|{
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|localDelegate
init|=
name|delegate
decl_stmt|;
if|if
condition|(
name|localDelegate
operator|!=
literal|null
condition|)
block|{
return|return
literal|"delegate=["
operator|+
name|localDelegate
operator|+
literal|"]"
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|afterDone ()
specifier|protected
name|void
name|afterDone
parameter_list|()
block|{
name|delegate
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its    * successful input futures. The list of results is in the same order as the input list, and if    * any of the provided futures fails or is canceled, its corresponding position will contain    * {@code null} (which is indistinguishable from the future having a successful value of {@code    * null}).    *    *<p>The list of results is in the same order as the input list.    *    *<p>This differs from {@link #allAsList(ListenableFuture[])} in that it's tolerant of failed    * futures for any of the items, representing them as {@code null} in the result list.    *    *<p>Canceling this future will attempt to cancel all the component futures.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
DECL|method|successfulAsList ( ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its    * successful input futures. The list of results is in the same order as the input list, and if    * any of the provided futures fails or is canceled, its corresponding position will contain    * {@code null} (which is indistinguishable from the future having a successful value of {@code    * null}).    *    *<p>The list of results is in the same order as the input list.    *    *<p>This differs from {@link #allAsList(Iterable)} in that it's tolerant of failed futures for    * any of the items, representing them as {@code null} in the result list.    *    *<p>Canceling this future will attempt to cancel all the component futures.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component futures    * @since 10.0    */
annotation|@
name|Beta
DECL|method|successfulAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a list of delegate futures that correspond to the futures received in the order that    * they complete. Delegate futures return the same value or throw the same exception as the    * corresponding input future returns/throws.    *    *<p>"In the order that they complete" means, for practical purposes, about what you would    * expect, but there are some subtleties. First, we do guarantee that, if the output future at    * index n is done, the output future at index n-1 is also done. (But as usual with futures, some    * listeners for future n may complete before some for future n-1.) However, it is possible, if    * one input completes with result X and another later with result Y, for Y to come before X in    * the output future list. (Such races are impossible to solve without global synchronization of    * all future completions. And they should have little practical impact.)    *    *<p>Cancelling a delegate future propagates to input futures once all the delegates complete,    * either from cancellation or because an input future has completed. If N futures are passed in,    * and M delegates are cancelled, the remaining M input futures will be cancelled once N - M of    * the input futures complete. If all the delegates are cancelled, all the input futures will be    * too.    *    * @since 17.0    */
annotation|@
name|Beta
DECL|method|inCompletionOrder ( Iterable<? extends ListenableFuture<? extends T>> futures)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|inCompletionOrder
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
index|[]
name|copy
init|=
name|gwtCompatibleToArray
argument_list|(
name|futures
argument_list|)
decl_stmt|;
specifier|final
name|InCompletionOrderState
argument_list|<
name|T
argument_list|>
name|state
init|=
operator|new
name|InCompletionOrderState
argument_list|<>
argument_list|(
name|copy
argument_list|)
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|AbstractFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|delegatesBuilder
init|=
name|ImmutableList
operator|.
name|builderWithExpectedSize
argument_list|(
name|copy
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copy
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|delegatesBuilder
operator|.
name|add
argument_list|(
operator|new
name|InCompletionOrderFuture
argument_list|<
name|T
argument_list|>
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
argument_list|<
name|AbstractFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|delegates
init|=
name|delegatesBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copy
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|localI
init|=
name|i
decl_stmt|;
name|copy
index|[
name|i
index|]
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|state
operator|.
name|recordInputCompletion
argument_list|(
name|delegates
argument_list|,
name|localI
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|delegatesCast
init|=
operator|(
name|ImmutableList
operator|)
name|delegates
decl_stmt|;
return|return
name|delegatesCast
return|;
block|}
comment|/** Can't use Iterables.toArray because it's not gwt compatible */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|gwtCompatibleToArray ( Iterable<? extends ListenableFuture<? extends T>> futures)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
index|[]
name|gwtCompatibleToArray
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|collection
decl_stmt|;
if|if
condition|(
name|futures
operator|instanceof
name|Collection
condition|)
block|{
name|collection
operator|=
operator|(
name|Collection
argument_list|<
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
operator|)
name|futures
expr_stmt|;
block|}
else|else
block|{
name|collection
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
index|[]
operator|)
name|collection
operator|.
name|toArray
argument_list|(
operator|new
name|ListenableFuture
argument_list|<
name|?
argument_list|>
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|// This can't be a TrustedFuture, because TrustedFuture has clever optimizations that
comment|// mean cancel won't be called if this Future is passed into setFuture, and then
comment|// cancelled.
DECL|class|InCompletionOrderFuture
specifier|private
specifier|static
specifier|final
class|class
name|InCompletionOrderFuture
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|state
specifier|private
name|InCompletionOrderState
argument_list|<
name|T
argument_list|>
name|state
decl_stmt|;
DECL|method|InCompletionOrderFuture (InCompletionOrderState<T> state)
specifier|private
name|InCompletionOrderFuture
parameter_list|(
name|InCompletionOrderState
argument_list|<
name|T
argument_list|>
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cancel (boolean interruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|interruptIfRunning
parameter_list|)
block|{
name|InCompletionOrderState
argument_list|<
name|T
argument_list|>
name|localState
init|=
name|state
decl_stmt|;
if|if
condition|(
name|super
operator|.
name|cancel
argument_list|(
name|interruptIfRunning
argument_list|)
condition|)
block|{
name|localState
operator|.
name|recordOutputCancellation
argument_list|(
name|interruptIfRunning
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|afterDone ()
specifier|protected
name|void
name|afterDone
parameter_list|()
block|{
name|state
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|pendingToString ()
specifier|protected
name|String
name|pendingToString
parameter_list|()
block|{
name|InCompletionOrderState
argument_list|<
name|T
argument_list|>
name|localState
init|=
name|state
decl_stmt|;
if|if
condition|(
name|localState
operator|!=
literal|null
condition|)
block|{
comment|// Don't print the actual array! We don't want inCompletionOrder(list).toString() to have
comment|// quadratic output.
return|return
literal|"inputCount=["
operator|+
name|localState
operator|.
name|inputFutures
operator|.
name|length
operator|+
literal|"], remaining=["
operator|+
name|localState
operator|.
name|incompleteOutputCount
operator|.
name|get
argument_list|()
operator|+
literal|"]"
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|class|InCompletionOrderState
specifier|private
specifier|static
specifier|final
class|class
name|InCompletionOrderState
parameter_list|<
name|T
parameter_list|>
block|{
comment|// A happens-before edge between the writes of these fields and their reads exists, because
comment|// in order to read these fields, the corresponding write to incompleteOutputCount must have
comment|// been read.
DECL|field|wasCancelled
specifier|private
name|boolean
name|wasCancelled
init|=
literal|false
decl_stmt|;
DECL|field|shouldInterrupt
specifier|private
name|boolean
name|shouldInterrupt
init|=
literal|true
decl_stmt|;
DECL|field|incompleteOutputCount
specifier|private
specifier|final
name|AtomicInteger
name|incompleteOutputCount
decl_stmt|;
DECL|field|inputFutures
specifier|private
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
index|[]
name|inputFutures
decl_stmt|;
DECL|field|delegateIndex
specifier|private
specifier|volatile
name|int
name|delegateIndex
init|=
literal|0
decl_stmt|;
DECL|method|InCompletionOrderState (ListenableFuture<? extends T>[] inputFutures)
specifier|private
name|InCompletionOrderState
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
index|[]
name|inputFutures
parameter_list|)
block|{
name|this
operator|.
name|inputFutures
operator|=
name|inputFutures
expr_stmt|;
name|incompleteOutputCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
name|inputFutures
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|recordOutputCancellation (boolean interruptIfRunning)
specifier|private
name|void
name|recordOutputCancellation
parameter_list|(
name|boolean
name|interruptIfRunning
parameter_list|)
block|{
name|wasCancelled
operator|=
literal|true
expr_stmt|;
comment|// If all the futures were cancelled with interruption, cancel the input futures
comment|// with interruption; otherwise cancel without
if|if
condition|(
operator|!
name|interruptIfRunning
condition|)
block|{
name|shouldInterrupt
operator|=
literal|false
expr_stmt|;
block|}
name|recordCompletion
argument_list|()
expr_stmt|;
block|}
DECL|method|recordInputCompletion ( ImmutableList<AbstractFuture<T>> delegates, int inputFutureIndex)
specifier|private
name|void
name|recordInputCompletion
parameter_list|(
name|ImmutableList
argument_list|<
name|AbstractFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|delegates
parameter_list|,
name|int
name|inputFutureIndex
parameter_list|)
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|inputFuture
init|=
name|inputFutures
index|[
name|inputFutureIndex
index|]
decl_stmt|;
comment|// Null out our reference to this future, so it can be GCed
name|inputFutures
index|[
name|inputFutureIndex
index|]
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|delegateIndex
init|;
name|i
operator|<
name|delegates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|delegates
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|setFuture
argument_list|(
name|inputFuture
argument_list|)
condition|)
block|{
name|recordCompletion
argument_list|()
expr_stmt|;
comment|// this is technically unnecessary, but should speed up later accesses
name|delegateIndex
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|// If all the delegates were complete, no reason for the next listener to have to
comment|// go through the whole list. Avoids O(n^2) behavior when the entire output list is
comment|// cancelled.
name|delegateIndex
operator|=
name|delegates
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
DECL|method|recordCompletion ()
specifier|private
name|void
name|recordCompletion
parameter_list|()
block|{
if|if
condition|(
name|incompleteOutputCount
operator|.
name|decrementAndGet
argument_list|()
operator|==
literal|0
operator|&&
name|wasCancelled
condition|)
block|{
for|for
control|(
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|toCancel
range|:
name|inputFutures
control|)
block|{
if|if
condition|(
name|toCancel
operator|!=
literal|null
condition|)
block|{
name|toCancel
operator|.
name|cancel
argument_list|(
name|shouldInterrupt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Registers separate success and failure callbacks to be run when the {@code Future}'s    * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the    * computation is already complete, immediately.    *    *<p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of    * callbacks, but any callback added through this method is guaranteed to be called once the    * computation is complete.    *    *<p>Exceptions thrown by a {@code callback} will be propagated up to the executor. Any exception    * thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an    * exception thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught    * and logged.    *    *<p>Example:    *    *<pre>{@code    * ListenableFuture<QueryResult> future = ...;    * Executor e = ...    * addCallback(future,    *     new FutureCallback<QueryResult>() {    *       public void onSuccess(QueryResult result) {    *         storeInCache(result);    *       }    *       public void onFailure(Throwable t) {    *         reportError(t);    *       }    *     }, e);    * }</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the warnings the {@link MoreExecutors#directExecutor} documentation.    *    *<p>For a more general interface to attach a completion listener to a {@code Future}, see {@link    * ListenableFuture#addListener addListener}.    *    * @param future The future attach the callback to.    * @param callback The callback to invoke when {@code future} is completed.    * @param executor The executor to run {@code callback} when the future completes.    * @since 10.0    */
DECL|method|addCallback ( final ListenableFuture<V> future, final FutureCallback<? super V> callback, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|void
name|addCallback
parameter_list|(
specifier|final
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
specifier|final
name|FutureCallback
argument_list|<
name|?
super|super
name|V
argument_list|>
name|callback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|callback
argument_list|)
expr_stmt|;
name|future
operator|.
name|addListener
argument_list|(
operator|new
name|CallbackListener
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|,
name|callback
argument_list|)
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link #addCallback(ListenableFuture, FutureCallback, Executor)} for behavioral notes. */
DECL|class|CallbackListener
specifier|private
specifier|static
specifier|final
class|class
name|CallbackListener
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Runnable
block|{
DECL|field|future
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|future
decl_stmt|;
DECL|field|callback
specifier|final
name|FutureCallback
argument_list|<
name|?
super|super
name|V
argument_list|>
name|callback
decl_stmt|;
DECL|method|CallbackListener (Future<V> future, FutureCallback<? super V> callback)
name|CallbackListener
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|FutureCallback
argument_list|<
name|?
super|super
name|V
argument_list|>
name|callback
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|future
operator|instanceof
name|InternalFutureFailureAccess
condition|)
block|{
name|Throwable
name|failure
init|=
name|InternalFutures
operator|.
name|tryInternalFastPathGetFailure
argument_list|(
operator|(
name|InternalFutureFailureAccess
operator|)
name|future
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|failure
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|final
name|V
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
name|getDone
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|Error
name|e
parameter_list|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|callback
operator|.
name|onSuccess
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreObjects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
operator|.
name|addValue
argument_list|(
name|callback
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the result of the input {@code Future}, which must have already completed.    *    *<p>The benefits of this method are twofold. First, the name "getDone" suggests to readers that    * the {@code Future} is already done. Second, if buggy code calls {@code getDone} on a {@code    * Future} that is still pending, the program will throw instead of block. This can be important    * for APIs like {@link #whenAllComplete whenAllComplete(...)}{@code .}{@link    * FutureCombiner#call(Callable, Executor) call(...)}, where it is easy to use a new input from    * the {@code call} implementation but forget to add it to the arguments of {@code    * whenAllComplete}.    *    *<p>If you are looking for a method to determine whether a given {@code Future} is done, use the    * instance method {@link Future#isDone()}.    *    * @throws ExecutionException if the {@code Future} failed with an exception    * @throws CancellationException if the {@code Future} was cancelled    * @throws IllegalStateException if the {@code Future} is not done    * @since 20.0    */
annotation|@
name|CanIgnoreReturnValue
comment|// TODO(cpovirk): Consider calling getDone() in our own code.
DECL|method|getDone (Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|getDone
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|/*      * We throw IllegalStateException, since the call could succeed later. Perhaps we "should" throw      * IllegalArgumentException, since the call could succeed with a different argument. Those      * exceptions' docs suggest that either is acceptable. Google's Java Practices page recommends      * IllegalArgumentException here, in part to keep its recommendation simple: Static methods      * should throw IllegalStateException only when they use static state.      *      * Why do we deviate here? The answer: We want for fluentFuture.getDone() to throw the same      * exception as Futures.getDone(fluentFuture).      */
name|checkState
argument_list|(
name|future
operator|.
name|isDone
argument_list|()
argument_list|,
literal|"Future was expected to be done: %s"
argument_list|,
name|future
argument_list|)
expr_stmt|;
return|return
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
return|;
block|}
comment|/**    * Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the    * given checked exception type. This reduces boilerplate for a common use of {@code Future} in    * which it is unnecessary to programmatically distinguish between exception types or to extract    * other information from the exception instance.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *    *<ul>    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an {@code X} if the cause    *       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code    *       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.    *<li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the    *       interrupt).    *<li>Any {@link CancellationException} is propagated untouched, as is any other {@link    *       RuntimeException} (though {@code get} implementations are discouraged from throwing such    *       exceptions).    *</ul>    *    *<p>The overall principle is to continue to treat every checked exception as a checked    * exception, every unchecked exception as an unchecked exception, and every error as an error. In    * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the    * new stack trace matches that of the current thread.    *    *<p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor    * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}    * (preferring constructors with at least one {@code String}) and calling the constructor via    * reflection. If the exception did not already have a cause, one is set by calling {@link    * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code    * IllegalArgumentException} is thrown.    *    * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}    *     whose cause is not itself a checked exception    * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a    *     {@code RuntimeException} as its cause    * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code    *     Error} as its cause    * @throws CancellationException if {@code get} throws a {@code CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or    *     does not have a suitable constructor    * @since 19.0 (in 10.0 as {@code get})    */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|GwtIncompatible
comment|// reflection
DECL|method|getChecked (Future<V> future, Class<X> exceptionClass)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|V
name|getChecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|)
throws|throws
name|X
block|{
return|return
name|FuturesGetChecked
operator|.
name|getChecked
argument_list|(
name|future
argument_list|,
name|exceptionClass
argument_list|)
return|;
block|}
comment|/**    * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new    * instance of the given checked exception type. This reduces boilerplate for a common use of    * {@code Future} in which it is unnecessary to programmatically distinguish between exception    * types or to extract other information from the exception instance.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *    *<ul>    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an {@code X} if the cause    *       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code    *       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.    *<li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the    *       interrupt).    *<li>Any {@link TimeoutException} is wrapped in an {@code X}.    *<li>Any {@link CancellationException} is propagated untouched, as is any other {@link    *       RuntimeException} (though {@code get} implementations are discouraged from throwing such    *       exceptions).    *</ul>    *    *<p>The overall principle is to continue to treat every checked exception as a checked    * exception, every unchecked exception as an unchecked exception, and every error as an error. In    * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the    * new stack trace matches that of the current thread.    *    *<p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor    * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}    * (preferring constructors with at least one {@code String}) and calling the constructor via    * reflection. If the exception did not already have a cause, one is set by calling {@link    * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code    * IllegalArgumentException} is thrown.    *    * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}    *     whose cause is not itself a checked exception    * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a    *     {@code RuntimeException} as its cause    * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code    *     Error} as its cause    * @throws CancellationException if {@code get} throws a {@code CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or    *     does not have a suitable constructor    * @since 28.0    */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|GwtIncompatible
comment|// reflection
DECL|method|getChecked ( Future<V> future, Class<X> exceptionClass, Duration timeout)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|V
name|getChecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|,
name|Duration
name|timeout
parameter_list|)
throws|throws
name|X
block|{
return|return
name|getChecked
argument_list|(
name|future
argument_list|,
name|exceptionClass
argument_list|,
name|toNanosSaturated
argument_list|(
name|timeout
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
return|;
block|}
comment|/**    * Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new    * instance of the given checked exception type. This reduces boilerplate for a common use of    * {@code Future} in which it is unnecessary to programmatically distinguish between exception    * types or to extract other information from the exception instance.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *    *<ul>    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an {@code X} if the cause    *       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code    *       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.    *<li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the    *       interrupt).    *<li>Any {@link TimeoutException} is wrapped in an {@code X}.    *<li>Any {@link CancellationException} is propagated untouched, as is any other {@link    *       RuntimeException} (though {@code get} implementations are discouraged from throwing such    *       exceptions).    *</ul>    *    *<p>The overall principle is to continue to treat every checked exception as a checked    * exception, every unchecked exception as an unchecked exception, and every error as an error. In    * addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the    * new stack trace matches that of the current thread.    *    *<p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor    * that accepts zero or more arguments, all of type {@code String} or {@code Throwable}    * (preferring constructors with at least one {@code String}) and calling the constructor via    * reflection. If the exception did not already have a cause, one is set by calling {@link    * Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code    * IllegalArgumentException} is thrown.    *    * @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}    *     whose cause is not itself a checked exception    * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a    *     {@code RuntimeException} as its cause    * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code    *     Error} as its cause    * @throws CancellationException if {@code get} throws a {@code CancellationException}    * @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or    *     does not have a suitable constructor    * @since 19.0 (in 10.0 as {@code get} and with different parameter order)    */
annotation|@
name|Beta
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|GwtIncompatible
comment|// reflection
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// should accept a java.time.Duration
DECL|method|getChecked ( Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|V
name|getChecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionClass
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|X
block|{
return|return
name|FuturesGetChecked
operator|.
name|getChecked
argument_list|(
name|future
argument_list|,
name|exceptionClass
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Returns the result of calling {@link Future#get()} uninterruptibly on a task known not to throw    * a checked exception. This makes {@code Future} more suitable for lightweight, fast-running    * tasks that, barring bugs in the code, will not fail. This gives it exception-handling behavior    * similar to that of {@code ForkJoinTask.join}.    *    *<p>Exceptions from {@code Future.get} are treated as follows:    *    *<ul>    *<li>Any {@link ExecutionException} has its<i>cause</i> wrapped in an {@link    *       UncheckedExecutionException} (if the cause is an {@code Exception}) or {@link    *       ExecutionError} (if the cause is an {@code Error}).    *<li>Any {@link InterruptedException} causes a retry of the {@code get} call. The interrupt is    *       restored before {@code getUnchecked} returns.    *<li>Any {@link CancellationException} is propagated untouched. So is any other {@link    *       RuntimeException} ({@code get} implementations are discouraged from throwing such    *       exceptions).    *</ul>    *    *<p>The overall principle is to eliminate all checked exceptions: to loop to avoid {@code    * InterruptedException}, to pass through {@code CancellationException}, and to wrap any exception    * from the underlying computation in an {@code UncheckedExecutionException} or {@code    * ExecutionError}.    *    *<p>For an uninterruptible {@code get} that preserves other exceptions, see {@link    * Uninterruptibles#getUninterruptibly(Future)}.    *    * @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with an    *     {@code Exception} as its cause    * @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code    *     Error} as its cause    * @throws CancellationException if {@code get} throws a {@code CancellationException}    * @since 10.0    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|getUnchecked (Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|getUnchecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|wrapAndThrowUnchecked
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
DECL|method|wrapAndThrowUnchecked (Throwable cause)
specifier|private
specifier|static
name|void
name|wrapAndThrowUnchecked
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|new
name|ExecutionError
argument_list|(
operator|(
name|Error
operator|)
name|cause
argument_list|)
throw|;
block|}
comment|/*      * It's an Exception. (Or it's a non-Error, non-Exception Throwable. From my survey of such      * classes, I believe that most users intended to extend Exception, so we'll treat it like an      * Exception.)      */
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
comment|/*    * Arguably we don't need a timed getUnchecked because any operation slow enough to require a    * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to    * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to    * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by    * the computation -- makes sense, and if we don't convert it, the user still has to write a    * try-catch block.    *    * If you think you would use this method, let us know. You might also also look into the    * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html    */
block|}
end_class

end_unit

