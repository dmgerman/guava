begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Queues
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|Immutable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|inject
operator|.
name|Singleton
import|;
end_import

begin_comment
comment|/**  * A manager for monitoring and controlling a set of {@link Service services}. This class provides  * methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and  * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.  * Additionally, users can monitor state transitions with the {@link Listener listener} mechanism.  *  *<p>While it is recommended that service lifecycles be managed via this class, state transitions  * initiated via other mechanisms do not impact the correctness of its methods. For example, if the  * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked  * when appropriate and {@link #awaitHealthy} will still work as expected.  *  *<p>Here is a simple example of how to use a {@link ServiceManager} to start a server.  *<pre>   {@code  * class Server {  *   public static void main(String[] args) {  *     Set<Service> services = ...;  *     ServiceManager manager = new ServiceManager(services);  *     manager.addListener(new Listener() {  *         public void stopped() {}  *         public void healthy() {  *           // Services have been initialized and are healthy, start accepting requests...  *         }  *         public void failure(Service service) {  *           // Something failed, at this point we could log it, notify a load balancer, or take  *           // some other action.  For now we will just exit.  *           System.exit(1);  *         }  *       },  *       MoreExecutors.sameThreadExecutor());  *  *     Runtime.getRuntime().addShutdownHook(new Thread() {  *       public void run() {  *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown   *         // requests.  *         try {  *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);  *         } catch (TimeoutException timeout) {  *           // stopping timed out  *         }  *       }  *     });  *     manager.startAsync();  // start all the services asynchronously  *   }  * }}</pre>  *  * This class uses the ServiceManager's methods to start all of its services, to respond to service  * failure and to ensure that when the JVM is shutting down all the services are stopped.  *  * @author Luke Sandberg  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|Singleton
DECL|class|ServiceManager
specifier|public
specifier|final
class|class
name|ServiceManager
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ServiceManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * A listener for the aggregate state changes of the services that are under management. Users    * that need to listen to more fine-grained events (such as when each particular    * {@link Service service} starts, or terminates), should attach {@link Service.Listener service    * listeners} to each individual service.    *     * @author Luke Sandberg    * @since 14.0    */
annotation|@
name|Beta
comment|// Should come out of Beta when ServiceManager does
DECL|interface|Listener
specifier|public
specifier|static
interface|interface
name|Listener
block|{
comment|/**       * Called when the service initially becomes healthy.      *       *<p>This will be called at most once after all the services have entered the       * {@linkplain State#RUNNING running} state. If any services fail during start up or       * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other       * services have started {@linkplain State#RUNNING running} then this method will not be called.      */
DECL|method|healthy ()
name|void
name|healthy
parameter_list|()
function_decl|;
comment|/**       * Called when the all of the component services have reached a terminal state, either       * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.      */
DECL|method|stopped ()
name|void
name|stopped
parameter_list|()
function_decl|;
comment|/**       * Called when a component service has {@linkplain State#FAILED failed}.      *       * @param service The service that failed.      */
DECL|method|failure (Service service)
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
function_decl|;
block|}
comment|/**    * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener     * service listeners}.  This is extracted into its own object so that {@link ServiceListener}     * could be made {@code static} and its instances can be safely constructed and added in the     * {@link ServiceManager} constructor without having to close over the partially constructed     * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).    */
DECL|field|state
specifier|private
specifier|final
name|ServiceManagerState
name|state
decl_stmt|;
DECL|field|services
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|ServiceListener
argument_list|>
name|services
decl_stmt|;
comment|/**    * Constructs a new instance for managing the given services.    *     * @param services The services to manage    *     * @throws IllegalArgumentException if not all services are {@link State#NEW new} or if there are    *     any duplicate services.    */
DECL|method|ServiceManager (Iterable<? extends Service> services)
specifier|public
name|ServiceManager
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|Service
argument_list|>
name|copy
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|services
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Having no services causes the manager to behave strangely. Notably, listeners are never
comment|// fired.  To avoid this we substitute a placeholder service.
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ServiceManager configured with no services.  Is your application configured properly?"
argument_list|,
operator|new
name|EmptyServiceManagerWarning
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|=
name|ImmutableList
operator|.
expr|<
name|Service
operator|>
name|of
argument_list|(
operator|new
name|NoOpService
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|state
operator|=
operator|new
name|ServiceManagerState
argument_list|(
name|copy
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Service
argument_list|,
name|ServiceListener
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|Executor
name|executor
init|=
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|copy
control|)
block|{
name|ServiceListener
name|listener
init|=
operator|new
name|ServiceListener
argument_list|(
name|service
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|service
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
comment|// We check the state after adding the listener as a way to ensure that our listener was added
comment|// to a NEW service.
name|checkArgument
argument_list|(
name|service
operator|.
name|state
argument_list|()
operator|==
name|State
operator|.
name|NEW
argument_list|,
literal|"Can only manage NEW services, %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|service
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|services
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constructs a new instance for managing the given services. This constructor is provided so that    * dependency injection frameworks can inject instances of {@link ServiceManager}.    *     * @param services The services to manage    *     * @throws IllegalStateException if not all services are {@link State#NEW new}.    */
DECL|method|ServiceManager (Set<Service> services)
annotation|@
name|Inject
name|ServiceManager
parameter_list|(
name|Set
argument_list|<
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|this
argument_list|(
operator|(
name|Iterable
argument_list|<
name|Service
argument_list|>
operator|)
name|services
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given     * executor. The listener will not have previous state changes replayed, so it is     * suggested that listeners are added before any of the managed services are     * {@linkplain Service#start started}.    *    *<p>There is no guaranteed ordering of execution of listeners, but any listener added through     * this method is guaranteed to be called whenever there is a state change.    *    *<p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown     * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception     * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and    * logged.    *     *<p> For fast, lightweight listeners that would be safe to execute in any thread, consider     * calling {@link #addListener(Listener)}.    *     * @param listener the listener to run when the manager changes state    * @param executor the executor in which the listeners callback methods will be run.    */
DECL|method|addListener (Listener listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The     * listener will not have previous state changes replayed, so it is suggested that listeners are     * added before any of the managed services are {@linkplain Service#start started}.    *    *<p>There is no guaranteed ordering of execution of listeners, but any listener added through     * this method is guaranteed to be called whenever there is a state change.    *    *<p>Exceptions thrown by a listener will be will be caught and logged.    *     * @param listener the listener to run when the manager changes state    */
DECL|method|addListener (Listener listener)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#start startup} on all the services being managed.  It is    * only valid to call this method if all of the services are {@linkplain State#NEW new}.    *     * @return this    * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the     *     method is called.    */
DECL|method|startAsync ()
specifier|public
name|ServiceManager
name|startAsync
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Service
argument_list|,
name|ServiceListener
argument_list|>
name|entry
range|:
name|services
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Service
name|service
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|service
operator|.
name|state
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|NEW
argument_list|,
literal|"Service %s is %s, cannot start it."
argument_list|,
name|service
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ServiceListener
name|service
range|:
name|services
operator|.
name|values
argument_list|()
control|)
block|{
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager    * will become healthy after all the component services have reached the {@linkplain State#RUNNING    * running} state.      *     * @throws IllegalStateException if the service manager reaches a state from which it cannot     *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy ()
specifier|public
name|void
name|awaitHealthy
parameter_list|()
block|{
name|state
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|checkState
argument_list|(
name|isHealthy
argument_list|()
argument_list|,
literal|"Expected to be healthy after starting"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more     * than the given time.  The manager will become healthy after all the component services have     * reached the {@linkplain State#RUNNING running} state.     *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have finished starting within the deadline    * @throws IllegalStateException if the service manager reaches a state from which it cannot     *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|awaitHealthy
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
comment|// It would be nice to tell the caller who we are still waiting on, and this information is
comment|// likely to be in servicesByState(), however due to race conditions we can't actually tell
comment|// which services are holding up healthiness. The current set of NEW or STARTING services is
comment|// likely to point out the culprit, but may not.  If we really wanted to solve this we could
comment|// change state to track exactly which services have started and then we could accurately
comment|// report on this. But it is only for logging so we likely don't care.
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to become healthy."
argument_list|)
throw|;
block|}
name|checkState
argument_list|(
name|isHealthy
argument_list|()
argument_list|,
literal|"Expected to be healthy after starting"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#stop shutdown} if necessary on all the services being     * managed.     *        * @return this    */
DECL|method|stopAsync ()
specifier|public
name|ServiceManager
name|stopAsync
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
operator|.
name|keySet
argument_list|()
control|)
block|{
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state. After this method returns all    * services will either be {@link Service.State#TERMINATED terminated} or     * {@link Service.State#FAILED failed}    */
DECL|method|awaitStopped ()
specifier|public
name|void
name|awaitStopped
parameter_list|()
block|{
name|state
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state for no more than the given time. After    * this method returns all services will either be {@link Service.State#TERMINATED terminated} or     * {@link Service.State#FAILED failed}    *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have stopped within the deadline    */
DECL|method|awaitStopped (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|awaitStopped
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to stop."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.      *     *<p>Users who want more detailed information should use the {@link #servicesByState} method to     * get detailed information about which services are not running.    */
DECL|method|isHealthy ()
specifier|public
name|boolean
name|isHealthy
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|service
operator|.
name|isRunning
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Provides a snapshot of the current state of all the services under management.    *     *<p>N.B. This snapshot it not guaranteed to be consistent, i.e. the set of states returned may    * not correspond to any particular point in time view of the services.     */
DECL|method|servicesByState ()
specifier|public
name|ImmutableMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
parameter_list|()
block|{
name|ImmutableMultimap
operator|.
name|Builder
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|builder
init|=
name|ImmutableMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|services
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|service
operator|.
name|state
argument_list|()
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns the service load times. This value will only return startup times for services that    * have finished starting.    *    * @return Map of services and their corresponding startup time in millis, the map entries will be    *     ordered by startup time.    */
DECL|method|startupTimes ()
specifier|public
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
parameter_list|()
block|{
name|List
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|>
name|loadTimes
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|services
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Service
argument_list|,
name|ServiceListener
argument_list|>
name|entry
range|:
name|services
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Service
name|service
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|service
operator|.
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|NEW
operator|&
name|state
operator|!=
name|State
operator|.
name|STARTING
operator|&
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|loadTimes
operator|.
name|add
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|service
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|startupTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|loadTimes
argument_list|,
name|Ordering
operator|.
expr|<
name|Long
operator|>
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|loadTimes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|ServiceManager
operator|.
name|class
argument_list|)
operator|.
name|add
argument_list|(
literal|"services"
argument_list|,
name|Collections2
operator|.
name|filter
argument_list|(
name|services
operator|.
name|keySet
argument_list|()
argument_list|,
name|not
argument_list|(
name|instanceOf
argument_list|(
name|NoOpService
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be     * accessed by instances of {@link ServiceListener}.    */
DECL|class|ServiceManagerState
specifier|private
specifier|static
specifier|final
class|class
name|ServiceManagerState
block|{
DECL|field|monitor
specifier|final
name|Monitor
name|monitor
init|=
operator|new
name|Monitor
argument_list|()
decl_stmt|;
DECL|field|numberOfServices
specifier|final
name|int
name|numberOfServices
decl_stmt|;
comment|/** The number of services that have not finished starting up. */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|unstartedServices
name|int
name|unstartedServices
decl_stmt|;
comment|/** The number of services that have not reached a terminal state. */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|unstoppedServices
name|int
name|unstoppedServices
decl_stmt|;
comment|/**       * Controls how long to wait for all the service manager to either become healthy or reach a       * state where it is guaranteed that it can never become healthy.      */
DECL|field|awaitHealthGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|awaitHealthGuard
init|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
comment|// All services have started or some service has terminated/failed.
return|return
name|unstartedServices
operator|==
literal|0
operator||
name|unstoppedServices
operator|!=
name|numberOfServices
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Controls how long to wait for all services to reach a terminal state.      */
DECL|field|stoppedGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|stoppedGuard
init|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|unstoppedServices
operator|==
literal|0
return|;
block|}
block|}
decl_stmt|;
comment|/** The listeners to notify during a state transition. */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|listeners
specifier|final
name|List
argument_list|<
name|ListenerExecutorPair
argument_list|>
name|listeners
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|/**      * The queue of listeners that are waiting to be executed.      *      *<p>Enqueue operations should be protected by {@link #monitor} while dequeue operations should      * be protected by the implicit lock on this object. This is to ensure that listeners are      * executed in the correct order and also so that a listener can not hold the {@link #monitor}       * for an arbitrary amount of time (listeners can only block other listeners, not internal state      * transitions). We use a concurrent queue implementation so that enqueues can be executed       * concurrently with dequeues.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"queuedListeners"
argument_list|)
DECL|field|queuedListeners
specifier|final
name|Queue
argument_list|<
name|Runnable
argument_list|>
name|queuedListeners
init|=
name|Queues
operator|.
name|newConcurrentLinkedQueue
argument_list|()
decl_stmt|;
DECL|method|ServiceManagerState (int numberOfServices)
name|ServiceManagerState
parameter_list|(
name|int
name|numberOfServices
parameter_list|)
block|{
name|this
operator|.
name|numberOfServices
operator|=
name|numberOfServices
expr_stmt|;
name|this
operator|.
name|unstoppedServices
operator|=
name|numberOfServices
expr_stmt|;
name|this
operator|.
name|unstartedServices
operator|=
name|numberOfServices
expr_stmt|;
block|}
DECL|method|addListener (Listener listener, Executor executor)
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|,
literal|"listener"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|executor
argument_list|,
literal|"executor"
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
comment|// no point in adding a listener that will never be called
if|if
condition|(
name|unstartedServices
operator|>
literal|0
operator|||
name|unstoppedServices
operator|>
literal|0
condition|)
block|{
name|listeners
operator|.
name|add
argument_list|(
operator|new
name|ListenerExecutorPair
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitHealthy ()
name|void
name|awaitHealthy
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
name|boolean
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|awaitStopped ()
name|void
name|awaitStopped
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
DECL|method|awaitStopped (long timeout, TimeUnit unit)
name|boolean
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * This should be called when a service finishes starting up.      *       * @param currentlyHealthy whether or not the service that finished starting was healthy at the       *        time that it finished starting.       */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|serviceFinishedStarting (Service service, boolean currentlyHealthy)
specifier|private
name|void
name|serviceFinishedStarting
parameter_list|(
name|Service
name|service
parameter_list|,
name|boolean
name|currentlyHealthy
parameter_list|)
block|{
name|checkState
argument_list|(
name|unstartedServices
operator|>
literal|0
argument_list|,
literal|"All services should have already finished starting but %s just finished."
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|unstartedServices
operator|--
expr_stmt|;
if|if
condition|(
name|currentlyHealthy
operator|&&
name|unstartedServices
operator|==
literal|0
operator|&&
name|unstoppedServices
operator|==
name|numberOfServices
condition|)
block|{
comment|// This means that the manager is currently healthy, or at least it should have been
comment|// healthy at some point from some perspective. Calling isHealthy is not currently
comment|// guaranteed to return true because any service could fail right now. However, the
comment|// happens-before relationship enforced by the monitor ensures that this method was called
comment|// before either serviceTerminated or serviceFailed, so we know that the manager was at
comment|// least healthy for some period of time. Furthermore we are guaranteed that this call to
comment|// healthy() will be before any call to terminated() or failure(Service) on the listener.
comment|// So it is correct to execute the listener's health() callback.
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|healthy
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This should be called when a service is {@linkplain State#TERMINATED terminated}.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|serviceTerminated (Service service)
specifier|private
name|void
name|serviceTerminated
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|serviceStopped
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
comment|/**      * This should be called when a service is {@linkplain State#FAILED failed}.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|serviceFailed (final Service service)
specifier|private
name|void
name|serviceFailed
parameter_list|(
specifier|final
name|Service
name|service
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|failure
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|serviceStopped
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
comment|/**      * Should be called whenever a service reaches a terminal state (      * {@linkplain State#TERMINATED terminated} or       * {@linkplain State#FAILED failed}).      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|serviceStopped (Service service)
specifier|private
name|void
name|serviceStopped
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|checkState
argument_list|(
name|unstoppedServices
operator|>
literal|0
argument_list|,
literal|"All services should have already stopped but %s just stopped."
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|unstoppedServices
operator|--
expr_stmt|;
if|if
condition|(
name|unstoppedServices
operator|==
literal|0
condition|)
block|{
name|checkState
argument_list|(
name|unstartedServices
operator|==
literal|0
argument_list|,
literal|"All services are stopped but %d services haven't finished starting"
argument_list|,
name|unstartedServices
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|stopped
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// no more listeners could possibly be called, so clear them out
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**       * Attempts to execute all the listeners in {@link #queuedListeners}.      */
DECL|method|executeListeners ()
specifier|private
name|void
name|executeListeners
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|,
literal|"It is incorrect to execute listeners with the monitor held."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|queuedListeners
init|)
block|{
name|Runnable
name|listener
decl_stmt|;
while|while
condition|(
operator|(
name|listener
operator|=
name|queuedListeners
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * A {@link Service} that wraps another service and times how long it takes for it to start and     * also calls the {@link ServiceManagerState#serviceFinishedStarting},     * {@link ServiceManagerState#serviceTerminated} and {@link ServiceManagerState#serviceFailed}    * according to its current state.    */
DECL|class|ServiceListener
specifier|private
specifier|static
specifier|final
class|class
name|ServiceListener
implements|implements
name|Service
operator|.
name|Listener
block|{
annotation|@
name|GuardedBy
argument_list|(
literal|"watch"
argument_list|)
comment|// AFAICT Stopwatch is not thread safe so we need to protect accesses
DECL|field|watch
specifier|final
name|Stopwatch
name|watch
init|=
operator|new
name|Stopwatch
argument_list|()
decl_stmt|;
DECL|field|service
specifier|final
name|Service
name|service
decl_stmt|;
DECL|field|state
specifier|final
name|ServiceManagerState
name|state
decl_stmt|;
comment|/**      * @param service the service that       */
DECL|method|ServiceListener (Service service, ServiceManagerState state)
name|ServiceListener
parameter_list|(
name|Service
name|service
parameter_list|,
name|ServiceManagerState
name|state
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|starting ()
annotation|@
name|Override
specifier|public
name|void
name|starting
parameter_list|()
block|{
comment|// This can happen if someone besides the ServiceManager starts the service, in this case
comment|// our timings may be inaccurate.
name|startTimer
argument_list|()
expr_stmt|;
block|}
DECL|method|running ()
annotation|@
name|Override
specifier|public
name|void
name|running
parameter_list|()
block|{
name|state
operator|.
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|finishedStarting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|state
operator|.
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|state
operator|.
name|executeListeners
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stopping (State from)
annotation|@
name|Override
specifier|public
name|void
name|stopping
parameter_list|(
name|State
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
name|State
operator|.
name|STARTING
condition|)
block|{
name|state
operator|.
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|finishedStarting
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|state
operator|.
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|state
operator|.
name|executeListeners
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|terminated (State from)
annotation|@
name|Override
specifier|public
name|void
name|terminated
parameter_list|(
name|State
name|from
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Service {0} has terminated. Previous state was: {1}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|from
block|}
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|from
operator|==
name|State
operator|.
name|NEW
condition|)
block|{
comment|// startTimer is idempotent, so this is safe to call and it may be necessary if no one has
comment|// started the timer yet.
name|startTimer
argument_list|()
expr_stmt|;
name|finishedStarting
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|serviceTerminated
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|state
operator|.
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|state
operator|.
name|executeListeners
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|failed (State from, Throwable failure)
annotation|@
name|Override
specifier|public
name|void
name|failed
parameter_list|(
name|State
name|from
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Service "
operator|+
name|service
operator|+
literal|" has failed in the "
operator|+
name|from
operator|+
literal|" state."
argument_list|,
name|failure
argument_list|)
expr_stmt|;
name|state
operator|.
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|from
operator|==
name|State
operator|.
name|STARTING
condition|)
block|{
name|finishedStarting
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|serviceFailed
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|state
operator|.
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|state
operator|.
name|executeListeners
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**       * Stop the stopwatch, log the startup time and decrement the startup latch      *        * @param currentlyHealthy whether or not the service that finished starting is currently       *        healthy       */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|finishedStarting (boolean currentlyHealthy)
name|void
name|finishedStarting
parameter_list|(
name|boolean
name|currentlyHealthy
parameter_list|)
block|{
synchronized|synchronized
init|(
name|watch
init|)
block|{
name|watch
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Started {0} in {1} ms."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|startupTimeMillis
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|.
name|serviceFinishedStarting
argument_list|(
name|service
argument_list|,
name|currentlyHealthy
argument_list|)
expr_stmt|;
block|}
DECL|method|start ()
name|void
name|start
parameter_list|()
block|{
name|startTimer
argument_list|()
expr_stmt|;
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/** Start the timer if it hasn't been started. */
DECL|method|startTimer ()
name|void
name|startTimer
parameter_list|()
block|{
synchronized|synchronized
init|(
name|watch
init|)
block|{
if|if
condition|(
operator|!
name|watch
operator|.
name|isRunning
argument_list|()
condition|)
block|{
comment|// only start the watch once.
name|watch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Starting {0}."
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Returns the amount of time it took for the service to finish starting in milliseconds. */
DECL|method|startupTimeMillis ()
name|long
name|startupTimeMillis
parameter_list|()
block|{
synchronized|synchronized
init|(
name|watch
init|)
block|{
return|return
name|watch
operator|.
name|elapsed
argument_list|(
name|MILLISECONDS
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Simple value object binding a listener to its executor. */
DECL|class|ListenerExecutorPair
annotation|@
name|Immutable
specifier|private
specifier|static
specifier|final
class|class
name|ListenerExecutorPair
block|{
DECL|field|listener
specifier|final
name|Listener
name|listener
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ListenerExecutorPair (Listener listener, Executor executor)
name|ListenerExecutorPair
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
comment|/**      * Executes the given {@link Runnable} on {@link #executor} logging and swallowing all       * exceptions      */
DECL|method|execute (Runnable runnable)
name|void
name|execute
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Exception while executing listener "
operator|+
name|listener
operator|+
literal|" with executor "
operator|+
name|executor
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A {@link Service} instance that does nothing.  This is only useful as a placeholder to    * ensure that the {@link ServiceManager} functions properly even when it is managing no services.    *     *<p>The use of this class is considered an implementation detail of the class and as such it is    * excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all     * logging statements.    */
DECL|class|NoOpService
specifier|private
specifier|static
specifier|final
class|class
name|NoOpService
extends|extends
name|AbstractService
block|{
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
DECL|method|doStop ()
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** This is never thrown but only used for logging. */
DECL|class|EmptyServiceManagerWarning
specifier|private
specifier|static
specifier|final
class|class
name|EmptyServiceManagerWarning
extends|extends
name|Throwable
block|{}
block|}
end_class

end_unit

