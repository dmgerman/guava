begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|in
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|FAILED
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|NEW
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|RUNNING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|STARTING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|STOPPING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|TERMINATED
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimaps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|Immutable
import|;
end_import

begin_comment
comment|/**  * A manager for monitoring and controlling a set of {@link Service services}. This class provides  * methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and  * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.  * Additionally, users can monitor state transitions with the {@link Listener listener} mechanism.  *  *<p>While it is recommended that service lifecycles be managed via this class, state transitions  * initiated via other mechanisms do not impact the correctness of its methods. For example, if the  * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked  * when appropriate and {@link #awaitHealthy} will still work as expected.  *  *<p>Here is a simple example of how to use a {@link ServiceManager} to start a server.  *<pre>   {@code  * class Server {  *   public static void main(String[] args) {  *     Set<Service> services = ...;  *     ServiceManager manager = new ServiceManager(services);  *     manager.addListener(new Listener() {  *         public void stopped() {}  *         public void healthy() {  *           // Services have been initialized and are healthy, start accepting requests...  *         }  *         public void failure(Service service) {  *           // Something failed, at this point we could log it, notify a load balancer, or take  *           // some other action.  For now we will just exit.  *           System.exit(1);  *         }  *       },  *       MoreExecutors.sameThreadExecutor());  *  *     Runtime.getRuntime().addShutdownHook(new Thread() {  *       public void run() {  *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown   *         // requests.  *         try {  *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);  *         } catch (TimeoutException timeout) {  *           // stopping timed out  *         }  *       }  *     });  *     manager.startAsync();  // start all the services asynchronously  *   }  * }}</pre>  *  *<p>This class uses the ServiceManager's methods to start all of its services, to respond to  * service failure and to ensure that when the JVM is shutting down all the services are stopped.  *  * @author Luke Sandberg  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|ServiceManager
specifier|public
specifier|final
class|class
name|ServiceManager
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ServiceManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * A listener for the aggregate state changes of the services that are under management. Users    * that need to listen to more fine-grained events (such as when each particular    * {@link Service service} starts, or terminates), should attach {@link Service.Listener service    * listeners} to each individual service.    *     * @author Luke Sandberg    * @since 15.0 (present as an interface in 14.0)    */
annotation|@
name|Beta
comment|// Should come out of Beta when ServiceManager does
DECL|class|Listener
specifier|public
specifier|abstract
specifier|static
class|class
name|Listener
block|{
comment|/**       * Called when the service initially becomes healthy.      *       *<p>This will be called at most once after all the services have entered the       * {@linkplain State#RUNNING running} state. If any services fail during start up or       * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other       * services have started {@linkplain State#RUNNING running} then this method will not be called.      */
DECL|method|healthy ()
specifier|public
name|void
name|healthy
parameter_list|()
block|{}
comment|/**       * Called when the all of the component services have reached a terminal state, either       * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.      */
DECL|method|stopped ()
specifier|public
name|void
name|stopped
parameter_list|()
block|{}
comment|/**       * Called when a component service has {@linkplain State#FAILED failed}.      *       * @param service The service that failed.      */
DECL|method|failure (Service service)
specifier|public
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
block|{}
block|}
comment|/**    * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener     * service listeners}.  This is extracted into its own object so that {@link ServiceListener}     * could be made {@code static} and its instances can be safely constructed and added in the     * {@link ServiceManager} constructor without having to close over the partially constructed     * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).    */
DECL|field|state
specifier|private
specifier|final
name|ServiceManagerState
name|state
decl_stmt|;
DECL|field|services
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Service
argument_list|>
name|services
decl_stmt|;
comment|/**    * Constructs a new instance for managing the given services.    *     * @param services The services to manage    *     * @throws IllegalArgumentException if not all services are {@link State#NEW new} or if there are    *     any duplicate services.    */
DECL|method|ServiceManager (Iterable<? extends Service> services)
specifier|public
name|ServiceManager
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|Service
argument_list|>
name|copy
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|services
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Having no services causes the manager to behave strangely. Notably, listeners are never
comment|// fired.  To avoid this we substitute a placeholder service.
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ServiceManager configured with no services.  Is your application configured properly?"
argument_list|,
operator|new
name|EmptyServiceManagerWarning
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|=
name|ImmutableList
operator|.
expr|<
name|Service
operator|>
name|of
argument_list|(
operator|new
name|NoOpService
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|state
operator|=
operator|new
name|ServiceManagerState
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|this
operator|.
name|services
operator|=
name|copy
expr_stmt|;
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|stateReference
init|=
operator|new
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|copy
control|)
block|{
comment|// We give each listener its own SynchronizedExecutor to ensure that the state transitions
comment|// are run in the same order that they occur.  The Service.Listener api guarantees us only
comment|// that the transitions are submitted to the executor in the same order that they occur, so by
comment|// synchronizing the executions of each listeners callbacks we can ensure that the entire
comment|// execution of the listener occurs in the same order as the transitions themselves.
comment|//
comment|// This is necessary to prevent transitions being played back in the wrong order due to thread
comment|// races to acquire the monitor in ServiceManagerState.
name|service
operator|.
name|addListener
argument_list|(
operator|new
name|ServiceListener
argument_list|(
name|service
argument_list|,
name|stateReference
argument_list|)
argument_list|,
operator|new
name|SynchronizedExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// We check the state after adding the listener as a way to ensure that our listener was added
comment|// to a NEW service.
name|checkArgument
argument_list|(
name|service
operator|.
name|state
argument_list|()
operator|==
name|NEW
argument_list|,
literal|"Can only manage NEW services, %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
comment|// We have installed all of our listeners and after this point any state transition should be
comment|// correct.
name|this
operator|.
name|state
operator|.
name|markReady
argument_list|()
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given     * executor. The listener will not have previous state changes replayed, so it is     * suggested that listeners are added before any of the managed services are     * {@linkplain Service#start started}.    *    *<p>There is no guaranteed ordering of execution of listeners, but any listener added through     * this method is guaranteed to be called whenever there is a state change.    *    *<p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown     * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception     * thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and    * logged.    *     *<p> For fast, lightweight listeners that would be safe to execute in any thread, consider     * calling {@link #addListener(Listener)}.    *     * @param listener the listener to run when the manager changes state    * @param executor the executor in which the listeners callback methods will be run.    */
DECL|method|addListener (Listener listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The     * listener will not have previous state changes replayed, so it is suggested that listeners are     * added before any of the managed services are {@linkplain Service#start started}.    *    *<p>There is no guaranteed ordering of execution of listeners, but any listener added through     * this method is guaranteed to be called whenever there is a state change.    *    *<p>Exceptions thrown by a listener will be will be caught and logged.    *     * @param listener the listener to run when the manager changes state    */
DECL|method|addListener (Listener listener)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#start startup} on all the services being managed.  It is    * only valid to call this method if all of the services are {@linkplain State#NEW new}.    *     * @return this    * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the     *     method is called.    */
DECL|method|startAsync ()
specifier|public
name|ServiceManager
name|startAsync
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|State
name|state
init|=
name|service
operator|.
name|state
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|state
operator|==
name|NEW
argument_list|,
literal|"Service %s is %s, cannot start it."
argument_list|,
name|service
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
try|try
block|{
name|service
operator|.
name|startAsync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// This can happen if the service has already been started or stopped (e.g. by another
comment|// service or listener). Our contract says it is safe to call this method if
comment|// all services were NEW when it was called, and this has already been verified above, so we
comment|// don't propagate the exception.
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Unable to start Service "
operator|+
name|service
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}.  The manager    * will become healthy after all the component services have reached the {@linkplain State#RUNNING    * running} state.      *     * @throws IllegalStateException if the service manager reaches a state from which it cannot     *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy ()
specifier|public
name|void
name|awaitHealthy
parameter_list|()
block|{
name|state
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more     * than the given time.  The manager will become healthy after all the component services have     * reached the {@linkplain State#RUNNING running} state.     *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have finished starting within the deadline    * @throws IllegalStateException if the service manager reaches a state from which it cannot     *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|state
operator|.
name|awaitHealthy
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#stop shutdown} if necessary on all the services being     * managed.     *        * @return this    */
DECL|method|stopAsync ()
specifier|public
name|ServiceManager
name|stopAsync
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|service
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state. After this method returns all    * services will either be {@link Service.State#TERMINATED terminated} or     * {@link Service.State#FAILED failed}    */
DECL|method|awaitStopped ()
specifier|public
name|void
name|awaitStopped
parameter_list|()
block|{
name|state
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state for no more than the given time. After    * this method returns all services will either be {@link Service.State#TERMINATED terminated} or     * {@link Service.State#FAILED failed}    *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have stopped within the deadline    */
DECL|method|awaitStopped (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|state
operator|.
name|awaitStopped
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.      *     *<p>Users who want more detailed information should use the {@link #servicesByState} method to     * get detailed information about which services are not running.    */
DECL|method|isHealthy ()
specifier|public
name|boolean
name|isHealthy
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
if|if
condition|(
operator|!
name|service
operator|.
name|isRunning
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Provides a snapshot of the current state of all the services under management.    *    *<p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will    * correspond to a point in time view of the services.    */
DECL|method|servicesByState ()
specifier|public
name|ImmutableMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
parameter_list|()
block|{
return|return
name|state
operator|.
name|servicesByState
argument_list|()
return|;
block|}
comment|/**    * Returns the service load times. This value will only return startup times for services that    * have finished starting.    *    * @return Map of services and their corresponding startup time in millis, the map entries will be    *     ordered by startup time.    */
DECL|method|startupTimes ()
specifier|public
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
parameter_list|()
block|{
return|return
name|state
operator|.
name|startupTimes
argument_list|()
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|ServiceManager
operator|.
name|class
argument_list|)
operator|.
name|add
argument_list|(
literal|"services"
argument_list|,
name|Collections2
operator|.
name|filter
argument_list|(
name|services
argument_list|,
name|not
argument_list|(
name|instanceOf
argument_list|(
name|NoOpService
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be     * accessed by instances of {@link ServiceListener}.    */
DECL|class|ServiceManagerState
specifier|private
specifier|static
specifier|final
class|class
name|ServiceManagerState
block|{
DECL|field|monitor
specifier|final
name|Monitor
name|monitor
init|=
operator|new
name|Monitor
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|servicesByState
specifier|final
name|SetMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
init|=
name|Multimaps
operator|.
name|newSetMultimap
argument_list|(
operator|new
name|EnumMap
argument_list|<
name|State
argument_list|,
name|Collection
argument_list|<
name|Service
argument_list|>
argument_list|>
argument_list|(
name|State
operator|.
name|class
argument_list|)
argument_list|,
operator|new
name|Supplier
argument_list|<
name|Set
argument_list|<
name|Service
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Service
argument_list|>
name|get
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|states
specifier|final
name|Multiset
argument_list|<
name|State
argument_list|>
name|states
init|=
name|servicesByState
operator|.
name|keys
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|startupTimers
specifier|final
name|Map
argument_list|<
name|Service
argument_list|,
name|Stopwatch
argument_list|>
name|startupTimers
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
comment|/**      * These two booleans are used to mark the state as ready to start.      * {@link #ready}: is set by {@link #markReady} to indicate that all listeners have been       *     correctly installed      * {@link #transitioned}: is set by {@link #transitionService} to indicate that some transition       *     has been performed.      *       *<p>Together, they allow us to enforce that all services have their listeners installed prior      * to any service performing a transition, then we can fail in the ServiceManager constructor      * rather than in a Service.Listener callback.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|ready
name|boolean
name|ready
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|transitioned
name|boolean
name|transitioned
decl_stmt|;
DECL|field|numberOfServices
specifier|final
name|int
name|numberOfServices
decl_stmt|;
comment|/**      * Controls how long to wait for all the services to either become healthy or reach a      * state from which it is guaranteed that it can never become healthy.      */
DECL|field|awaitHealthGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|awaitHealthGuard
init|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
comment|// All services have started or some service has terminated/failed.
return|return
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|==
name|numberOfServices
operator|||
name|states
operator|.
name|contains
argument_list|(
name|STOPPING
argument_list|)
operator|||
name|states
operator|.
name|contains
argument_list|(
name|TERMINATED
argument_list|)
operator|||
name|states
operator|.
name|contains
argument_list|(
name|FAILED
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Controls how long to wait for all services to reach a terminal state.      */
DECL|field|stoppedGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|stoppedGuard
init|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|states
operator|.
name|count
argument_list|(
name|TERMINATED
argument_list|)
operator|+
name|states
operator|.
name|count
argument_list|(
name|FAILED
argument_list|)
operator|==
name|numberOfServices
return|;
block|}
block|}
decl_stmt|;
comment|/** The listeners to notify during a state transition. */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|listeners
specifier|final
name|List
argument_list|<
name|ListenerExecutorPair
argument_list|>
name|listeners
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|/**      * The queue of listeners that are waiting to be executed.      *      *<p>Enqueue operations should be protected by {@link #monitor} while dequeue operations are      * not protected. Holding {@link #monitor} while enqueuing ensures that listeners in the queue      * are in the correct order and {@link ExecutionQueue} ensures that they are executed in the      * correct order.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|queuedListeners
specifier|final
name|ExecutionQueue
name|queuedListeners
init|=
operator|new
name|ExecutionQueue
argument_list|()
decl_stmt|;
comment|/**      * It is implicitly assumed that all the services are NEW and that they will all remain NEW       * until all the Listeners are installed and {@link #markReady()} is called.  It is our caller's      * responsibility to only call {@link #markReady()} if all services were new at the time this      * method was called and when all the listeners were installed.      */
DECL|method|ServiceManagerState (ImmutableCollection<Service> services)
name|ServiceManagerState
parameter_list|(
name|ImmutableCollection
argument_list|<
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|this
operator|.
name|numberOfServices
operator|=
name|services
operator|.
name|size
argument_list|()
expr_stmt|;
name|servicesByState
operator|.
name|putAll
argument_list|(
name|NEW
argument_list|,
name|services
argument_list|)
expr_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|startupTimers
operator|.
name|put
argument_list|(
name|service
argument_list|,
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have      * been observed yet.      */
DECL|method|markReady ()
name|void
name|markReady
parameter_list|()
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|transitioned
condition|)
block|{
comment|// nothing has transitioned since construction, good.
name|ready
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// This should be an extremely rare race condition.
name|List
argument_list|<
name|Service
argument_list|>
name|servicesInBadStates
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|servicesByState
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|service
operator|.
name|state
argument_list|()
operator|!=
name|NEW
condition|)
block|{
name|servicesInBadStates
operator|.
name|add
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Services started transitioning asynchronously before "
operator|+
literal|"the ServiceManager was constructed: "
operator|+
name|servicesInBadStates
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addListener (Listener listener, Executor executor)
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|,
literal|"listener"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|executor
argument_list|,
literal|"executor"
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
comment|// no point in adding a listener that will never be called
if|if
condition|(
operator|!
name|stoppedGuard
operator|.
name|isSatisfied
argument_list|()
condition|)
block|{
name|listeners
operator|.
name|add
argument_list|(
operator|new
name|ListenerExecutorPair
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitHealthy ()
name|void
name|awaitHealthy
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|)
expr_stmt|;
try|try
block|{
name|checkHealthy
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
name|void
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|monitor
operator|.
name|waitForUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to become healthy. The "
operator|+
literal|"following services have not started: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|in
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|NEW
argument_list|,
name|STARTING
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|checkHealthy
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitStopped ()
name|void
name|awaitStopped
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
DECL|method|awaitStopped (long timeout, TimeUnit unit)
name|void
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|monitor
operator|.
name|waitForUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to stop. The following "
operator|+
literal|"services have not stopped: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|not
argument_list|(
name|in
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|TERMINATED
argument_list|,
name|FAILED
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|servicesByState ()
name|ImmutableMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
parameter_list|()
block|{
name|ImmutableSetMultimap
operator|.
name|Builder
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|builder
init|=
name|ImmutableSetMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|entry
range|:
name|servicesByState
operator|.
name|entries
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|startupTimes ()
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
parameter_list|()
block|{
name|List
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|>
name|loadTimes
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|loadTimes
operator|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|states
operator|.
name|size
argument_list|()
operator|-
name|states
operator|.
name|count
argument_list|(
name|NEW
argument_list|)
operator|+
name|states
operator|.
name|count
argument_list|(
name|STARTING
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Service
argument_list|,
name|Stopwatch
argument_list|>
name|entry
range|:
name|startupTimers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Service
name|service
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Stopwatch
name|stopWatch
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// N.B. we check the service state in the multimap rather than via Service.state() because
comment|// the multimap is guaranteed to be in sync with our timers while the Service.state() is
comment|// not.  Due to happens-before ness of the monitor this 'weirdness' will not be observable
comment|// by our caller.
if|if
condition|(
operator|!
name|stopWatch
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
name|servicesByState
operator|.
name|containsEntry
argument_list|(
name|NEW
argument_list|,
name|service
argument_list|)
operator|&&
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|loadTimes
operator|.
name|add
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|service
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|(
name|MILLISECONDS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|loadTimes
argument_list|,
name|Ordering
operator|.
expr|<
name|Long
operator|>
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|loadTimes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**       * Updates the state with the given service transition.      *       *<p>This method performs the main logic of ServiceManager in the following steps.      *<ol>      *<li>Update the {@link #servicesByState()}      *<li>Update the {@link #startupTimers}      *<li>Based on the new state queue listeners to run      *<li>Run the listeners (outside of the lock)      *</ol>      */
DECL|method|transitionService (final Service service, State from, State to)
name|void
name|transitionService
parameter_list|(
specifier|final
name|Service
name|service
parameter_list|,
name|State
name|from
parameter_list|,
name|State
name|to
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|from
operator|!=
name|to
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|transitioned
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
block|{
return|return;
block|}
comment|// Update state.
name|checkState
argument_list|(
name|servicesByState
operator|.
name|remove
argument_list|(
name|from
argument_list|,
name|service
argument_list|)
argument_list|,
literal|"Service %s not at the expected location in the state map %s"
argument_list|,
name|service
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|servicesByState
operator|.
name|put
argument_list|(
name|to
argument_list|,
name|service
argument_list|)
argument_list|,
literal|"Service %s in the state map unexpectedly at %s"
argument_list|,
name|service
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|// Update the timer
name|Stopwatch
name|stopwatch
init|=
name|startupTimers
operator|.
name|get
argument_list|(
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|NEW
condition|)
block|{
name|stopwatch
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|.
name|compareTo
argument_list|(
name|RUNNING
argument_list|)
operator|>=
literal|0
operator|&&
name|stopwatch
operator|.
name|isRunning
argument_list|()
condition|)
block|{
comment|// N.B. if we miss the STARTING event then we will never record a startup time.
name|stopwatch
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Started {0} in {1}."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|stopwatch
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Queue our listeners
comment|// Did a service fail?
if|if
condition|(
name|to
operator|==
name|FAILED
condition|)
block|{
name|fireFailedListeners
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|==
name|numberOfServices
condition|)
block|{
comment|// This means that the manager is currently healthy. N.B. If other threads call isHealthy
comment|// they are not guaranteed to get 'true', because any service could fail right now.
name|fireHealthyListeners
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|TERMINATED
argument_list|)
operator|+
name|states
operator|.
name|count
argument_list|(
name|FAILED
argument_list|)
operator|==
name|numberOfServices
condition|)
block|{
name|fireStoppedListeners
argument_list|()
expr_stmt|;
comment|// no more listeners could possibly be called, so clear them out to save some memory.
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
comment|// Run our executors outside of the lock
name|executeListeners
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|fireStoppedListeners ()
name|void
name|fireStoppedListeners
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|stopped
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
name|pair
operator|.
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|fireHealthyListeners ()
name|void
name|fireHealthyListeners
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|healthy
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
name|pair
operator|.
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|fireFailedListeners (final Service service)
name|void
name|fireFailedListeners
parameter_list|(
specifier|final
name|Service
name|service
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ListenerExecutorPair
name|pair
range|:
name|listeners
control|)
block|{
name|queuedListeners
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pair
operator|.
name|listener
operator|.
name|failure
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|pair
operator|.
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Attempts to execute all the listeners in {@link #queuedListeners}. */
DECL|method|executeListeners ()
name|void
name|executeListeners
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|,
literal|"It is incorrect to execute listeners with the monitor held."
argument_list|)
expr_stmt|;
name|queuedListeners
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|checkHealthy ()
name|void
name|checkHealthy
parameter_list|()
block|{
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|!=
name|numberOfServices
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected to be healthy after starting. "
operator|+
literal|"The following services are not running: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
name|RUNNING
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * A {@link Service} that wraps another service and times how long it takes for it to start and    * also calls the {@link ServiceManagerState#transitionService(Service, State, State)},    * to record the state transitions.    */
DECL|class|ServiceListener
specifier|private
specifier|static
specifier|final
class|class
name|ServiceListener
extends|extends
name|Service
operator|.
name|Listener
block|{
DECL|field|service
specifier|final
name|Service
name|service
decl_stmt|;
comment|// We store the state in a weak reference to ensure that if something went wrong while
comment|// constructing the ServiceManager we don't pointlessly keep updating the state.
DECL|field|state
specifier|final
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|state
decl_stmt|;
DECL|method|ServiceListener (Service service, WeakReference<ServiceManagerState> state)
name|ServiceListener
parameter_list|(
name|Service
name|service
parameter_list|,
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|state
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|starting ()
annotation|@
name|Override
specifier|public
name|void
name|starting
parameter_list|()
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|NEW
argument_list|,
name|STARTING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Starting {0}."
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|running ()
annotation|@
name|Override
specifier|public
name|void
name|running
parameter_list|()
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|STARTING
argument_list|,
name|RUNNING
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopping (State from)
annotation|@
name|Override
specifier|public
name|void
name|stopping
parameter_list|(
name|State
name|from
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|STOPPING
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|terminated (State from)
annotation|@
name|Override
specifier|public
name|void
name|terminated
parameter_list|(
name|State
name|from
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Service {0} has terminated. Previous state was: {1}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|from
block|}
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|TERMINATED
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|failed (State from, Throwable failure)
annotation|@
name|Override
specifier|public
name|void
name|failed
parameter_list|(
name|State
name|from
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
comment|// Log before the transition, so that if the process exits in response to server failure,
comment|// there is a higher likelihood that the cause will be in the logs.
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Service "
operator|+
name|service
operator|+
literal|" has failed in the "
operator|+
name|from
operator|+
literal|" state."
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|FAILED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Simple value object binding a listener to its executor. */
DECL|class|ListenerExecutorPair
annotation|@
name|Immutable
specifier|private
specifier|static
specifier|final
class|class
name|ListenerExecutorPair
block|{
DECL|field|listener
specifier|final
name|Listener
name|listener
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ListenerExecutorPair (Listener listener, Executor executor)
name|ListenerExecutorPair
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
block|}
comment|/**    * A {@link Service} instance that does nothing.  This is only useful as a placeholder to    * ensure that the {@link ServiceManager} functions properly even when it is managing no services.    *     *<p>The use of this class is considered an implementation detail of ServiceManager and as such    * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all    * logging statements.    */
DECL|class|NoOpService
specifier|private
specifier|static
specifier|final
class|class
name|NoOpService
extends|extends
name|AbstractService
block|{
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
DECL|method|doStop ()
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** This is never thrown but only used for logging. */
DECL|class|EmptyServiceManagerWarning
specifier|private
specifier|static
specifier|final
class|class
name|EmptyServiceManagerWarning
extends|extends
name|Throwable
block|{}
comment|/**     * A same-thread executor that executes all the runnables from within a synchronized block.    *     *<p>This ensures that tasks submitted to the executor run in the same order that they were     * submitted.    */
DECL|class|SynchronizedExecutor
specifier|private
specifier|static
specifier|final
class|class
name|SynchronizedExecutor
implements|implements
name|Executor
block|{
DECL|method|execute (Runnable command)
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|execute
parameter_list|(
name|Runnable
name|command
parameter_list|)
block|{
name|command
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

