begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|in
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|FAILED
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|NEW
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|RUNNING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|STARTING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|STOPPING
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
operator|.
name|TERMINATED
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MultimapBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimaps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Service
operator|.
name|State
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * A manager for monitoring and controlling a set of {@linkplain Service services}. This class  * provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and  * {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.  * Additionally, users can monitor state transitions with the {@linkplain Listener listener}  * mechanism.  *  *<p>While it is recommended that service lifecycles be managed via this class, state transitions  * initiated via other mechanisms do not impact the correctness of its methods. For example, if the  * services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked  * when appropriate and {@link #awaitHealthy} will still work as expected.  *  *<p>Here is a simple example of how to use a {@code ServiceManager} to start a server.  *<pre>   {@code  * class Server {  *   public static void main(String[] args) {  *     Set<Service> services = ...;  *     ServiceManager manager = new ServiceManager(services);  *     manager.addListener(new Listener() {  *         public void stopped() {}  *         public void healthy() {  *           // Services have been initialized and are healthy, start accepting requests...  *         }  *         public void failure(Service service) {  *           // Something failed, at this point we could log it, notify a load balancer, or take  *           // some other action.  For now we will just exit.  *           System.exit(1);  *         }  *       },  *       MoreExecutors.directExecutor());  *  *     Runtime.getRuntime().addShutdownHook(new Thread() {  *       public void run() {  *         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown  *         // requests.  *         try {  *           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);  *         } catch (TimeoutException timeout) {  *           // stopping timed out  *         }  *       }  *     });  *     manager.startAsync();  // start all the services asynchronously  *   }  * }}</pre>  *  *<p>This class uses the ServiceManager's methods to start all of its services, to respond to  * service failure and to ensure that when the JVM is shutting down all the services are stopped.  *  * @author Luke Sandberg  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|ServiceManager
specifier|public
specifier|final
class|class
name|ServiceManager
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ServiceManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|HEALTHY_EVENT
specifier|private
specifier|static
specifier|final
name|ListenerCallQueue
operator|.
name|Event
argument_list|<
name|Listener
argument_list|>
name|HEALTHY_EVENT
init|=
operator|new
name|ListenerCallQueue
operator|.
name|Event
argument_list|<
name|Listener
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|call
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|listener
operator|.
name|healthy
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"healthy()"
return|;
block|}
block|}
decl_stmt|;
DECL|field|STOPPED_EVENT
specifier|private
specifier|static
specifier|final
name|ListenerCallQueue
operator|.
name|Event
argument_list|<
name|Listener
argument_list|>
name|STOPPED_EVENT
init|=
operator|new
name|ListenerCallQueue
operator|.
name|Event
argument_list|<
name|Listener
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|call
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|listener
operator|.
name|stopped
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"stopped()"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A listener for the aggregate state changes of the services that are under management. Users    * that need to listen to more fine-grained events (such as when each particular    * {@linkplain Service service} starts, or terminates), should attach {@linkplain Service.Listener    * service listeners} to each individual service.    *    * @author Luke Sandberg    * @since 15.0 (present as an interface in 14.0)    */
annotation|@
name|Beta
comment|// Should come out of Beta when ServiceManager does
DECL|class|Listener
specifier|public
specifier|abstract
specifier|static
class|class
name|Listener
block|{
comment|/**      * Called when the service initially becomes healthy.      *      *<p>This will be called at most once after all the services have entered the      * {@linkplain State#RUNNING running} state. If any services fail during start up or      * {@linkplain State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other      * services have started {@linkplain State#RUNNING running} then this method will not be called.      */
DECL|method|healthy ()
specifier|public
name|void
name|healthy
parameter_list|()
block|{}
comment|/**      * Called when the all of the component services have reached a terminal state, either      * {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.      */
DECL|method|stopped ()
specifier|public
name|void
name|stopped
parameter_list|()
block|{}
comment|/**      * Called when a component service has {@linkplain State#FAILED failed}.      *      * @param service The service that failed.      */
DECL|method|failure (Service service)
specifier|public
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
block|{}
block|}
comment|/**    * An encapsulation of all of the state that is accessed by the {@linkplain ServiceListener    * service listeners}. This is extracted into its own object so that {@link ServiceListener} could    * be made {@code static} and its instances can be safely constructed and added in the    * {@link ServiceManager} constructor without having to close over the partially constructed    * {@link ServiceManager} instance (i.e. avoid leaking a pointer to {@code this}).    */
DECL|field|state
specifier|private
specifier|final
name|ServiceManagerState
name|state
decl_stmt|;
DECL|field|services
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Service
argument_list|>
name|services
decl_stmt|;
comment|/**    * Constructs a new instance for managing the given services.    *    * @param services The services to manage    *    * @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there    *     are any duplicate services.    */
DECL|method|ServiceManager (Iterable<? extends Service> services)
specifier|public
name|ServiceManager
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|Service
argument_list|>
name|copy
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|services
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Having no services causes the manager to behave strangely. Notably, listeners are never
comment|// fired. To avoid this we substitute a placeholder service.
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"ServiceManager configured with no services.  Is your application configured properly?"
argument_list|,
operator|new
name|EmptyServiceManagerWarning
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|=
name|ImmutableList
operator|.
expr|<
name|Service
operator|>
name|of
argument_list|(
operator|new
name|NoOpService
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|state
operator|=
operator|new
name|ServiceManagerState
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|this
operator|.
name|services
operator|=
name|copy
expr_stmt|;
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|stateReference
init|=
operator|new
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|copy
control|)
block|{
name|service
operator|.
name|addListener
argument_list|(
operator|new
name|ServiceListener
argument_list|(
name|service
argument_list|,
name|stateReference
argument_list|)
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// We check the state after adding the listener as a way to ensure that our listener was added
comment|// to a NEW service.
name|checkArgument
argument_list|(
name|service
operator|.
name|state
argument_list|()
operator|==
name|NEW
argument_list|,
literal|"Can only manage NEW services, %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
comment|// We have installed all of our listeners and after this point any state transition should be
comment|// correct.
name|this
operator|.
name|state
operator|.
name|markReady
argument_list|()
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given    * executor. The listener will not have previous state changes replayed, so it is suggested that    * listeners are added before any of the managed services are {@linkplain Service#startAsync    * started}.    *    *<p>{@code addListener} guarantees execution ordering across calls to a given listener but not    * across calls to multiple listeners. Specifically, a given listener will have its callbacks    * invoked in the same order as the underlying service enters those states. Additionally, at most    * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks    * may execute concurrently, and listeners may execute in an order different from the one in which    * they were registered.    *    *<p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown    * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and    * logged.    *    *<p>For fast, lightweight listeners that would be safe to execute in any thread, consider    * calling {@link #addListener(Listener)}.    *    * @param listener the listener to run when the manager changes state    * @param executor the executor in which the listeners callback methods will be run.    */
DECL|method|addListener (Listener listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a {@link Listener} to be run when this {@link ServiceManager} changes state. The    * listener will not have previous state changes replayed, so it is suggested that listeners are    * added before any of the managed services are {@linkplain Service#startAsync started}.    *    *<p>{@code addListener} guarantees execution ordering across calls to a given listener but not    * across calls to multiple listeners. Specifically, a given listener will have its callbacks    * invoked in the same order as the underlying service enters those states. Additionally, at most    * one of the listener's callbacks will execute at once. However, multiple listeners' callbacks    * may execute concurrently, and listeners may execute in an order different from the one in which    * they were registered.    *    *<p>RuntimeExceptions thrown by a listener will be caught and logged.    *    * @param listener the listener to run when the manager changes state    */
DECL|method|addListener (Listener listener)
specifier|public
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|state
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#startAsync startup} on all the services being managed. It    * is only valid to call this method if all of the services are {@linkplain State#NEW new}.    *    * @return this    * @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the    *     method is called.    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|startAsync ()
specifier|public
name|ServiceManager
name|startAsync
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|State
name|state
init|=
name|service
operator|.
name|state
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|state
operator|==
name|NEW
argument_list|,
literal|"Service %s is %s, cannot start it."
argument_list|,
name|service
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
try|try
block|{
name|state
operator|.
name|tryStartTiming
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|.
name|startAsync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// This can happen if the service has already been started or stopped (e.g. by another
comment|// service or listener). Our contract says it is safe to call this method if
comment|// all services were NEW when it was called, and this has already been verified above, so we
comment|// don't propagate the exception.
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Unable to start Service "
operator|+
name|service
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}. The manager    * will become healthy after all the component services have reached the {@linkplain State#RUNNING    * running} state.    *    * @throws IllegalStateException if the service manager reaches a state from which it cannot    *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy ()
specifier|public
name|void
name|awaitHealthy
parameter_list|()
block|{
name|state
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
block|}
comment|/**    * Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more    * than the given time. The manager will become healthy after all the component services have    * reached the {@linkplain State#RUNNING running} state.    *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have finished starting within the deadline    * @throws IllegalStateException if the service manager reaches a state from which it cannot    *     become {@linkplain #isHealthy() healthy}.    */
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|state
operator|.
name|awaitHealthy
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services    * being managed.    *    * @return this    */
annotation|@
name|CanIgnoreReturnValue
DECL|method|stopAsync ()
specifier|public
name|ServiceManager
name|stopAsync
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|service
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state. After this method returns all    * services will either be {@linkplain Service.State#TERMINATED terminated} or    * {@linkplain Service.State#FAILED failed}.    */
DECL|method|awaitStopped ()
specifier|public
name|void
name|awaitStopped
parameter_list|()
block|{
name|state
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
block|}
comment|/**    * Waits for the all the services to reach a terminal state for no more than the given time. After    * this method returns all services will either be {@linkplain Service.State#TERMINATED    * terminated} or {@linkplain Service.State#FAILED failed}.    *    * @param timeout the maximum time to wait    * @param unit the time unit of the timeout argument    * @throws TimeoutException if not all of the services have stopped within the deadline    */
DECL|method|awaitStopped (long timeout, TimeUnit unit)
specifier|public
name|void
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|state
operator|.
name|awaitStopped
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if all services are currently in the {@linkplain State#RUNNING running} state.    *    *<p>Users who want more detailed information should use the {@link #servicesByState} method to    * get detailed information about which services are not running.    */
DECL|method|isHealthy ()
specifier|public
name|boolean
name|isHealthy
parameter_list|()
block|{
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
if|if
condition|(
operator|!
name|service
operator|.
name|isRunning
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Provides a snapshot of the current state of all the services under management.    *    *<p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will    * correspond to a point in time view of the services.    */
DECL|method|servicesByState ()
specifier|public
name|ImmutableMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
parameter_list|()
block|{
return|return
name|state
operator|.
name|servicesByState
argument_list|()
return|;
block|}
comment|/**    * Returns the service load times. This value will only return startup times for services that    * have finished starting.    *    * @return Map of services and their corresponding startup time in millis, the map entries will be    *     ordered by startup time.    */
DECL|method|startupTimes ()
specifier|public
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
parameter_list|()
block|{
return|return
name|state
operator|.
name|startupTimes
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreObjects
operator|.
name|toStringHelper
argument_list|(
name|ServiceManager
operator|.
name|class
argument_list|)
operator|.
name|add
argument_list|(
literal|"services"
argument_list|,
name|Collections2
operator|.
name|filter
argument_list|(
name|services
argument_list|,
name|not
argument_list|(
name|instanceOf
argument_list|(
name|NoOpService
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * An encapsulation of all the mutable state of the {@link ServiceManager} that needs to be    * accessed by instances of {@link ServiceListener}.    */
DECL|class|ServiceManagerState
specifier|private
specifier|static
specifier|final
class|class
name|ServiceManagerState
block|{
DECL|field|monitor
specifier|final
name|Monitor
name|monitor
init|=
operator|new
name|Monitor
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|servicesByState
specifier|final
name|SetMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
init|=
name|MultimapBuilder
operator|.
name|enumKeys
argument_list|(
name|State
operator|.
name|class
argument_list|)
operator|.
name|linkedHashSetValues
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|states
specifier|final
name|Multiset
argument_list|<
name|State
argument_list|>
name|states
init|=
name|servicesByState
operator|.
name|keys
argument_list|()
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|startupTimers
specifier|final
name|Map
argument_list|<
name|Service
argument_list|,
name|Stopwatch
argument_list|>
name|startupTimers
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
comment|/**      * These two booleans are used to mark the state as ready to start.      *      *<p>{@link #ready}: is set by {@link #markReady} to indicate that all listeners have been      * correctly installed      *      *<p>{@link #transitioned}: is set by {@link #transitionService} to indicate that some      * transition has been performed.      *      *<p>Together, they allow us to enforce that all services have their listeners installed prior      * to any service performing a transition, then we can fail in the ServiceManager constructor      * rather than in a Service.Listener callback.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|ready
name|boolean
name|ready
decl_stmt|;
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|field|transitioned
name|boolean
name|transitioned
decl_stmt|;
DECL|field|numberOfServices
specifier|final
name|int
name|numberOfServices
decl_stmt|;
comment|/**      * Controls how long to wait for all the services to either become healthy or reach a state from      * which it is guaranteed that it can never become healthy.      */
DECL|field|awaitHealthGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|awaitHealthGuard
init|=
operator|new
name|AwaitHealthGuard
argument_list|()
decl_stmt|;
annotation|@
name|WeakOuter
DECL|class|AwaitHealthGuard
specifier|final
class|class
name|AwaitHealthGuard
extends|extends
name|Monitor
operator|.
name|Guard
block|{
DECL|method|AwaitHealthGuard ()
name|AwaitHealthGuard
parameter_list|()
block|{
name|super
argument_list|(
name|ServiceManagerState
operator|.
name|this
operator|.
name|monitor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|GuardedBy
argument_list|(
literal|"ServiceManagerState.this.monitor"
argument_list|)
DECL|method|isSatisfied ()
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
comment|// All services have started or some service has terminated/failed.
return|return
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|==
name|numberOfServices
operator|||
name|states
operator|.
name|contains
argument_list|(
name|STOPPING
argument_list|)
operator|||
name|states
operator|.
name|contains
argument_list|(
name|TERMINATED
argument_list|)
operator|||
name|states
operator|.
name|contains
argument_list|(
name|FAILED
argument_list|)
return|;
block|}
block|}
comment|/**      * Controls how long to wait for all services to reach a terminal state.      */
DECL|field|stoppedGuard
specifier|final
name|Monitor
operator|.
name|Guard
name|stoppedGuard
init|=
operator|new
name|StoppedGuard
argument_list|()
decl_stmt|;
annotation|@
name|WeakOuter
DECL|class|StoppedGuard
specifier|final
class|class
name|StoppedGuard
extends|extends
name|Monitor
operator|.
name|Guard
block|{
DECL|method|StoppedGuard ()
name|StoppedGuard
parameter_list|()
block|{
name|super
argument_list|(
name|ServiceManagerState
operator|.
name|this
operator|.
name|monitor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|GuardedBy
argument_list|(
literal|"ServiceManagerState.this.monitor"
argument_list|)
DECL|method|isSatisfied ()
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|states
operator|.
name|count
argument_list|(
name|TERMINATED
argument_list|)
operator|+
name|states
operator|.
name|count
argument_list|(
name|FAILED
argument_list|)
operator|==
name|numberOfServices
return|;
block|}
block|}
comment|/** The listeners to notify during a state transition. */
DECL|field|listeners
specifier|final
name|ListenerCallQueue
argument_list|<
name|Listener
argument_list|>
name|listeners
init|=
operator|new
name|ListenerCallQueue
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * It is implicitly assumed that all the services are NEW and that they will all remain NEW      * until all the Listeners are installed and {@link #markReady()} is called. It is our caller's      * responsibility to only call {@link #markReady()} if all services were new at the time this      * method was called and when all the listeners were installed.      */
DECL|method|ServiceManagerState (ImmutableCollection<Service> services)
name|ServiceManagerState
parameter_list|(
name|ImmutableCollection
argument_list|<
name|Service
argument_list|>
name|services
parameter_list|)
block|{
name|this
operator|.
name|numberOfServices
operator|=
name|services
operator|.
name|size
argument_list|()
expr_stmt|;
name|servicesByState
operator|.
name|putAll
argument_list|(
name|NEW
argument_list|,
name|services
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempts to start the timer immediately prior to the service being started via      * {@link Service#startAsync()}.      */
DECL|method|tryStartTiming (Service service)
name|void
name|tryStartTiming
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|Stopwatch
name|stopwatch
init|=
name|startupTimers
operator|.
name|get
argument_list|(
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopwatch
operator|==
literal|null
condition|)
block|{
name|startupTimers
operator|.
name|put
argument_list|(
name|service
argument_list|,
name|Stopwatch
operator|.
name|createStarted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Marks the {@link State} as ready to receive transitions. Returns true if no transitions have      * been observed yet.      */
DECL|method|markReady ()
name|void
name|markReady
parameter_list|()
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|transitioned
condition|)
block|{
comment|// nothing has transitioned since construction, good.
name|ready
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// This should be an extremely rare race condition.
name|List
argument_list|<
name|Service
argument_list|>
name|servicesInBadStates
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|servicesByState
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|service
operator|.
name|state
argument_list|()
operator|!=
name|NEW
condition|)
block|{
name|servicesInBadStates
operator|.
name|add
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Services started transitioning asynchronously before "
operator|+
literal|"the ServiceManager was constructed: "
operator|+
name|servicesInBadStates
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addListener (Listener listener, Executor executor)
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|listeners
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|awaitHealthy ()
name|void
name|awaitHealthy
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|)
expr_stmt|;
try|try
block|{
name|checkHealthy
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitHealthy (long timeout, TimeUnit unit)
name|void
name|awaitHealthy
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|monitor
operator|.
name|waitForUninterruptibly
argument_list|(
name|awaitHealthGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to become healthy. The "
operator|+
literal|"following services have not started: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|in
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|NEW
argument_list|,
name|STARTING
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|checkHealthy
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitStopped ()
name|void
name|awaitStopped
parameter_list|()
block|{
name|monitor
operator|.
name|enterWhenUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
DECL|method|awaitStopped (long timeout, TimeUnit unit)
name|void
name|awaitStopped
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|monitor
operator|.
name|waitForUninterruptibly
argument_list|(
name|stoppedGuard
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timeout waiting for the services to stop. The following "
operator|+
literal|"services have not stopped: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|not
argument_list|(
name|in
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|TERMINATED
argument_list|,
name|FAILED
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|servicesByState ()
name|ImmutableMultimap
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|servicesByState
parameter_list|()
block|{
name|ImmutableSetMultimap
operator|.
name|Builder
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|builder
init|=
name|ImmutableSetMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|State
argument_list|,
name|Service
argument_list|>
name|entry
range|:
name|servicesByState
operator|.
name|entries
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|startupTimes ()
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
parameter_list|()
block|{
name|List
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|>
name|loadTimes
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|loadTimes
operator|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|startupTimers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// N.B. There will only be an entry in the map if the service has started
for|for
control|(
name|Entry
argument_list|<
name|Service
argument_list|,
name|Stopwatch
argument_list|>
name|entry
range|:
name|startupTimers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Service
name|service
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Stopwatch
name|stopWatch
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|stopWatch
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|loadTimes
operator|.
name|add
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|service
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|(
name|MILLISECONDS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|loadTimes
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|loadTimes
argument_list|)
return|;
block|}
comment|/**      * Updates the state with the given service transition.      *      *<p>This method performs the main logic of ServiceManager in the following steps.      *<ol>      *<li>Update the {@link #servicesByState()}      *<li>Update the {@link #startupTimers}      *<li>Based on the new state queue listeners to run      *<li>Run the listeners (outside of the lock)      *</ol>      */
DECL|method|transitionService (final Service service, State from, State to)
name|void
name|transitionService
parameter_list|(
specifier|final
name|Service
name|service
parameter_list|,
name|State
name|from
parameter_list|,
name|State
name|to
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|from
operator|!=
name|to
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|transitioned
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
block|{
return|return;
block|}
comment|// Update state.
name|checkState
argument_list|(
name|servicesByState
operator|.
name|remove
argument_list|(
name|from
argument_list|,
name|service
argument_list|)
argument_list|,
literal|"Service %s not at the expected location in the state map %s"
argument_list|,
name|service
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|servicesByState
operator|.
name|put
argument_list|(
name|to
argument_list|,
name|service
argument_list|)
argument_list|,
literal|"Service %s in the state map unexpectedly at %s"
argument_list|,
name|service
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|// Update the timer
name|Stopwatch
name|stopwatch
init|=
name|startupTimers
operator|.
name|get
argument_list|(
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopwatch
operator|==
literal|null
condition|)
block|{
comment|// This means the service was started by some means other than ServiceManager.startAsync
name|stopwatch
operator|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
expr_stmt|;
name|startupTimers
operator|.
name|put
argument_list|(
name|service
argument_list|,
name|stopwatch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|.
name|compareTo
argument_list|(
name|RUNNING
argument_list|)
operator|>=
literal|0
operator|&&
name|stopwatch
operator|.
name|isRunning
argument_list|()
condition|)
block|{
comment|// N.B. if we miss the STARTING event then we may never record a startup time.
name|stopwatch
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Started {0} in {1}."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|stopwatch
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Queue our listeners
comment|// Did a service fail?
if|if
condition|(
name|to
operator|==
name|FAILED
condition|)
block|{
name|enqueueFailedEvent
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|==
name|numberOfServices
condition|)
block|{
comment|// This means that the manager is currently healthy. N.B. If other threads call isHealthy
comment|// they are not guaranteed to get 'true', because any service could fail right now.
name|enqueueHealthyEvent
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|TERMINATED
argument_list|)
operator|+
name|states
operator|.
name|count
argument_list|(
name|FAILED
argument_list|)
operator|==
name|numberOfServices
condition|)
block|{
name|enqueueStoppedEvent
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
comment|// Run our executors outside of the lock
name|dispatchListenerEvents
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|enqueueStoppedEvent ()
name|void
name|enqueueStoppedEvent
parameter_list|()
block|{
name|listeners
operator|.
name|enqueue
argument_list|(
name|STOPPED_EVENT
argument_list|)
expr_stmt|;
block|}
DECL|method|enqueueHealthyEvent ()
name|void
name|enqueueHealthyEvent
parameter_list|()
block|{
name|listeners
operator|.
name|enqueue
argument_list|(
name|HEALTHY_EVENT
argument_list|)
expr_stmt|;
block|}
DECL|method|enqueueFailedEvent (final Service service)
name|void
name|enqueueFailedEvent
parameter_list|(
specifier|final
name|Service
name|service
parameter_list|)
block|{
name|listeners
operator|.
name|enqueue
argument_list|(
operator|new
name|ListenerCallQueue
operator|.
name|Event
argument_list|<
name|Listener
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|call
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|listener
operator|.
name|failure
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"failed({service="
operator|+
name|service
operator|+
literal|"})"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Attempts to execute all the listeners in {@link #listeners}. */
DECL|method|dispatchListenerEvents ()
name|void
name|dispatchListenerEvents
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|,
literal|"It is incorrect to execute listeners with the monitor held."
argument_list|)
expr_stmt|;
name|listeners
operator|.
name|dispatch
argument_list|()
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"monitor"
argument_list|)
DECL|method|checkHealthy ()
name|void
name|checkHealthy
parameter_list|()
block|{
if|if
condition|(
name|states
operator|.
name|count
argument_list|(
name|RUNNING
argument_list|)
operator|!=
name|numberOfServices
condition|)
block|{
name|IllegalStateException
name|exception
init|=
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected to be healthy after starting. The following services are not running: "
operator|+
name|Multimaps
operator|.
name|filterKeys
argument_list|(
name|servicesByState
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
name|RUNNING
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|servicesByState
operator|.
name|get
argument_list|(
name|State
operator|.
name|FAILED
argument_list|)
control|)
block|{
name|exception
operator|.
name|addSuppressed
argument_list|(
operator|new
name|FailedService
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
name|exception
throw|;
block|}
block|}
block|}
comment|/**    * A {@link Service} that wraps another service and times how long it takes for it to start and    * also calls the {@link ServiceManagerState#transitionService(Service, State, State)}, to record    * the state transitions.    */
DECL|class|ServiceListener
specifier|private
specifier|static
specifier|final
class|class
name|ServiceListener
extends|extends
name|Service
operator|.
name|Listener
block|{
DECL|field|service
specifier|final
name|Service
name|service
decl_stmt|;
comment|// We store the state in a weak reference to ensure that if something went wrong while
comment|// constructing the ServiceManager we don't pointlessly keep updating the state.
DECL|field|state
specifier|final
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|state
decl_stmt|;
DECL|method|ServiceListener (Service service, WeakReference<ServiceManagerState> state)
name|ServiceListener
parameter_list|(
name|Service
name|service
parameter_list|,
name|WeakReference
argument_list|<
name|ServiceManagerState
argument_list|>
name|state
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|starting ()
specifier|public
name|void
name|starting
parameter_list|()
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|NEW
argument_list|,
name|STARTING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Starting {0}."
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|running ()
specifier|public
name|void
name|running
parameter_list|()
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|STARTING
argument_list|,
name|RUNNING
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopping (State from)
specifier|public
name|void
name|stopping
parameter_list|(
name|State
name|from
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|STOPPING
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|terminated (State from)
specifier|public
name|void
name|terminated
parameter_list|(
name|State
name|from
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Service {0} has terminated. Previous state was: {1}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|service
block|,
name|from
block|}
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|TERMINATED
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|failed (State from, Throwable failure)
specifier|public
name|void
name|failed
parameter_list|(
name|State
name|from
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|ServiceManagerState
name|state
init|=
name|this
operator|.
name|state
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
comment|// Log before the transition, so that if the process exits in response to server failure,
comment|// there is a higher likelihood that the cause will be in the logs.
name|boolean
name|log
init|=
operator|!
operator|(
name|service
operator|instanceof
name|NoOpService
operator|)
decl_stmt|;
comment|/*          * We have already exposed startup exceptions to the user in the form of suppressed          * exceptions. We don't need to log those exceptions again.          */
name|log
operator|&=
name|from
operator|!=
name|State
operator|.
name|STARTING
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Service "
operator|+
name|service
operator|+
literal|" has failed in the "
operator|+
name|from
operator|+
literal|" state."
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|transitionService
argument_list|(
name|service
argument_list|,
name|from
argument_list|,
name|FAILED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A {@link Service} instance that does nothing. This is only useful as a placeholder to ensure    * that the {@link ServiceManager} functions properly even when it is managing no services.    *    *<p>The use of this class is considered an implementation detail of ServiceManager and as such    * it is excluded from {@link #servicesByState}, {@link #startupTimes}, {@link #toString} and all    * logging statements.    */
DECL|class|NoOpService
specifier|private
specifier|static
specifier|final
class|class
name|NoOpService
extends|extends
name|AbstractService
block|{
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** This is never thrown but only used for logging. */
DECL|class|EmptyServiceManagerWarning
specifier|private
specifier|static
specifier|final
class|class
name|EmptyServiceManagerWarning
extends|extends
name|Throwable
block|{}
DECL|class|FailedService
specifier|private
specifier|static
specifier|final
class|class
name|FailedService
extends|extends
name|Throwable
block|{
DECL|method|FailedService (Service service)
name|FailedService
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|super
argument_list|(
name|service
operator|.
name|toString
argument_list|()
argument_list|,
name|service
operator|.
name|failureCause
argument_list|()
argument_list|,
literal|false
comment|/* don't enable suppression */
argument_list|,
literal|false
comment|/* don't calculate a stack trace. */
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

