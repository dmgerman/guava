begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|ThreadSafe
import|;
end_import

begin_comment
comment|/**  * A rate limiter. Conceptually, a rate limiter distributes permits at a  * configurable rate. Each {@link #acquire()} blocks if necessary until a permit is  * available, and then takes it. Once acquired, permits need not be released.  *  *<p>Rate limiters are often used to restrict the rate at which some  * physical or logical resource is accessed. This is in contrast to {@link  * java.util.concurrent.Semaphore} which restricts the number of concurrent  * accesses instead of the rate (note though that concurrency and rate are closely related,  * e.g. see<a href="http://en.wikipedia.org/wiki/Little's_law">Little's Law</a>).  *  *<p>A {@code RateLimiter} is defined primarily by the rate at which permits  * are issued. Absent additional configuration, permits will be distributed at a  * fixed rate, defined in terms of permits per second. Permits will be distributed  * smoothly, with the delay between individual permits being adjusted to ensure  * that the configured rate is maintained.  *  *<p>It is possible to configure a {@code RateLimiter} to have a warmup  * period during which time the permits issued each second steadily increases until  * it hits the stable rate.  *  *<p>As an example, imagine that we have a list of tasks to execute, but we don't want to  * submit more than 2 per second:  *<pre>  {@code  *  final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is "2 permits per second"  *  void submitTasks(List<Runnable> tasks, Executor executor) {  *    for (Runnable task : tasks) {  *      rateLimiter.acquire(); // may wait  *      executor.execute(task);  *    }  *  }  *}</pre>  *  *<p>As another example, imagine that we produce a stream of data, and we want to cap it  * at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying  * a rate of 5000 permits per second:  *<pre>  {@code  *  final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second  *  void submitPacket(byte[] packet) {  *    rateLimiter.acquire(packet.length);  *    networkService.send(packet);  *  }  *}</pre>  *  *<p>It is important to note that the number of permits requested<i>never</i>  * affect the throttling of the request itself (an invocation to {@code acquire(1)}  * and an invocation to {@code acquire(1000)} will result in exactly the same throttling, if any),  * but it affects the throttling of the<i>next</i> request. I.e., if an expensive task  * arrives at an idle RateLimiter, it will be granted immediately, but it is the<i>next</i>  * request that will experience extra throttling, thus paying for the cost of the expensive  * task.  *  *<p>Note: {@code RateLimiter} does not provide fairness guarantees.  *  * @author Dimitris Andreou  * @since 13.0  */
end_comment

begin_comment
comment|// TODO(user): switch to nano precision. A natural unit of cost is "bytes", and a micro precision
end_comment

begin_comment
comment|//     would mean a maximum rate of "1MB/s", which might be small in some cases.
end_comment

begin_class
annotation|@
name|ThreadSafe
annotation|@
name|Beta
DECL|class|RateLimiter
specifier|public
specifier|abstract
class|class
name|RateLimiter
block|{
comment|/*    * How is the RateLimiter designed, and why?    *    * The primary feature of a RateLimiter is its "stable rate", the maximum rate that    * is should allow at normal conditions. This is enforced by "throttling" incoming    * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time,    * and make the calling thread wait as much.    *    * The simplest way to maintain a rate of QPS is to keep the timestamp of the last    * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example,    * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted    * earlier than 200ms after the last one, then we achieve the intended rate.    * If a request comes and the last request was granted only 100ms ago, then we wait for    * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request)    * naturally takes 3 seconds.    *    * It is important to realize that such a RateLimiter has a very superficial memory    * of the past: it only remembers the last request. What if the RateLimiter was unused for    * a long period of time, then a request arrived and was immediately granted?    * This RateLimiter would immediately forget about that past underutilization. This may    * result in either underutilization or overflow, depending on the real world consequences    * of not using the expected rate.    *    * Past underutilization could mean that excess resources are available. Then, the RateLimiter    * should speed up for a while, to take advantage of these resources. This is important    * when the rate is applied to networking (limiting bandwidth), where past underutilization    * typically translates to "almost empty buffers", which can be filled immediately.    *    * On the other hand, past underutilization could mean that "the server responsible for    * handling the request has become less ready for future requests", i.e. its caches become    * stale, and requests become more likely to trigger expensive operations (a more extreme    * case of this example is when a server has just booted, and it is mostly busy with getting    * itself up to speed).    *    * To deal with such scenarios, we add an extra dimension, that of "past underutilization",    * modeled by "storedPermits" variable. This variable is zero when there is no    * underutilization, and it can grow up to maxStoredPermits, for sufficiently large    * underutilization. So, the requested permits, by an invocation acquire(permits),    * are served from:    * - stored permits (if available)    * - fresh permits (for any remaining permits)    *    * How this works is best explained with an example:    *    * For a RateLimiter that produces 1 token per second, every second    * that goes by with the RateLimiter being unused, we increase storedPermits by 1.    * Say we leave the RateLimiter unused for 10 seconds (i.e., we expected a request at time    * X, but we are at time X + 10 seconds before a request actually arrives; this is    * also related to the point made in the last paragraph), thus storedPermits    * becomes 10.0 (assuming maxStoredPermits>= 10.0). At that point, a request of acquire(3)    * arrives. We serve this request out of storedPermits, and reduce that to 7.0 (how this is    * translated to throttling time is discussed later). Immediately after, assume that an    * acquire(10) request arriving. We serve the request partly from storedPermits,    * using all the remaining 7.0 permits, and the remaining 3.0, we serve them by fresh permits    * produced by the rate limiter.    *    * We already know how much time it takes to serve 3 fresh permits: if the rate is    * "1 token per second", then this will take 3 seconds. But what does it mean to serve 7    * stored permits? As explained above, there is no unique answer. If we are primarily    * interested to deal with underutilization, then we want stored permits to be given out    * /faster/ than fresh ones, because underutilization = free resources for the taking.    * If we are primarily interested to deal with overflow, then stored permits could    * be given out /slower/ than fresh ones. Thus, we require a (different in each case)    * function that translates storedPermits to throtting time.    *    * This role is played by storedPermitsToWaitTime(double storedPermits, double permitsToTake).    * The underlying model is a continuous function mapping storedPermits    * (from 0.0 to maxStoredPermits) onto the 1/rate (i.e. intervals) that is effective at the given    * storedPermits. "storedPermits" essentially measure unused time; we spend unused time    * buying/storing permits. Rate is "permits / time", thus "1 / rate = time / permits".    * Thus, "1/rate" (time / permits) times "permits" gives time, i.e., integrals on this    * function (which is what storedPermitsToWaitTime() computes) correspond to minimum intervals    * between subsequent requests, for the specified number of requested permits.    *    * Here is an example of storedPermitsToWaitTime:    * If storedPermits == 10.0, and we want 3 permits, we take them from storedPermits,    * reducing them to 7.0, and compute the throttling for these as a call to    * storedPermitsToWaitTime(storedPermits = 10.0, permitsToTake = 3.0), which will    * evaluate the integral of the function from 7.0 to 10.0.    *    * Using integrals guarantees that the effect of a single acquire(3) is equivalent    * to { acquire(1); acquire(1); acquire(1); }, or { acquire(2); acquire(1); }, etc,    * since the integral of the function in [7.0, 10.0] is equivalent to the sum of the    * integrals of [7.0, 8.0], [8.0, 9.0], [9.0, 10.0] (and so on), no matter    * what the function is. This guarantees that we handle correctly requests of varying weight    * (permits), /no matter/ what the actual function is - so we can tweak the latter freely.    * (The only requirement, obviously, is that we can compute its integrals).    *    * Note well that if, for this function, we chose a horizontal line, at height of exactly    * (1/QPS), then the effect of the function is non-existent: we serve storedPermits at    * exactly the same cost as fresh ones (1/QPS is the cost for each). We use this trick later.    *    * If we pick a function that goes /below/ that horizontal line, it means that we reduce    * the area of the function, thus time. Thus, the RateLimiter becomes /faster/ after a    * period of underutilization. If, on the other hand, we pick a function that    * goes /above/ that horizontal line, then it means that the area (time) is increased,    * thus storedPermits are more costly than fresh permits, thus the RateLimiter becomes    * /slower/ after a period of underutilization.    *    * Last, but not least: consider a RateLimiter with rate of 1 permit per second, currently    * completely unused, and an expensive acquire(100) request comes. It would be nonsensical    * to just wait for 100 seconds, and /then/ start the actual task. Why wait without doing    * anything? A much better approach is to /allow/ the request right away (as if it was an    * acquire(1) request instead), and postpone /subsequent/ requests as needed. In this version,    * we allow starting the task immediately, and postpone by 100 seconds future requests,    * thus we allow for work to get done in the meantime instead of waiting idly.    *    * This has important consequences: it means that the RateLimiter doesn't remember the time    * of the _last_ request, but it remembers the (expected) time of the _next_ request. This    * also enables us to tell immediately (see tryAcquire(timeout)) whether a particular    * timeout is enough to get us to the point of the next scheduling time, since we always    * maintain that. And what we mean by "an unused RateLimiter" is also defined by that    * notion: when we observe that the "expected arrival time of the next request" is actually    * in the past, then the difference (now - past) is the amount of time that the RateLimiter    * was formally unused, and it is that amount of time which we translate to storedPermits.    * (We increase storedPermits with the amount of permits that would have been produced    * in that idle time). So, if rate == 1 permit per second, and arrivals come exactly    * one second after the previous, then storedPermits is _never_ increased -- we would only    * increase it for arrivals _later_ than the expected one second.    */
comment|/**    * Creates a {@code RateLimiter} with the specified stable throughput, given as    * "permits per second" (commonly referred to as<i>QPS</i>, queries per second).    *    *<p>The returned {@code RateLimiter} ensures that on average no more than {@code    * permitsPerSecond} are issued during any given second, with sustained requests    * being smoothly spread over each second. When the incoming request rate exceeds    * {@code permitsPerSecond} the rate limiter will release one permit every {@code    * (1.0 / permitsPerSecond)} seconds. When the rate limiter is unused,    * bursts of up to {@code permitsPerSecond} permits will be allowed, with subsequent    * requests being smoothly limited at the stable rate of {@code permitsPerSecond}.    *    * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in    *        how many permits become available per second. Must be positive    */
comment|// TODO(user): "This is equivalent to
comment|//                 {@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)}".
DECL|method|create (double permitsPerSecond)
specifier|public
specifier|static
name|RateLimiter
name|create
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|)
block|{
comment|/*        * The default RateLimiter configuration can save the unused permits of up to one second.        * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps,        * and 4 threads, all calling acquire() at these moments:        *        * T0 at 0 seconds        * T1 at 1.05 seconds        * T2 at 2 seconds        * T3 at 3 seconds        *        * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds,        * and T3 would also have to sleep till 3.05 seconds.      */
return|return
name|create
argument_list|(
name|SleepingTicker
operator|.
name|SYSTEM_TICKER
argument_list|,
name|permitsPerSecond
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|create (SleepingTicker ticker, double permitsPerSecond)
specifier|static
name|RateLimiter
name|create
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|,
name|double
name|permitsPerSecond
parameter_list|)
block|{
name|RateLimiter
name|rateLimiter
init|=
operator|new
name|Bursty
argument_list|(
name|ticker
argument_list|,
literal|1.0
comment|/* maxBurstSeconds */
argument_list|)
decl_stmt|;
name|rateLimiter
operator|.
name|setRate
argument_list|(
name|permitsPerSecond
argument_list|)
expr_stmt|;
return|return
name|rateLimiter
return|;
block|}
comment|/**    * Creates a {@code RateLimiter} with the specified stable throughput, given as    * "permits per second" (commonly referred to as<i>QPS</i>, queries per second), and a    *<i>warmup period</i>, during which the {@code RateLimiter} smoothly ramps up its rate,    * until it reaches its maximum rate at the end of the period (as long as there are enough    * requests to saturate it). Similarly, if the {@code RateLimiter} is left<i>unused</i> for    * a duration of {@code warmupPeriod}, it will gradually return to its "cold" state,    * i.e. it will go through the same warming up process as when it was first created.    *    *<p>The returned {@code RateLimiter} is intended for cases where the resource that actually    * fulfills the requests (e.g., a remote server) needs "warmup" time, rather than    * being immediately accessed at the stable (maximum) rate.    *    *<p>The returned {@code RateLimiter} starts in a "cold" state (i.e. the warmup period    * will follow), and if it is left unused for long enough, it will return to that state.    *    * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in    *        how many permits become available per second. Must be positive    * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its    *        rate, before reaching its stable (maximum) rate    * @param unit the time unit of the warmupPeriod argument    */
DECL|method|create (double permitsPerSecond, long warmupPeriod, TimeUnit unit)
specifier|public
specifier|static
name|RateLimiter
name|create
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|,
name|long
name|warmupPeriod
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|SleepingTicker
operator|.
name|SYSTEM_TICKER
argument_list|,
name|permitsPerSecond
argument_list|,
name|warmupPeriod
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|create ( SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit)
specifier|static
name|RateLimiter
name|create
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|,
name|double
name|permitsPerSecond
parameter_list|,
name|long
name|warmupPeriod
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|RateLimiter
name|rateLimiter
init|=
operator|new
name|WarmingUp
argument_list|(
name|ticker
argument_list|,
name|warmupPeriod
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|rateLimiter
operator|.
name|setRate
argument_list|(
name|permitsPerSecond
argument_list|)
expr_stmt|;
return|return
name|rateLimiter
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|createWithCapacity ( SleepingTicker ticker, double permitsPerSecond, long maxBurstBuildup, TimeUnit unit)
specifier|static
name|RateLimiter
name|createWithCapacity
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|,
name|double
name|permitsPerSecond
parameter_list|,
name|long
name|maxBurstBuildup
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|double
name|maxBurstSeconds
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|maxBurstBuildup
argument_list|)
operator|/
literal|1E
operator|+
literal|9
decl_stmt|;
name|Bursty
name|rateLimiter
init|=
operator|new
name|Bursty
argument_list|(
name|ticker
argument_list|,
name|maxBurstSeconds
argument_list|)
decl_stmt|;
name|rateLimiter
operator|.
name|setRate
argument_list|(
name|permitsPerSecond
argument_list|)
expr_stmt|;
return|return
name|rateLimiter
return|;
block|}
comment|/**    * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate    * object to facilitate testing.    */
DECL|field|ticker
specifier|private
specifier|final
name|SleepingTicker
name|ticker
decl_stmt|;
comment|/**    * The timestamp when the RateLimiter was created; used to avoid possible overflow/time-wrapping    * errors.    */
DECL|field|offsetNanos
specifier|private
specifier|final
name|long
name|offsetNanos
decl_stmt|;
comment|/**    * The currently stored permits.    */
DECL|field|storedPermits
name|double
name|storedPermits
decl_stmt|;
comment|/**    * The maximum number of stored permits.    */
DECL|field|maxPermits
name|double
name|maxPermits
decl_stmt|;
comment|/**    * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits    * per second has a stable interval of 200ms.    */
DECL|field|stableIntervalMicros
specifier|volatile
name|double
name|stableIntervalMicros
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * The time when the next request (no matter its size) will be granted. After granting a request,    * this is pushed further in the future. Large requests push this further than small requests.    */
DECL|field|nextFreeTicketMicros
specifier|private
name|long
name|nextFreeTicketMicros
init|=
literal|0L
decl_stmt|;
comment|// could be either in the past or future
DECL|method|RateLimiter (SleepingTicker ticker)
specifier|private
name|RateLimiter
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|)
block|{
name|this
operator|.
name|ticker
operator|=
name|ticker
expr_stmt|;
name|this
operator|.
name|offsetNanos
operator|=
name|ticker
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the stable rate of this {@code RateLimiter}, that is, the    * {@code permitsPerSecond} argument provided in the factory method that    * constructed the {@code RateLimiter}. Currently throttled threads will<b>not</b>    * be awakened as a result of this invocation, thus they do not observe the new rate;    * only subsequent requests will.    *    *<p>Note though that, since each request repays (by waiting, if necessary) the cost    * of the<i>previous</i> request, this means that the very next request    * after an invocation to {@code setRate} will not be affected by the new rate;    * it will pay the cost of the previous request, which is in terms of the previous rate.    *    *<p>The behavior of the {@code RateLimiter} is not modified in any other way,    * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,    * it still has a warmup period of 20 seconds after this method invocation.    *    * @param permitsPerSecond the new stable rate of this {@code RateLimiter}. Must be positive    */
DECL|method|setRate (double permitsPerSecond)
specifier|public
specifier|final
name|void
name|setRate
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|permitsPerSecond
operator|>
literal|0.0
operator|&&
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|permitsPerSecond
argument_list|)
argument_list|,
literal|"rate must be positive"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|resync
argument_list|(
name|readSafeMicros
argument_list|()
argument_list|)
expr_stmt|;
name|double
name|stableIntervalMicros
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMicros
argument_list|(
literal|1L
argument_list|)
operator|/
name|permitsPerSecond
decl_stmt|;
name|this
operator|.
name|stableIntervalMicros
operator|=
name|stableIntervalMicros
expr_stmt|;
name|doSetRate
argument_list|(
name|permitsPerSecond
argument_list|,
name|stableIntervalMicros
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doSetRate (double permitsPerSecond, double stableIntervalMicros)
specifier|abstract
name|void
name|doSetRate
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|,
name|double
name|stableIntervalMicros
parameter_list|)
function_decl|;
comment|/**    * Returns the stable rate (as {@code permits per seconds}) with which this    * {@code RateLimiter} is configured with. The initial value of this is the same as    * the {@code permitsPerSecond} argument passed in the factory method that produced    * this {@code RateLimiter}, and it is only updated after invocations    * to {@linkplain #setRate}.    */
DECL|method|getRate ()
specifier|public
specifier|final
name|double
name|getRate
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMicros
argument_list|(
literal|1L
argument_list|)
operator|/
name|stableIntervalMicros
return|;
block|}
comment|/**    * Acquires a single permit from this {@code RateLimiter}, blocking until the    * request can be granted. Tells the amount of time slept, if any.    *    *<p>This method is equivalent to {@code acquire(1)}.    *    * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited    * @since 16.0 (present in 13.0 with {@code void} return type})    */
DECL|method|acquire ()
specifier|public
name|double
name|acquire
parameter_list|()
block|{
return|return
name|acquire
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**    * Acquires the given number of permits from this {@code RateLimiter}, blocking until the    * request can be granted. Tells the amount of time slept, if any.    *    * @param permits the number of permits to acquire    * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited    * @since 16.0 (present in 13.0 with {@code void} return type})    */
DECL|method|acquire (int permits)
specifier|public
name|double
name|acquire
parameter_list|(
name|int
name|permits
parameter_list|)
block|{
name|long
name|microsToWait
init|=
name|reserve
argument_list|(
name|permits
argument_list|)
decl_stmt|;
name|ticker
operator|.
name|sleepMicrosUninterruptibly
argument_list|(
name|microsToWait
argument_list|)
expr_stmt|;
return|return
literal|1.0
operator|*
name|microsToWait
operator|/
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMicros
argument_list|(
literal|1L
argument_list|)
return|;
block|}
comment|/**    * Reserves a single permit from this {@code RateLimiter} for future use, returning the number of    * microseconds until the reservation.    *    *<p>This method is equivalent to {@code reserve(1)}.    *    * @return time in microseconds to wait until the resource can be acquired.    */
DECL|method|reserve ()
name|long
name|reserve
parameter_list|()
block|{
return|return
name|reserve
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**    * Reserves the given number of permits from this {@code RateLimiter} for future use, returning    * the number of microseconds until the reservation can be consumed.    *    * @return time in microseconds to wait until the resource can be acquired.    */
DECL|method|reserve (int permits)
name|long
name|reserve
parameter_list|(
name|int
name|permits
parameter_list|)
block|{
name|checkPermits
argument_list|(
name|permits
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|reserveNextTicket
argument_list|(
name|permits
argument_list|,
name|readSafeMicros
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Acquires a permit from this {@code RateLimiter} if it can be obtained    * without exceeding the specified {@code timeout}, or returns {@code false}    * immediately (without waiting) if the permit would not have been granted    * before the timeout expired.    *    *<p>This method is equivalent to {@code tryAcquire(1, timeout, unit)}.    *    * @param timeout the maximum time to wait for the permit    * @param unit the time unit of the timeout argument    * @return {@code true} if the permit was acquired, {@code false} otherwise    */
DECL|method|tryAcquire (long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryAcquire
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|tryAcquire
argument_list|(
literal|1
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay.    *    *<p>    * This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}.    *    * @param permits the number of permits to acquire    * @return {@code true} if the permits were acquired, {@code false} otherwise    * @since 14.0    */
DECL|method|tryAcquire (int permits)
specifier|public
name|boolean
name|tryAcquire
parameter_list|(
name|int
name|permits
parameter_list|)
block|{
return|return
name|tryAcquire
argument_list|(
name|permits
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MICROSECONDS
argument_list|)
return|;
block|}
comment|/**    * Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without    * delay.    *    *<p>    * This method is equivalent to {@code tryAcquire(1)}.    *    * @return {@code true} if the permit was acquired, {@code false} otherwise    * @since 14.0    */
DECL|method|tryAcquire ()
specifier|public
name|boolean
name|tryAcquire
parameter_list|()
block|{
return|return
name|tryAcquire
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MICROSECONDS
argument_list|)
return|;
block|}
comment|/**    * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained    * without exceeding the specified {@code timeout}, or returns {@code false}    * immediately (without waiting) if the permits would not have been granted    * before the timeout expired.    *    * @param permits the number of permits to acquire    * @param timeout the maximum time to wait for the permits    * @param unit the time unit of the timeout argument    * @return {@code true} if the permits were acquired, {@code false} otherwise    */
DECL|method|tryAcquire (int permits, long timeout, TimeUnit unit)
specifier|public
name|boolean
name|tryAcquire
parameter_list|(
name|int
name|permits
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|long
name|timeoutMicros
init|=
name|unit
operator|.
name|toMicros
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|checkPermits
argument_list|(
name|permits
argument_list|)
expr_stmt|;
name|long
name|microsToWait
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|long
name|nowMicros
init|=
name|readSafeMicros
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextFreeTicketMicros
operator|>
name|nowMicros
operator|+
name|timeoutMicros
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|microsToWait
operator|=
name|reserveNextTicket
argument_list|(
name|permits
argument_list|,
name|nowMicros
argument_list|)
expr_stmt|;
block|}
block|}
name|ticker
operator|.
name|sleepMicrosUninterruptibly
argument_list|(
name|microsToWait
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|checkPermits (int permits)
specifier|private
specifier|static
name|void
name|checkPermits
parameter_list|(
name|int
name|permits
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|permits
operator|>
literal|0
argument_list|,
literal|"Requested permits must be positive"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reserves next ticket and returns the wait time that the caller must wait for.    *    *<p>The return value is guaranteed to be non-negative.    */
DECL|method|reserveNextTicket (double requiredPermits, long nowMicros)
specifier|private
name|long
name|reserveNextTicket
parameter_list|(
name|double
name|requiredPermits
parameter_list|,
name|long
name|nowMicros
parameter_list|)
block|{
name|resync
argument_list|(
name|nowMicros
argument_list|)
expr_stmt|;
name|long
name|microsToNextFreeTicket
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|nextFreeTicketMicros
operator|-
name|nowMicros
argument_list|)
decl_stmt|;
name|double
name|storedPermitsToSpend
init|=
name|Math
operator|.
name|min
argument_list|(
name|requiredPermits
argument_list|,
name|this
operator|.
name|storedPermits
argument_list|)
decl_stmt|;
name|double
name|freshPermits
init|=
name|requiredPermits
operator|-
name|storedPermitsToSpend
decl_stmt|;
name|long
name|waitMicros
init|=
name|storedPermitsToWaitTime
argument_list|(
name|this
operator|.
name|storedPermits
argument_list|,
name|storedPermitsToSpend
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|freshPermits
operator|*
name|stableIntervalMicros
argument_list|)
decl_stmt|;
name|this
operator|.
name|nextFreeTicketMicros
operator|=
name|nextFreeTicketMicros
operator|+
name|waitMicros
expr_stmt|;
name|this
operator|.
name|storedPermits
operator|-=
name|storedPermitsToSpend
expr_stmt|;
return|return
name|microsToNextFreeTicket
return|;
block|}
comment|/**    * Translates a specified portion of our currently stored permits which we want to    * spend/acquire, into a throttling time. Conceptually, this evaluates the integral    * of the underlying function we use, for the range of    * [(storedPermits - permitsToTake), storedPermits].    *    * This always holds: {@code 0<= permitsToTake<= storedPermits}    */
DECL|method|storedPermitsToWaitTime (double storedPermits, double permitsToTake)
specifier|abstract
name|long
name|storedPermitsToWaitTime
parameter_list|(
name|double
name|storedPermits
parameter_list|,
name|double
name|permitsToTake
parameter_list|)
function_decl|;
DECL|method|resync (long nowMicros)
specifier|private
name|void
name|resync
parameter_list|(
name|long
name|nowMicros
parameter_list|)
block|{
comment|// if nextFreeTicket is in the past, resync to now
if|if
condition|(
name|nowMicros
operator|>
name|nextFreeTicketMicros
condition|)
block|{
name|storedPermits
operator|=
name|Math
operator|.
name|min
argument_list|(
name|maxPermits
argument_list|,
name|storedPermits
operator|+
operator|(
name|nowMicros
operator|-
name|nextFreeTicketMicros
operator|)
operator|/
name|stableIntervalMicros
argument_list|)
expr_stmt|;
name|nextFreeTicketMicros
operator|=
name|nowMicros
expr_stmt|;
block|}
block|}
DECL|method|readSafeMicros ()
specifier|private
name|long
name|readSafeMicros
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMicros
argument_list|(
name|ticker
operator|.
name|read
argument_list|()
operator|-
name|offsetNanos
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"RateLimiter[stableRate=%3.1fqps]"
argument_list|,
literal|1000000.0
operator|/
name|stableIntervalMicros
argument_list|)
return|;
block|}
comment|/**    * This implements the following function:    *    *          ^ throttling    *          |    * 3*stable +                  /    * interval |                 /.    *  (cold)  |                / .    *          |               /  .<-- "warmup period" is the area of the trapezoid between    * 2*stable +              /   .       halfPermits and maxPermits    * interval |             /    .    *          |            /     .    *          |           /      .    *   stable +----------/  WARM . }    * interval |          .   UP  . }<-- this rectangle (from 0 to maxPermits, and    *          |          . PERIOD. }     height == stableInterval) defines the cooldown period,    *          |          .       . }     and we want cooldownPeriod == warmupPeriod    *          |---------------------------------> storedPermits    *              (halfPermits) (maxPermits)    *    * Before going into the details of this particular function, let's keep in mind the basics:    * 1) The state of the RateLimiter (storedPermits) is a vertical line in this figure.    * 2) When the RateLimiter is not used, this goes right (up to maxPermits)    * 3) When the RateLimiter is used, this goes left (down to zero), since if we have storedPermits,    *    we serve from those first    * 4) When _unused_, we go right at the same speed (rate)! I.e., if our rate is    *    2 permits per second, and 3 unused seconds pass, we will always save 6 permits    *    (no matter what our initial position was), up to maxPermits.    *    If we invert the rate, we get the "stableInterval" (interval between two requests    *    in a perfectly spaced out sequence of requests of the given rate). Thus, if you    *    want to see "how much time it will take to go from X storedPermits to X+K storedPermits?",    *    the answer is always stableInterval * K. In the same example, for 2 permits per second,    *    stableInterval is 500ms. Thus to go from X storedPermits to X+6 storedPermits, we    *    require 6 * 500ms = 3 seconds.    *    *    In short, the time it takes to move to the right (save K permits) is equal to the    *    rectangle of width == K and height == stableInterval.    * 4) When _used_, the time it takes, as explained in the introductory class note, is    *    equal to the integral of our function, between X permits and X-K permits, assuming    *    we want to spend K saved permits.    *    *    In summary, the time it takes to move to the left (spend K permits), is equal to the    *    area of the function of width == K.    *    * Let's dive into this function now:    *    * When we have storedPermits<= halfPermits (the left portion of the function), then    * we spend them at the exact same rate that    * fresh permits would be generated anyway (that rate is 1/stableInterval). We size    * this area to be equal to _half_ the specified warmup period. Why we need this?    * And why half? We'll explain shortly below (after explaining the second part).    *    * Stored permits that are beyond halfPermits, are mapped to an ascending line, that goes    * from stableInterval to 3 * stableInterval. The average height for that part is    * 2 * stableInterval, and is sized appropriately to have an area _equal_ to the    * specified warmup period. Thus, by point (4) above, it takes "warmupPeriod" amount of time    * to go from maxPermits to halfPermits.    *    * BUT, by point (3) above, it only takes "warmupPeriod / 2" amount of time to return back    * to maxPermits, from halfPermits! (Because the trapezoid has double the area of the rectangle    * of height stableInterval and equivalent width). We decided that the "cooldown period"    * time should be equivalent to "warmup period", thus a fully saturated RateLimiter    * (with zero stored permits, serving only fresh ones) can go to a fully unsaturated    * (with storedPermits == maxPermits) in the same amount of time it takes for a fully    * unsaturated RateLimiter to return to the stableInterval -- which happens in halfPermits,    * since beyond that point, we use a horizontal line of "stableInterval" height, simulating    * the regular rate.    *    * Thus, we have figured all dimensions of this shape, to give all the desired    * properties:    * - the width is warmupPeriod / stableInterval, to make cooldownPeriod == warmupPeriod    * - the slope starts at the middle, and goes from stableInterval to 3*stableInterval so    *   to have halfPermits being spend in double the usual time (half the rate), while their    *   respective rate is steadily ramping up    */
DECL|class|WarmingUp
specifier|private
specifier|static
class|class
name|WarmingUp
extends|extends
name|RateLimiter
block|{
DECL|field|warmupPeriodMicros
specifier|final
name|long
name|warmupPeriodMicros
decl_stmt|;
comment|/**      * The slope of the line from the stable interval (when permits == 0), to the cold interval      * (when permits == maxPermits)      */
DECL|field|slope
specifier|private
name|double
name|slope
decl_stmt|;
DECL|field|halfPermits
specifier|private
name|double
name|halfPermits
decl_stmt|;
DECL|method|WarmingUp (SleepingTicker ticker, long warmupPeriod, TimeUnit timeUnit)
name|WarmingUp
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|,
name|long
name|warmupPeriod
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
name|this
operator|.
name|warmupPeriodMicros
operator|=
name|timeUnit
operator|.
name|toMicros
argument_list|(
name|warmupPeriod
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doSetRate (double permitsPerSecond, double stableIntervalMicros)
name|void
name|doSetRate
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|,
name|double
name|stableIntervalMicros
parameter_list|)
block|{
name|double
name|oldMaxPermits
init|=
name|maxPermits
decl_stmt|;
name|maxPermits
operator|=
name|warmupPeriodMicros
operator|/
name|stableIntervalMicros
expr_stmt|;
name|halfPermits
operator|=
name|maxPermits
operator|/
literal|2.0
expr_stmt|;
comment|// Stable interval is x, cold is 3x, so on average it's 2x. Double the time -> halve the rate
name|double
name|coldIntervalMicros
init|=
name|stableIntervalMicros
operator|*
literal|3.0
decl_stmt|;
name|slope
operator|=
operator|(
name|coldIntervalMicros
operator|-
name|stableIntervalMicros
operator|)
operator|/
name|halfPermits
expr_stmt|;
if|if
condition|(
name|oldMaxPermits
operator|==
name|Double
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
comment|// if we don't special-case this, we would get storedPermits == NaN, below
name|storedPermits
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|storedPermits
operator|=
operator|(
name|oldMaxPermits
operator|==
literal|0.0
operator|)
condition|?
name|maxPermits
comment|// initial state is cold
else|:
name|storedPermits
operator|*
name|maxPermits
operator|/
name|oldMaxPermits
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|storedPermitsToWaitTime (double storedPermits, double permitsToTake)
name|long
name|storedPermitsToWaitTime
parameter_list|(
name|double
name|storedPermits
parameter_list|,
name|double
name|permitsToTake
parameter_list|)
block|{
name|double
name|availablePermitsAboveHalf
init|=
name|storedPermits
operator|-
name|halfPermits
decl_stmt|;
name|long
name|micros
init|=
literal|0
decl_stmt|;
comment|// measuring the integral on the right part of the function (the climbing line)
if|if
condition|(
name|availablePermitsAboveHalf
operator|>
literal|0.0
condition|)
block|{
name|double
name|permitsAboveHalfToTake
init|=
name|Math
operator|.
name|min
argument_list|(
name|availablePermitsAboveHalf
argument_list|,
name|permitsToTake
argument_list|)
decl_stmt|;
name|micros
operator|=
call|(
name|long
call|)
argument_list|(
name|permitsAboveHalfToTake
operator|*
operator|(
name|permitsToTime
argument_list|(
name|availablePermitsAboveHalf
argument_list|)
operator|+
name|permitsToTime
argument_list|(
name|availablePermitsAboveHalf
operator|-
name|permitsAboveHalfToTake
argument_list|)
operator|)
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|permitsToTake
operator|-=
name|permitsAboveHalfToTake
expr_stmt|;
block|}
comment|// measuring the integral on the left part of the function (the horizontal line)
name|micros
operator|+=
operator|(
name|stableIntervalMicros
operator|*
name|permitsToTake
operator|)
expr_stmt|;
return|return
name|micros
return|;
block|}
DECL|method|permitsToTime (double permits)
specifier|private
name|double
name|permitsToTime
parameter_list|(
name|double
name|permits
parameter_list|)
block|{
return|return
name|stableIntervalMicros
operator|+
name|permits
operator|*
name|slope
return|;
block|}
block|}
comment|/**    * This implements a "bursty" RateLimiter, where storedPermits are translated to    * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is    * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this    * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.    */
DECL|class|Bursty
specifier|private
specifier|static
class|class
name|Bursty
extends|extends
name|RateLimiter
block|{
comment|/** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */
DECL|field|maxBurstSeconds
specifier|final
name|double
name|maxBurstSeconds
decl_stmt|;
DECL|method|Bursty (SleepingTicker ticker, double maxBurstSeconds)
name|Bursty
parameter_list|(
name|SleepingTicker
name|ticker
parameter_list|,
name|double
name|maxBurstSeconds
parameter_list|)
block|{
name|super
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBurstSeconds
operator|=
name|maxBurstSeconds
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doSetRate (double permitsPerSecond, double stableIntervalMicros)
name|void
name|doSetRate
parameter_list|(
name|double
name|permitsPerSecond
parameter_list|,
name|double
name|stableIntervalMicros
parameter_list|)
block|{
name|double
name|oldMaxPermits
init|=
name|this
operator|.
name|maxPermits
decl_stmt|;
name|maxPermits
operator|=
name|maxBurstSeconds
operator|*
name|permitsPerSecond
expr_stmt|;
name|storedPermits
operator|=
operator|(
name|oldMaxPermits
operator|==
literal|0.0
operator|)
condition|?
literal|0.0
comment|// initial state
else|:
name|storedPermits
operator|*
name|maxPermits
operator|/
name|oldMaxPermits
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|storedPermitsToWaitTime (double storedPermits, double permitsToTake)
name|long
name|storedPermitsToWaitTime
parameter_list|(
name|double
name|storedPermits
parameter_list|,
name|double
name|permitsToTake
parameter_list|)
block|{
return|return
literal|0L
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|class|SleepingTicker
specifier|static
specifier|abstract
class|class
name|SleepingTicker
extends|extends
name|Ticker
block|{
DECL|method|sleepMicrosUninterruptibly (long micros)
specifier|abstract
name|void
name|sleepMicrosUninterruptibly
parameter_list|(
name|long
name|micros
parameter_list|)
function_decl|;
DECL|field|SYSTEM_TICKER
specifier|static
specifier|final
name|SleepingTicker
name|SYSTEM_TICKER
init|=
operator|new
name|SleepingTicker
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|read
parameter_list|()
block|{
return|return
name|systemTicker
argument_list|()
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sleepMicrosUninterruptibly
parameter_list|(
name|long
name|micros
parameter_list|)
block|{
if|if
condition|(
name|micros
operator|>
literal|0
condition|)
block|{
name|Uninterruptibles
operator|.
name|sleepUninterruptibly
argument_list|(
name|micros
argument_list|,
name|TimeUnit
operator|.
name|MICROSECONDS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
block|}
block|}
end_class

end_unit

