begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.net
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|net
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
operator|.
name|ascii
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
operator|.
name|javaIsoControl
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ascii
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
operator|.
name|MapJoiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimaps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|Immutable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|LazyInit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|IllegalCharsetNameException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Represents an<a href="http://en.wikipedia.org/wiki/Internet_media_type">Internet Media Type</a>  * (also known as a MIME Type or Content Type). This class also supports the concept of media ranges  *<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">defined by HTTP/1.1</a>.  * As such, the {@code *} character is treated as a wildcard and is used to represent any acceptable  * type or subtype value. A media type may not have wildcard type with a declared subtype. The  * {@code *} character has no special meaning as part of a parameter. All values for type, subtype,  * parameter attributes or parameter values must be valid according to RFCs<a  * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and<a  * href="http://www.ietf.org/rfc/rfc2046.txt">2046</a>.  *  *<p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)  * are normalized to lowercase. The value of the {@code charset} parameter is normalized to  * lowercase, but all others are left as-is.  *  *<p>Note that this specifically does<strong>not</strong> represent the value of the MIME {@code  * Content-Type} header and as such has no support for header-specific considerations such as line  * folding and comments.  *  *<p>For media types that take a charset the predefined constants default to UTF-8 and have a  * "_UTF_8" suffix. To get a version without a character set, use {@link #withoutParameters}.  *  * @since 12.0  * @author Gregory Kick  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
annotation|@
name|Immutable
DECL|class|MediaType
specifier|public
specifier|final
class|class
name|MediaType
block|{
DECL|field|CHARSET_ATTRIBUTE
specifier|private
specifier|static
specifier|final
name|String
name|CHARSET_ATTRIBUTE
init|=
literal|"charset"
decl_stmt|;
DECL|field|UTF_8_CONSTANT_PARAMETERS
specifier|private
specifier|static
specifier|final
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|UTF_8_CONSTANT_PARAMETERS
init|=
name|ImmutableListMultimap
operator|.
name|of
argument_list|(
name|CHARSET_ATTRIBUTE
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Matcher for type, subtype and attributes. */
DECL|field|TOKEN_MATCHER
specifier|private
specifier|static
specifier|final
name|CharMatcher
name|TOKEN_MATCHER
init|=
name|ascii
argument_list|()
operator|.
name|and
argument_list|(
name|javaIsoControl
argument_list|()
operator|.
name|negate
argument_list|()
argument_list|)
operator|.
name|and
argument_list|(
name|CharMatcher
operator|.
name|isNot
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|and
argument_list|(
name|CharMatcher
operator|.
name|noneOf
argument_list|(
literal|"()<>@,;:\\\"/[]?="
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|QUOTED_TEXT_MATCHER
specifier|private
specifier|static
specifier|final
name|CharMatcher
name|QUOTED_TEXT_MATCHER
init|=
name|ascii
argument_list|()
operator|.
name|and
argument_list|(
name|CharMatcher
operator|.
name|noneOf
argument_list|(
literal|"\"\\\r"
argument_list|)
argument_list|)
decl_stmt|;
comment|/*    * This matches the same characters as linear-white-space from RFC 822, but we make no effort to    * enforce any particular rules with regards to line folding as stated in the class docs.    */
DECL|field|LINEAR_WHITE_SPACE
specifier|private
specifier|static
specifier|final
name|CharMatcher
name|LINEAR_WHITE_SPACE
init|=
name|CharMatcher
operator|.
name|anyOf
argument_list|(
literal|" \t\r\n"
argument_list|)
decl_stmt|;
comment|// TODO(gak): make these public?
DECL|field|APPLICATION_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|APPLICATION_TYPE
init|=
literal|"application"
decl_stmt|;
DECL|field|AUDIO_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|AUDIO_TYPE
init|=
literal|"audio"
decl_stmt|;
DECL|field|IMAGE_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|IMAGE_TYPE
init|=
literal|"image"
decl_stmt|;
DECL|field|TEXT_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|TEXT_TYPE
init|=
literal|"text"
decl_stmt|;
DECL|field|VIDEO_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|VIDEO_TYPE
init|=
literal|"video"
decl_stmt|;
DECL|field|WILDCARD
specifier|private
specifier|static
specifier|final
name|String
name|WILDCARD
init|=
literal|"*"
decl_stmt|;
DECL|field|KNOWN_TYPES
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|MediaType
argument_list|,
name|MediaType
argument_list|>
name|KNOWN_TYPES
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
DECL|method|createConstant (String type, String subtype)
specifier|private
specifier|static
name|MediaType
name|createConstant
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|subtype
parameter_list|)
block|{
name|MediaType
name|mediaType
init|=
name|addKnownType
argument_list|(
operator|new
name|MediaType
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|ImmutableListMultimap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|of
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|mediaType
operator|.
name|parsedCharset
operator|=
name|Optional
operator|.
name|absent
argument_list|()
expr_stmt|;
return|return
name|mediaType
return|;
block|}
DECL|method|createConstantUtf8 (String type, String subtype)
specifier|private
specifier|static
name|MediaType
name|createConstantUtf8
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|subtype
parameter_list|)
block|{
name|MediaType
name|mediaType
init|=
name|addKnownType
argument_list|(
operator|new
name|MediaType
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|UTF_8_CONSTANT_PARAMETERS
argument_list|)
argument_list|)
decl_stmt|;
name|mediaType
operator|.
name|parsedCharset
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|UTF_8
argument_list|)
expr_stmt|;
return|return
name|mediaType
return|;
block|}
DECL|method|addKnownType (MediaType mediaType)
specifier|private
specifier|static
name|MediaType
name|addKnownType
parameter_list|(
name|MediaType
name|mediaType
parameter_list|)
block|{
name|KNOWN_TYPES
operator|.
name|put
argument_list|(
name|mediaType
argument_list|,
name|mediaType
argument_list|)
expr_stmt|;
return|return
name|mediaType
return|;
block|}
comment|/*    * The following constants are grouped by their type and ordered alphabetically by the constant    * name within that type. The constant name should be a sensible identifier that is closest to the    * "common name" of the media. This is often, but not necessarily the same as the subtype.    *    * Be sure to declare all constants with the type and subtype in all lowercase. For types that    * take a charset (e.g. all text/* types), default to UTF-8 and suffix the constant name with    * "_UTF_8".    */
DECL|field|ANY_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_TYPE
init|=
name|createConstant
argument_list|(
name|WILDCARD
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
DECL|field|ANY_TEXT_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_TEXT_TYPE
init|=
name|createConstant
argument_list|(
name|TEXT_TYPE
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
DECL|field|ANY_IMAGE_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_IMAGE_TYPE
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
DECL|field|ANY_AUDIO_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_AUDIO_TYPE
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
DECL|field|ANY_VIDEO_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_VIDEO_TYPE
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
DECL|field|ANY_APPLICATION_TYPE
specifier|public
specifier|static
specifier|final
name|MediaType
name|ANY_APPLICATION_TYPE
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
name|WILDCARD
argument_list|)
decl_stmt|;
comment|/* text types */
DECL|field|CACHE_MANIFEST_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|CACHE_MANIFEST_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"cache-manifest"
argument_list|)
decl_stmt|;
DECL|field|CSS_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|CSS_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"css"
argument_list|)
decl_stmt|;
DECL|field|CSV_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|CSV_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"csv"
argument_list|)
decl_stmt|;
DECL|field|HTML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|HTML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"html"
argument_list|)
decl_stmt|;
DECL|field|I_CALENDAR_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|I_CALENDAR_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"calendar"
argument_list|)
decl_stmt|;
DECL|field|PLAIN_TEXT_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|PLAIN_TEXT_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"plain"
argument_list|)
decl_stmt|;
comment|/**    *<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares {@link    * #JAVASCRIPT_UTF_8 application/javascript} to be the correct media type for JavaScript, but this    * may be necessary in certain situations for compatibility.    */
DECL|field|TEXT_JAVASCRIPT_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|TEXT_JAVASCRIPT_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"javascript"
argument_list|)
decl_stmt|;
comment|/**    *<a href="http://www.iana.org/assignments/media-types/text/tab-separated-values">Tab separated    * values</a>.    *    * @since 15.0    */
DECL|field|TSV_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|TSV_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"tab-separated-values"
argument_list|)
decl_stmt|;
DECL|field|VCARD_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|VCARD_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"vcard"
argument_list|)
decl_stmt|;
DECL|field|WML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|WML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"vnd.wap.wml"
argument_list|)
decl_stmt|;
comment|/**    * As described in<a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a>, this constant    * ({@code text/xml}) is used for XML documents that are "readable by casual users." {@link    * #APPLICATION_XML_UTF_8} is provided for documents that are intended for applications.    */
DECL|field|XML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|XML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"xml"
argument_list|)
decl_stmt|;
comment|/**    * As described in<a href="https://w3c.github.io/webvtt/#iana-text-vtt">the VTT spec</a>, this is    * used for Web Video Text Tracks (WebVTT) files, used with the HTML5 track element.    *    * @since 20.0    */
DECL|field|VTT_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|VTT_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|TEXT_TYPE
argument_list|,
literal|"vtt"
argument_list|)
decl_stmt|;
comment|/* image types */
DECL|field|BMP
specifier|public
specifier|static
specifier|final
name|MediaType
name|BMP
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"bmp"
argument_list|)
decl_stmt|;
comment|/**    * The media type for the<a href="http://en.wikipedia.org/wiki/Camera_Image_File_Format">Canon    * Image File Format</a> ({@code crw} files), a widely-used "raw image" format for cameras. It is    * found in {@code /etc/mime.types}, e.g. in<a href=    * "http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD"    *>Debian 3.48-1</a>.    *    * @since 15.0    */
DECL|field|CRW
specifier|public
specifier|static
specifier|final
name|MediaType
name|CRW
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"x-canon-crw"
argument_list|)
decl_stmt|;
DECL|field|GIF
specifier|public
specifier|static
specifier|final
name|MediaType
name|GIF
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"gif"
argument_list|)
decl_stmt|;
DECL|field|ICO
specifier|public
specifier|static
specifier|final
name|MediaType
name|ICO
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"vnd.microsoft.icon"
argument_list|)
decl_stmt|;
DECL|field|JPEG
specifier|public
specifier|static
specifier|final
name|MediaType
name|JPEG
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"jpeg"
argument_list|)
decl_stmt|;
DECL|field|PNG
specifier|public
specifier|static
specifier|final
name|MediaType
name|PNG
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"png"
argument_list|)
decl_stmt|;
comment|/**    * The media type for the Photoshop File Format ({@code psd} files) as defined by<a    * href="http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop">IANA</a>, and    * found in {@code /etc/mime.types}, e.g.<a    * href="http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types"></a> of the    * Apache<a href="http://httpd.apache.org/">HTTPD project</a>; for the specification, see<a    * href="http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/PhotoshopFileFormats.htm">    * Adobe Photoshop Document Format</a> and<a    * href="http://en.wikipedia.org/wiki/Adobe_Photoshop#File_format">Wikipedia</a>; this is the    * regular output/input of Photoshop (which can also export to various image formats; note that    * files with extension "PSB" are in a distinct but related format).    *    *<p>This is a more recent replacement for the older, experimental type {@code x-photoshop}:<a    * href="http://tools.ietf.org/html/rfc2046#section-6">RFC-2046.6</a>.    *    * @since 15.0    */
DECL|field|PSD
specifier|public
specifier|static
specifier|final
name|MediaType
name|PSD
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"vnd.adobe.photoshop"
argument_list|)
decl_stmt|;
DECL|field|SVG_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|SVG_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"svg+xml"
argument_list|)
decl_stmt|;
DECL|field|TIFF
specifier|public
specifier|static
specifier|final
name|MediaType
name|TIFF
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"tiff"
argument_list|)
decl_stmt|;
DECL|field|WEBP
specifier|public
specifier|static
specifier|final
name|MediaType
name|WEBP
init|=
name|createConstant
argument_list|(
name|IMAGE_TYPE
argument_list|,
literal|"webp"
argument_list|)
decl_stmt|;
comment|/* audio types */
DECL|field|MP4_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|MP4_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"mp4"
argument_list|)
decl_stmt|;
DECL|field|MPEG_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|MPEG_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"mpeg"
argument_list|)
decl_stmt|;
DECL|field|OGG_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|OGG_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"ogg"
argument_list|)
decl_stmt|;
DECL|field|WEBM_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|WEBM_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"webm"
argument_list|)
decl_stmt|;
comment|/**    * Media type for L16 audio, as defined by<a href="https://tools.ietf.org/html/rfc2586">RFC    * 2586</a>.    *    * @since 24.1    */
DECL|field|L16_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|L16_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"l16"
argument_list|)
decl_stmt|;
comment|/**    * Media type for L24 audio, as defined by<a href="https://tools.ietf.org/html/rfc3190">RFC    * 3190</a>.    *    * @since 20.0    */
DECL|field|L24_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|L24_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"l24"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Basic Audio, as defined by<a    * href="http://tools.ietf.org/html/rfc2046#section-4.3">RFC 2046</a>.    *    * @since 20.0    */
DECL|field|BASIC_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|BASIC_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"basic"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Advanced Audio Coding. For more information, see<a    * href="https://en.wikipedia.org/wiki/Advanced_Audio_Coding">Advanced Audio Coding</a>.    *    * @since 20.0    */
DECL|field|AAC_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|AAC_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"aac"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Vorbis Audio, as defined by<a href="http://tools.ietf.org/html/rfc5215">RFC    * 5215</a>.    *    * @since 20.0    */
DECL|field|VORBIS_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|VORBIS_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"vorbis"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Windows Media Audio. For more information, see<a    * href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx">file    * name extensions for Windows Media metafiles</a>.    *    * @since 20.0    */
DECL|field|WMA_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|WMA_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"x-ms-wma"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Windows Media metafiles. For more information, see<a    * href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx">file    * name extensions for Windows Media metafiles</a>.    *    * @since 20.0    */
DECL|field|WAX_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|WAX_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"x-ms-wax"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Real Audio. For more information, see<a    * href="http://service.real.com/help/faq/rp8/configrp8win.html">this link</a>.    *    * @since 20.0    */
DECL|field|VND_REAL_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|VND_REAL_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"vnd.rn-realaudio"
argument_list|)
decl_stmt|;
comment|/**    * Media type for WAVE format, as defined by<a href="https://tools.ietf.org/html/rfc2361">RFC    * 2361</a>.    *    * @since 20.0    */
DECL|field|VND_WAVE_AUDIO
specifier|public
specifier|static
specifier|final
name|MediaType
name|VND_WAVE_AUDIO
init|=
name|createConstant
argument_list|(
name|AUDIO_TYPE
argument_list|,
literal|"vnd.wave"
argument_list|)
decl_stmt|;
comment|/* video types */
DECL|field|MP4_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|MP4_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"mp4"
argument_list|)
decl_stmt|;
DECL|field|MPEG_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|MPEG_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"mpeg"
argument_list|)
decl_stmt|;
DECL|field|OGG_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|OGG_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"ogg"
argument_list|)
decl_stmt|;
DECL|field|QUICKTIME
specifier|public
specifier|static
specifier|final
name|MediaType
name|QUICKTIME
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"quicktime"
argument_list|)
decl_stmt|;
DECL|field|WEBM_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|WEBM_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"webm"
argument_list|)
decl_stmt|;
DECL|field|WMV
specifier|public
specifier|static
specifier|final
name|MediaType
name|WMV
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"x-ms-wmv"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Flash video. For more information, see<a href=    * "http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html"    *>this link</a>.    *    * @since 20.0    */
DECL|field|FLV_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|FLV_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"x-flv"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the 3GP multimedia container format. For more information, see<a    * href="ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10">3GPP TS    * 26.244</a>.    *    * @since 20.0    */
DECL|field|THREE_GPP_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|THREE_GPP_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"3gpp"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the 3G2 multimedia container format. For more information, see<a    * href="http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16">3GPP2    * C.S0050-B</a>.    *    * @since 20.0    */
DECL|field|THREE_GPP2_VIDEO
specifier|public
specifier|static
specifier|final
name|MediaType
name|THREE_GPP2_VIDEO
init|=
name|createConstant
argument_list|(
name|VIDEO_TYPE
argument_list|,
literal|"3gpp2"
argument_list|)
decl_stmt|;
comment|/* application types */
comment|/**    * As described in<a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a>, this constant    * ({@code application/xml}) is used for XML documents that are "unreadable by casual users."    * {@link #XML_UTF_8} is provided for documents that may be read by users.    */
DECL|field|APPLICATION_XML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|APPLICATION_XML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"xml"
argument_list|)
decl_stmt|;
DECL|field|ATOM_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|ATOM_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"atom+xml"
argument_list|)
decl_stmt|;
DECL|field|BZIP2
specifier|public
specifier|static
specifier|final
name|MediaType
name|BZIP2
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-bzip2"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="https://www.dartlang.org/articles/embedding-in-html/">dart files</a>.    *    * @since 19.0    */
DECL|field|DART_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|DART_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"dart"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="https://goo.gl/2QoMvg">Apple Passbook</a>.    *    * @since 19.0    */
DECL|field|APPLE_PASSBOOK
specifier|public
specifier|static
specifier|final
name|MediaType
name|APPLE_PASSBOOK
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.apple.pkpass"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="http://en.wikipedia.org/wiki/Embedded_OpenType">Embedded OpenType</a>    * fonts. This is<a    * href="http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject">registered    *</a> with the IANA.    *    * @since 17.0    */
DECL|field|EOT
specifier|public
specifier|static
specifier|final
name|MediaType
name|EOT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.ms-fontobject"
argument_list|)
decl_stmt|;
comment|/**    * As described in the<a href="http://idpf.org/epub">International Digital Publishing Forum</a>    * EPUB is the distribution and interchange format standard for digital publications and    * documents. This media type is defined in the<a    * href="http://www.idpf.org/epub/30/spec/epub30-ocf.html">EPUB Open Container Format</a>    * specification.    *    * @since 15.0    */
DECL|field|EPUB
specifier|public
specifier|static
specifier|final
name|MediaType
name|EPUB
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"epub+zip"
argument_list|)
decl_stmt|;
DECL|field|FORM_DATA
specifier|public
specifier|static
specifier|final
name|MediaType
name|FORM_DATA
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-www-form-urlencoded"
argument_list|)
decl_stmt|;
comment|/**    * As described in<a href="https://www.rsa.com/rsalabs/node.asp?id=2138">PKCS #12: Personal    * Information Exchange Syntax Standard</a>, PKCS #12 defines an archive file format for storing    * many cryptography objects as a single file.    *    * @since 15.0    */
DECL|field|KEY_ARCHIVE
specifier|public
specifier|static
specifier|final
name|MediaType
name|KEY_ARCHIVE
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"pkcs12"
argument_list|)
decl_stmt|;
comment|/**    * This is a non-standard media type, but is commonly used in serving hosted binary files as it is    *<a href="http://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors">    * known not to trigger content sniffing in current browsers</a>. It<i>should not</i> be used in    * other situations as it is not specified by any RFC and does not appear in the<a    * href="http://www.iana.org/assignments/media-types">/IANA MIME Media Types</a> list. Consider    * {@link #OCTET_STREAM} for binary data that is not being served to a browser.    *    * @since 14.0    */
DECL|field|APPLICATION_BINARY
specifier|public
specifier|static
specifier|final
name|MediaType
name|APPLICATION_BINARY
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"binary"
argument_list|)
decl_stmt|;
DECL|field|GZIP
specifier|public
specifier|static
specifier|final
name|MediaType
name|GZIP
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-gzip"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the<a href="https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3">JSON    * Hypertext Application Language (HAL) documents</a>.    *    * @since 26.0    */
DECL|field|HAL_JSON
specifier|public
specifier|static
specifier|final
name|MediaType
name|HAL_JSON
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"hal+json"
argument_list|)
decl_stmt|;
comment|/**    *<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares this to be the    * correct media type for JavaScript, but {@link #TEXT_JAVASCRIPT_UTF_8 text/javascript} may be    * necessary in certain situations for compatibility.    */
DECL|field|JAVASCRIPT_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|JAVASCRIPT_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"javascript"
argument_list|)
decl_stmt|;
DECL|field|JSON_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|JSON_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"json"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the<a href="http://www.w3.org/TR/appmanifest/">Manifest for a web    * application</a>.    *    * @since 19.0    */
DECL|field|MANIFEST_JSON_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|MANIFEST_JSON_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"manifest+json"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="http://www.opengeospatial.org/standards/kml/">OGC KML (Keyhole Markup    * Language)</a>.    */
DECL|field|KML
specifier|public
specifier|static
specifier|final
name|MediaType
name|KML
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.google-earth.kml+xml"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="http://www.opengeospatial.org/standards/kml/">OGC KML (Keyhole Markup    * Language)</a>, compressed using the ZIP format into KMZ archives.    */
DECL|field|KMZ
specifier|public
specifier|static
specifier|final
name|MediaType
name|KMZ
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.google-earth.kmz"
argument_list|)
decl_stmt|;
comment|/** Media type for the<a href="https://tools.ietf.org/html/rfc4155">mbox database format</a>. */
DECL|field|MBOX
specifier|public
specifier|static
specifier|final
name|MediaType
name|MBOX
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"mbox"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="http://goo.gl/1pGBFm">Apple over-the-air mobile configuration    * profiles</a>.    *    * @since 18.0    */
DECL|field|APPLE_MOBILE_CONFIG
specifier|public
specifier|static
specifier|final
name|MediaType
name|APPLE_MOBILE_CONFIG
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-apple-aspen-config"
argument_list|)
decl_stmt|;
comment|/** Media type for<a href="http://goo.gl/XDQ1h2">Microsoft Excel</a> spreadsheets. */
DECL|field|MICROSOFT_EXCEL
specifier|public
specifier|static
specifier|final
name|MediaType
name|MICROSOFT_EXCEL
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.ms-excel"
argument_list|)
decl_stmt|;
comment|/**    * Media type for<a href="http://goo.gl/XrTEqG">Microsoft Outlook</a> items.    *    * @since NEXT    */
DECL|field|MICROSOFT_OUTLOOK
specifier|public
specifier|static
specifier|final
name|MediaType
name|MICROSOFT_OUTLOOK
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.ms-outlook"
argument_list|)
decl_stmt|;
comment|/** Media type for<a href="http://goo.gl/XDQ1h2">Microsoft Powerpoint</a> presentations. */
DECL|field|MICROSOFT_POWERPOINT
specifier|public
specifier|static
specifier|final
name|MediaType
name|MICROSOFT_POWERPOINT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.ms-powerpoint"
argument_list|)
decl_stmt|;
comment|/** Media type for<a href="http://goo.gl/XDQ1h2">Microsoft Word</a> documents. */
DECL|field|MICROSOFT_WORD
specifier|public
specifier|static
specifier|final
name|MediaType
name|MICROSOFT_WORD
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"msword"
argument_list|)
decl_stmt|;
comment|/**    * Media type for WASM applications. For more information see<a    * href="https://webassembly.org/">the Web Assembly overview</a>.    *    * @since 27.0    */
DECL|field|WASM_APPLICATION
specifier|public
specifier|static
specifier|final
name|MediaType
name|WASM_APPLICATION
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"wasm"
argument_list|)
decl_stmt|;
comment|/**    * Media type for NaCl applications. For more information see<a    * href="https://developer.chrome.com/native-client/devguide/coding/application-structure">the    * Developer Guide for Native Client Application Structure</a>.    *    * @since 20.0    */
DECL|field|NACL_APPLICATION
specifier|public
specifier|static
specifier|final
name|MediaType
name|NACL_APPLICATION
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-nacl"
argument_list|)
decl_stmt|;
comment|/**    * Media type for NaCl portable applications. For more information see<a    * href="https://developer.chrome.com/native-client/devguide/coding/application-structure">the    * Developer Guide for Native Client Application Structure</a>.    *    * @since 20.0    */
DECL|field|NACL_PORTABLE_APPLICATION
specifier|public
specifier|static
specifier|final
name|MediaType
name|NACL_PORTABLE_APPLICATION
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-pnacl"
argument_list|)
decl_stmt|;
DECL|field|OCTET_STREAM
specifier|public
specifier|static
specifier|final
name|MediaType
name|OCTET_STREAM
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"octet-stream"
argument_list|)
decl_stmt|;
DECL|field|OGG_CONTAINER
specifier|public
specifier|static
specifier|final
name|MediaType
name|OGG_CONTAINER
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"ogg"
argument_list|)
decl_stmt|;
DECL|field|OOXML_DOCUMENT
specifier|public
specifier|static
specifier|final
name|MediaType
name|OOXML_DOCUMENT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.openxmlformats-officedocument.wordprocessingml.document"
argument_list|)
decl_stmt|;
DECL|field|OOXML_PRESENTATION
specifier|public
specifier|static
specifier|final
name|MediaType
name|OOXML_PRESENTATION
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.openxmlformats-officedocument.presentationml.presentation"
argument_list|)
decl_stmt|;
DECL|field|OOXML_SHEET
specifier|public
specifier|static
specifier|final
name|MediaType
name|OOXML_SHEET
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.openxmlformats-officedocument.spreadsheetml.sheet"
argument_list|)
decl_stmt|;
DECL|field|OPENDOCUMENT_GRAPHICS
specifier|public
specifier|static
specifier|final
name|MediaType
name|OPENDOCUMENT_GRAPHICS
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.oasis.opendocument.graphics"
argument_list|)
decl_stmt|;
DECL|field|OPENDOCUMENT_PRESENTATION
specifier|public
specifier|static
specifier|final
name|MediaType
name|OPENDOCUMENT_PRESENTATION
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.oasis.opendocument.presentation"
argument_list|)
decl_stmt|;
DECL|field|OPENDOCUMENT_SPREADSHEET
specifier|public
specifier|static
specifier|final
name|MediaType
name|OPENDOCUMENT_SPREADSHEET
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.oasis.opendocument.spreadsheet"
argument_list|)
decl_stmt|;
DECL|field|OPENDOCUMENT_TEXT
specifier|public
specifier|static
specifier|final
name|MediaType
name|OPENDOCUMENT_TEXT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.oasis.opendocument.text"
argument_list|)
decl_stmt|;
DECL|field|PDF
specifier|public
specifier|static
specifier|final
name|MediaType
name|PDF
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"pdf"
argument_list|)
decl_stmt|;
DECL|field|POSTSCRIPT
specifier|public
specifier|static
specifier|final
name|MediaType
name|POSTSCRIPT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"postscript"
argument_list|)
decl_stmt|;
comment|/**    *<a href="http://tools.ietf.org/html/draft-rfernando-protocol-buffers-00">Protocol buffers</a>    *    * @since 15.0    */
DECL|field|PROTOBUF
specifier|public
specifier|static
specifier|final
name|MediaType
name|PROTOBUF
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"protobuf"
argument_list|)
decl_stmt|;
DECL|field|RDF_XML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|RDF_XML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"rdf+xml"
argument_list|)
decl_stmt|;
DECL|field|RTF_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|RTF_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"rtf"
argument_list|)
decl_stmt|;
comment|/**    * Media type for SFNT fonts (which includes<a    * href="http://en.wikipedia.org/wiki/TrueType/">TrueType</a> and<a    * href="http://en.wikipedia.org/wiki/OpenType/">OpenType</a> fonts). This is<a    * href="http://www.iana.org/assignments/media-types/application/font-sfnt">registered</a> with    * the IANA.    *    * @since 17.0    */
DECL|field|SFNT
specifier|public
specifier|static
specifier|final
name|MediaType
name|SFNT
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"font-sfnt"
argument_list|)
decl_stmt|;
DECL|field|SHOCKWAVE_FLASH
specifier|public
specifier|static
specifier|final
name|MediaType
name|SHOCKWAVE_FLASH
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-shockwave-flash"
argument_list|)
decl_stmt|;
DECL|field|SKETCHUP
specifier|public
specifier|static
specifier|final
name|MediaType
name|SKETCHUP
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"vnd.sketchup.skp"
argument_list|)
decl_stmt|;
comment|/**    * As described in<a href="http://www.ietf.org/rfc/rfc3902.txt">RFC 3902</a>, this constant    * ({@code application/soap+xml}) is used to identify SOAP 1.2 message envelopes that have been    * serialized with XML 1.0.    *    *<p>For SOAP 1.1 messages, see {@code XML_UTF_8} per<a    * href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/">W3C Note on Simple Object Access Protocol    * (SOAP) 1.1</a>    *    * @since 20.0    */
DECL|field|SOAP_XML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|SOAP_XML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"soap+xml"
argument_list|)
decl_stmt|;
DECL|field|TAR
specifier|public
specifier|static
specifier|final
name|MediaType
name|TAR
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"x-tar"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the<a href="http://en.wikipedia.org/wiki/Web_Open_Font_Format">Web Open Font    * Format</a> (WOFF)<a href="http://www.w3.org/TR/WOFF/">defined</a> by the W3C. This is<a    * href="http://www.iana.org/assignments/media-types/application/font-woff">registered</a> with    * the IANA.    *    * @since 17.0    */
DECL|field|WOFF
specifier|public
specifier|static
specifier|final
name|MediaType
name|WOFF
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"font-woff"
argument_list|)
decl_stmt|;
comment|/**    * Media type for the<a href="http://en.wikipedia.org/wiki/Web_Open_Font_Format">Web Open Font    * Format</a> (WOFF) version 2<a href="https://www.w3.org/TR/WOFF2/">defined</a> by the W3C.    *    * @since 20.0    */
DECL|field|WOFF2
specifier|public
specifier|static
specifier|final
name|MediaType
name|WOFF2
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"font-woff2"
argument_list|)
decl_stmt|;
DECL|field|XHTML_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|XHTML_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"xhtml+xml"
argument_list|)
decl_stmt|;
comment|/**    * Media type for Extensible Resource Descriptors. This is not yet registered with the IANA, but    * it is specified by OASIS in the<a    * href="http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html">XRD definition</a> and    * implemented in projects such as<a href="http://code.google.com/p/webfinger/">WebFinger</a>.    */
DECL|field|XRD_UTF_8
specifier|public
specifier|static
specifier|final
name|MediaType
name|XRD_UTF_8
init|=
name|createConstantUtf8
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"xrd+xml"
argument_list|)
decl_stmt|;
DECL|field|ZIP
specifier|public
specifier|static
specifier|final
name|MediaType
name|ZIP
init|=
name|createConstant
argument_list|(
name|APPLICATION_TYPE
argument_list|,
literal|"zip"
argument_list|)
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|String
name|type
decl_stmt|;
DECL|field|subtype
specifier|private
specifier|final
name|String
name|subtype
decl_stmt|;
DECL|field|parameters
specifier|private
specifier|final
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
decl_stmt|;
DECL|field|toString
annotation|@
name|LazyInit
specifier|private
name|String
name|toString
decl_stmt|;
DECL|field|hashCode
annotation|@
name|LazyInit
specifier|private
name|int
name|hashCode
decl_stmt|;
DECL|field|parsedCharset
annotation|@
name|LazyInit
specifier|private
name|Optional
argument_list|<
name|Charset
argument_list|>
name|parsedCharset
decl_stmt|;
DECL|method|MediaType (String type, String subtype, ImmutableListMultimap<String, String> parameters)
specifier|private
name|MediaType
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|subtype
parameter_list|,
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|subtype
operator|=
name|subtype
expr_stmt|;
name|this
operator|.
name|parameters
operator|=
name|parameters
expr_stmt|;
block|}
comment|/** Returns the top-level media type. For example, {@code "text"} in {@code "text/plain"}. */
DECL|method|type ()
specifier|public
name|String
name|type
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/** Returns the media subtype. For example, {@code "plain"} in {@code "text/plain"}. */
DECL|method|subtype ()
specifier|public
name|String
name|subtype
parameter_list|()
block|{
return|return
name|subtype
return|;
block|}
comment|/** Returns a multimap containing the parameters of this media type. */
DECL|method|parameters ()
specifier|public
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
parameter_list|()
block|{
return|return
name|parameters
return|;
block|}
DECL|method|parametersAsMap ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ImmutableMultiset
argument_list|<
name|String
argument_list|>
argument_list|>
name|parametersAsMap
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|parameters
operator|.
name|asMap
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|,
name|ImmutableMultiset
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ImmutableMultiset
argument_list|<
name|String
argument_list|>
name|apply
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|ImmutableMultiset
operator|.
name|copyOf
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns an optional charset for the value of the charset parameter if it is specified.    *    * @throws IllegalStateException if multiple charset values have been set for this media type    * @throws IllegalCharsetNameException if a charset value is present, but illegal    * @throws UnsupportedCharsetException if a charset value is present, but no support is available    *     in this instance of the Java virtual machine    */
DECL|method|charset ()
specifier|public
name|Optional
argument_list|<
name|Charset
argument_list|>
name|charset
parameter_list|()
block|{
comment|// racy single-check idiom, this is safe because Optional is immutable.
name|Optional
argument_list|<
name|Charset
argument_list|>
name|local
init|=
name|parsedCharset
decl_stmt|;
if|if
condition|(
name|local
operator|==
literal|null
condition|)
block|{
name|String
name|value
init|=
literal|null
decl_stmt|;
name|local
operator|=
name|Optional
operator|.
name|absent
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|currentValue
range|:
name|parameters
operator|.
name|get
argument_list|(
name|CHARSET_ATTRIBUTE
argument_list|)
control|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
name|currentValue
expr_stmt|;
name|local
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|value
operator|.
name|equals
argument_list|(
name|currentValue
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Multiple charset values defined: "
operator|+
name|value
operator|+
literal|", "
operator|+
name|currentValue
argument_list|)
throw|;
block|}
block|}
name|parsedCharset
operator|=
name|local
expr_stmt|;
block|}
return|return
name|local
return|;
block|}
comment|/**    * Returns a new instance with the same type and subtype as this instance, but without any    * parameters.    */
DECL|method|withoutParameters ()
specifier|public
name|MediaType
name|withoutParameters
parameter_list|()
block|{
return|return
name|parameters
operator|.
name|isEmpty
argument_list|()
condition|?
name|this
else|:
name|create
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|)
return|;
block|}
comment|/**    *<em>Replaces</em> all parameters with the given parameters.    *    * @throws IllegalArgumentException if any parameter or value is invalid    */
DECL|method|withParameters (Multimap<String, String> parameters)
specifier|public
name|MediaType
name|withParameters
parameter_list|(
name|Multimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|parameters
argument_list|)
return|;
block|}
comment|/**    *<em>Replaces</em> all parameters with the given attribute with parameters using the given    * values. If there are no values, any existing parameters with the given attribute are removed.    *    * @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid    * @since 24.0    */
DECL|method|withParameters (String attribute, Iterable<String> values)
specifier|public
name|MediaType
name|withParameters
parameter_list|(
name|String
name|attribute
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|values
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|String
name|normalizedAttribute
init|=
name|normalizeToken
argument_list|(
name|attribute
argument_list|)
decl_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|parameters
operator|.
name|entries
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|normalizedAttribute
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|value
range|:
name|values
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|normalizedAttribute
argument_list|,
name|normalizeParameterValue
argument_list|(
name|normalizedAttribute
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MediaType
name|mediaType
init|=
operator|new
name|MediaType
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// if the attribute isn't charset, we can just inherit the current parsedCharset
if|if
condition|(
operator|!
name|normalizedAttribute
operator|.
name|equals
argument_list|(
name|CHARSET_ATTRIBUTE
argument_list|)
condition|)
block|{
name|mediaType
operator|.
name|parsedCharset
operator|=
name|this
operator|.
name|parsedCharset
expr_stmt|;
block|}
comment|// Return one of the constants if the media type is a known type.
return|return
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|KNOWN_TYPES
operator|.
name|get
argument_list|(
name|mediaType
argument_list|)
argument_list|,
name|mediaType
argument_list|)
return|;
block|}
comment|/**    *<em>Replaces</em> all parameters with the given attribute with a single parameter with the    * given value. If multiple parameters with the same attributes are necessary use {@link    * #withParameters(String, Iterable)}. Prefer {@link #withCharset} for setting the {@code charset}    * parameter when using a {@link Charset} object.    *    * @throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid    */
DECL|method|withParameter (String attribute, String value)
specifier|public
name|MediaType
name|withParameter
parameter_list|(
name|String
name|attribute
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|withParameters
argument_list|(
name|attribute
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new instance with the same type and subtype as this instance, with the {@code    * charset} parameter set to the {@link Charset#name name} of the given charset. Only one {@code    * charset} parameter will be present on the new instance regardless of the number set on this    * one.    *    *<p>If a charset must be specified that is not supported on this JVM (and thus is not    * representable as a {@link Charset} instance, use {@link #withParameter}.    */
DECL|method|withCharset (Charset charset)
specifier|public
name|MediaType
name|withCharset
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|charset
argument_list|)
expr_stmt|;
name|MediaType
name|withCharset
init|=
name|withParameter
argument_list|(
name|CHARSET_ATTRIBUTE
argument_list|,
name|charset
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
comment|// precache the charset so we don't need to parse it
name|withCharset
operator|.
name|parsedCharset
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|charset
argument_list|)
expr_stmt|;
return|return
name|withCharset
return|;
block|}
comment|/** Returns true if either the type or subtype is the wildcard. */
DECL|method|hasWildcard ()
specifier|public
name|boolean
name|hasWildcard
parameter_list|()
block|{
return|return
name|WILDCARD
operator|.
name|equals
argument_list|(
name|type
argument_list|)
operator|||
name|WILDCARD
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if this instance falls within the range (as defined by<a    * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">the HTTP Accept header</a>) given    * by the argument according to three criteria:    *    *<ol>    *<li>The type of the argument is the wildcard or equal to the type of this instance.    *<li>The subtype of the argument is the wildcard or equal to the subtype of this instance.    *<li>All of the parameters present in the argument are present in this instance.    *</ol>    *    *<p>For example:    *    *<pre>{@code    * PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true    * PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false    * PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true    * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true    * PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false    * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true    * PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false    * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false    * }</pre>    *    *<p>Note that while it is possible to have the same parameter declared multiple times within a    * media type this method does not consider the number of occurrences of a parameter. For example,    * {@code "text/plain; charset=UTF-8"} satisfies {@code "text/plain; charset=UTF-8;    * charset=UTF-8"}.    */
DECL|method|is (MediaType mediaTypeRange)
specifier|public
name|boolean
name|is
parameter_list|(
name|MediaType
name|mediaTypeRange
parameter_list|)
block|{
return|return
operator|(
name|mediaTypeRange
operator|.
name|type
operator|.
name|equals
argument_list|(
name|WILDCARD
argument_list|)
operator|||
name|mediaTypeRange
operator|.
name|type
operator|.
name|equals
argument_list|(
name|this
operator|.
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|mediaTypeRange
operator|.
name|subtype
operator|.
name|equals
argument_list|(
name|WILDCARD
argument_list|)
operator|||
name|mediaTypeRange
operator|.
name|subtype
operator|.
name|equals
argument_list|(
name|this
operator|.
name|subtype
argument_list|)
operator|)
operator|&&
name|this
operator|.
name|parameters
operator|.
name|entries
argument_list|()
operator|.
name|containsAll
argument_list|(
name|mediaTypeRange
operator|.
name|parameters
operator|.
name|entries
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new media type with the given type and subtype.    *    * @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the    *     type, but not the subtype.    */
DECL|method|create (String type, String subtype)
specifier|public
specifier|static
name|MediaType
name|create
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|subtype
parameter_list|)
block|{
name|MediaType
name|mediaType
init|=
name|create
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|ImmutableListMultimap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|mediaType
operator|.
name|parsedCharset
operator|=
name|Optional
operator|.
name|absent
argument_list|()
expr_stmt|;
return|return
name|mediaType
return|;
block|}
DECL|method|create ( String type, String subtype, Multimap<String, String> parameters)
specifier|private
specifier|static
name|MediaType
name|create
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|subtype
parameter_list|,
name|Multimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|String
name|normalizedType
init|=
name|normalizeToken
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|String
name|normalizedSubtype
init|=
name|normalizeToken
argument_list|(
name|subtype
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
operator|!
name|WILDCARD
operator|.
name|equals
argument_list|(
name|normalizedType
argument_list|)
operator|||
name|WILDCARD
operator|.
name|equals
argument_list|(
name|normalizedSubtype
argument_list|)
argument_list|,
literal|"A wildcard type cannot be used with a non-wildcard subtype"
argument_list|)
expr_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|parameters
operator|.
name|entries
argument_list|()
control|)
block|{
name|String
name|attribute
init|=
name|normalizeToken
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|attribute
argument_list|,
name|normalizeParameterValue
argument_list|(
name|attribute
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MediaType
name|mediaType
init|=
operator|new
name|MediaType
argument_list|(
name|normalizedType
argument_list|,
name|normalizedSubtype
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Return one of the constants if the media type is a known type.
return|return
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|KNOWN_TYPES
operator|.
name|get
argument_list|(
name|mediaType
argument_list|)
argument_list|,
name|mediaType
argument_list|)
return|;
block|}
comment|/**    * Creates a media type with the "application" type and the given subtype.    *    * @throws IllegalArgumentException if subtype is invalid    */
DECL|method|createApplicationType (String subtype)
specifier|static
name|MediaType
name|createApplicationType
parameter_list|(
name|String
name|subtype
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|APPLICATION_TYPE
argument_list|,
name|subtype
argument_list|)
return|;
block|}
comment|/**    * Creates a media type with the "audio" type and the given subtype.    *    * @throws IllegalArgumentException if subtype is invalid    */
DECL|method|createAudioType (String subtype)
specifier|static
name|MediaType
name|createAudioType
parameter_list|(
name|String
name|subtype
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|AUDIO_TYPE
argument_list|,
name|subtype
argument_list|)
return|;
block|}
comment|/**    * Creates a media type with the "image" type and the given subtype.    *    * @throws IllegalArgumentException if subtype is invalid    */
DECL|method|createImageType (String subtype)
specifier|static
name|MediaType
name|createImageType
parameter_list|(
name|String
name|subtype
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|IMAGE_TYPE
argument_list|,
name|subtype
argument_list|)
return|;
block|}
comment|/**    * Creates a media type with the "text" type and the given subtype.    *    * @throws IllegalArgumentException if subtype is invalid    */
DECL|method|createTextType (String subtype)
specifier|static
name|MediaType
name|createTextType
parameter_list|(
name|String
name|subtype
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|TEXT_TYPE
argument_list|,
name|subtype
argument_list|)
return|;
block|}
comment|/**    * Creates a media type with the "video" type and the given subtype.    *    * @throws IllegalArgumentException if subtype is invalid    */
DECL|method|createVideoType (String subtype)
specifier|static
name|MediaType
name|createVideoType
parameter_list|(
name|String
name|subtype
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|VIDEO_TYPE
argument_list|,
name|subtype
argument_list|)
return|;
block|}
DECL|method|normalizeToken (String token)
specifier|private
specifier|static
name|String
name|normalizeToken
parameter_list|(
name|String
name|token
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|TOKEN_MATCHER
operator|.
name|matchesAllOf
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|token
argument_list|)
return|;
block|}
DECL|method|normalizeParameterValue (String attribute, String value)
specifier|private
specifier|static
name|String
name|normalizeParameterValue
parameter_list|(
name|String
name|attribute
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|CHARSET_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attribute
argument_list|)
condition|?
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|value
argument_list|)
else|:
name|value
return|;
block|}
comment|/**    * Parses a media type from its string representation.    *    * @throws IllegalArgumentException if the input is not parsable    */
DECL|method|parse (String input)
specifier|public
specifier|static
name|MediaType
name|parse
parameter_list|(
name|String
name|input
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|Tokenizer
name|tokenizer
init|=
operator|new
name|Tokenizer
argument_list|(
name|input
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|type
init|=
name|tokenizer
operator|.
name|consumeToken
argument_list|(
name|TOKEN_MATCHER
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|String
name|subtype
init|=
name|tokenizer
operator|.
name|consumeToken
argument_list|(
name|TOKEN_MATCHER
argument_list|)
decl_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parameters
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMore
argument_list|()
condition|)
block|{
name|tokenizer
operator|.
name|consumeTokenIfPresent
argument_list|(
name|LINEAR_WHITE_SPACE
argument_list|)
expr_stmt|;
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|tokenizer
operator|.
name|consumeTokenIfPresent
argument_list|(
name|LINEAR_WHITE_SPACE
argument_list|)
expr_stmt|;
name|String
name|attribute
init|=
name|tokenizer
operator|.
name|consumeToken
argument_list|(
name|TOKEN_MATCHER
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
specifier|final
name|String
name|value
decl_stmt|;
if|if
condition|(
literal|'"'
operator|==
name|tokenizer
operator|.
name|previewChar
argument_list|()
condition|)
block|{
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|StringBuilder
name|valueBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|'"'
operator|!=
name|tokenizer
operator|.
name|previewChar
argument_list|()
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|==
name|tokenizer
operator|.
name|previewChar
argument_list|()
condition|)
block|{
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|valueBuilder
operator|.
name|append
argument_list|(
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
name|ascii
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valueBuilder
operator|.
name|append
argument_list|(
name|tokenizer
operator|.
name|consumeToken
argument_list|(
name|QUOTED_TEXT_MATCHER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|value
operator|=
name|valueBuilder
operator|.
name|toString
argument_list|()
expr_stmt|;
name|tokenizer
operator|.
name|consumeCharacter
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|tokenizer
operator|.
name|consumeToken
argument_list|(
name|TOKEN_MATCHER
argument_list|)
expr_stmt|;
block|}
name|parameters
operator|.
name|put
argument_list|(
name|attribute
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|create
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|parameters
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Could not parse '"
operator|+
name|input
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|class|Tokenizer
specifier|private
specifier|static
specifier|final
class|class
name|Tokenizer
block|{
DECL|field|input
specifier|final
name|String
name|input
decl_stmt|;
DECL|field|position
name|int
name|position
init|=
literal|0
decl_stmt|;
DECL|method|Tokenizer (String input)
name|Tokenizer
parameter_list|(
name|String
name|input
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
block|}
DECL|method|consumeTokenIfPresent (CharMatcher matcher)
name|String
name|consumeTokenIfPresent
parameter_list|(
name|CharMatcher
name|matcher
parameter_list|)
block|{
name|checkState
argument_list|(
name|hasMore
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|startPosition
init|=
name|position
decl_stmt|;
name|position
operator|=
name|matcher
operator|.
name|negate
argument_list|()
operator|.
name|indexIn
argument_list|(
name|input
argument_list|,
name|startPosition
argument_list|)
expr_stmt|;
return|return
name|hasMore
argument_list|()
condition|?
name|input
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|,
name|position
argument_list|)
else|:
name|input
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|)
return|;
block|}
DECL|method|consumeToken (CharMatcher matcher)
name|String
name|consumeToken
parameter_list|(
name|CharMatcher
name|matcher
parameter_list|)
block|{
name|int
name|startPosition
init|=
name|position
decl_stmt|;
name|String
name|token
init|=
name|consumeTokenIfPresent
argument_list|(
name|matcher
argument_list|)
decl_stmt|;
name|checkState
argument_list|(
name|position
operator|!=
name|startPosition
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
DECL|method|consumeCharacter (CharMatcher matcher)
name|char
name|consumeCharacter
parameter_list|(
name|CharMatcher
name|matcher
parameter_list|)
block|{
name|checkState
argument_list|(
name|hasMore
argument_list|()
argument_list|)
expr_stmt|;
name|char
name|c
init|=
name|previewChar
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|matcher
operator|.
name|matches
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|consumeCharacter (char c)
name|char
name|consumeCharacter
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|checkState
argument_list|(
name|hasMore
argument_list|()
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|previewChar
argument_list|()
operator|==
name|c
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|previewChar ()
name|char
name|previewChar
parameter_list|()
block|{
name|checkState
argument_list|(
name|hasMore
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|input
operator|.
name|charAt
argument_list|(
name|position
argument_list|)
return|;
block|}
DECL|method|hasMore ()
name|boolean
name|hasMore
parameter_list|()
block|{
return|return
operator|(
name|position
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|position
operator|<
name|input
operator|.
name|length
argument_list|()
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|MediaType
condition|)
block|{
name|MediaType
name|that
init|=
operator|(
name|MediaType
operator|)
name|obj
decl_stmt|;
return|return
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|that
operator|.
name|type
argument_list|)
operator|&&
name|this
operator|.
name|subtype
operator|.
name|equals
argument_list|(
name|that
operator|.
name|subtype
argument_list|)
comment|// compare parameters regardless of order
operator|&&
name|this
operator|.
name|parametersAsMap
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|parametersAsMap
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// racy single-check idiom
name|int
name|h
init|=
name|hashCode
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|h
operator|=
name|Objects
operator|.
name|hashCode
argument_list|(
name|type
argument_list|,
name|subtype
argument_list|,
name|parametersAsMap
argument_list|()
argument_list|)
expr_stmt|;
name|hashCode
operator|=
name|h
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
DECL|field|PARAMETER_JOINER
specifier|private
specifier|static
specifier|final
name|MapJoiner
name|PARAMETER_JOINER
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|"; "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
comment|/**    * Returns the string representation of this media type in the format described in<a    * href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// racy single-check idiom, safe because String is immutable
name|String
name|result
init|=
name|toString
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|computeToString
argument_list|()
expr_stmt|;
name|toString
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|computeToString ()
specifier|private
name|String
name|computeToString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|type
argument_list|)
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|subtype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parameters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|Multimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|quotedParameters
init|=
name|Multimaps
operator|.
name|transformValues
argument_list|(
name|parameters
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|TOKEN_MATCHER
operator|.
name|matchesAllOf
argument_list|(
name|value
argument_list|)
condition|?
name|value
else|:
name|escapeAndQuote
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|PARAMETER_JOINER
operator|.
name|appendTo
argument_list|(
name|builder
argument_list|,
name|quotedParameters
operator|.
name|entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|escapeAndQuote (String value)
specifier|private
specifier|static
name|String
name|escapeAndQuote
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|StringBuilder
name|escaped
init|=
operator|new
name|StringBuilder
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|+
literal|16
argument_list|)
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\\'
operator|||
name|ch
operator|==
literal|'"'
condition|)
block|{
name|escaped
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|escaped
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|escaped
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

