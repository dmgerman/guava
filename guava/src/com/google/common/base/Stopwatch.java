begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright 2008 Google Inc. All Rights Reserved.
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MICROSECONDS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|SECONDS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * An object that measures elapsed time in nanoseconds. Note that measurement  * overhead is typically on the order of a microsecond (1000 ns) or more.  *  *<p>This class is not thread-safe.  *  *<p> Basic usage:  *<pre>  *   Stopwatch stopwatch = new Stopwatch().{@link #start()};  *  *   long millis = stopwatch.{@link #elapsedMillis()};  *   long nanos  = stopwatch.{@link #elapsedTime}(TimeUnit.NANOSECONDS);  *      // Measurement accuracy is really only to millis, but if you want ...  *  *   String formatted = stopwatch.{@link #toString()};  // e.g. "1.234 ms" or "23.45 s"  *  *   stopwatch.{@link #stop()};  *   stopwatch.{@link #reset()}; // Resets the elapsed time to zero, stops the stopwatch.  *</pre>  *  *<p>Note that it is an error to start or stop a Stopwatch that is already  * started or stopped respectively.  *   *<p>When testing code that uses this class, use the  * {@linkplain #Stopwatch(Ticker) alternate constructor} to supply a fake or  * mock ticker, such as {@link com.google.common.testing.FakeTicker}. This  * allows you to simulate any valid behavior of the stopwatch.  *  * @author kevinb@google.com (Kevin Bourrillion)  */
end_comment

begin_class
DECL|class|Stopwatch
specifier|public
specifier|final
class|class
name|Stopwatch
block|{
DECL|field|ticker
specifier|private
specifier|final
name|Ticker
name|ticker
decl_stmt|;
DECL|field|isRunning
specifier|private
name|boolean
name|isRunning
decl_stmt|;
DECL|field|elapsedNanos
specifier|private
name|long
name|elapsedNanos
decl_stmt|;
DECL|field|startTick
specifier|private
name|long
name|startTick
decl_stmt|;
comment|/**    * Creates (but does not start) a new stopwatch using {@link System#nanoTime}    * as its time source.    */
DECL|method|Stopwatch ()
specifier|public
name|Stopwatch
parameter_list|()
block|{
name|this
argument_list|(
name|Ticker
operator|.
name|systemTicker
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates (but does not start) a new stopwatch, using the specified time    * source.    */
DECL|method|Stopwatch (Ticker ticker)
specifier|public
name|Stopwatch
parameter_list|(
name|Ticker
name|ticker
parameter_list|)
block|{
name|this
operator|.
name|ticker
operator|=
name|checkNotNull
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns {@code true} if {@link #start()} has been called on this stopwatch,    * and {@link #stop()} has not been called since the last call to {@code    * start()}.    */
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|isRunning
return|;
block|}
comment|/**    * Starts the stopwatch.    *    * @throws IllegalStateException if the stopwatch is already running.    */
DECL|method|start ()
specifier|public
name|Stopwatch
name|start
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|isRunning
argument_list|)
expr_stmt|;
name|isRunning
operator|=
literal|true
expr_stmt|;
name|startTick
operator|=
name|ticker
operator|.
name|read
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Stops the stopwatch. Future reads will return the fixed duration that had    * elapsed up to this point.    *    * @throws IllegalStateException if the stopwatch is already stopped.    */
DECL|method|stop ()
specifier|public
name|Stopwatch
name|stop
parameter_list|()
block|{
name|long
name|tick
init|=
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|isRunning
argument_list|)
expr_stmt|;
name|isRunning
operator|=
literal|false
expr_stmt|;
name|elapsedNanos
operator|+=
name|tick
operator|-
name|startTick
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Sets the elapsed time for this stopwatch to zero,    * and places it in a stopped state.    */
DECL|method|reset ()
specifier|public
name|Stopwatch
name|reset
parameter_list|()
block|{
name|elapsedNanos
operator|=
literal|0
expr_stmt|;
name|isRunning
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|elapsedNanos ()
specifier|private
name|long
name|elapsedNanos
parameter_list|()
block|{
return|return
name|isRunning
condition|?
name|ticker
operator|.
name|read
argument_list|()
operator|-
name|startTick
operator|+
name|elapsedNanos
else|:
name|elapsedNanos
return|;
block|}
comment|/**    * Returns the current elapsed time shown on this stopwatch, expressed    * in the desired time unit, with any fraction rounded down.    *    *<p>Note that the overhead of measurement can be more than a microsecond, so    * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}    * precision here.    */
DECL|method|elapsedTime (TimeUnit desiredUnit)
specifier|public
name|long
name|elapsedTime
parameter_list|(
name|TimeUnit
name|desiredUnit
parameter_list|)
block|{
return|return
name|desiredUnit
operator|.
name|convert
argument_list|(
name|elapsedNanos
argument_list|()
argument_list|,
name|NANOSECONDS
argument_list|)
return|;
block|}
comment|/**    * Returns the current elapsed time shown on this stopwatch, expressed    * in milliseconds, with any fraction rounded down. This is identical to    * {@code elapsedTime(TimeUnit.MILLISECONDS}.    */
DECL|method|elapsedMillis ()
specifier|public
name|long
name|elapsedMillis
parameter_list|()
block|{
return|return
name|elapsedTime
argument_list|(
name|MILLISECONDS
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of the current elapsed time; equivalent to    * {@code toString(4)} (four significant figures).    */
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of the current elapsed time, choosing an    * appropriate unit and using the specified number of significant figures.    * For example, at the instant when {@code elapsedTime(NANOSECONDS)} would    * return {1234567}, {@code toString(4)} returns {@code "1.235 ms"}.    */
DECL|method|toString (int significantDigits)
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|significantDigits
parameter_list|)
block|{
name|long
name|nanos
init|=
name|elapsedNanos
argument_list|()
decl_stmt|;
name|TimeUnit
name|unit
init|=
name|chooseUnit
argument_list|(
name|nanos
argument_list|)
decl_stmt|;
name|double
name|value
init|=
operator|(
name|double
operator|)
name|nanos
operator|/
name|NANOSECONDS
operator|.
name|convert
argument_list|(
literal|1
argument_list|,
name|unit
argument_list|)
decl_stmt|;
comment|// Too bad this functionality is not exposed as a regular method call
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%."
operator|+
name|significantDigits
operator|+
literal|"g %s"
argument_list|,
name|value
argument_list|,
name|abbreviate
argument_list|(
name|unit
argument_list|)
argument_list|)
return|;
block|}
DECL|method|chooseUnit (long nanos)
specifier|private
specifier|static
name|TimeUnit
name|chooseUnit
parameter_list|(
name|long
name|nanos
parameter_list|)
block|{
if|if
condition|(
name|SECONDS
operator|.
name|convert
argument_list|(
name|nanos
argument_list|,
name|NANOSECONDS
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|SECONDS
return|;
block|}
if|if
condition|(
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|nanos
argument_list|,
name|NANOSECONDS
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|MILLISECONDS
return|;
block|}
if|if
condition|(
name|MICROSECONDS
operator|.
name|convert
argument_list|(
name|nanos
argument_list|,
name|NANOSECONDS
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|MICROSECONDS
return|;
block|}
return|return
name|NANOSECONDS
return|;
block|}
DECL|method|abbreviate (TimeUnit unit)
specifier|private
specifier|static
name|String
name|abbreviate
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|NANOSECONDS
case|:
return|return
literal|"ns"
return|;
case|case
name|MICROSECONDS
case|:
return|return
literal|"\u03bcs"
return|;
comment|// Î¼s
case|case
name|MILLISECONDS
case|:
return|return
literal|"ms"
return|;
case|case
name|SECONDS
case|:
return|return
literal|"s"
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

