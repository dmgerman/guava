begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_comment
comment|/**  * Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does  * for any {@link Object}. Also offers basic text processing methods based on this function.  * Implementations are strongly encouraged to be side-effect-free and immutable.  *  *<p>Throughout the documentation of this class, the phrase "matching character" is used to mean  * "any character {@code c} for which {@code this.matches(c)} returns {@code true}".  *  *<p><b>Note:</b> This class deals only with {@code char} values; it does not understand  * supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical  * characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}  * treats these just as two separate characters.  *  *<p>Example usages:<pre>  *   String trimmed = {@link #WHITESPACE WHITESPACE}.{@link #trimFrom trimFrom}(userInput);  *   if ({@link #ASCII ASCII}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/StringsExplained#CharMatcher">  * {@code CharMatcher}</a>.  *  * @author Kevin Bourrillion  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
comment|// Possibly change from chars to code points; decide constants vs. methods
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|CharMatcher
specifier|public
specifier|abstract
class|class
name|CharMatcher
implements|implements
name|Predicate
argument_list|<
name|Character
argument_list|>
block|{
comment|// Constants
comment|/**    * Determines whether a character is a breaking whitespace (that is, a whitespace which can be    * interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a    * discussion of that term.    *    * @since 2.0    */
DECL|field|BREAKING_WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|BREAKING_WHITESPACE
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\013'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
case|case
literal|'\u0085'
case|:
case|case
literal|'\u1680'
case|:
case|case
literal|'\u2028'
case|:
case|case
literal|'\u2029'
case|:
case|case
literal|'\u205f'
case|:
case|case
literal|'\u3000'
case|:
return|return
literal|true
return|;
case|case
literal|'\u2007'
case|:
return|return
literal|false
return|;
default|default:
return|return
name|c
operator|>=
literal|'\u2000'
operator|&&
name|c
operator|<=
literal|'\u200a'
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.BREAKING_WHITESPACE"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is ASCII, meaning that its code point is less than 128.    */
DECL|field|ASCII
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ASCII
init|=
name|inRange
argument_list|(
literal|'\0'
argument_list|,
literal|'\u007f'
argument_list|,
literal|"CharMatcher.ASCII"
argument_list|)
decl_stmt|;
DECL|class|RangesMatcher
specifier|private
specifier|static
class|class
name|RangesMatcher
extends|extends
name|CharMatcher
block|{
DECL|field|rangeStarts
specifier|private
specifier|final
name|char
index|[]
name|rangeStarts
decl_stmt|;
DECL|field|rangeEnds
specifier|private
specifier|final
name|char
index|[]
name|rangeEnds
decl_stmt|;
DECL|method|RangesMatcher (String description, char[] rangeStarts, char[] rangeEnds)
name|RangesMatcher
parameter_list|(
name|String
name|description
parameter_list|,
name|char
index|[]
name|rangeStarts
parameter_list|,
name|char
index|[]
name|rangeEnds
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
name|this
operator|.
name|rangeStarts
operator|=
name|rangeStarts
expr_stmt|;
name|this
operator|.
name|rangeEnds
operator|=
name|rangeEnds
expr_stmt|;
name|checkArgument
argument_list|(
name|rangeStarts
operator|.
name|length
operator|==
name|rangeEnds
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rangeStarts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkArgument
argument_list|(
name|rangeStarts
index|[
name|i
index|]
operator|<=
name|rangeEnds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|rangeStarts
operator|.
name|length
condition|)
block|{
name|checkArgument
argument_list|(
name|rangeEnds
index|[
name|i
index|]
operator|<
name|rangeStarts
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|int
name|index
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|rangeStarts
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|index
operator|=
operator|~
name|index
operator|-
literal|1
expr_stmt|;
return|return
name|index
operator|>=
literal|0
operator|&&
name|c
operator|<=
name|rangeEnds
index|[
name|index
index|]
return|;
block|}
block|}
block|}
comment|// Must be in ascending order.
DECL|field|ZEROES
specifier|private
specifier|static
specifier|final
name|String
name|ZEROES
init|=
literal|"0\u0660\u06f0\u07c0\u0966\u09e6\u0a66\u0ae6\u0b66\u0be6"
operator|+
literal|"\u0c66\u0ce6\u0d66\u0e50\u0ed0\u0f20\u1040\u1090\u17e0\u1810\u1946\u19d0\u1b50\u1bb0"
operator|+
literal|"\u1c40\u1c50\ua620\ua8d0\ua900\uaa50\uff10"
decl_stmt|;
DECL|field|NINES
specifier|private
specifier|static
specifier|final
name|String
name|NINES
decl_stmt|;
static|static
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|ZEROES
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ZEROES
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|ZEROES
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|+
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NINES
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**    * Determines whether a character is a digit according to    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>.    * If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.    */
DECL|field|DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|DIGIT
init|=
operator|new
name|RangesMatcher
argument_list|(
literal|"CharMatcher.DIGIT"
argument_list|,
name|ZEROES
operator|.
name|toCharArray
argument_list|()
argument_list|,
name|NINES
operator|.
name|toCharArray
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Determines whether a character is a digit according to {@link Character#isDigit(char) Java's    * definition}. If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.    */
DECL|field|JAVA_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_DIGIT
init|=
operator|new
name|CharMatcher
argument_list|(
literal|"CharMatcher.JAVA_DIGIT"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is a letter according to {@link Character#isLetter(char) Java's    * definition}. If you only care to match letters of the Latin alphabet, you can use {@code    * inRange('a', 'z').or(inRange('A', 'Z'))}.    */
DECL|field|JAVA_LETTER
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER
init|=
operator|new
name|CharMatcher
argument_list|(
literal|"CharMatcher.JAVA_LETTER"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is a letter or digit according to {@link    * Character#isLetterOrDigit(char) Java's definition}.    */
DECL|field|JAVA_LETTER_OR_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER_OR_DIGIT
init|=
operator|new
name|CharMatcher
argument_list|(
literal|"CharMatcher.JAVA_LETTER_OR_DIGIT"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is upper case according to {@link Character#isUpperCase(char)    * Java's definition}.    */
DECL|field|JAVA_UPPER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_UPPER_CASE
init|=
operator|new
name|CharMatcher
argument_list|(
literal|"CharMatcher.JAVA_UPPER_CASE"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is lower case according to {@link Character#isLowerCase(char)    * Java's definition}.    */
DECL|field|JAVA_LOWER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LOWER_CASE
init|=
operator|new
name|CharMatcher
argument_list|(
literal|"CharMatcher.JAVA_LOWER_CASE"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is an ISO control character as specified by {@link    * Character#isISOControl(char)}.    */
DECL|field|JAVA_ISO_CONTROL
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_ISO_CONTROL
init|=
name|inRange
argument_list|(
literal|'\u0000'
argument_list|,
literal|'\u001f'
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u007f'
argument_list|,
literal|'\u009f'
argument_list|)
argument_list|)
operator|.
name|withToString
argument_list|(
literal|"CharMatcher.JAVA_ISO_CONTROL"
argument_list|)
decl_stmt|;
comment|/**    * Determines whether a character is invisible; that is, if its Unicode category is any of    * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and    * PRIVATE_USE according to ICU4J.    */
DECL|field|INVISIBLE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|INVISIBLE
init|=
operator|new
name|RangesMatcher
argument_list|(
literal|"CharMatcher.INVISIBLE"
argument_list|,
operator|(
literal|"\u0000\u007f\u00ad\u0600\u06dd\u070f\u1680\u180e\u2000\u2028\u205f\u206a\u3000\ud800\ufeff"
operator|+
literal|"\ufff9\ufffa"
operator|)
operator|.
name|toCharArray
argument_list|()
argument_list|,
operator|(
literal|"\u0020\u00a0\u00ad\u0604\u06dd\u070f\u1680\u180e\u200f\u202f\u2064\u206f\u3000\uf8ff\ufeff"
operator|+
literal|"\ufff9\ufffb"
operator|)
operator|.
name|toCharArray
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|showCharacter (char c)
specifier|private
specifier|static
name|String
name|showCharacter
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|String
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|char
index|[]
name|tmp
init|=
block|{
literal|'\\'
block|,
literal|'u'
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|tmp
index|[
literal|5
operator|-
name|i
index|]
operator|=
name|hex
operator|.
name|charAt
argument_list|(
name|c
operator|&
literal|0xF
argument_list|)
expr_stmt|;
name|c
operator|>>=
literal|4
expr_stmt|;
block|}
return|return
name|String
operator|.
name|copyValueOf
argument_list|(
name|tmp
argument_list|)
return|;
block|}
comment|/**    * Determines whether a character is single-width (not double-width). When in doubt, this matcher    * errs on the side of returning {@code false} (that is, it tends to assume a character is    * double-width).    *    *<p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to    * date.    */
DECL|field|SINGLE_WIDTH
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|SINGLE_WIDTH
init|=
operator|new
name|RangesMatcher
argument_list|(
literal|"CharMatcher.SINGLE_WIDTH"
argument_list|,
literal|"\u0000\u05be\u05d0\u05f3\u0600\u0750\u0e00\u1e00\u2100\ufb50\ufe70\uff61"
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|"\u04f9\u05be\u05ea\u05f4\u06ff\u077f\u0e7f\u20af\u213a\ufdff\ufeff\uffdc"
operator|.
name|toCharArray
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Matches any character. */
DECL|field|ANY
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ANY
init|=
operator|new
name|FastMatcher
argument_list|(
literal|"CharMatcher.ANY"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|==
name|length
operator|)
condition|?
operator|-
literal|1
else|:
name|start
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|char
index|[]
name|array
init|=
operator|new
name|char
index|[
name|sequence
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|array
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|array
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|StringBuilder
name|retval
init|=
operator|new
name|StringBuilder
argument_list|(
name|sequence
operator|.
name|length
argument_list|()
operator|*
name|replacement
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|String
operator|.
name|valueOf
argument_list|(
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|NONE
return|;
block|}
block|}
decl_stmt|;
comment|/** Matches no characters. */
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|NONE
init|=
operator|new
name|FastMatcher
argument_list|(
literal|"CharMatcher.NONE"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimLeadingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimTrailingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|ANY
return|;
block|}
block|}
decl_stmt|;
comment|// Static factories
comment|/**    * Returns a {@code char} matcher that matches only one specified character.    */
DECL|method|is (final char match)
specifier|public
specifier|static
name|CharMatcher
name|is
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
name|String
name|description
init|=
literal|"CharMatcher.is('"
operator|+
name|showCharacter
argument_list|(
name|match
argument_list|)
operator|+
literal|"')"
decl_stmt|;
return|return
operator|new
name|FastMatcher
argument_list|(
name|description
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|match
argument_list|,
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|this
else|:
name|NONE
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|other
else|:
name|super
operator|.
name|or
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|isNot
argument_list|(
name|match
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character except the one specified.    *    *<p>To negate another {@code CharMatcher}, use {@link #negate()}.    */
DECL|method|isNot (final char match)
specifier|public
specifier|static
name|CharMatcher
name|isNot
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
name|String
name|description
init|=
literal|"CharMatcher.isNot('"
operator|+
name|showCharacter
argument_list|(
name|match
argument_list|)
operator|+
literal|"')"
decl_stmt|;
return|return
operator|new
name|FastMatcher
argument_list|(
name|description
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|!=
name|match
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|super
operator|.
name|and
argument_list|(
name|other
argument_list|)
else|:
name|other
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|ANY
else|:
name|this
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|match
operator|+
literal|1
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|is
argument_list|(
name|match
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character present in the given character    * sequence.    */
DECL|method|anyOf (final CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|anyOf
parameter_list|(
specifier|final
name|CharSequence
name|sequence
parameter_list|)
block|{
switch|switch
condition|(
name|sequence
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|NONE
return|;
case|case
literal|1
case|:
return|return
name|is
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|isEither
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sequence
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
default|default:
comment|// continue below to handle the general case
block|}
comment|// TODO(user): is it potentially worth just going ahead and building a precomputed matcher?
specifier|final
name|char
index|[]
name|chars
init|=
name|sequence
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|chars
argument_list|)
expr_stmt|;
name|StringBuilder
name|description
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"CharMatcher.anyOf(\""
argument_list|)
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
name|description
operator|.
name|append
argument_list|(
name|showCharacter
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|description
operator|.
name|append
argument_list|(
literal|"\")"
argument_list|)
expr_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|(
name|description
operator|.
name|toString
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|chars
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
return|;
block|}
annotation|@
name|Override
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
DECL|method|isEither ( final char match1, final char match2)
specifier|private
specifier|static
name|CharMatcher
name|isEither
parameter_list|(
specifier|final
name|char
name|match1
parameter_list|,
specifier|final
name|char
name|match2
parameter_list|)
block|{
name|String
name|description
init|=
literal|"CharMatcher.anyOf(\""
operator|+
name|showCharacter
argument_list|(
name|match1
argument_list|)
operator|+
name|showCharacter
argument_list|(
name|match2
argument_list|)
operator|+
literal|"\")"
decl_stmt|;
return|return
operator|new
name|FastMatcher
argument_list|(
name|description
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match1
operator|||
name|c
operator|==
name|match2
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match1
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|match2
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character not present in the given character    * sequence.    */
DECL|method|noneOf (CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|noneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|anyOf
argument_list|(
name|sequence
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character in a given range (both endpoints are    * inclusive). For example, to match any lowercase letter of the English alphabet, use {@code    * CharMatcher.inRange('a', 'z')}.    *    * @throws IllegalArgumentException if {@code endInclusive< startInclusive}    */
DECL|method|inRange (final char startInclusive, final char endInclusive)
specifier|public
specifier|static
name|CharMatcher
name|inRange
parameter_list|(
specifier|final
name|char
name|startInclusive
parameter_list|,
specifier|final
name|char
name|endInclusive
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|endInclusive
operator|>=
name|startInclusive
argument_list|)
expr_stmt|;
name|String
name|description
init|=
literal|"CharMatcher.inRange('"
operator|+
name|showCharacter
argument_list|(
name|startInclusive
argument_list|)
operator|+
literal|"', '"
operator|+
name|showCharacter
argument_list|(
name|endInclusive
argument_list|)
operator|+
literal|"')"
decl_stmt|;
return|return
name|inRange
argument_list|(
name|startInclusive
argument_list|,
name|endInclusive
argument_list|,
name|description
argument_list|)
return|;
block|}
DECL|method|inRange (final char startInclusive, final char endInclusive, String description)
specifier|static
name|CharMatcher
name|inRange
parameter_list|(
specifier|final
name|char
name|startInclusive
parameter_list|,
specifier|final
name|char
name|endInclusive
parameter_list|,
name|String
name|description
parameter_list|)
block|{
return|return
operator|new
name|FastMatcher
argument_list|(
name|description
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|startInclusive
operator|<=
name|c
operator|&&
name|c
operator|<=
name|endInclusive
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|startInclusive
argument_list|,
name|endInclusive
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a matcher with identical behavior to the given {@link Character}-based predicate, but    * which operates on primitive {@code char} instances instead.    */
DECL|method|forPredicate (final Predicate<? super Character> predicate)
specifier|public
specifier|static
name|CharMatcher
name|forPredicate
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Character
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|predicate
operator|instanceof
name|CharMatcher
condition|)
block|{
return|return
operator|(
name|CharMatcher
operator|)
name|predicate
return|;
block|}
name|String
name|description
init|=
literal|"CharMatcher.forPredicate("
operator|+
name|predicate
operator|+
literal|")"
decl_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|(
name|description
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|checkNotNull
argument_list|(
name|character
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|// State
DECL|field|description
specifier|final
name|String
name|description
decl_stmt|;
comment|// Constructors
comment|/**    * Sets the {@code toString()} from the given description.    */
DECL|method|CharMatcher (String description)
name|CharMatcher
parameter_list|(
name|String
name|description
parameter_list|)
block|{
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
comment|/**    * Constructor for use by subclasses. When subclassing, you may want to override    * {@code toString()} to provide a useful description.    */
DECL|method|CharMatcher ()
specifier|protected
name|CharMatcher
parameter_list|()
block|{
name|description
operator|=
name|super
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|// Abstract methods
comment|/** Determines a true or false value for the given character. */
DECL|method|matches (char c)
specifier|public
specifier|abstract
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
comment|// Non-static factories
comment|/**    * Returns a matcher that matches any character not matched by this matcher.    */
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
operator|new
name|NegatedMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|class|NegatedMatcher
specifier|private
specifier|static
class|class
name|NegatedMatcher
extends|extends
name|CharMatcher
block|{
DECL|field|original
specifier|final
name|CharMatcher
name|original
decl_stmt|;
DECL|method|NegatedMatcher (String toString, CharMatcher original)
name|NegatedMatcher
parameter_list|(
name|String
name|toString
parameter_list|,
name|CharMatcher
name|original
parameter_list|)
block|{
name|super
argument_list|(
name|toString
argument_list|)
expr_stmt|;
name|this
operator|.
name|original
operator|=
name|original
expr_stmt|;
block|}
DECL|method|NegatedMatcher (CharMatcher original)
name|NegatedMatcher
parameter_list|(
name|CharMatcher
name|original
parameter_list|)
block|{
name|this
argument_list|(
name|original
operator|+
literal|".negate()"
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
DECL|method|matches (char c)
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|!
name|original
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|matchesAllOf (CharSequence sequence)
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesNoneOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
DECL|method|matchesNoneOf (CharSequence sequence)
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesAllOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
DECL|method|countIn (CharSequence sequence)
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
name|original
operator|.
name|countIn
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|BitSet
name|tmp
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|original
operator|.
name|setBits
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|flip
argument_list|(
name|Character
operator|.
name|MIN_VALUE
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|table
operator|.
name|or
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
DECL|method|negate ()
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|original
return|;
block|}
annotation|@
name|Override
DECL|method|withToString (String description)
name|CharMatcher
name|withToString
parameter_list|(
name|String
name|description
parameter_list|)
block|{
return|return
operator|new
name|NegatedMatcher
argument_list|(
name|description
argument_list|,
name|original
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a matcher that matches any character matched by both this matcher and {@code other}.    */
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|And
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
return|;
block|}
DECL|class|And
specifier|private
specifier|static
class|class
name|And
extends|extends
name|CharMatcher
block|{
DECL|field|first
specifier|final
name|CharMatcher
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|CharMatcher
name|second
decl_stmt|;
DECL|method|And (CharMatcher a, CharMatcher b)
name|And
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|)
block|{
name|this
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|"CharMatcher.and("
operator|+
name|a
operator|+
literal|", "
operator|+
name|b
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
DECL|method|And (CharMatcher a, CharMatcher b, String description)
name|And
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
name|first
operator|=
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|second
operator|=
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|first
operator|.
name|matches
argument_list|(
name|c
argument_list|)
operator|&&
name|second
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|BitSet
name|tmp1
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|first
operator|.
name|setBits
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|BitSet
name|tmp2
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|second
operator|.
name|setBits
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|.
name|and
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|table
operator|.
name|or
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|withToString (String description)
name|CharMatcher
name|withToString
parameter_list|(
name|String
name|description
parameter_list|)
block|{
return|return
operator|new
name|And
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|description
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a matcher that matches any character matched by either this matcher or {@code other}.    */
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|Or
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
return|;
block|}
DECL|class|Or
specifier|private
specifier|static
class|class
name|Or
extends|extends
name|CharMatcher
block|{
DECL|field|first
specifier|final
name|CharMatcher
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|CharMatcher
name|second
decl_stmt|;
DECL|method|Or (CharMatcher a, CharMatcher b, String description)
name|Or
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
name|first
operator|=
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|second
operator|=
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
DECL|method|Or (CharMatcher a, CharMatcher b)
name|Or
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|)
block|{
name|this
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|"CharMatcher.or("
operator|+
name|a
operator|+
literal|", "
operator|+
name|b
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|first
operator|.
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|second
operator|.
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|first
operator|.
name|matches
argument_list|(
name|c
argument_list|)
operator|||
name|second
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|withToString (String description)
name|CharMatcher
name|withToString
parameter_list|(
name|String
name|description
parameter_list|)
block|{
return|return
operator|new
name|Or
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|description
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to    * query than the original; your mileage may vary. Precomputation takes time and is likely to be    * worthwhile only if the precomputed matcher is queried many thousands of times.    *    *<p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a    * precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a    * worthwhile tradeoff in a browser.    */
DECL|method|precomputed ()
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|Platform
operator|.
name|precomputeCharMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Subclasses should provide a new CharMatcher with the same characteristics as {@code this},    * but with their {@code toString} method overridden with the new description.    *    *<p>This is unsupported by default.    */
DECL|method|withToString (String description)
name|CharMatcher
name|withToString
parameter_list|(
name|String
name|description
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|DISTINCT_CHARS
specifier|private
specifier|static
specifier|final
name|int
name|DISTINCT_CHARS
init|=
name|Character
operator|.
name|MAX_VALUE
operator|-
name|Character
operator|.
name|MIN_VALUE
operator|+
literal|1
decl_stmt|;
comment|/**    * This is the actual implementation of {@link #precomputed}, but we bounce calls through a    * method on {@link Platform} so that we can have different behavior in GWT.    *    *<p>This implementation tries to be smart in a number of ways.  It recognizes cases where    * the negation is cheaper to precompute than the matcher itself; it tries to build small    * hash tables for matchers that only match a few characters, and so on.  In the worst-case    * scenario, it constructs an eight-kilobyte bit array and queries that.    * In many situations this produces a matcher which is faster to query than the original.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
DECL|method|precomputedInternal ()
name|CharMatcher
name|precomputedInternal
parameter_list|()
block|{
specifier|final
name|BitSet
name|table
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|int
name|totalCharacters
init|=
name|table
operator|.
name|cardinality
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalCharacters
operator|*
literal|2
operator|<=
name|DISTINCT_CHARS
condition|)
block|{
return|return
name|precomputedPositive
argument_list|(
name|totalCharacters
argument_list|,
name|table
argument_list|,
name|description
argument_list|)
return|;
block|}
else|else
block|{
comment|// TODO(user): is it worth it to worry about the last character of large matchers?
name|table
operator|.
name|flip
argument_list|(
name|Character
operator|.
name|MIN_VALUE
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|negatedCharacters
init|=
name|DISTINCT_CHARS
operator|-
name|totalCharacters
decl_stmt|;
name|String
name|suffix
init|=
literal|".negate()"
decl_stmt|;
name|String
name|negatedDescription
init|=
name|description
operator|.
name|endsWith
argument_list|(
name|suffix
argument_list|)
condition|?
name|description
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|description
operator|.
name|length
argument_list|()
operator|-
name|suffix
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|description
operator|+
name|suffix
decl_stmt|;
return|return
operator|new
name|NegatedFastMatcher
argument_list|(
name|toString
argument_list|()
argument_list|,
name|precomputedPositive
argument_list|(
name|negatedCharacters
argument_list|,
name|table
argument_list|,
name|negatedDescription
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * A matcher for which precomputation will not yield any significant benefit.    */
DECL|class|FastMatcher
specifier|abstract
specifier|static
class|class
name|FastMatcher
extends|extends
name|CharMatcher
block|{
DECL|method|FastMatcher ()
name|FastMatcher
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
DECL|method|FastMatcher (String description)
name|FastMatcher
parameter_list|(
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|precomputed ()
specifier|public
specifier|final
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
operator|new
name|NegatedFastMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
DECL|class|NegatedFastMatcher
specifier|static
specifier|final
class|class
name|NegatedFastMatcher
extends|extends
name|NegatedMatcher
block|{
DECL|method|NegatedFastMatcher (CharMatcher original)
name|NegatedFastMatcher
parameter_list|(
name|CharMatcher
name|original
parameter_list|)
block|{
name|super
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
DECL|method|NegatedFastMatcher (String toString, CharMatcher original)
name|NegatedFastMatcher
parameter_list|(
name|String
name|toString
parameter_list|,
name|CharMatcher
name|original
parameter_list|)
block|{
name|super
argument_list|(
name|toString
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|precomputed ()
specifier|public
specifier|final
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|withToString (String description)
name|CharMatcher
name|withToString
parameter_list|(
name|String
name|description
parameter_list|)
block|{
return|return
operator|new
name|NegatedFastMatcher
argument_list|(
name|description
argument_list|,
name|original
argument_list|)
return|;
block|}
block|}
comment|/**    * Helper method for {@link #precomputedInternal} that doesn't test if the negation is cheaper.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
DECL|method|precomputedPositive ( int totalCharacters, BitSet table, String description)
specifier|private
specifier|static
name|CharMatcher
name|precomputedPositive
parameter_list|(
name|int
name|totalCharacters
parameter_list|,
name|BitSet
name|table
parameter_list|,
name|String
name|description
parameter_list|)
block|{
switch|switch
condition|(
name|totalCharacters
condition|)
block|{
case|case
literal|0
case|:
return|return
name|NONE
return|;
case|case
literal|1
case|:
return|return
name|is
argument_list|(
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
name|char
name|c1
init|=
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|c2
init|=
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|isEither
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
default|default:
return|return
name|isSmall
argument_list|(
name|totalCharacters
argument_list|,
name|table
operator|.
name|length
argument_list|()
argument_list|)
condition|?
name|SmallCharMatcher
operator|.
name|from
argument_list|(
name|table
argument_list|,
name|description
argument_list|)
else|:
operator|new
name|BitSetMatcher
argument_list|(
name|table
argument_list|,
name|description
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"SmallCharMatcher"
argument_list|)
DECL|method|isSmall (int totalCharacters, int tableLength)
specifier|private
specifier|static
name|boolean
name|isSmall
parameter_list|(
name|int
name|totalCharacters
parameter_list|,
name|int
name|tableLength
parameter_list|)
block|{
return|return
name|totalCharacters
operator|<=
name|SmallCharMatcher
operator|.
name|MAX_SIZE
operator|&&
name|tableLength
operator|>
operator|(
name|totalCharacters
operator|*
literal|4
operator|*
name|Character
operator|.
name|SIZE
operator|)
return|;
comment|// err on the side of BitSetMatcher
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
DECL|class|BitSetMatcher
specifier|private
specifier|static
class|class
name|BitSetMatcher
extends|extends
name|FastMatcher
block|{
DECL|field|table
specifier|private
specifier|final
name|BitSet
name|table
decl_stmt|;
DECL|method|BitSetMatcher (BitSet table, String description)
specifier|private
name|BitSetMatcher
parameter_list|(
name|BitSet
name|table
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|.
name|length
argument_list|()
operator|+
name|Long
operator|.
name|SIZE
operator|<
name|table
operator|.
name|size
argument_list|()
condition|)
block|{
name|table
operator|=
operator|(
name|BitSet
operator|)
name|table
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// If only we could actually call BitSet.trimToSize() ourselves...
block|}
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
block|}
DECL|method|matches (char c)
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|table
operator|.
name|get
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setBits (BitSet bitSet)
name|void
name|setBits
parameter_list|(
name|BitSet
name|bitSet
parameter_list|)
block|{
name|bitSet
operator|.
name|or
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets bits in {@code table} matched by this matcher.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
name|Character
operator|.
name|MAX_VALUE
init|;
name|c
operator|>=
name|Character
operator|.
name|MIN_VALUE
condition|;
name|c
operator|--
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Text processing routines
comment|/**    * Returns {@code true} if a character sequence contains at least one matching character.    * Equivalent to {@code !matchesNoneOf(sequence)}.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code true} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches at least one character in the sequence    * @since 8.0    */
DECL|method|matchesAnyOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAnyOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|!
name|matchesNoneOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if a character sequence contains only matching characters.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code false} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches every character in the sequence, including when    *         the sequence is empty    */
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns {@code true} if a character sequence contains no matching characters. Equivalent to    * {@code !matchesAnyOf(sequence)}.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code false} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches every character in the sequence, including when    *         the sequence is empty    */
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|indexIn
argument_list|(
name|sequence
argument_list|)
operator|==
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the first matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in forward order calling {@link    * #matches} for each character.    *    * @param sequence the character sequence to examine from the beginning    * @return an index, or {@code -1} if no character matches    */
DECL|method|indexIn (CharSequence sequence)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the first matching character in a character sequence, starting from a    * given position, or {@code -1} if no character matches after that position.    *    *<p>The default implementation iterates over the sequence in forward order, beginning at {@code    * start}, calling {@link #matches} for each character.    *    * @param sequence the character sequence to examine    * @param start the first index to examine; must be nonnegative and no greater than {@code    *        sequence.length()}    * @return the index of the first matching character, guaranteed to be no less than {@code start},    *         or {@code -1} if no character matches    * @throws IndexOutOfBoundsException if start is negative or greater than {@code    *         sequence.length()}    */
DECL|method|indexIn (CharSequence sequence, int start)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the last matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in reverse order calling {@link    * #matches} for each character.    *    * @param sequence the character sequence to examine from the end    * @return an index, or {@code -1} if no character matches    */
DECL|method|lastIndexIn (CharSequence sequence)
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the number of matching characters found in a character sequence.    */
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns a string containing all non-matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').removeFrom("bazaar")}</pre>    *    * ... returns {@code "bzr"}.    */
annotation|@
name|CheckReturnValue
DECL|method|removeFrom (CharSequence sequence)
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|spread
init|=
literal|1
decl_stmt|;
comment|// This unusual loop comes from extensive benchmarking
name|OUT
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|pos
operator|++
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|chars
operator|.
name|length
condition|)
block|{
break|break
name|OUT
break|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|chars
index|[
name|pos
operator|-
name|spread
index|]
operator|=
name|chars
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|spread
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|pos
operator|-
name|spread
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing all matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').retainFrom("bazaar")}</pre>    *    * ... returns {@code "aaa"}.    */
annotation|@
name|CheckReturnValue
DECL|method|retainFrom (CharSequence sequence)
specifier|public
name|String
name|retainFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|negate
argument_list|()
operator|.
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement character. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>    *    * ... returns {@code "rodor"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the character to append to the result string in place of each matching    *        character in {@code sequence}    * @return the new string    */
annotation|@
name|CheckReturnValue
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|chars
index|[
name|pos
index|]
operator|=
name|replacement
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pos
operator|+
literal|1
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|chars
index|[
name|i
index|]
operator|=
name|replacement
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement sequence. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>    *    * ... returns {@code "yoohoo"}.    *    *<p><b>Note:</b> If the replacement is a fixed string with only one character, you are better    * off calling {@link #replaceFrom(CharSequence, char)} directly.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the characters to append to the result string in place of each matching    *        character in {@code sequence}    * @return the new string    */
annotation|@
name|CheckReturnValue
DECL|method|replaceFrom (CharSequence sequence, CharSequence replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|int
name|replacementLen
init|=
name|replacement
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|replacementLen
operator|==
literal|0
condition|)
block|{
return|return
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
if|if
condition|(
name|replacementLen
operator|==
literal|1
condition|)
block|{
return|return
name|replaceFrom
argument_list|(
name|sequence
argument_list|,
name|replacement
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|int
name|len
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
operator|(
name|len
operator|*
literal|3
operator|/
literal|2
operator|)
operator|+
literal|16
argument_list|)
decl_stmt|;
name|int
name|oldpos
init|=
literal|0
decl_stmt|;
do|do
block|{
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
name|indexIn
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
do|;
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning and from the end of the string. For example:<pre>   {@code    *    *   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>    *    * ... returns {@code "cat"}.    *    *<p>Note that:<pre>   {@code    *    *   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>    *    * ... is equivalent to {@link String#trim()}.    */
annotation|@
name|CheckReturnValue
DECL|method|trimFrom (CharSequence sequence)
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|last
operator|=
name|len
operator|-
literal|1
init|;
name|last
operator|>
name|first
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>    *    * ... returns {@code "catbab"}.    */
annotation|@
name|CheckReturnValue
DECL|method|trimLeadingFrom (CharSequence sequence)
specifier|public
name|String
name|trimLeadingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|first
init|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|len
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the end of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>    *    * ... returns {@code "abacat"}.    */
annotation|@
name|CheckReturnValue
DECL|method|trimTrailingFrom (CharSequence sequence)
specifier|public
name|String
name|trimTrailingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|last
init|=
name|len
operator|-
literal|1
init|;
name|last
operator|>=
literal|0
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each group of consecutive    * characters that match this matcher replaced by a single replacement character. For example:    *<pre>   {@code    *    *   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>    *    * ... returns {@code "b-p-r"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching groups of characters in    * @param replacement the character to append to the result string in place of each group of    *        matching characters in {@code sequence}    * @return the new string    */
annotation|@
name|CheckReturnValue
DECL|method|collapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
comment|// This implementation avoids unnecessary allocation.
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|replacement
operator|&&
operator|(
name|i
operator|==
name|len
operator|-
literal|1
operator|||
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// a no-op replacement
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|len
argument_list|)
operator|.
name|append
argument_list|(
name|sequence
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
decl_stmt|;
return|return
name|finishCollapseFrom
argument_list|(
name|sequence
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|len
argument_list|,
name|replacement
argument_list|,
name|builder
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
comment|// no replacement needed
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that    * groups of matching characters at the start or end of the sequence are removed without    * replacement.    */
annotation|@
name|CheckReturnValue
DECL|method|trimAndCollapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|trimAndCollapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
comment|// This implementation avoids unnecessary allocation.
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|len
operator|&&
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|;
name|first
operator|++
control|)
block|{}
for|for
control|(
name|last
operator|=
name|len
operator|-
literal|1
init|;
name|last
operator|>
name|first
operator|&&
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|;
name|last
operator|--
control|)
block|{}
return|return
operator|(
name|first
operator|==
literal|0
operator|&&
name|last
operator|==
name|len
operator|-
literal|1
operator|)
condition|?
name|collapseFrom
argument_list|(
name|sequence
argument_list|,
name|replacement
argument_list|)
else|:
name|finishCollapseFrom
argument_list|(
name|sequence
argument_list|,
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|,
name|replacement
argument_list|,
operator|new
name|StringBuilder
argument_list|(
name|last
operator|+
literal|1
operator|-
name|first
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|finishCollapseFrom ( CharSequence sequence, int start, int end, char replacement, StringBuilder builder, boolean inMatchingGroup)
specifier|private
name|String
name|finishCollapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|char
name|replacement
parameter_list|,
name|StringBuilder
name|builder
parameter_list|,
name|boolean
name|inMatchingGroup
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inMatchingGroup
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|inMatchingGroup
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|inMatchingGroup
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}    *     instead.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|apply (Character character)
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|matches
argument_list|(
name|character
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of this {@code CharMatcher}, such as    * {@code CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
comment|/**    * Determines whether a character is whitespace according to the latest Unicode standard, as    * illustrated    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.    * This is not the same definition used by other Java APIs. (See a    *<a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several    * definitions of "whitespace"</a>.)    *    *<p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up    * to date.    */
DECL|field|WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|WHITESPACE
init|=
operator|new
name|FastMatcher
argument_list|(
literal|"WHITESPACE"
argument_list|)
block|{
specifier|private
specifier|static
specifier|final
name|String
name|TABLE
init|=
literal|"\u0009\u3000\n\u0009\u0009\u0009\u202F\u0009"
operator|+
literal|"\u0009\u2001\u2006\u0009\u0009\u0009\u0009\u0009"
operator|+
literal|"\u180E\u0009\u2029\u0009\u0009\u0009\u2000\u2005"
operator|+
literal|"\u200A\u0009\u0009\u0009\r\u0009\u0009\u2028"
operator|+
literal|"\u1680\u0009\u00A0\u0009\u2004\u2009\u0009\u0009"
operator|+
literal|"\u0009\u000C\u205F\u0009\u0009\u0020\u0009\u0009"
operator|+
literal|"\u2003\u2008\u0009\u0009\u0009\u000B\u0085\u0009"
operator|+
literal|"\u0009\u0009\u0009\u0009\u0009\u2002\u2007\u0009"
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|TABLE
operator|.
name|charAt
argument_list|(
operator|(
operator|-
literal|844444961
operator|*
name|c
operator|)
operator|>>>
literal|26
argument_list|)
operator|==
name|c
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.BitSet"
argument_list|)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TABLE
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|TABLE
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

