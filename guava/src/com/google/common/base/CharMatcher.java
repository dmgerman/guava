begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_comment
comment|/**  * Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does  * for any {@link Object}. Also offers basic text processing methods based on this function.  * Implementations are strongly encouraged to be side-effect-free and immutable.  *  *<p>Throughout the documentation of this class, the phrase "matching character" is used to mean  * "any character {@code c} for which {@code this.matches(c)} returns {@code true}".  *  *<p><b>Note:</b> This class deals only with {@code char} values; it does not understand  * supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical  * characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}  * treats these just as two separate characters.  *  *<p>Example usages:<pre>  *   String trimmed = {@link #whitespace() whitespace()}.{@link #trimFrom trimFrom}(userInput);  *   if ({@link #ascii() ascii()}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>  *  *<p>See the Guava User Guide article on  *<a href="https://github.com/google/guava/wiki/StringsExplained#charmatcher">{@code CharMatcher}  *</a>.  *  * @author Kevin Bourrillion  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
comment|// Possibly change from chars to code points; decide constants vs. methods
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|CharMatcher
specifier|public
specifier|abstract
class|class
name|CharMatcher
implements|implements
name|Predicate
argument_list|<
name|Character
argument_list|>
block|{
comment|// Constant matcher factory methods
comment|/**    * Matches any character.    *    * @since 19.0 (since 1.0 as constant {@code ANY})    */
DECL|method|any ()
specifier|public
specifier|static
name|CharMatcher
name|any
parameter_list|()
block|{
return|return
name|Any
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Matches no characters.    *    * @since 19.0 (since 1.0 as constant {@code NONE})    */
DECL|method|none ()
specifier|public
specifier|static
name|CharMatcher
name|none
parameter_list|()
block|{
return|return
name|None
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is whitespace according to the latest Unicode standard, as    * illustrated    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.    * This is not the same definition used by other Java APIs. (See a    *<a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several    * definitions of "whitespace"</a>.)    *    *<p><b>Note:</b> as the Unicode definition evolves, we will modify this matcher to keep it up to    * date.    *    * @since 19.0 (since 1.0 as constant {@code WHITESPACE})    */
DECL|method|whitespace ()
specifier|public
specifier|static
name|CharMatcher
name|whitespace
parameter_list|()
block|{
return|return
name|Whitespace
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is a breaking whitespace (that is, a whitespace which can be    * interpreted as a break between words for formatting purposes). See {@link #whitespace()} for a    * discussion of that term.    *    * @since 19.0 (since 2.0 as constant {@code BREAKING_WHITESPACE})    */
DECL|method|breakingWhitespace ()
specifier|public
specifier|static
name|CharMatcher
name|breakingWhitespace
parameter_list|()
block|{
return|return
name|BreakingWhitespace
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is ASCII, meaning that its code point is less than 128.    *    * @since 19.0 (since 1.0 as constant {@code ASCII})    */
DECL|method|ascii ()
specifier|public
specifier|static
name|CharMatcher
name|ascii
parameter_list|()
block|{
return|return
name|Ascii
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is a digit according to    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>. If    * you only care to match ASCII digits, you can use {@code inRange('0', '9')}.    *    * @since 19.0 (since 1.0 as constant {@code DIGIT})    */
DECL|method|digit ()
specifier|public
specifier|static
name|CharMatcher
name|digit
parameter_list|()
block|{
return|return
name|Digit
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is a digit according to {@linkplain Character#isDigit(char)    * Java's definition}. If you only care to match ASCII digits, you can use {@code inRange('0',    * '9')}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_DIGIT})    */
DECL|method|javaDigit ()
specifier|public
specifier|static
name|CharMatcher
name|javaDigit
parameter_list|()
block|{
return|return
name|JavaDigit
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is a letter according to {@linkplain Character#isLetter(char)    * Java's definition}. If you only care to match letters of the Latin alphabet, you can use {@code    * inRange('a', 'z').or(inRange('A', 'Z'))}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER})    */
DECL|method|javaLetter ()
specifier|public
specifier|static
name|CharMatcher
name|javaLetter
parameter_list|()
block|{
return|return
name|JavaLetter
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is a letter or digit according to    * {@linkplain Character#isLetterOrDigit(char) Java's definition}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER_OR_DIGIT}).    */
DECL|method|javaLetterOrDigit ()
specifier|public
specifier|static
name|CharMatcher
name|javaLetterOrDigit
parameter_list|()
block|{
return|return
name|JavaLetterOrDigit
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is upper case according to    * {@linkplain Character#isUpperCase(char) Java's definition}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_UPPER_CASE})    */
DECL|method|javaUpperCase ()
specifier|public
specifier|static
name|CharMatcher
name|javaUpperCase
parameter_list|()
block|{
return|return
name|JavaUpperCase
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is lower case according to    * {@linkplain Character#isLowerCase(char) Java's definition}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_LOWER_CASE})    */
DECL|method|javaLowerCase ()
specifier|public
specifier|static
name|CharMatcher
name|javaLowerCase
parameter_list|()
block|{
return|return
name|JavaLowerCase
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is an ISO control character as specified by    * {@link Character#isISOControl(char)}.    *    * @since 19.0 (since 1.0 as constant {@code JAVA_ISO_CONTROL})    */
DECL|method|javaIsoControl ()
specifier|public
specifier|static
name|CharMatcher
name|javaIsoControl
parameter_list|()
block|{
return|return
name|JavaIsoControl
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is invisible; that is, if its Unicode category is any of    * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and    * PRIVATE_USE according to ICU4J.    *    * @since 19.0 (since 1.0 as constant {@code INVISIBLE})    */
DECL|method|invisible ()
specifier|public
specifier|static
name|CharMatcher
name|invisible
parameter_list|()
block|{
return|return
name|Invisible
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Determines whether a character is single-width (not double-width). When in doubt, this matcher    * errs on the side of returning {@code false} (that is, it tends to assume a character is    * double-width).    *    *<p><b>Note:</b> as the reference file evolves, we will modify this matcher to keep it up to    * date.    *    * @since 19.0 (since 1.0 as constant {@code SINGLE_WIDTH})    */
DECL|method|singleWidth ()
specifier|public
specifier|static
name|CharMatcher
name|singleWidth
parameter_list|()
block|{
return|return
name|SingleWidth
operator|.
name|INSTANCE
return|;
block|}
comment|// Legacy constants
comment|/**    * Determines whether a character is whitespace according to the latest Unicode    * standard, as illustrated    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.    * This is not the same definition used by other Java APIs. (See a    *<a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">    * comparison of several definitions of "whitespace"</a>.)    *    *<p><b>Note:</b> as the Unicode definition evolves, we will modify this constant    * to keep it up to date.    *    * @deprecated Use {@link #whitespace()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|WHITESPACE
init|=
name|whitespace
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a breaking whitespace (that is, a whitespace    * which can be interpreted as a break between words for formatting purposes). See    * {@link #whitespace} for a discussion of that term.    *    * @since 2.0    * @deprecated Use {@link #breakingWhitespace()} instead. This constant is scheduled    *     to be removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|BREAKING_WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|BREAKING_WHITESPACE
init|=
name|breakingWhitespace
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is ASCII, meaning that its code point is less than    * 128.    *    * @deprecated Use {@link #ascii()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|ASCII
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ASCII
init|=
name|ascii
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a digit according to    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">    * Unicode</a>. If you only care to match ASCII digits, you can use    * {@code inRange('0', '9')}.    *    * @deprecated Use {@link #digit()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|DIGIT
init|=
name|digit
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a digit according to    * {@linkplain Character#isDigit(char) Java's definition}. If you only care to match    * ASCII digits, you can use {@code inRange('0', '9')}.    *    * @deprecated Use {@link #javaDigit()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_DIGIT
init|=
name|javaDigit
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a letter according to    * {@linkplain Character#isLetter(char) Java's definition}. If you only care to    * match letters of the Latin alphabet, you can use    * {@code inRange('a', 'z').or(inRange('A', 'Z'))}.    *    * @deprecated Use {@link #javaLetter()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_LETTER
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER
init|=
name|javaLetter
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a letter or digit according to    * {@linkplain Character#isLetterOrDigit(char) Java's definition}.    *    * @deprecated Use {@link #javaLetterOrDigit()} instead. This constant is scheduled    *     to be removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_LETTER_OR_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER_OR_DIGIT
init|=
name|javaLetterOrDigit
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is upper case according to    * {@linkplain Character#isUpperCase(char) Java's definition}.    *    * @deprecated Use {@link #javaUpperCase()} instead. This constant is scheduled to    *     be removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_UPPER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_UPPER_CASE
init|=
name|javaUpperCase
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is lower case according to    * {@linkplain Character#isLowerCase(char) Java's definition}.    *    * @deprecated Use {@link #javaLowerCase()} instead. This constant is scheduled to    *     be removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_LOWER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LOWER_CASE
init|=
name|javaLowerCase
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is an ISO control character as specified by    * {@link Character#isISOControl(char)}.    *    * @deprecated Use {@link #javaIsoControl()} instead. This constant is scheduled to    *     be removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|JAVA_ISO_CONTROL
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_ISO_CONTROL
init|=
name|javaIsoControl
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is invisible; that is, if its Unicode category is    * any of SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT,    * SURROGATE, and PRIVATE_USE according to ICU4J.    *    * @deprecated Use {@link #invisible()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|INVISIBLE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|INVISIBLE
init|=
name|invisible
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is single-width (not double-width). When in doubt,    * this matcher errs on the side of returning {@code false} (that is, it tends to    * assume a character is double-width).    *    *<p><b>Note:</b> as the reference file evolves, we will modify this constant to    * keep it up to date.    *    * @deprecated Use {@link #singleWidth()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|SINGLE_WIDTH
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|SINGLE_WIDTH
init|=
name|singleWidth
argument_list|()
decl_stmt|;
comment|/**    * Matches any character.    *    * @deprecated Use {@link #any()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|ANY
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ANY
init|=
name|any
argument_list|()
decl_stmt|;
comment|/**    * Matches no characters.    *    * @deprecated Use {@link #none()} instead. This constant is scheduled to be    *     removed in June 2018.    */
annotation|@
name|Deprecated
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|NONE
init|=
name|none
argument_list|()
decl_stmt|;
comment|// Static factories
comment|/**    * Returns a {@code char} matcher that matches only one specified character.    */
DECL|method|is (final char match)
specifier|public
specifier|static
name|CharMatcher
name|is
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
return|return
operator|new
name|Is
argument_list|(
name|match
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character except the one specified.    *    *<p>To negate another {@code CharMatcher}, use {@link #negate()}.    */
DECL|method|isNot (final char match)
specifier|public
specifier|static
name|CharMatcher
name|isNot
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
return|return
operator|new
name|IsNot
argument_list|(
name|match
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character present in the given character    * sequence.    */
DECL|method|anyOf (final CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|anyOf
parameter_list|(
specifier|final
name|CharSequence
name|sequence
parameter_list|)
block|{
switch|switch
condition|(
name|sequence
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|none
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|is
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|isEither
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sequence
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
default|default:
comment|// TODO(lowasser): is it potentially worth just going ahead and building a precomputed
comment|// matcher?
return|return
operator|new
name|AnyOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@code char} matcher that matches any character not present in the given character    * sequence.    */
DECL|method|noneOf (CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|noneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|anyOf
argument_list|(
name|sequence
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character in a given range (both endpoints are    * inclusive). For example, to match any lowercase letter of the English alphabet, use {@code    * CharMatcher.inRange('a', 'z')}.    *    * @throws IllegalArgumentException if {@code endInclusive< startInclusive}    */
DECL|method|inRange (final char startInclusive, final char endInclusive)
specifier|public
specifier|static
name|CharMatcher
name|inRange
parameter_list|(
specifier|final
name|char
name|startInclusive
parameter_list|,
specifier|final
name|char
name|endInclusive
parameter_list|)
block|{
return|return
operator|new
name|InRange
argument_list|(
name|startInclusive
argument_list|,
name|endInclusive
argument_list|)
return|;
block|}
comment|/**    * Returns a matcher with identical behavior to the given {@link Character}-based predicate, but    * which operates on primitive {@code char} instances instead.    */
DECL|method|forPredicate (final Predicate<? super Character> predicate)
specifier|public
specifier|static
name|CharMatcher
name|forPredicate
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Character
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|predicate
operator|instanceof
name|CharMatcher
condition|?
operator|(
name|CharMatcher
operator|)
name|predicate
else|:
operator|new
name|ForPredicate
argument_list|(
name|predicate
argument_list|)
return|;
block|}
comment|// Constructors
comment|/**    * Constructor for use by subclasses. When subclassing, you may want to override    * {@code toString()} to provide a useful description.    */
DECL|method|CharMatcher ()
specifier|protected
name|CharMatcher
parameter_list|()
block|{}
comment|// Abstract methods
comment|/** Determines a true or false value for the given character. */
DECL|method|matches (char c)
specifier|public
specifier|abstract
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
comment|// Non-static factories
comment|/**    * Returns a matcher that matches any character not matched by this matcher.    */
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
operator|new
name|Negated
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns a matcher that matches any character matched by both this matcher and {@code other}.    */
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|And
argument_list|(
name|this
argument_list|,
name|other
argument_list|)
return|;
block|}
comment|/**    * Returns a matcher that matches any character matched by either this matcher or {@code other}.    */
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|Or
argument_list|(
name|this
argument_list|,
name|other
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to    * query than the original; your mileage may vary. Precomputation takes time and is likely to be    * worthwhile only if the precomputed matcher is queried many thousands of times.    *    *<p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a    * precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a    * worthwhile tradeoff in a browser.    */
DECL|method|precomputed ()
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|Platform
operator|.
name|precomputeCharMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|field|DISTINCT_CHARS
specifier|private
specifier|static
specifier|final
name|int
name|DISTINCT_CHARS
init|=
name|Character
operator|.
name|MAX_VALUE
operator|-
name|Character
operator|.
name|MIN_VALUE
operator|+
literal|1
decl_stmt|;
comment|/**    * This is the actual implementation of {@link #precomputed}, but we bounce calls through a method    * on {@link Platform} so that we can have different behavior in GWT.    *    *<p>This implementation tries to be smart in a number of ways. It recognizes cases where the    * negation is cheaper to precompute than the matcher itself; it tries to build small hash tables    * for matchers that only match a few characters, and so on. In the worst-case scenario, it    * constructs an eight-kilobyte bit array and queries that. In many situations this produces a    * matcher which is faster to query than the original.    */
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
DECL|method|precomputedInternal ()
name|CharMatcher
name|precomputedInternal
parameter_list|()
block|{
specifier|final
name|BitSet
name|table
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|int
name|totalCharacters
init|=
name|table
operator|.
name|cardinality
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalCharacters
operator|*
literal|2
operator|<=
name|DISTINCT_CHARS
condition|)
block|{
return|return
name|precomputedPositive
argument_list|(
name|totalCharacters
argument_list|,
name|table
argument_list|,
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// TODO(lowasser): is it worth it to worry about the last character of large matchers?
name|table
operator|.
name|flip
argument_list|(
name|Character
operator|.
name|MIN_VALUE
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|negatedCharacters
init|=
name|DISTINCT_CHARS
operator|-
name|totalCharacters
decl_stmt|;
name|String
name|suffix
init|=
literal|".negate()"
decl_stmt|;
specifier|final
name|String
name|description
init|=
name|toString
argument_list|()
decl_stmt|;
name|String
name|negatedDescription
init|=
name|description
operator|.
name|endsWith
argument_list|(
name|suffix
argument_list|)
condition|?
name|description
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|description
operator|.
name|length
argument_list|()
operator|-
name|suffix
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|description
operator|+
name|suffix
decl_stmt|;
return|return
operator|new
name|NegatedFastMatcher
argument_list|(
name|precomputedPositive
argument_list|(
name|negatedCharacters
argument_list|,
name|table
argument_list|,
name|negatedDescription
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * Helper method for {@link #precomputedInternal} that doesn't test if the negation is cheaper.    */
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
DECL|method|precomputedPositive ( int totalCharacters, BitSet table, String description)
specifier|private
specifier|static
name|CharMatcher
name|precomputedPositive
parameter_list|(
name|int
name|totalCharacters
parameter_list|,
name|BitSet
name|table
parameter_list|,
name|String
name|description
parameter_list|)
block|{
switch|switch
condition|(
name|totalCharacters
condition|)
block|{
case|case
literal|0
case|:
return|return
name|none
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|is
argument_list|(
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
name|char
name|c1
init|=
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|c2
init|=
operator|(
name|char
operator|)
name|table
operator|.
name|nextSetBit
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|isEither
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
default|default:
return|return
name|isSmall
argument_list|(
name|totalCharacters
argument_list|,
name|table
operator|.
name|length
argument_list|()
argument_list|)
condition|?
name|SmallCharMatcher
operator|.
name|from
argument_list|(
name|table
argument_list|,
name|description
argument_list|)
else|:
operator|new
name|BitSetMatcher
argument_list|(
name|table
argument_list|,
name|description
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// SmallCharMatcher
DECL|method|isSmall (int totalCharacters, int tableLength)
specifier|private
specifier|static
name|boolean
name|isSmall
parameter_list|(
name|int
name|totalCharacters
parameter_list|,
name|int
name|tableLength
parameter_list|)
block|{
return|return
name|totalCharacters
operator|<=
name|SmallCharMatcher
operator|.
name|MAX_SIZE
operator|&&
name|tableLength
operator|>
operator|(
name|totalCharacters
operator|*
literal|4
operator|*
name|Character
operator|.
name|SIZE
operator|)
return|;
comment|// err on the side of BitSetMatcher
block|}
comment|/**    * Sets bits in {@code table} matched by this matcher.    */
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
name|Character
operator|.
name|MAX_VALUE
init|;
name|c
operator|>=
name|Character
operator|.
name|MIN_VALUE
condition|;
name|c
operator|--
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Text processing routines
comment|/**    * Returns {@code true} if a character sequence contains at least one matching character.    * Equivalent to {@code !matchesNoneOf(sequence)}.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code true} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches at least one character in the sequence    * @since 8.0    */
DECL|method|matchesAnyOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAnyOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|!
name|matchesNoneOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if a character sequence contains only matching characters.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code false} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches every character in the sequence, including when    *     the sequence is empty    */
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns {@code true} if a character sequence contains no matching characters. Equivalent to    * {@code !matchesAnyOf(sequence)}.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code true} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches no characters in the sequence, including when    *     the sequence is empty    */
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|indexIn
argument_list|(
name|sequence
argument_list|)
operator|==
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the first matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in forward order calling    * {@link #matches} for each character.    *    * @param sequence the character sequence to examine from the beginning    * @return an index, or {@code -1} if no character matches    */
DECL|method|indexIn (CharSequence sequence)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|indexIn
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Returns the index of the first matching character in a character sequence, starting from a    * given position, or {@code -1} if no character matches after that position.    *    *<p>The default implementation iterates over the sequence in forward order, beginning at {@code    * start}, calling {@link #matches} for each character.    *    * @param sequence the character sequence to examine    * @param start the first index to examine; must be nonnegative and no greater than {@code    *        sequence.length()}    * @return the index of the first matching character, guaranteed to be no less than {@code start},    *     or {@code -1} if no character matches    * @throws IndexOutOfBoundsException if start is negative or greater than {@code    *         sequence.length()}    */
DECL|method|indexIn (CharSequence sequence, int start)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the last matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in reverse order calling    * {@link #matches} for each character.    *    * @param sequence the character sequence to examine from the end    * @return an index, or {@code -1} if no character matches    */
DECL|method|lastIndexIn (CharSequence sequence)
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the number of matching characters found in a character sequence.    */
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns a string containing all non-matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').removeFrom("bazaar")}</pre>    *    * ... returns {@code "bzr"}.    */
DECL|method|removeFrom (CharSequence sequence)
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|spread
init|=
literal|1
decl_stmt|;
comment|// This unusual loop comes from extensive benchmarking
name|OUT
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|pos
operator|++
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|chars
operator|.
name|length
condition|)
block|{
break|break
name|OUT
break|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|chars
index|[
name|pos
operator|-
name|spread
index|]
operator|=
name|chars
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|spread
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|pos
operator|-
name|spread
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing all matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').retainFrom("bazaar")}</pre>    *    * ... returns {@code "aaa"}.    */
DECL|method|retainFrom (CharSequence sequence)
specifier|public
name|String
name|retainFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|negate
argument_list|()
operator|.
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement character. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>    *    * ... returns {@code "rodor"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the character to append to the result string in place of each matching    *     character in {@code sequence}    * @return the new string    */
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|chars
index|[
name|pos
index|]
operator|=
name|replacement
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pos
operator|+
literal|1
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|chars
index|[
name|i
index|]
operator|=
name|replacement
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement sequence. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>    *    * ... returns {@code "yoohoo"}.    *    *<p><b>Note:</b> If the replacement is a fixed string with only one character, you are better    * off calling {@link #replaceFrom(CharSequence, char)} directly.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the characters to append to the result string in place of each matching    *     character in {@code sequence}    * @return the new string    */
DECL|method|replaceFrom (CharSequence sequence, CharSequence replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|int
name|replacementLen
init|=
name|replacement
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|replacementLen
operator|==
literal|0
condition|)
block|{
return|return
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
if|if
condition|(
name|replacementLen
operator|==
literal|1
condition|)
block|{
return|return
name|replaceFrom
argument_list|(
name|sequence
argument_list|,
name|replacement
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|int
name|len
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
operator|(
name|len
operator|*
literal|3
operator|/
literal|2
operator|)
operator|+
literal|16
argument_list|)
decl_stmt|;
name|int
name|oldpos
init|=
literal|0
decl_stmt|;
do|do
block|{
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
name|indexIn
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
do|;
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning and from the end of the string. For example:<pre>   {@code    *    *   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>    *    * ... returns {@code "cat"}.    *    *<p>Note that:<pre>   {@code    *    *   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>    *    * ... is equivalent to {@link String#trim()}.    */
DECL|method|trimFrom (CharSequence sequence)
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|last
operator|=
name|len
operator|-
literal|1
init|;
name|last
operator|>
name|first
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>    *    * ... returns {@code "catbab"}.    */
DECL|method|trimLeadingFrom (CharSequence sequence)
specifier|public
name|String
name|trimLeadingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|first
init|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|len
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the end of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>    *    * ... returns {@code "abacat"}.    */
DECL|method|trimTrailingFrom (CharSequence sequence)
specifier|public
name|String
name|trimTrailingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|last
init|=
name|len
operator|-
literal|1
init|;
name|last
operator|>=
literal|0
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each group of consecutive    * characters that match this matcher replaced by a single replacement character. For example:    *<pre>   {@code    *    *   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>    *    * ... returns {@code "b-p-r"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching groups of characters in    * @param replacement the character to append to the result string in place of each group of    *     matching characters in {@code sequence}    * @return the new string    */
DECL|method|collapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
comment|// This implementation avoids unnecessary allocation.
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|replacement
operator|&&
operator|(
name|i
operator|==
name|len
operator|-
literal|1
operator|||
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// a no-op replacement
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|len
argument_list|)
operator|.
name|append
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
decl_stmt|;
return|return
name|finishCollapseFrom
argument_list|(
name|sequence
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|len
argument_list|,
name|replacement
argument_list|,
name|builder
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
comment|// no replacement needed
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that    * groups of matching characters at the start or end of the sequence are removed without    * replacement.    */
DECL|method|trimAndCollapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|trimAndCollapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
comment|// This implementation avoids unnecessary allocation.
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
name|len
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|first
operator|<
name|len
operator|&&
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
name|first
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|last
operator|>
name|first
operator|&&
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
name|last
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|first
operator|==
literal|0
operator|&&
name|last
operator|==
name|len
operator|-
literal|1
operator|)
condition|?
name|collapseFrom
argument_list|(
name|sequence
argument_list|,
name|replacement
argument_list|)
else|:
name|finishCollapseFrom
argument_list|(
name|sequence
argument_list|,
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|,
name|replacement
argument_list|,
operator|new
name|StringBuilder
argument_list|(
name|last
operator|+
literal|1
operator|-
name|first
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|finishCollapseFrom ( CharSequence sequence, int start, int end, char replacement, StringBuilder builder, boolean inMatchingGroup)
specifier|private
name|String
name|finishCollapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|char
name|replacement
parameter_list|,
name|StringBuilder
name|builder
parameter_list|,
name|boolean
name|inMatchingGroup
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inMatchingGroup
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|inMatchingGroup
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|inMatchingGroup
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}    *     instead.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|apply (Character character)
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|matches
argument_list|(
name|character
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of this {@code CharMatcher}, such as    * {@code CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the Java Unicode escape sequence for the given character, in the form "\u12AB" where    * "12AB" is the four hexadecimal digits representing the 16 bits of the UTF-16 character.    */
DECL|method|showCharacter (char c)
specifier|private
specifier|static
name|String
name|showCharacter
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|String
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|char
index|[]
name|tmp
init|=
block|{
literal|'\\'
block|,
literal|'u'
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|tmp
index|[
literal|5
operator|-
name|i
index|]
operator|=
name|hex
operator|.
name|charAt
argument_list|(
name|c
operator|&
literal|0xF
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|String
operator|.
name|copyValueOf
argument_list|(
name|tmp
argument_list|)
return|;
block|}
comment|// Fast matchers
comment|/** A matcher for which precomputation will not yield any significant benefit. */
DECL|class|FastMatcher
specifier|abstract
specifier|static
class|class
name|FastMatcher
extends|extends
name|CharMatcher
block|{
annotation|@
name|Override
DECL|method|precomputed ()
specifier|public
specifier|final
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
operator|new
name|NegatedFastMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/** {@link FastMatcher} which overrides {@code toString()} with a custom name. */
DECL|class|NamedFastMatcher
specifier|abstract
specifier|static
class|class
name|NamedFastMatcher
extends|extends
name|FastMatcher
block|{
DECL|field|description
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
DECL|method|NamedFastMatcher (String description)
name|NamedFastMatcher
parameter_list|(
name|String
name|description
parameter_list|)
block|{
name|this
operator|.
name|description
operator|=
name|checkNotNull
argument_list|(
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
block|}
comment|/** Negation of a {@link FastMatcher}. */
DECL|class|NegatedFastMatcher
specifier|static
class|class
name|NegatedFastMatcher
extends|extends
name|Negated
block|{
DECL|method|NegatedFastMatcher (CharMatcher original)
name|NegatedFastMatcher
parameter_list|(
name|CharMatcher
name|original
parameter_list|)
block|{
name|super
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|precomputed ()
specifier|public
specifier|final
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
comment|/** Fast matcher using a {@link BitSet} table of matching characters. */
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
DECL|class|BitSetMatcher
specifier|private
specifier|static
specifier|final
class|class
name|BitSetMatcher
extends|extends
name|NamedFastMatcher
block|{
DECL|field|table
specifier|private
specifier|final
name|BitSet
name|table
decl_stmt|;
DECL|method|BitSetMatcher (BitSet table, String description)
specifier|private
name|BitSetMatcher
parameter_list|(
name|BitSet
name|table
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|.
name|length
argument_list|()
operator|+
name|Long
operator|.
name|SIZE
operator|<
name|table
operator|.
name|size
argument_list|()
condition|)
block|{
name|table
operator|=
operator|(
name|BitSet
operator|)
name|table
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// If only we could actually call BitSet.trimToSize() ourselves...
block|}
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|table
operator|.
name|get
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setBits (BitSet bitSet)
name|void
name|setBits
parameter_list|(
name|BitSet
name|bitSet
parameter_list|)
block|{
name|bitSet
operator|.
name|or
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Static constant implementation classes
comment|/** Implementation of {@link #any()}. */
DECL|class|Any
specifier|private
specifier|static
specifier|final
class|class
name|Any
extends|extends
name|NamedFastMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|Any
name|INSTANCE
init|=
operator|new
name|Any
argument_list|()
decl_stmt|;
DECL|method|Any ()
specifier|private
name|Any
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.any()"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|indexIn (CharSequence sequence)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|indexIn (CharSequence sequence, int start)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|==
name|length
operator|)
condition|?
operator|-
literal|1
else|:
name|start
return|;
block|}
annotation|@
name|Override
DECL|method|lastIndexIn (CharSequence sequence)
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|removeFrom (CharSequence sequence)
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|char
index|[]
name|array
init|=
operator|new
name|char
index|[
name|sequence
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|array
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|array
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFrom (CharSequence sequence, CharSequence replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|sequence
operator|.
name|length
argument_list|()
operator|*
name|replacement
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|collapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|String
operator|.
name|valueOf
argument_list|(
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|trimFrom (CharSequence sequence)
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|none
argument_list|()
return|;
block|}
block|}
comment|/** Implementation of {@link #none()}. */
DECL|class|None
specifier|private
specifier|static
specifier|final
class|class
name|None
extends|extends
name|NamedFastMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|None
name|INSTANCE
init|=
operator|new
name|None
argument_list|()
decl_stmt|;
DECL|method|None ()
specifier|private
name|None
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.none()"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|indexIn (CharSequence sequence)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|indexIn (CharSequence sequence, int start)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|lastIndexIn (CharSequence sequence)
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|removeFrom (CharSequence sequence)
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFrom (CharSequence sequence, CharSequence replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|collapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|trimFrom (CharSequence sequence)
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|trimLeadingFrom (CharSequence sequence)
specifier|public
name|String
name|trimLeadingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|trimTrailingFrom (CharSequence sequence)
specifier|public
name|String
name|trimTrailingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|any
argument_list|()
return|;
block|}
block|}
comment|/** Implementation of {@link #whitespace()}. */
annotation|@
name|VisibleForTesting
DECL|class|Whitespace
specifier|static
specifier|final
class|class
name|Whitespace
extends|extends
name|NamedFastMatcher
block|{
DECL|field|TABLE
specifier|static
specifier|final
name|String
name|TABLE
init|=
literal|"\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000"
operator|+
literal|"\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680"
operator|+
literal|"\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009"
operator|+
literal|"\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000"
decl_stmt|;
DECL|field|MULTIPLIER
specifier|static
specifier|final
name|int
name|MULTIPLIER
init|=
literal|1682554634
decl_stmt|;
DECL|field|SHIFT
specifier|static
specifier|final
name|int
name|SHIFT
init|=
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|TABLE
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
DECL|field|INSTANCE
specifier|static
specifier|final
name|Whitespace
name|INSTANCE
init|=
operator|new
name|Whitespace
argument_list|()
decl_stmt|;
DECL|method|Whitespace ()
name|Whitespace
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.whitespace()"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|TABLE
operator|.
name|charAt
argument_list|(
operator|(
name|MULTIPLIER
operator|*
name|c
operator|)
operator|>>>
name|SHIFT
argument_list|)
operator|==
name|c
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TABLE
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|TABLE
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Implementation of {@link #breakingWhitespace()}. */
DECL|class|BreakingWhitespace
specifier|private
specifier|static
specifier|final
class|class
name|BreakingWhitespace
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|CharMatcher
name|INSTANCE
init|=
operator|new
name|BreakingWhitespace
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\013'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
case|case
literal|'\u0085'
case|:
case|case
literal|'\u1680'
case|:
case|case
literal|'\u2028'
case|:
case|case
literal|'\u2029'
case|:
case|case
literal|'\u205f'
case|:
case|case
literal|'\u3000'
case|:
return|return
literal|true
return|;
case|case
literal|'\u2007'
case|:
return|return
literal|false
return|;
default|default:
return|return
name|c
operator|>=
literal|'\u2000'
operator|&&
name|c
operator|<=
literal|'\u200a'
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.breakingWhitespace()"
return|;
block|}
block|}
comment|/** Implementation of {@link #ascii()}. */
DECL|class|Ascii
specifier|private
specifier|static
specifier|final
class|class
name|Ascii
extends|extends
name|NamedFastMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|Ascii
name|INSTANCE
init|=
operator|new
name|Ascii
argument_list|()
decl_stmt|;
DECL|method|Ascii ()
name|Ascii
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.ascii()"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|<=
literal|'\u007f'
return|;
block|}
block|}
comment|/** Implementation that matches characters that fall within multiple ranges. */
DECL|class|RangesMatcher
specifier|private
specifier|static
class|class
name|RangesMatcher
extends|extends
name|CharMatcher
block|{
DECL|field|description
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
DECL|field|rangeStarts
specifier|private
specifier|final
name|char
index|[]
name|rangeStarts
decl_stmt|;
DECL|field|rangeEnds
specifier|private
specifier|final
name|char
index|[]
name|rangeEnds
decl_stmt|;
DECL|method|RangesMatcher (String description, char[] rangeStarts, char[] rangeEnds)
name|RangesMatcher
parameter_list|(
name|String
name|description
parameter_list|,
name|char
index|[]
name|rangeStarts
parameter_list|,
name|char
index|[]
name|rangeEnds
parameter_list|)
block|{
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
name|this
operator|.
name|rangeStarts
operator|=
name|rangeStarts
expr_stmt|;
name|this
operator|.
name|rangeEnds
operator|=
name|rangeEnds
expr_stmt|;
name|checkArgument
argument_list|(
name|rangeStarts
operator|.
name|length
operator|==
name|rangeEnds
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rangeStarts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkArgument
argument_list|(
name|rangeStarts
index|[
name|i
index|]
operator|<=
name|rangeEnds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|rangeStarts
operator|.
name|length
condition|)
block|{
name|checkArgument
argument_list|(
name|rangeEnds
index|[
name|i
index|]
operator|<
name|rangeStarts
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|int
name|index
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|rangeStarts
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|index
operator|=
operator|~
name|index
operator|-
literal|1
expr_stmt|;
return|return
name|index
operator|>=
literal|0
operator|&&
name|c
operator|<=
name|rangeEnds
index|[
name|index
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
block|}
comment|/** Implementation of {@link #digit()}. */
DECL|class|Digit
specifier|private
specifier|static
specifier|final
class|class
name|Digit
extends|extends
name|RangesMatcher
block|{
comment|// Must be in ascending order.
DECL|field|ZEROES
specifier|private
specifier|static
specifier|final
name|String
name|ZEROES
init|=
literal|"0\u0660\u06f0\u07c0\u0966\u09e6\u0a66\u0ae6\u0b66"
operator|+
literal|"\u0be6\u0c66\u0ce6\u0d66\u0e50\u0ed0\u0f20\u1040\u1090\u17e0\u1810"
operator|+
literal|"\u1946\u19d0\u1b50\u1bb0\u1c40\u1c50\ua620\ua8d0\ua900\uaa50\uff10"
decl_stmt|;
DECL|method|zeroes ()
specifier|private
specifier|static
name|char
index|[]
name|zeroes
parameter_list|()
block|{
return|return
name|ZEROES
operator|.
name|toCharArray
argument_list|()
return|;
block|}
DECL|method|nines ()
specifier|private
specifier|static
name|char
index|[]
name|nines
parameter_list|()
block|{
name|char
index|[]
name|nines
init|=
operator|new
name|char
index|[
name|ZEROES
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ZEROES
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nines
index|[
name|i
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|ZEROES
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
block|}
return|return
name|nines
return|;
block|}
DECL|field|INSTANCE
specifier|static
specifier|final
name|Digit
name|INSTANCE
init|=
operator|new
name|Digit
argument_list|()
decl_stmt|;
DECL|method|Digit ()
specifier|private
name|Digit
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.digit()"
argument_list|,
name|zeroes
argument_list|()
argument_list|,
name|nines
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementation of {@link #javaDigit()}. */
DECL|class|JavaDigit
specifier|private
specifier|static
specifier|final
class|class
name|JavaDigit
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaDigit
name|INSTANCE
init|=
operator|new
name|JavaDigit
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.javaDigit()"
return|;
block|}
block|}
comment|/** Implementation of {@link #javaLetter()}. */
DECL|class|JavaLetter
specifier|private
specifier|static
specifier|final
class|class
name|JavaLetter
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaLetter
name|INSTANCE
init|=
operator|new
name|JavaLetter
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.javaLetter()"
return|;
block|}
block|}
comment|/** Implementation of {@link #javaLetterOrDigit()}. */
DECL|class|JavaLetterOrDigit
specifier|private
specifier|static
specifier|final
class|class
name|JavaLetterOrDigit
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaLetterOrDigit
name|INSTANCE
init|=
operator|new
name|JavaLetterOrDigit
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.javaLetterOrDigit()"
return|;
block|}
block|}
comment|/** Implementation of {@link #javaUpperCase()}. */
DECL|class|JavaUpperCase
specifier|private
specifier|static
specifier|final
class|class
name|JavaUpperCase
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaUpperCase
name|INSTANCE
init|=
operator|new
name|JavaUpperCase
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.javaUpperCase()"
return|;
block|}
block|}
comment|/** Implementation of {@link #javaLowerCase()}. */
DECL|class|JavaLowerCase
specifier|private
specifier|static
specifier|final
class|class
name|JavaLowerCase
extends|extends
name|CharMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaLowerCase
name|INSTANCE
init|=
operator|new
name|JavaLowerCase
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.javaLowerCase()"
return|;
block|}
block|}
comment|/** Implementation of {@link #javaIsoControl()}. */
DECL|class|JavaIsoControl
specifier|private
specifier|static
specifier|final
class|class
name|JavaIsoControl
extends|extends
name|NamedFastMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|JavaIsoControl
name|INSTANCE
init|=
operator|new
name|JavaIsoControl
argument_list|()
decl_stmt|;
DECL|method|JavaIsoControl ()
specifier|private
name|JavaIsoControl
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.javaIsoControl()"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|<=
literal|'\u001f'
operator|||
operator|(
name|c
operator|>=
literal|'\u007f'
operator|&&
name|c
operator|<=
literal|'\u009f'
operator|)
return|;
block|}
block|}
comment|/** Implementation of {@link #invisible()}. */
DECL|class|Invisible
specifier|private
specifier|static
specifier|final
class|class
name|Invisible
extends|extends
name|RangesMatcher
block|{
DECL|field|RANGE_STARTS
specifier|private
specifier|static
specifier|final
name|String
name|RANGE_STARTS
init|=
literal|"\u0000\u007f\u00ad\u0600\u061c\u06dd\u070f\u1680\u180e\u2000\u2028\u205f\u2066\u2067"
operator|+
literal|"\u2068\u2069\u206a\u3000\ud800\ufeff\ufff9\ufffa"
decl_stmt|;
DECL|field|RANGE_ENDS
specifier|private
specifier|static
specifier|final
name|String
name|RANGE_ENDS
init|=
literal|"\u0020\u00a0\u00ad\u0604\u061c\u06dd\u070f\u1680\u180e\u200f\u202f\u2064\u2066\u2067"
operator|+
literal|"\u2068\u2069\u206f\u3000\uf8ff\ufeff\ufff9\ufffb"
decl_stmt|;
DECL|field|INSTANCE
specifier|static
specifier|final
name|Invisible
name|INSTANCE
init|=
operator|new
name|Invisible
argument_list|()
decl_stmt|;
DECL|method|Invisible ()
specifier|private
name|Invisible
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.invisible()"
argument_list|,
name|RANGE_STARTS
operator|.
name|toCharArray
argument_list|()
argument_list|,
name|RANGE_ENDS
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementation of {@link #singleWidth()}. */
DECL|class|SingleWidth
specifier|private
specifier|static
specifier|final
class|class
name|SingleWidth
extends|extends
name|RangesMatcher
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|SingleWidth
name|INSTANCE
init|=
operator|new
name|SingleWidth
argument_list|()
decl_stmt|;
DECL|method|SingleWidth ()
specifier|private
name|SingleWidth
parameter_list|()
block|{
name|super
argument_list|(
literal|"CharMatcher.singleWidth()"
argument_list|,
literal|"\u0000\u05be\u05d0\u05f3\u0600\u0750\u0e00\u1e00\u2100\ufb50\ufe70\uff61"
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|"\u04f9\u05be\u05ea\u05f4\u06ff\u077f\u0e7f\u20af\u213a\ufdff\ufeff\uffdc"
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Non-static factory implementation classes
comment|/** Implementation of {@link #negate()}. */
DECL|class|Negated
specifier|private
specifier|static
class|class
name|Negated
extends|extends
name|CharMatcher
block|{
DECL|field|original
specifier|final
name|CharMatcher
name|original
decl_stmt|;
DECL|method|Negated (CharMatcher original)
name|Negated
parameter_list|(
name|CharMatcher
name|original
parameter_list|)
block|{
name|this
operator|.
name|original
operator|=
name|checkNotNull
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|!
name|original
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesNoneOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesAllOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
name|original
operator|.
name|countIn
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|BitSet
name|tmp
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|original
operator|.
name|setBits
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|flip
argument_list|(
name|Character
operator|.
name|MIN_VALUE
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|table
operator|.
name|or
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|original
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|original
operator|+
literal|".negate()"
return|;
block|}
block|}
comment|/** Implementation of {@link #and(CharMatcher)}. */
DECL|class|And
specifier|private
specifier|static
specifier|final
class|class
name|And
extends|extends
name|CharMatcher
block|{
DECL|field|first
specifier|final
name|CharMatcher
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|CharMatcher
name|second
decl_stmt|;
DECL|method|And (CharMatcher a, CharMatcher b)
name|And
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|)
block|{
name|first
operator|=
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|second
operator|=
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|first
operator|.
name|matches
argument_list|(
name|c
argument_list|)
operator|&&
name|second
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|BitSet
name|tmp1
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|first
operator|.
name|setBits
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|BitSet
name|tmp2
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|second
operator|.
name|setBits
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|.
name|and
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|table
operator|.
name|or
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.and("
operator|+
name|first
operator|+
literal|", "
operator|+
name|second
operator|+
literal|")"
return|;
block|}
block|}
comment|/** Implementation of {@link #or(CharMatcher)}. */
DECL|class|Or
specifier|private
specifier|static
specifier|final
class|class
name|Or
extends|extends
name|CharMatcher
block|{
DECL|field|first
specifier|final
name|CharMatcher
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|CharMatcher
name|second
decl_stmt|;
DECL|method|Or (CharMatcher a, CharMatcher b)
name|Or
parameter_list|(
name|CharMatcher
name|a
parameter_list|,
name|CharMatcher
name|b
parameter_list|)
block|{
name|first
operator|=
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|second
operator|=
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|first
operator|.
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|second
operator|.
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|first
operator|.
name|matches
argument_list|(
name|c
argument_list|)
operator|||
name|second
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.or("
operator|+
name|first
operator|+
literal|", "
operator|+
name|second
operator|+
literal|")"
return|;
block|}
block|}
comment|// Static factory implementations
comment|/** Implementation of {@link #is(char)}. */
DECL|class|Is
specifier|private
specifier|static
specifier|final
class|class
name|Is
extends|extends
name|FastMatcher
block|{
DECL|field|match
specifier|private
specifier|final
name|char
name|match
decl_stmt|;
DECL|method|Is (char match)
name|Is
parameter_list|(
name|char
name|match
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match
return|;
block|}
annotation|@
name|Override
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|match
argument_list|,
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|this
else|:
name|none
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|other
else|:
name|super
operator|.
name|or
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|isNot
argument_list|(
name|match
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.is('"
operator|+
name|showCharacter
argument_list|(
name|match
argument_list|)
operator|+
literal|"')"
return|;
block|}
block|}
comment|/** Implementation of {@link #isNot(char)}. */
DECL|class|IsNot
specifier|private
specifier|static
specifier|final
class|class
name|IsNot
extends|extends
name|FastMatcher
block|{
DECL|field|match
specifier|private
specifier|final
name|char
name|match
decl_stmt|;
DECL|method|IsNot (char match)
name|IsNot
parameter_list|(
name|char
name|match
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|!=
name|match
return|;
block|}
annotation|@
name|Override
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|super
operator|.
name|and
argument_list|(
name|other
argument_list|)
else|:
name|other
return|;
block|}
annotation|@
name|Override
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|any
argument_list|()
else|:
name|this
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|match
operator|+
literal|1
argument_list|,
name|Character
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|is
argument_list|(
name|match
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.isNot('"
operator|+
name|showCharacter
argument_list|(
name|match
argument_list|)
operator|+
literal|"')"
return|;
block|}
block|}
DECL|method|isEither (char c1, char c2)
specifier|private
specifier|static
name|CharMatcher
operator|.
name|IsEither
name|isEither
parameter_list|(
name|char
name|c1
parameter_list|,
name|char
name|c2
parameter_list|)
block|{
return|return
operator|new
name|CharMatcher
operator|.
name|IsEither
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
block|}
comment|/** Implementation of {@link #anyOf(CharSequence)} for exactly two characters. */
DECL|class|IsEither
specifier|private
specifier|static
specifier|final
class|class
name|IsEither
extends|extends
name|FastMatcher
block|{
DECL|field|match1
specifier|private
specifier|final
name|char
name|match1
decl_stmt|;
DECL|field|match2
specifier|private
specifier|final
name|char
name|match2
decl_stmt|;
DECL|method|IsEither (char match1, char match2)
name|IsEither
parameter_list|(
name|char
name|match1
parameter_list|,
name|char
name|match2
parameter_list|)
block|{
name|this
operator|.
name|match1
operator|=
name|match1
expr_stmt|;
name|this
operator|.
name|match2
operator|=
name|match2
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match1
operator|||
name|c
operator|==
name|match2
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match1
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|match2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.anyOf(\""
operator|+
name|showCharacter
argument_list|(
name|match1
argument_list|)
operator|+
name|showCharacter
argument_list|(
name|match2
argument_list|)
operator|+
literal|"\")"
return|;
block|}
block|}
comment|/** Implementation of {@link #anyOf(CharSequence)} for three or more characters. */
DECL|class|AnyOf
specifier|private
specifier|static
specifier|final
class|class
name|AnyOf
extends|extends
name|CharMatcher
block|{
DECL|field|chars
specifier|private
specifier|final
name|char
index|[]
name|chars
decl_stmt|;
DECL|method|AnyOf (CharSequence chars)
specifier|public
name|AnyOf
parameter_list|(
name|CharSequence
name|chars
parameter_list|)
block|{
name|this
operator|.
name|chars
operator|=
name|chars
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|this
operator|.
name|chars
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|chars
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
return|;
block|}
annotation|@
name|Override
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|description
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"CharMatcher.anyOf(\""
argument_list|)
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
name|description
operator|.
name|append
argument_list|(
name|showCharacter
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|description
operator|.
name|append
argument_list|(
literal|"\")"
argument_list|)
expr_stmt|;
return|return
name|description
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Implementation of {@link #inRange(char, char)}. */
DECL|class|InRange
specifier|private
specifier|static
specifier|final
class|class
name|InRange
extends|extends
name|FastMatcher
block|{
DECL|field|startInclusive
specifier|private
specifier|final
name|char
name|startInclusive
decl_stmt|;
DECL|field|endInclusive
specifier|private
specifier|final
name|char
name|endInclusive
decl_stmt|;
DECL|method|InRange (char startInclusive, char endInclusive)
name|InRange
parameter_list|(
name|char
name|startInclusive
parameter_list|,
name|char
name|endInclusive
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|endInclusive
operator|>=
name|startInclusive
argument_list|)
expr_stmt|;
name|this
operator|.
name|startInclusive
operator|=
name|startInclusive
expr_stmt|;
name|this
operator|.
name|endInclusive
operator|=
name|endInclusive
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|startInclusive
operator|<=
name|c
operator|&&
name|c
operator|<=
name|endInclusive
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// java.util.BitSet
annotation|@
name|Override
DECL|method|setBits (BitSet table)
name|void
name|setBits
parameter_list|(
name|BitSet
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|startInclusive
argument_list|,
name|endInclusive
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.inRange('"
operator|+
name|showCharacter
argument_list|(
name|startInclusive
argument_list|)
operator|+
literal|"', '"
operator|+
name|showCharacter
argument_list|(
name|endInclusive
argument_list|)
operator|+
literal|"')"
return|;
block|}
block|}
comment|/** Implementation of {@link #forPredicate(Predicate)}. */
DECL|class|ForPredicate
specifier|private
specifier|static
specifier|final
class|class
name|ForPredicate
extends|extends
name|CharMatcher
block|{
DECL|field|predicate
specifier|private
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Character
argument_list|>
name|predicate
decl_stmt|;
DECL|method|ForPredicate (Predicate<? super Character> predicate)
name|ForPredicate
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|Character
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|predicate
operator|=
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches (char c)
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// intentional; deprecation is for callers primarily
annotation|@
name|Override
DECL|method|apply (Character character)
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|checkNotNull
argument_list|(
name|character
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CharMatcher.forPredicate("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

