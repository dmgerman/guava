begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.hash
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
operator|.
name|log2
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|max
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|CEILING
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|HashCodes
operator|.
name|HashCodeSlicer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_comment
comment|/**  * A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test  * with one-sided error: if it claims that an element is contained in it, this might be in error,   * but if it claims that an element is<i>not</i> contained in it, then this is definitely true.  *   *<p>If you are unfamiliar with Bloom filters, this nice   *<a href="http://llimllib.github.com/bloomfilter-tutorial/">tutorial</a> may help you understand   * how they work.  *   * @param<T> the type of instances that the {@code BloomFilter} accepts  * @author Kevin Bourrillion  * @author Dimitris Andreou  * @since 11.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|BloomFilter
specifier|public
specifier|final
class|class
name|BloomFilter
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Serializable
block|{
comment|/** A power of two sized bit set */
DECL|field|bits
specifier|private
specifier|final
name|BitArray
name|bits
decl_stmt|;
comment|/** Number of bits required to index a bit out of {@code bits} */
DECL|field|hashBitsPerSlice
specifier|private
specifier|final
name|int
name|hashBitsPerSlice
decl_stmt|;
comment|/** Number of hashes per element */
DECL|field|numHashFunctions
specifier|private
specifier|final
name|int
name|numHashFunctions
decl_stmt|;
comment|/** The funnel to translate T's to bytes */
DECL|field|funnel
specifier|private
specifier|final
name|Funnel
argument_list|<
name|T
argument_list|>
name|funnel
decl_stmt|;
comment|/** The HashFunction that generates as many bits as this BloomFilter needs */
DECL|field|hashFunction
specifier|private
specifier|final
name|HashFunction
name|hashFunction
decl_stmt|;
comment|/**    * Creates a BloomFilter.     */
DECL|method|BloomFilter (BitArray bits, int numHashFunctions, Funnel<T> funnel, HashFunction hashFunction)
specifier|private
name|BloomFilter
parameter_list|(
name|BitArray
name|bits
parameter_list|,
name|int
name|numHashFunctions
parameter_list|,
name|Funnel
argument_list|<
name|T
argument_list|>
name|funnel
parameter_list|,
name|HashFunction
name|hashFunction
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numHashFunctions
operator|>
literal|0
argument_list|,
literal|"numHashFunctions zero or negative"
argument_list|)
expr_stmt|;
name|this
operator|.
name|bits
operator|=
name|checkNotNull
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|this
operator|.
name|numHashFunctions
operator|=
name|numHashFunctions
expr_stmt|;
name|this
operator|.
name|funnel
operator|=
name|checkNotNull
argument_list|(
name|funnel
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashFunction
operator|=
name|checkNotNull
argument_list|(
name|hashFunction
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashBitsPerSlice
operator|=
name|log2
argument_list|(
name|max
argument_list|(
name|bits
operator|.
name|size
argument_list|()
argument_list|,
name|Long
operator|.
name|SIZE
comment|/* minimum capacity */
argument_list|)
argument_list|,
name|CEILING
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns {@code true} if the element<i>might</i> have been put in this Bloom filter,     * {@code false} if this is<i>definitely</i> not the case.     */
DECL|method|mightContain (T instance)
specifier|public
name|boolean
name|mightContain
parameter_list|(
name|T
name|instance
parameter_list|)
block|{
name|HashCodeSlicer
name|slicer
init|=
name|HashCodes
operator|.
name|slice
argument_list|(
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putObject
argument_list|(
name|instance
argument_list|,
name|funnel
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|,
name|hashBitsPerSlice
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numHashFunctions
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bits
operator|.
name|get
argument_list|(
name|slicer
operator|.
name|nextSlice
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Puts an element into this {@code BloomFilter}. Ensures that subsequent invocations of     * {@link #mightContain(Object)} with the same element will always return {@code true}.    */
DECL|method|put (T instance)
specifier|public
name|void
name|put
parameter_list|(
name|T
name|instance
parameter_list|)
block|{
name|HashCodeSlicer
name|slicer
init|=
name|HashCodes
operator|.
name|slice
argument_list|(
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putObject
argument_list|(
name|instance
argument_list|,
name|funnel
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|,
name|hashBitsPerSlice
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numHashFunctions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextSlice
init|=
name|slicer
operator|.
name|nextSlice
argument_list|()
decl_stmt|;
name|bits
operator|.
name|set
argument_list|(
name|nextSlice
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getHashCount ()
annotation|@
name|VisibleForTesting
name|int
name|getHashCount
parameter_list|()
block|{
return|return
name|numHashFunctions
return|;
block|}
DECL|method|computeExpectedFalsePositiveRate (int insertions)
annotation|@
name|VisibleForTesting
name|double
name|computeExpectedFalsePositiveRate
parameter_list|(
name|int
name|insertions
parameter_list|)
block|{
return|return
name|Math
operator|.
name|pow
argument_list|(
literal|1
operator|-
name|Math
operator|.
name|exp
argument_list|(
operator|-
name|numHashFunctions
operator|*
operator|(
operator|(
name|double
operator|)
name|insertions
operator|/
operator|(
name|bits
operator|.
name|size
argument_list|()
operator|)
operator|)
argument_list|)
argument_list|,
name|numHashFunctions
argument_list|)
return|;
block|}
comment|// This little gem is kindly offered by kevinb
DECL|class|BitArray
specifier|private
specifier|static
class|class
name|BitArray
block|{
DECL|field|data
specifier|final
name|long
index|[]
name|data
decl_stmt|;
DECL|method|BitArray (int bits)
name|BitArray
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|long
index|[
name|bits
operator|>>
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Used by serialization
DECL|method|BitArray (long[] data)
name|BitArray
parameter_list|(
name|long
index|[]
name|data
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|data
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"data length is zero!"
argument_list|)
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
DECL|method|set (int index)
name|void
name|set
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|data
index|[
name|index
operator|>>
literal|6
index|]
operator||=
operator|(
literal|1L
operator|<<
name|index
operator|)
expr_stmt|;
block|}
DECL|method|get (int index)
name|boolean
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|data
index|[
name|index
operator|>>
literal|6
index|]
operator|&
operator|(
literal|1L
operator|<<
name|index
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** Number of bits */
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|data
operator|.
name|length
operator|*
name|Long
operator|.
name|SIZE
return|;
block|}
block|}
comment|/*    * Cheat sheet for the factories:    *     * m: total bits    * n: expected insertions    * b: m/n, bits per insertion     * p: expected false positive probability    *     * 1) Optimal k = b * ln2    * 2) p = (1 - e ^ (-kn/m))^k    * 3) For optimal k: p = 2 ^ (-k) ~= 0.6185^b    * 4) For optimal k: m = -nlnp / ((ln2) ^ 2)    *     * I expect the user to provide "n", and then one of {m,b,p} is needed.    * Providing both (n, m) and (n, b) would be confusing, so I go for the 2nd.    */
comment|/**    * Creates a {@code Builder} of a {@link BloomFilter BloomFilter<T>}, with the expected number     * of insertions and expected false positive probability.    *     *<p>Note that overflowing a {@code BloomFilter} with significantly more elements     * than specified, will result in its saturation, and a sharp deterioration of its    * false positive probability.    *     *<p>The constructed {@code BloomFilter<T>} will be serializable if the provided     * {@code Funnel<T>} is.    *     * @param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use    * @param expectedInsertions the number of expected insertions to the constructed     *        {@code BloomFilter<T>}; must be positive    * @param falsePositiveProbability the desired false positive probability (must be positive and     *        less than 1.0)    * @return a {@code Builder}    */
DECL|method|create (Funnel<T> funnel, int expectedInsertions , double falsePositiveProbability)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|BloomFilter
argument_list|<
name|T
argument_list|>
name|create
parameter_list|(
name|Funnel
argument_list|<
name|T
argument_list|>
name|funnel
parameter_list|,
name|int
name|expectedInsertions
comment|/* n */
parameter_list|,
name|double
name|falsePositiveProbability
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|funnel
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|expectedInsertions
operator|>
literal|0
argument_list|,
literal|"Expected insertions must be positive"
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|falsePositiveProbability
operator|>
literal|0.0
operator|&
name|falsePositiveProbability
operator|<
literal|1.0
argument_list|,
literal|"False positive probability in (0.0, 1.0)"
argument_list|)
expr_stmt|;
comment|/*       * andreou: I wanted to put a warning in the javadoc about tiny fpp values,      * since the resulting size is proportional to -log(p), but there is not      * much of a point after all, e.g. optimalM(1000, 0.0000000000000001) = 76680      * which is less that 10kb. Who cares!      */
name|int
name|m
init|=
name|optimalM
argument_list|(
name|expectedInsertions
argument_list|,
name|falsePositiveProbability
argument_list|)
decl_stmt|;
name|int
name|k
init|=
name|optimalK
argument_list|(
name|expectedInsertions
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|BitArray
name|bits
init|=
operator|new
name|BitArray
argument_list|(
literal|1
operator|<<
name|log2
argument_list|(
name|max
argument_list|(
name|m
argument_list|,
name|Long
operator|.
name|SIZE
comment|/* minimum capacity */
argument_list|)
argument_list|,
name|CEILING
argument_list|)
argument_list|)
decl_stmt|;
name|HashFunction
name|hashFunction
init|=
name|BloomFilterStrategies
operator|.
name|From128ToN
operator|.
name|withBits
argument_list|(
name|bits
operator|.
name|size
argument_list|()
operator|*
name|k
argument_list|,
name|Hashing
operator|.
name|murmur3_128
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|BloomFilter
argument_list|<
name|T
argument_list|>
argument_list|(
name|bits
argument_list|,
name|k
argument_list|,
name|funnel
argument_list|,
name|hashFunction
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code Builder} of a {@link BloomFilter BloomFilter<T>}, with the expected number     * of insertions, and a default expected false positive probability of 3%.    *     *<p>Note that overflowing a {@code BloomFilter} with significantly more elements     * than specified, will result in its saturation, and a sharp deterioration of its    * false positive probability.    *     *<p>The constructed {@code BloomFilter<T>} will be serializable if the provided     * {@code Funnel<T>} is.    *     * @param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use    * @param expectedInsertions the number of expected insertions to the constructed     *        {@code BloomFilter<T>}; must be positive    * @return a {@code Builder}    */
DECL|method|create (Funnel<T> funnel, int expectedInsertions )
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|BloomFilter
argument_list|<
name|T
argument_list|>
name|create
parameter_list|(
name|Funnel
argument_list|<
name|T
argument_list|>
name|funnel
parameter_list|,
name|int
name|expectedInsertions
comment|/* n */
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|funnel
argument_list|,
name|expectedInsertions
argument_list|,
literal|0.03
argument_list|)
return|;
comment|// FYI, for 3%, we always get 5 hash functions
block|}
DECL|field|LN2
specifier|private
specifier|static
specifier|final
name|double
name|LN2
init|=
name|Math
operator|.
name|log
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|LN2_SQUARED
specifier|private
specifier|static
specifier|final
name|double
name|LN2_SQUARED
init|=
name|LN2
operator|*
name|LN2
decl_stmt|;
comment|/**    * Computes the optimal k (number of hashes per element inserted in Bloom filter), given the     * expected insertions and total number of bits in the Bloom filter.    *     * See http://en.wikipedia.org/wiki/File:Bloom_filter_fp_probability.svg for the formula.    *     * @param n expected insertions (must be positive)    * @param m total number of bits in Bloom filter (must be positive)    */
DECL|method|optimalK (int n, int m)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|optimalK
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|m
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|m
operator|/
name|n
operator|*
name|LN2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes m (total bits of Bloom filter) which is expected to achieve, for the specified     * expected insertions, the required false positive probability.    *     * See http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives for the formula.    *     * @param n expected insertions (must be positive)    * @param p false positive rate (must be 0< p< 1)    */
DECL|method|optimalM (int n, double p)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|optimalM
parameter_list|(
name|int
name|n
parameter_list|,
name|double
name|p
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|-
name|n
operator|*
name|Math
operator|.
name|log
argument_list|(
name|p
argument_list|)
operator|/
name|LN2_SQUARED
argument_list|)
return|;
block|}
DECL|method|writeReplace ()
specifier|private
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerialForm
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|class|SerialForm
specifier|private
specifier|static
class|class
name|SerialForm
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|data
specifier|final
name|long
index|[]
name|data
decl_stmt|;
DECL|field|numHashFunctions
specifier|final
name|int
name|numHashFunctions
decl_stmt|;
DECL|field|funnel
specifier|final
name|Funnel
argument_list|<
name|T
argument_list|>
name|funnel
decl_stmt|;
DECL|field|hashFunction
specifier|final
name|HashFunction
name|hashFunction
decl_stmt|;
DECL|method|SerialForm (BloomFilter<T> bf)
name|SerialForm
parameter_list|(
name|BloomFilter
argument_list|<
name|T
argument_list|>
name|bf
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|bf
operator|.
name|bits
operator|.
name|data
expr_stmt|;
name|this
operator|.
name|numHashFunctions
operator|=
name|bf
operator|.
name|numHashFunctions
expr_stmt|;
name|this
operator|.
name|funnel
operator|=
name|bf
operator|.
name|funnel
expr_stmt|;
name|this
operator|.
name|hashFunction
operator|=
name|bf
operator|.
name|hashFunction
expr_stmt|;
block|}
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
return|return
operator|new
name|BloomFilter
argument_list|<
name|T
argument_list|>
argument_list|(
operator|new
name|BitArray
argument_list|(
name|data
argument_list|)
argument_list|,
name|numHashFunctions
argument_list|,
name|funnel
argument_list|,
name|hashFunction
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
block|}
end_class

end_unit

