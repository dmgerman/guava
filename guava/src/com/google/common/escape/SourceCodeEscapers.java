begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.escape
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * A factory for Escaper instances used to escape strings for safe use in  * various common programming languages.  *  * @author Alex Matevossian  * @author David Beaumont  * @since 11.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
DECL|class|SourceCodeEscapers
specifier|public
specifier|final
class|class
name|SourceCodeEscapers
block|{
DECL|method|SourceCodeEscapers ()
specifier|private
name|SourceCodeEscapers
parameter_list|()
block|{ }
comment|// For each xxxEscaper() method, please add links to external reference pages
comment|// that are considered authoritative for the behavior of that escaper.
comment|// From: http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
DECL|field|PRINTABLE_ASCII_MIN
specifier|private
specifier|static
specifier|final
name|char
name|PRINTABLE_ASCII_MIN
init|=
literal|0x20
decl_stmt|;
comment|// ' '
DECL|field|PRINTABLE_ASCII_MAX
specifier|private
specifier|static
specifier|final
name|char
name|PRINTABLE_ASCII_MAX
init|=
literal|0x7E
decl_stmt|;
comment|// '~'
DECL|field|HEX_DIGITS
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|HEX_DIGITS
init|=
literal|"0123456789abcdef"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
comment|/**    * Returns an {@link Escaper} instance that escapes special characters in a    * string so it can safely be included in either a Java character literal or    * string literal. This is the preferred way to escape Java characters for    * use in String or character literals.    *    *<p>See:<a href=    * "http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089"    *>The Java Language Specification</a> for more details.    */
DECL|method|javaCharEscaper ()
specifier|public
specifier|static
name|CharEscaper
name|javaCharEscaper
parameter_list|()
block|{
return|return
name|JAVA_CHAR_ESCAPER
return|;
block|}
DECL|field|JAVA_CHAR_ESCAPER
specifier|private
specifier|static
specifier|final
name|CharEscaper
name|JAVA_CHAR_ESCAPER
decl_stmt|;
DECL|field|JAVA_CHAR_ESCAPER_WITH_OCTAL
specifier|private
specifier|static
specifier|final
name|CharEscaper
name|JAVA_CHAR_ESCAPER_WITH_OCTAL
decl_stmt|;
DECL|field|JAVA_STRING_ESCAPER_WITH_OCTAL
specifier|private
specifier|static
specifier|final
name|CharEscaper
name|JAVA_STRING_ESCAPER_WITH_OCTAL
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|javaMap
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\b'
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\f'
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\n'
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\r'
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\t'
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\"'
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|javaMap
operator|.
name|put
argument_list|(
literal|'\\'
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|JAVA_STRING_ESCAPER_WITH_OCTAL
operator|=
operator|new
name|JavaCharEscaperWithOctal
argument_list|(
name|javaMap
argument_list|)
expr_stmt|;
comment|// The only difference is that the char escaper also escapes single quotes.
name|javaMap
operator|.
name|put
argument_list|(
literal|'\''
argument_list|,
literal|"\\'"
argument_list|)
expr_stmt|;
name|JAVA_CHAR_ESCAPER
operator|=
operator|new
name|JavaCharEscaper
argument_list|(
name|javaMap
argument_list|)
expr_stmt|;
name|JAVA_CHAR_ESCAPER_WITH_OCTAL
operator|=
operator|new
name|JavaCharEscaperWithOctal
argument_list|(
name|javaMap
argument_list|)
expr_stmt|;
block|}
comment|// This escaper does not produce octal escape sequences. See:
comment|// http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089
comment|//  "Octal escapes are provided for compatibility with C, but can express
comment|//   only Unicode values \u0000 through \u00FF, so Unicode escapes are
comment|//   usually preferred."
DECL|class|JavaCharEscaper
specifier|private
specifier|static
class|class
name|JavaCharEscaper
extends|extends
name|ArrayBasedCharEscaper
block|{
DECL|method|JavaCharEscaper (Map<Character, String> replacements)
name|JavaCharEscaper
parameter_list|(
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|)
block|{
name|super
argument_list|(
name|replacements
argument_list|,
name|PRINTABLE_ASCII_MIN
argument_list|,
name|PRINTABLE_ASCII_MAX
argument_list|)
expr_stmt|;
block|}
DECL|method|escapeUnsafe (char c)
annotation|@
name|Override
specifier|protected
name|char
index|[]
name|escapeUnsafe
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|asUnicodeHexEscape
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
DECL|class|JavaCharEscaperWithOctal
specifier|private
specifier|static
class|class
name|JavaCharEscaperWithOctal
extends|extends
name|ArrayBasedCharEscaper
block|{
DECL|method|JavaCharEscaperWithOctal (Map<Character, String> replacements)
name|JavaCharEscaperWithOctal
parameter_list|(
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|)
block|{
name|super
argument_list|(
name|replacements
argument_list|,
name|PRINTABLE_ASCII_MIN
argument_list|,
name|PRINTABLE_ASCII_MAX
argument_list|)
expr_stmt|;
block|}
DECL|method|escapeUnsafe (char c)
annotation|@
name|Override
specifier|protected
name|char
index|[]
name|escapeUnsafe
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|0x100
condition|)
block|{
return|return
name|asOctalEscape
argument_list|(
name|c
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|asUnicodeHexEscape
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Returns a {@link CharEscaper} instance that replaces non-ASCII characters    * in a string with their Unicode escape sequences ({@code \\uxxxx} where    * {@code xxxx} is a hex number). Existing escape sequences won't be affected.    *    *<p>As existing escape sequences are not re-escaped, this escaper is    * idempotent. However this means that there can be no well defined inverse    * function for this escaper.    *    *<p><b>Note</b></p>: the returned escaper is still a {@code CharEscaper} and    * will not combine surrogate pairs into a single code point before escaping.    */
DECL|method|javaStringUnicodeEscaper ()
specifier|public
specifier|static
name|CharEscaper
name|javaStringUnicodeEscaper
parameter_list|()
block|{
return|return
name|JAVA_STRING_UNICODE_ESCAPER
return|;
block|}
DECL|field|JAVA_STRING_UNICODE_ESCAPER
specifier|private
specifier|static
specifier|final
name|CharEscaper
name|JAVA_STRING_UNICODE_ESCAPER
init|=
operator|new
name|CharEscaper
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|char
index|[]
name|escape
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|asUnicodeHexEscape
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns an {@link Escaper} instance that replaces non-ASCII characters    * in a string with their equivalent Javascript UTF-16 escape sequences    * "{@literal \}unnnn", "\xnn" or special replacement sequences "\b", "\t",    * "\n", "\f", "\r" or "\\".    */
DECL|method|javascriptEscaper ()
specifier|public
specifier|static
name|CharEscaper
name|javascriptEscaper
parameter_list|()
block|{
return|return
name|JAVASCRIPT_ESCAPER
return|;
block|}
comment|/**    * A CharEscaper for javascript strings. Turns all non-ASCII characters into    * ASCII javascript escape sequences.    */
DECL|field|JAVASCRIPT_ESCAPER
specifier|private
specifier|static
specifier|final
name|CharEscaper
name|JAVASCRIPT_ESCAPER
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|jsMap
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\''
argument_list|,
literal|"\\x27"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'"'
argument_list|,
literal|"\\x22"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'<'
argument_list|,
literal|"\\x3c"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'='
argument_list|,
literal|"\\x3d"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'>'
argument_list|,
literal|"\\x3e"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'&'
argument_list|,
literal|"\\x26"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\b'
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\t'
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\n'
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\f'
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\r'
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
name|jsMap
operator|.
name|put
argument_list|(
literal|'\\'
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|JAVASCRIPT_ESCAPER
operator|=
operator|new
name|ArrayBasedCharEscaper
argument_list|(
name|jsMap
argument_list|,
name|PRINTABLE_ASCII_MIN
argument_list|,
name|PRINTABLE_ASCII_MAX
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|char
index|[]
name|escapeUnsafe
parameter_list|(
name|char
name|c
parameter_list|)
block|{
comment|// Do two digit hex escape for value less than 0x100.
if|if
condition|(
name|c
operator|<
literal|0x100
condition|)
block|{
name|char
index|[]
name|r
init|=
operator|new
name|char
index|[
literal|4
index|]
decl_stmt|;
name|r
index|[
literal|3
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
name|c
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
name|asUnicodeHexEscape
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
comment|/**    * Returns an {@link Escaper} instance that escapes special characters    * from a string so it can safely be included in a Python Unicode string    * literal.    *    *<p>The escaper returned by this method will correctly deal with all Unicode    * code point values and generate escape sequences of the form    * "{@literal \}unnnn" or "\Unnnnnnnn".    *    *<p><b>Note</b>: According to the    *<a href=    * "http://docs.python.org/reference/lexical_analysis.html#string-literals">    * Python reference documentation</a> the following escape sequences are    * recognized in string literals:    *<ul>    *<li>'\a'  ASCII Bell (BEL)</li>    *<li>'\b'  ASCII Backspace (BS)</li>    *<li>'\f'  ASCII Formfeed (FF)</li>    *<li>'\n'  ASCII Linefeed (LF)</li>    *<li>'\r'  ASCII Carriage Return (CR)</li>    *<li>'\t'  ASCII Horizontal Tab (TAB)</li>    *<li>'\\'  Backslash (\)</li>    *<li>'\''  Single quote (')</li>    *<li>'\"'  Double quote (")</li>    *</ul>    *<p>However in order to match the output of the Python {@code repr()}    * function this escaper only escapes '\n', '\r', '\t', '\\', '\'' and '\"'.    * The remaining ASCII control characters are escaped in the form "\xnn".    */
DECL|method|pythonEscaper ()
specifier|public
specifier|static
name|UnicodeEscaper
name|pythonEscaper
parameter_list|()
block|{
return|return
name|PYTHON_ESCAPER
return|;
block|}
DECL|field|PYTHON_ESCAPER
specifier|private
specifier|static
specifier|final
name|UnicodeEscaper
name|PYTHON_ESCAPER
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|pythonMap
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\n'
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\r'
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\t'
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\\'
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\''
argument_list|,
literal|"\\\'"
argument_list|)
expr_stmt|;
name|pythonMap
operator|.
name|put
argument_list|(
literal|'\"'
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|PYTHON_ESCAPER
operator|=
operator|new
name|ArrayBasedUnicodeEscaper
argument_list|(
name|pythonMap
argument_list|,
name|PRINTABLE_ASCII_MIN
argument_list|,
name|PRINTABLE_ASCII_MAX
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|char
index|[]
name|escapeUnsafe
parameter_list|(
name|int
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|<
literal|0x100
condition|)
block|{
comment|// Format as \xnn
name|char
index|[]
name|r
init|=
operator|new
name|char
index|[
literal|4
index|]
decl_stmt|;
name|r
index|[
literal|3
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<
literal|0x10000
condition|)
block|{
return|return
name|asUnicodeHexEscape
argument_list|(
operator|(
name|char
operator|)
name|cp
argument_list|)
return|;
block|}
else|else
block|{
comment|// Format as \Unnnnnnnn
name|char
index|[]
name|r
init|=
operator|new
name|char
index|[
literal|10
index|]
decl_stmt|;
name|r
index|[
literal|9
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|8
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|7
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|6
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|5
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|4
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|3
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|cp
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|HEX_DIGITS
index|[
name|cp
operator|&
literal|0xF
index|]
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
literal|'U'
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
comment|// Helper for common case of escaping a single char.
DECL|method|asUnicodeHexEscape (char c)
specifier|private
specifier|static
name|char
index|[]
name|asUnicodeHexEscape
parameter_list|(
name|char
name|c
parameter_list|)
block|{
comment|// Equivalent to String.format("\\u%04x", (int)c);
name|char
index|[]
name|r
init|=
operator|new
name|char
index|[
literal|6
index|]
decl_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
literal|'u'
expr_stmt|;
name|r
index|[
literal|5
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
name|c
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|4
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
name|c
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|3
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
name|c
operator|>>>=
literal|4
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0xF
index|]
expr_stmt|;
return|return
name|r
return|;
block|}
comment|// Helper for backward compatible octal escape sequences (c< 256)
DECL|method|asOctalEscape (char c)
specifier|private
specifier|static
name|char
index|[]
name|asOctalEscape
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|char
index|[]
name|r
init|=
operator|new
name|char
index|[
literal|4
index|]
decl_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|r
index|[
literal|3
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0x7
index|]
expr_stmt|;
name|c
operator|>>>=
literal|3
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0x7
index|]
expr_stmt|;
name|c
operator|>>>=
literal|3
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|HEX_DIGITS
index|[
name|c
operator|&
literal|0x3
index|]
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
end_class

end_unit

