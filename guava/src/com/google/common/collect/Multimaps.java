begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NullnessCasts
operator|.
name|uncheckedCastNullableTToT
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|LazyInit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Provides static methods acting on or generating a {@code Multimap}.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps"> {@code  * Multimaps}</a>.  *  * @author Jared Levy  * @author Robert Konigsberg  * @author Mike Bostock  * @author Louis Wasserman  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|ElementTypesAreNonnullByDefault
DECL|class|Multimaps
specifier|public
specifier|final
class|class
name|Multimaps
block|{
DECL|method|Multimaps ()
specifier|private
name|Multimaps
parameter_list|()
block|{}
comment|/**    * Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the    * specified supplier. The keys and values of the entries are the result of applying the provided    * mapping functions to the input elements, accumulated in the encounter order of the stream.    *    *<p>Example:    *    *<pre>{@code    * static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP =    *     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")    *         .collect(    *             toMultimap(    *                  str -> str.charAt(0),    *                  str -> str.substring(1),    *                  MultimapBuilder.treeKeys().arrayListValues()::build));    *    * // is equivalent to    *    * static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP;    *    * static {    *     FIRST_LETTER_MULTIMAP = MultimapBuilder.treeKeys().arrayListValues().build();    *     FIRST_LETTER_MULTIMAP.put('b', "anana");    *     FIRST_LETTER_MULTIMAP.put('a', "pple");    *     FIRST_LETTER_MULTIMAP.put('a', "sparagus");    *     FIRST_LETTER_MULTIMAP.put('c', "arrot");    *     FIRST_LETTER_MULTIMAP.put('c', "herry");    * }    * }</pre>    *    *<p>To collect to an {@link ImmutableMultimap}, use either {@link    * ImmutableSetMultimap#toImmutableSetMultimap} or {@link    * ImmutableListMultimap#toImmutableListMultimap}.    *    * @since 21.0    */
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|,
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|,
name|M
expr|extends
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
DECL|method|toMultimap ( java.util.function.Function<? super T, ? extends K> keyFunction, java.util.function.Function<? super T, ? extends V> valueFunction, java.util.function.Supplier<M> multimapSupplier)
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|M
argument_list|>
name|toMultimap
argument_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|keyFunction
operator|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|valueFunction
operator|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
argument_list|<
name|M
argument_list|>
name|multimapSupplier
argument_list|)
block|{
return|return
name|CollectCollectors
operator|.
name|toMultimap
argument_list|(
name|keyFunction
argument_list|,
name|valueFunction
argument_list|,
name|multimapSupplier
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the    * specified supplier. Each input element is mapped to a key and a stream of values, each of which    * are put into the resulting {@code Multimap}, in the encounter order of the stream and the    * encounter order of the streams of values.    *    *<p>Example:    *    *<pre>{@code    * static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =    *     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")    *         .collect(    *             flatteningToMultimap(    *                  str -> str.charAt(0),    *                  str -> str.substring(1).chars().mapToObj(c -> (char) c),    *                  MultimapBuilder.linkedHashKeys().arrayListValues()::build));    *    * // is equivalent to    *    * static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP;    *    * static {    *     FIRST_LETTER_MULTIMAP = MultimapBuilder.linkedHashKeys().arrayListValues().build();    *     FIRST_LETTER_MULTIMAP.putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'));    *     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('p', 'p', 'l', 'e'));    *     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'));    *     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'));    *     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'));    * }    * }</pre>    *    * @since 21.0    */
annotation|@
name|Beta
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|,
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|,
name|M
expr|extends
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
DECL|method|flatteningToMultimap ( java.util.function.Function<? super T, ? extends K> keyFunction, java.util.function.Function<? super T, ? extends Stream<? extends V>> valueFunction, java.util.function.Supplier<M> multimapSupplier)
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|M
argument_list|>
name|flatteningToMultimap
argument_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|keyFunction
operator|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|Stream
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|valueFunction
operator|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
argument_list|<
name|M
argument_list|>
name|multimapSupplier
argument_list|)
block|{
return|return
name|CollectCollectors
operator|.
name|flatteningToMultimap
argument_list|(
name|keyFunction
argument_list|,
name|valueFunction
argument_list|,
name|multimapSupplier
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code Multimap} backed by {@code map}, whose internal value collections are    * generated by {@code factory}.    *    *<p><b>Warning: do not use</b> this method when the collections returned by {@code factory}    * implement either {@link List} or {@code Set}! Use the more specific method {@link    * #newListMultimap}, {@link #newSetMultimap} or {@link #newSortedSetMultimap} instead, to avoid    * very surprising behavior from {@link Multimap#equals}.    *    *<p>The {@code factory}-generated and {@code map} classes determine the multimap iteration    * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code    * toString} methods for the multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()} does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the collections generated by    * {@code factory}, and the multimap contents are all serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the multimap, even if    * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will    * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link    * #synchronizedMultimap}.    *    *<p>Call this method only when the simpler methods {@link ArrayListMultimap#create()}, {@link    * HashMultimap#create()}, {@link LinkedHashMultimap#create()}, {@link    * LinkedListMultimap#create()}, {@link TreeMultimap#create()}, and {@link    * TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and the collections    * returned by {@code factory}. Those objects should not be manually updated and they should not    * use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding values    * @param factory supplier of new, empty collections that will each hold all values for a given    *     key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newMultimap ( Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory)
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
return|return
operator|new
name|CustomMultimap
argument_list|<>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomMultimap
specifier|private
specifier|static
name|class
name|CustomMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractMapBasedMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
block|;
DECL|method|CustomMultimap (Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory)
name|CustomMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
block|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
argument_list|()
block|{
return|return
name|createMaybeNavigableKeySet
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
argument_list|()
block|{
return|return
name|createMaybeNavigableAsMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createCollection ()
specifier|protected
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|unmodifiableCollectionSubclass ( Collection<E> collection)
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|Collection
argument_list|<
name|E
argument_list|>
name|unmodifiableCollectionSubclass
argument_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
argument_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|NavigableSet
condition|)
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
operator|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|wrapCollection (@arametricNullness K key, Collection<V> collection)
name|Collection
argument_list|<
name|V
argument_list|>
name|wrapCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|wrapList
argument_list|(
name|key
argument_list|,
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|NavigableSet
condition|)
block|{
return|return
operator|new
name|WrappedNavigableSet
argument_list|(
name|key
argument_list|,
operator|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|key
argument_list|,
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
operator|new
name|WrappedSet
argument_list|(
name|key
argument_list|,
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|WrappedCollection
argument_list|(
name|key
argument_list|,
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|// can't use Serialization writeMultimap and populateMultimap methods since
end_comment

begin_comment
comment|// there's no way to generate the empty backing map.
end_comment

begin_comment
comment|/** @serialData the factory and the backing map */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectOutputStream
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|backingMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectInputStream
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|factory
operator|=
operator|(
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|setMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// java serialization not supported
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a    * multimap based on arbitrary {@link Map} and {@link List} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the multimap iteration    * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code    * toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code    * removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory    * does. However, the multimap's {@code get} method returns instances of a different class than    * does {@code factory.get()}.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code    * factory}, and the multimap contents are all serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the multimap, even if    * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will    * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link    * #synchronizedListMultimap}.    *    *<p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link    * LinkedListMultimap#create()} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by    * {@code factory}. Those objects should not be manually updated, they should be empty when    * provided, and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding values    * @param factory supplier of new, empty lists that will each hold all values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|newListMultimap ( Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newListMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|final
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
return|return
operator|new
name|CustomListMultimap
argument_list|<>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
DECL|class|CustomListMultimap
specifier|private
specifier|static
name|class
name|CustomListMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
block|;
DECL|method|CustomListMultimap (Map<K, Collection<V>> map, Supplier<? extends List<V>> factory)
name|CustomListMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
block|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
argument_list|()
block|{
return|return
name|createMaybeNavigableKeySet
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
argument_list|()
block|{
return|return
name|createMaybeNavigableAsMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|createCollection ()
specifier|protected
name|List
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** @serialData the factory and the backing map */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectOutputStream
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|backingMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectInputStream
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|factory
operator|=
operator|(
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|setMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// java serialization not supported
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a    * multimap based on arbitrary {@link Map} and {@link Set} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the multimap iteration    * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code    * toString} methods for the multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()} does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code    * factory}, and the multimap contents are all serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the multimap, even if    * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will    * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link    * #synchronizedSetMultimap}.    *    *<p>Call this method only when the simpler methods {@link HashMultimap#create()}, {@link    * LinkedHashMultimap#create()}, {@link TreeMultimap#create()}, and {@link    * TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by    * {@code factory}. Those objects should not be manually updated and they should not use soft,    * weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding values    * @param factory supplier of new, empty sets that will each hold all values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|newSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSetMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
return|return
operator|new
name|CustomSetMultimap
argument_list|<>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
DECL|class|CustomSetMultimap
specifier|private
specifier|static
name|class
name|CustomSetMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
block|;
DECL|method|CustomSetMultimap (Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory)
name|CustomSetMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
block|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
argument_list|()
block|{
return|return
name|createMaybeNavigableKeySet
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
argument_list|()
block|{
return|return
name|createMaybeNavigableAsMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|createCollection ()
specifier|protected
name|Set
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_annotation
annotation|@
name|Override
end_annotation

begin_expr_stmt
DECL|method|unmodifiableCollectionSubclass ( Collection<E> collection)
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|Collection
argument_list|<
name|E
argument_list|>
name|unmodifiableCollectionSubclass
argument_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
argument_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|NavigableSet
condition|)
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
operator|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_else

begin_function
unit|}      @
name|Override
DECL|method|wrapCollection (@arametricNullness K key, Collection<V> collection)
name|Collection
argument_list|<
name|V
argument_list|>
name|wrapCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|NavigableSet
condition|)
block|{
return|return
operator|new
name|WrappedNavigableSet
argument_list|(
name|key
argument_list|,
operator|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|key
argument_list|,
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|WrappedSet
argument_list|(
name|key
argument_list|,
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** @serialData the factory and the backing map */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectOutputStream
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|backingMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectInputStream
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|factory
operator|=
operator|(
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|setMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// not needed in emulated source
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Creates a new {@code SortedSetMultimap} that uses the provided map and factory. It can generate    * a multimap based on arbitrary {@link Map} and {@link SortedSet} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the multimap iteration    * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code    * toString} methods for the multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()} does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code    * factory}, and the multimap contents are all serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the multimap, even if    * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will    * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link    * #synchronizedSortedSetMultimap}.    *    *<p>Call this method only when the simpler methods {@link TreeMultimap#create()} and {@link    * TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by    * {@code factory}. Those objects should not be manually updated and they should not use soft,    * weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding values    * @param factory supplier of new, empty sorted sets that will each hold all values for a given    *     key    * @throws IllegalArgumentException if {@code map} is not empty    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|newSortedSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory)
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSortedSetMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|final
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
return|return
operator|new
name|CustomSortedSetMultimap
argument_list|<>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
DECL|class|CustomSortedSetMultimap
specifier|private
specifier|static
name|class
name|CustomSortedSetMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
block|;     @
DECL|field|valueComparator
name|CheckForNull
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
block|;
DECL|method|CustomSortedSetMultimap (Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
name|CustomSortedSetMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
argument_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
block|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
block|;
name|valueComparator
operator|=
name|factory
operator|.
name|get
argument_list|()
operator|.
name|comparator
argument_list|()
block|;     }
expr|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
argument_list|()
block|{
return|return
name|createMaybeNavigableKeySet
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
argument_list|()
block|{
return|return
name|createMaybeNavigableAsMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|createCollection ()
specifier|protected
name|SortedSet
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|valueComparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|valueComparator
return|;
block|}
end_function

begin_comment
comment|/** @serialData the factory and the backing map */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectOutputStream
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|backingMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|GwtIncompatible
comment|// java.io.ObjectInputStream
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|factory
operator|=
operator|(
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|valueComparator
operator|=
name|factory
operator|.
name|get
argument_list|()
operator|.
name|comparator
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|setMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// not needed in emulated source
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Copies each key-value mapping in {@code source} into {@code dest}, with its key and value    * reversed.    *    *<p>If {@code source} is an {@link ImmutableMultimap}, consider using {@link    * ImmutableMultimap#inverse} instead.    *    * @param source any multimap    * @param dest the multimap to copy into; usually empty    * @return {@code dest}    */
end_comment

begin_expr_stmt
unit|@
name|CanIgnoreReturnValue
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|,
name|M
expr|extends
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
DECL|method|invertFrom (Multimap<? extends V, ? extends K> source, M dest)
name|M
name|invertFrom
argument_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|source
operator|,
name|M
name|dest
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|dest
argument_list|)
block|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|entry
range|:
name|source
operator|.
name|entries
argument_list|()
control|)
block|{
name|dest
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|dest
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns a synchronized (thread-safe) multimap backed by the specified multimap. In order to    * guarantee serial access, it is critical that<b>all</b> access to the backing multimap is    * accomplished through the returned multimap.    *    *<p>It is imperative that the user manually synchronize on the returned multimap when accessing    * any of its collection views:    *    *<pre>{@code    * Multimap<K, V> multimap = Multimaps.synchronizedMultimap(    *     HashMultimap.<K, V>create());    * ...    * Collection<V> values = multimap.get(key);  // Needn't be in synchronized block    * ...    * synchronized (multimap) {  // Synchronizing on multimap, not values!    *   Iterator<V> i = values.iterator(); // Must be in synchronized block    *   while (i.hasNext()) {    *     foo(i.next());    *   }    * }    * }</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and {@link    * Multimap#replaceValues} methods return collections that aren't synchronized.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param multimap the multimap to be wrapped in a synchronized view    * @return a synchronized view of the specified multimap    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|synchronizedMultimap (Multimap<K, V> multimap)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedMultimap
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
name|Synchronized
operator|.
name|multimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an unmodifiable view of the specified multimap. Query operations on the returned    * multimap "read through" to the specified multimap, and attempts to modify the returned    * multimap, either directly or through the multimap's views, result in an {@code    * UnsupportedOperationException}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified multimap    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|unmodifiableMultimap (Multimap<K, V> delegate)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMultimap
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|UnmodifiableMultimap
argument_list|<>
argument_list|(
name|delegate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_function
unit|@
name|Deprecated
DECL|method|unmodifiableMultimap (ImmutableMultimap<K, V> delegate)
specifier|public
specifier|static
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMultimap
parameter_list|(
name|ImmutableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
DECL|class|UnmodifiableMultimap
specifier|private
specifier|static
name|class
name|UnmodifiableMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|ForwardingMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|Serializable
block|{
DECL|field|delegate
name|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
block|;     @
DECL|field|entries
name|LazyInit
expr|@
name|CheckForNull
specifier|transient
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
block|;     @
DECL|field|keys
name|LazyInit
expr|@
name|CheckForNull
specifier|transient
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
block|;     @
DECL|field|keySet
name|LazyInit
expr|@
name|CheckForNull
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
block|;     @
DECL|field|values
name|LazyInit
expr|@
name|CheckForNull
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
block|;     @
DECL|field|map
name|LazyInit
expr|@
name|CheckForNull
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
block|;
DECL|method|UnmodifiableMultimap (final Multimap<K, V> delegate)
name|UnmodifiableMultimap
argument_list|(
name|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|()
block|{
return|return
name|delegate
return|;
block|}
expr|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
argument_list|()
block|{
throw|throw
argument_list|new
name|UnsupportedOperationException
argument_list|()
block|;     }
expr|@
name|Override
DECL|method|asMap ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
argument_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
operator|=
name|map
block|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|map
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Maps
operator|.
name|transformValues
argument_list|(
name|delegate
operator|.
name|asMap
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|}))
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|}       return
name|result
expr_stmt|;
end_expr_stmt

begin_function
unit|}      @
name|Override
DECL|method|entries ()
specifier|public
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entries
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|entries
operator|=
name|result
operator|=
name|unmodifiableEntries
argument_list|(
name|delegate
operator|.
name|entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|forEach (BiConsumer<? super K, ? super V> consumer)
specifier|public
name|void
name|forEach
parameter_list|(
name|BiConsumer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|consumer
parameter_list|)
block|{
name|delegate
operator|.
name|forEach
argument_list|(
name|checkNotNull
argument_list|(
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|delegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|keys ()
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
name|Multiset
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keys
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keys
operator|=
name|result
operator|=
name|Multisets
operator|.
name|unmodifiableMultiset
argument_list|(
name|delegate
operator|.
name|keys
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keySet
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|put (@arametricNullness K key, @ParametricNullness V value)
specifier|public
name|boolean
name|put
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|boolean
name|putAll
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|remove (@heckForNull Object key, @CheckForNull Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|}    private
DECL|class|UnmodifiableListMultimap
specifier|static
name|class
name|UnmodifiableListMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableListMultimap (ListMultimap<K, V> delegate)
name|UnmodifiableListMultimap
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|delegate ()
specifier|public
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|()
block|{
return|return
operator|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|get
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|}    private
DECL|class|UnmodifiableSetMultimap
specifier|static
name|class
name|UnmodifiableSetMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSetMultimap (SetMultimap<K, V> delegate)
name|UnmodifiableSetMultimap
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|delegate ()
specifier|public
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|()
block|{
return|return
operator|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|)
block|{
comment|/*        * Note that this doesn't return a SortedSet when delegate is a        * SortedSetMultiset, unlike (SortedSet<V>) super.get().        */
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|entries ()
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
name|delegate
argument_list|()
operator|.
name|entries
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|}    private
DECL|class|UnmodifiableSortedSetMultimap
specifier|static
name|class
name|UnmodifiableSortedSetMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|UnmodifiableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSortedSetMultimap (SortedSetMultimap<K, V> delegate)
name|UnmodifiableSortedSetMultimap
argument_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|delegate ()
specifier|public
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|()
block|{
return|return
operator|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|get
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|valueComparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|delegate
argument_list|()
operator|.
name|valueComparator
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|synchronizedSetMultimap (SetMultimap<K, V> multimap)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedSetMultimap
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
name|Synchronized
operator|.
name|setMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an unmodifiable view of the specified {@code SetMultimap}. Query operations on the    * returned multimap "read through" to the specified multimap, and attempts to modify the returned    * multimap, either directly or through the multimap's views, result in an {@code    * UnsupportedOperationException}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified multimap    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|unmodifiableSetMultimap (SetMultimap<K, V> delegate)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSetMultimap
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableSetMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableSetMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|UnmodifiableSetMultimap
argument_list|<>
argument_list|(
name|delegate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_function
unit|@
name|Deprecated
DECL|method|unmodifiableSetMultimap ( ImmutableSetMultimap<K, V> delegate)
specifier|public
specifier|static
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSetMultimap
parameter_list|(
name|ImmutableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by the specified    * multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|synchronizedSortedSetMultimap (SortedSetMultimap<K, V> multimap)
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedSortedSetMultimap
argument_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
name|Synchronized
operator|.
name|sortedSetMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an unmodifiable view of the specified {@code SortedSetMultimap}. Query operations on    * the returned multimap "read through" to the specified multimap, and attempts to modify the    * returned multimap, either directly or through the multimap's views, result in an {@code    * UnsupportedOperationException}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified multimap    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|unmodifiableSortedSetMultimap (SortedSetMultimap<K, V> delegate)
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSortedSetMultimap
argument_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableSortedSetMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|UnmodifiableSortedSetMultimap
argument_list|<>
argument_list|(
name|delegate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|synchronizedListMultimap (ListMultimap<K, V> multimap)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedListMultimap
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
name|Synchronized
operator|.
name|listMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an unmodifiable view of the specified {@code ListMultimap}. Query operations on the    * returned multimap "read through" to the specified multimap, and attempts to modify the returned    * multimap, either directly or through the multimap's views, result in an {@code    * UnsupportedOperationException}.    *    *<p>The returned multimap will be serializable if the specified multimap is serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified multimap    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|unmodifiableListMultimap (ListMultimap<K, V> delegate)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableListMultimap
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
argument_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableListMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableListMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|UnmodifiableListMultimap
argument_list|<>
argument_list|(
name|delegate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_function
unit|@
name|Deprecated
DECL|method|unmodifiableListMultimap ( ImmutableListMultimap<K, V> delegate)
specifier|public
specifier|static
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableListMultimap
parameter_list|(
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an unmodifiable view of the specified collection, preserving the interface for    * instances of {@code SortedSet}, {@code Set}, {@code List} and {@code Collection}, in that order    * of preference.    *    * @param collection the collection for which to return an unmodifiable view    * @return an unmodifiable view of the collection    */
end_comment

begin_expr_stmt
DECL|method|unmodifiableValueCollection ( Collection<V> collection)
specifier|private
specifier|static
operator|<
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Collection
argument_list|<
name|V
argument_list|>
name|unmodifiableValueCollection
argument_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
argument_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
end_elseif

begin_return
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns an unmodifiable view of the specified collection of entries. The {@link Entry#setValue}    * operation throws an {@link UnsupportedOperationException}. If the specified collection is a    * {@code Set}, the returned collection is also a {@code Set}.    *    * @param entries the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
end_comment

begin_expr_stmt
unit|private
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|unmodifiableEntries (Collection<Entry<K, V>> entries)
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntries
argument_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
argument_list|)
block|{
if|if
condition|(
name|entries
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
operator|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
operator|)
name|entries
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|new
name|Maps
operator|.
name|UnmodifiableEntries
argument_list|<>
argument_list|(
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|entries
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,    * Collection<V>>} to {@code Map<K, List<V>>}.    *    * @since 15.0    */
end_comment

begin_expr_stmt
unit|@
name|Beta
expr|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe by specification of ListMultimap.asMap()
DECL|method|asMap ( ListMultimap<K, V> multimap)
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Map
argument_list|<
name|K
argument_list|,
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
call|(
name|Map
argument_list|<
name|K
argument_list|,
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
call|)
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|)
name|multimap
operator|.
name|asMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,    * Collection<V>>} to {@code Map<K, Set<V>>}.    *    * @since 15.0    */
end_comment

begin_annotation
annotation|@
name|Beta
end_annotation

begin_annotation
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
end_annotation

begin_comment
comment|// safe by specification of SetMultimap.asMap()
end_comment

begin_expr_stmt
DECL|method|asMap ( SetMultimap<K, V> multimap)
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Map
argument_list|<
name|K
argument_list|,
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
call|(
name|Map
argument_list|<
name|K
argument_list|,
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
call|)
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|)
name|multimap
operator|.
name|asMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type corrected from {@code    * Map<K, Collection<V>>} to {@code Map<K, SortedSet<V>>}.    *    * @since 15.0    */
end_comment

begin_annotation
annotation|@
name|Beta
end_annotation

begin_annotation
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
end_annotation

begin_comment
comment|// safe by specification of SortedSetMultimap.asMap()
end_comment

begin_expr_stmt
DECL|method|asMap ( SortedSetMultimap<K, V> multimap)
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Map
argument_list|<
name|K
argument_list|,
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
argument_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
call|(
name|Map
argument_list|<
name|K
argument_list|,
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
call|)
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|)
name|multimap
operator|.
name|asMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for parity with the other    * more strongly-typed {@code asMap()} implementations.    *    * @since 15.0    */
end_comment

begin_annotation
annotation|@
name|Beta
end_annotation

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|asMap (Multimap<K, V> multimap)
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
return|return
name|multimap
operator|.
name|asMap
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a multimap view of the specified map. The multimap is backed by the map, so changes to    * the map are reflected in the multimap, and vice versa. If the map is modified while an    * iteration over one of the multimap's collection views is in progress (except through the    * iterator's own {@code remove} operation, or through the {@code setValue} operation on a map    * entry returned by the iterator), the results of the iteration are undefined.    *    *<p>The multimap supports mapping removal, which removes the corresponding mapping from the map.    * It does not support any operations which might add mappings, such as {@code put}, {@code    * putAll} or {@code replaceValues}.    *    *<p>The returned multimap will be serializable if the specified map is serializable.    *    * @param map the backing map for the returned multimap view    */
end_comment

begin_expr_stmt
DECL|method|forMap ( Map<K, V> map)
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|forMap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
argument_list|)
block|{
return|return
operator|new
name|MapMultimap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @see Multimaps#forMap */
end_comment

begin_expr_stmt
DECL|class|MapMultimap
specifier|private
specifier|static
name|class
name|MapMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|,
name|Serializable
block|{
DECL|field|map
name|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
block|;
DECL|method|MapMultimap (Map<K, V> map)
name|MapMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
argument_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
argument_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|containsKey (@heckForNull Object key)
specifier|public
name|boolean
name|containsKey
argument_list|(
annotation|@
name|CheckForNull
name|Object
name|key
argument_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|containsValue (@heckForNull Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|containsEntry (@heckForNull Object key, @CheckForNull Object value)
specifier|public
name|boolean
name|containsEntry
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|get (final K key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
operator|new
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
name|int
name|i
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|i
operator|++
expr_stmt|;
comment|/*                * The cast is safe because of the containsKey check in hasNext(). (That means it's                * unsafe under concurrent modification, but all bets are off then, anyway.)                */
return|return
name|uncheckedCastNullableTToT
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|put (@arametricNullness K key, @ParametricNullness V value)
specifier|public
name|boolean
name|put
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|boolean
name|putAll
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|remove (@heckForNull Object key, @CheckForNull Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|remove
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|values
init|=
operator|new
name|HashSet
argument_list|<
name|V
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|values
return|;
block|}
name|values
operator|.
name|add
argument_list|(
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|map
operator|.
name|keySet
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|entries ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createEntries ()
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntries
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unreachable"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createKeys ()
name|Multiset
argument_list|<
name|K
argument_list|>
name|createKeys
parameter_list|()
block|{
return|return
operator|new
name|Multimaps
operator|.
name|Keys
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
parameter_list|()
block|{
return|return
operator|new
name|AsMap
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|map
operator|.
name|hashCode
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7845222491160860175L
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|/**    * Returns a view of a multimap where each value is transformed by a function. All other    * properties of the multimap, such as iteration order, are left intact. For example, the code:    *    *<pre>{@code    * Multimap<String, Integer> multimap =    *     ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);    * Function<Integer, String> square = new Function<Integer, String>() {    *     public String apply(Integer in) {    *       return Integer.toString(in * in);    *     }    * };    * Multimap<String, String> transformed =    *     Multimaps.transformValues(multimap, square);    *   System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=[4, 16], b=[9, 9], c=[36]}}.    *    *<p>Changes in the underlying multimap are reflected in this view. Conversely, this view    * supports removal operations, and these are reflected in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys, and even null values    * provided that the function is capable of accepting null input. The transformed multimap might    * contain null values, if the function sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the underlying multimap    * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,    * since there is not a definition of {@code equals} or {@code hashCode} for general collections,    * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a    * {@code Set}.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned    * multimap to be a view, but it means that the function will be applied many times for bulk    * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to    * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned    * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your    * choosing.    *    * @since 7.0    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|transformValues ( Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
argument_list|,
name|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
block|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
operator|=
name|Maps
operator|.
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
block|;
return|return
name|transformEntries
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a view of a {@code ListMultimap} where each value is transformed by a function. All    * other properties of the multimap, such as iteration order, are left intact. For example, the    * code:    *    *<pre>{@code    * ListMultimap<String, Integer> multimap    *      = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);    * Function<Integer, Double> sqrt =    *     new Function<Integer, Double>() {    *       public Double apply(Integer in) {    *         return Math.sqrt((int) in);    *       }    *     };    * ListMultimap<String, Double> transformed = Multimaps.transformValues(map,    *     sqrt);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.    *    *<p>Changes in the underlying multimap are reflected in this view. Conversely, this view    * supports removal operations, and these are reflected in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys, and even null values    * provided that the function is capable of accepting null input. The transformed multimap might    * contain null values, if the function sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the underlying multimap    * is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned    * multimap to be a view, but it means that the function will be applied many times for bulk    * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to    * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned    * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your    * choosing.    *    * @since 7.0    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|transformValues ( ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
argument_list|,
name|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
block|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
operator|=
name|Maps
operator|.
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
block|;
return|return
name|transformEntries
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a view of a multimap whose values are derived from the original multimap's entries. In    * contrast to {@link #transformValues}, this method's entry-transformation logic may depend on    * the key as well as the value.    *    *<p>All other properties of the transformed multimap, such as iteration order, are left intact.    * For example, the code:    *    *<pre>{@code    * SetMultimap<String, Integer> multimap =    *     ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);    * EntryTransformer<String, Integer, String> transformer =    *     new EntryTransformer<String, Integer, String>() {    *       public String transformEntry(String key, Integer value) {    *          return (value>= 0) ? key : "no" + key;    *       }    *     };    * Multimap<String, String> transformed =    *     Multimaps.transformEntries(multimap, transformer);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=[a, a], b=[nob]}}.    *    *<p>Changes in the underlying multimap are reflected in this view. Conversely, this view    * supports removal operations, and these are reflected in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys and null values provided    * that the transformer is capable of accepting null inputs. The transformed multimap might    * contain null values if the transformer sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the underlying multimap    * is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,    * since there is not a definition of {@code equals} or {@code hashCode} for general collections,    * and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a    * {@code Set}.    *    *<p>The transformer is applied lazily, invoked when needed. This is necessary for the returned    * multimap to be a view, but it means that the transformer will be applied many times for bulk    * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap    * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code    * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the    * transformed multimap.    *    * @since 7.0    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|transformEntries ( Multimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
argument_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
argument_list|)
block|{
return|return
operator|new
name|TransformedEntriesMultimap
argument_list|<>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a view of a {@code ListMultimap} whose values are derived from the original multimap's    * entries. In contrast to {@link #transformValues(ListMultimap, Function)}, this method's    * entry-transformation logic may depend on the key as well as the value.    *    *<p>All other properties of the transformed multimap, such as iteration order, are left intact.    * For example, the code:    *    *<pre>{@code    * Multimap<String, Integer> multimap =    *     ImmutableMultimap.of("a", 1, "a", 4, "b", 6);    * EntryTransformer<String, Integer, String> transformer =    *     new EntryTransformer<String, Integer, String>() {    *       public String transformEntry(String key, Integer value) {    *         return key + value;    *       }    *     };    * Multimap<String, String> transformed =    *     Multimaps.transformEntries(multimap, transformer);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {"a"=["a1", "a4"], "b"=["b6"]}}.    *    *<p>Changes in the underlying multimap are reflected in this view. Conversely, this view    * supports removal operations, and these are reflected in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys and null values provided    * that the transformer is capable of accepting null inputs. The transformed multimap might    * contain null values if the transformer sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the underlying multimap    * is.    *    *<p>The transformer is applied lazily, invoked when needed. This is necessary for the returned    * multimap to be a view, but it means that the transformer will be applied many times for bulk    * operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap    * doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code    * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the    * transformed multimap.    *    * @since 7.0    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|transformEntries ( ListMultimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
argument_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
argument_list|)
block|{
return|return
operator|new
name|TransformedEntriesListMultimap
argument_list|<>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
DECL|class|TransformedEntriesMultimap
specifier|private
specifier|static
name|class
name|TransformedEntriesMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromMultimap
name|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
block|;
DECL|field|transformer
name|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
block|;
DECL|method|TransformedEntriesMultimap ( Multimap<K, V1> fromMultimap, final EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesMultimap
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
argument_list|,
name|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
argument_list|)
block|{
name|this
operator|.
name|fromMultimap
operator|=
name|checkNotNull
argument_list|(
name|fromMultimap
argument_list|)
block|;
name|this
operator|.
name|transformer
operator|=
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
block|;     }
DECL|method|transform (@arametricNullness K key, Collection<V1> values)
name|Collection
argument_list|<
name|V2
argument_list|>
name|transform
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|values
argument_list|)
block|{
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
operator|=
name|Maps
operator|.
name|asValueToValueFunction
argument_list|(
name|transformer
argument_list|,
name|key
argument_list|)
block|;
if|if
condition|(
name|values
operator|instanceof
name|List
condition|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
operator|(
name|List
argument_list|<
name|V1
argument_list|>
operator|)
name|values
argument_list|,
name|function
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|values
argument_list|,
name|function
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
unit|}      @
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V2
argument_list|>
argument_list|>
name|createAsMap
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|transformEntries
argument_list|(
name|fromMultimap
operator|.
name|asMap
argument_list|()
argument_list|,
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|transformEntry
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|value
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMultimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|containsKey (@heckForNull Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMultimap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createEntries ()
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|createEntries
parameter_list|()
block|{
return|return
operator|new
name|Entries
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromMultimap
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Maps
operator|.
expr|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
operator|>
name|asEntryToEntryFunction
argument_list|(
name|transformer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|get (final K key)
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|fromMultimap
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|keySet
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createKeys ()
name|Multiset
argument_list|<
name|K
argument_list|>
name|createKeys
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|keys
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|put (@arametricNullness K key, V2 value)
specifier|public
name|boolean
name|put
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|V2
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (@arametricNullness K key, Iterable<? extends V2> values)
specifier|public
name|boolean
name|putAll
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V2> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V2
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|remove (@heckForNull Object key, @CheckForNull Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|value
parameter_list|)
block|{
return|return
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
operator|.
name|remove
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMultimap
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V2> values)
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V2
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|fromMultimap
operator|.
name|entries
argument_list|()
argument_list|,
name|Maps
operator|.
expr|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
operator|>
name|asEntryToValueFunction
argument_list|(
name|transformer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|}    private
DECL|class|TransformedEntriesListMultimap
specifier|static
name|final
name|class
name|TransformedEntriesListMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V1
expr|extends @
name|Nullable
name|Object
operator|,
name|V2
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|TransformedEntriesMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
expr|implements
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|TransformedEntriesListMultimap ( ListMultimap<K, V1> fromMultimap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesListMultimap
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
argument_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
argument_list|)
block|{
name|super
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|transform (@arametricNullness K key, Collection<V1> values)
name|List
argument_list|<
name|V2
argument_list|>
name|transform
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|values
argument_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
operator|(
name|List
argument_list|<
name|V1
argument_list|>
operator|)
name|values
argument_list|,
name|Maps
operator|.
name|asValueToValueFunction
argument_list|(
name|transformer
argument_list|,
name|key
argument_list|)
argument_list|)
return|;
block|}
expr|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|get
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|fromMultimap
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMultimap
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V2> values)
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
end_function

begin_comment
unit|}
comment|/**    * Creates an index {@code ImmutableListMultimap} that contains the results of applying a    * specified function to each item in an {@code Iterable} of values. Each value will be stored as    * a value in the resulting multimap, yielding a multimap with the same size as the input    * iterable. The key used to store that value in the multimap will be the result of calling the    * function on that value. The resulting multimap is created as an immutable snapshot. In the    * returned multimap, keys appear in the order they are first encountered, and the values    * corresponding to each key appear in the same order as they are encountered.    *    *<p>For example,    *    *<pre>{@code    * List<String> badGuys =    *     Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");    * Function<String, Integer> stringLengthFunction = ...;    * Multimap<Integer, String> index =    *     Multimaps.index(badGuys, stringLengthFunction);    * System.out.println(index);    * }</pre>    *    *<p>prints    *    *<pre>{@code    * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}    * }</pre>    *    *<p>The returned multimap is serializable if its keys and values are all serializable.    *    * @param values the values to use when constructing the {@code ImmutableListMultimap}    * @param keyFunction the function used to produce the key for each value    * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code    *     keyFunction} on each value in the input collection to that value    * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code    *     keyFunction} produces {@code null} for any key    */
end_comment

begin_function
DECL|method|index ( Iterable<V> values, Function<? super V, K> keyFunction)
unit|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|index
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
return|return
name|index
argument_list|(
name|values
operator|.
name|iterator
argument_list|()
argument_list|,
name|keyFunction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an index {@code ImmutableListMultimap} that contains the results of applying a    * specified function to each item in an {@code Iterator} of values. Each value will be stored as    * a value in the resulting multimap, yielding a multimap with the same size as the input    * iterator. The key used to store that value in the multimap will be the result of calling the    * function on that value. The resulting multimap is created as an immutable snapshot. In the    * returned multimap, keys appear in the order they are first encountered, and the values    * corresponding to each key appear in the same order as they are encountered.    *    *<p>For example,    *    *<pre>{@code    * List<String> badGuys =    *     Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");    * Function<String, Integer> stringLengthFunction = ...;    * Multimap<Integer, String> index =    *     Multimaps.index(badGuys.iterator(), stringLengthFunction);    * System.out.println(index);    * }</pre>    *    *<p>prints    *    *<pre>{@code    * {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}    * }</pre>    *    *<p>The returned multimap is serializable if its keys and values are all serializable.    *    * @param values the values to use when constructing the {@code ImmutableListMultimap}    * @param keyFunction the function used to produce the key for each value    * @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code    *     keyFunction} on each value in the input collection to that value    * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code    *     keyFunction} produces {@code null} for any key    * @since 10.0    */
end_comment

begin_function
DECL|method|index ( Iterator<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|index
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|V
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
DECL|class|Keys
specifier|static
name|class
name|Keys
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractMultiset
argument_list|<
name|K
argument_list|>
block|{     @
DECL|field|multimap
name|Weak
name|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
block|;
DECL|method|Keys (Multimap<K, V> multimap)
name|Keys
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
name|this
operator|.
name|multimap
operator|=
name|multimap
block|;     }
expr|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
name|entryIterator
argument_list|()
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|,
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|backingEntry
parameter_list|)
block|{
return|return
operator|new
name|Multisets
operator|.
name|AbstractEntry
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getElement
parameter_list|()
block|{
return|return
name|backingEntry
operator|.
name|getKey
argument_list|()
return|;
block|}
expr|@
name|Override
specifier|public
name|int
name|getCount
argument_list|()
block|{
return|return
name|backingEntry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|};         }       }
empty_stmt|;
end_empty_stmt

begin_function
unit|}      @
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|K
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|multimap
operator|.
name|entries
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|Map
operator|.
name|Entry
operator|::
name|getKey
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|forEach (Consumer<? super K> consumer)
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|K
argument_list|>
name|consumer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|multimap
operator|.
name|entries
argument_list|()
operator|.
name|forEach
argument_list|(
name|entry
lambda|->
name|consumer
operator|.
name|accept
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|distinctElements ()
name|int
name|distinctElements
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|contains (@heckForNull Object element)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
return|return
name|multimap
operator|.
name|containsKey
argument_list|(
name|element
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|keyIterator
argument_list|(
name|multimap
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|count (@heckForNull Object element)
specifier|public
name|int
name|count
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
argument_list|,
name|element
argument_list|)
decl_stmt|;
return|return
operator|(
name|values
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|values
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|remove (@heckForNull Object element, int occurrences)
specifier|public
name|int
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|occurrences
argument_list|,
literal|"occurrences"
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
argument_list|,
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|oldCount
init|=
name|values
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|occurrences
operator|>=
name|oldCount
condition|)
block|{
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
init|=
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|occurrences
condition|;
name|i
operator|++
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|oldCount
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|elementSet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|elementSet
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|keySet
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|elementIterator ()
name|Iterator
argument_list|<
name|K
argument_list|>
name|elementIterator
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should never be called"
argument_list|)
throw|;
block|}
end_function

begin_comment
unit|}
comment|/** A skeleton implementation of {@link Multimap#entries()}. */
end_comment

begin_expr_stmt
DECL|class|Entries
unit|abstract
specifier|static
name|class
name|Entries
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractCollection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|multimap ()
specifier|abstract
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|()
block|;      @
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
argument_list|()
block|{
return|return
name|multimap
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|contains (@heckForNull Object o)
specifier|public
name|boolean
name|contains
argument_list|(
annotation|@
name|CheckForNull
name|Object
name|o
argument_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|multimap
argument_list|()
operator|.
name|containsEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
literal|false
return|;
end_return

begin_function
unit|}      @
name|Override
DECL|method|remove (@heckForNull Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|multimap
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/** A skeleton implementation of {@link Multimap#asMap()}. */
end_comment

begin_expr_stmt
DECL|class|AsMap
unit|static
name|final
name|class
name|AsMap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|Maps
operator|.
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{     @
DECL|field|multimap
name|Weak
specifier|private
name|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
block|;
DECL|method|AsMap (Multimap<K, V> multimap)
name|AsMap
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|)
block|{
name|this
operator|.
name|multimap
operator|=
name|checkNotNull
argument_list|(
name|multimap
argument_list|)
block|;     }
expr|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
argument_list|()
block|{
return|return
name|multimap
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|createEntrySet
argument_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
DECL|method|removeValuesForKey (@heckForNull Object key)
name|void
name|removeValuesForKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|multimap
operator|.
name|keySet
argument_list|()
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_class
annotation|@
name|WeakOuter
DECL|class|EntrySet
class|class
name|EntrySet
extends|extends
name|Maps
operator|.
name|EntrySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|map ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|asMapEntryIterator
argument_list|(
name|multimap
operator|.
name|keySet
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|multimap
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@heckForNull Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// requireNonNull is safe because of the contains check.
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
name|requireNonNull
argument_list|(
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
decl_stmt|;
name|removeValuesForKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_class

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|get (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|multimap
operator|.
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
else|:
literal|null
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|remove (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|multimap
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
else|:
literal|null
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|keySet
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|containsKey (@heckForNull Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|multimap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a    * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a key that doesn't    * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose keys satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 11.0    */
end_comment

begin_expr_stmt
DECL|method|filterKeys ( Multimap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
argument_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SetMultimap
condition|)
block|{
return|return
name|filterKeys
argument_list|(
operator|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|ListMultimap
condition|)
block|{
return|return
name|filterKeys
argument_list|(
operator|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredKeyMultimap
condition|)
block|{
name|FilteredKeyMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
init|=
operator|(
name|FilteredKeyMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
return|return
operator|new
name|FilteredKeyMultimap
argument_list|<>
argument_list|(
name|prev
operator|.
name|unfiltered
argument_list|,
name|Predicates
operator|.
expr|<
name|K
operator|>
name|and
argument_list|(
name|prev
operator|.
name|keyPredicate
argument_list|,
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredMultimap
condition|)
block|{
name|FilteredMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
init|=
operator|(
name|FilteredMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
return|return
name|filterFiltered
argument_list|(
name|prev
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
return|return
operator|new
name|FilteredKeyMultimap
argument_list|<>
argument_list|(
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
end_else

begin_comment
unit|}
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a    * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a key that doesn't    * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose keys satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 14.0    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterKeys ( SetMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
argument_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredKeySetMultimap
condition|)
block|{
name|FilteredKeySetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
init|=
operator|(
name|FilteredKeySetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
return|return
operator|new
name|FilteredKeySetMultimap
argument_list|<>
argument_list|(
name|prev
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|K
operator|>
name|and
argument_list|(
name|prev
operator|.
name|keyPredicate
argument_list|,
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSetMultimap
condition|)
block|{
name|FilteredSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
init|=
operator|(
name|FilteredSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
return|return
name|filterFiltered
argument_list|(
name|prev
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
return|return
operator|new
name|FilteredKeySetMultimap
argument_list|<>
argument_list|(
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
end_else

begin_comment
unit|}
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a    * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a key that doesn't    * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose keys satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 14.0    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterKeys ( ListMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
argument_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
argument_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredKeyListMultimap
condition|)
block|{
name|FilteredKeyListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
init|=
operator|(
name|FilteredKeyListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
return|return
operator|new
name|FilteredKeyListMultimap
argument_list|<>
argument_list|(
name|prev
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|K
operator|>
name|and
argument_list|(
name|prev
operator|.
name|keyPredicate
argument_list|,
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
operator|new
name|FilteredKeyListMultimap
argument_list|<>
argument_list|(
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
end_else

begin_comment
unit|}
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a    * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a value that doesn't    * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose value satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 11.0    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterValues ( Multimap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
argument_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a    * predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a value that doesn't    * satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose value satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 14.0    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterValues ( SetMultimap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
argument_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The    * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a key/value pair that    * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose keys satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 11.0    */
end_comment

begin_expr_stmt
specifier|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterEntries ( Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
argument_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
block|;
if|if
condition|(
name|unfiltered
operator|instanceof
name|SetMultimap
condition|)
block|{
return|return
name|filterEntries
argument_list|(
operator|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredMultimap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The    * returned multimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting multimap's views have iterators that don't support {@code remove()}, but all    * other methods are supported by the multimap and its views. When adding a key/value pair that    * doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code    * replaceValues()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * multimap or its views, only mappings whose keys satisfy the filter will be removed from the    * underlying multimap.    *    *<p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying multimap and determine which satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy the filtered multimap and use the    * copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 14.0    */
end_comment

begin_expr_stmt
unit|public
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterEntries ( SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
argument_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
block|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredSetMultimap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntrySetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Support removal operations when filtering a filtered multimap. Since a filtered multimap has    * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would    * lead to a multimap whose removal operations would fail. This method combines the predicates to    * avoid that problem.    */
end_comment

begin_expr_stmt
specifier|private
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterFiltered ( FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate)
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
argument_list|(
name|FilteredMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
argument_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
operator|=
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|multimap
operator|.
name|entryPredicate
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
block|;
return|return
operator|new
name|FilteredEntryMultimap
argument_list|<>
argument_list|(
name|multimap
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Support removal operations when filtering a filtered multimap. Since a filtered multimap has    * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would    * lead to a multimap whose removal operations would fail. This method combines the predicates to    * avoid that problem.    */
end_comment

begin_expr_stmt
specifier|private
specifier|static
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|filterFiltered ( FilteredSetMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate)
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
argument_list|(
name|FilteredSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
argument_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
operator|=
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|multimap
operator|.
name|entryPredicate
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
block|;
return|return
operator|new
name|FilteredEntrySetMultimap
argument_list|<>
argument_list|(
name|multimap
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
DECL|method|equalsImpl (Multimap<?, ?> multimap, @CheckForNull Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|multimap
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|multimap
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Multimap
condition|)
block|{
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|asMap
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|// TODO(jlevy): Create methods that filter a SortedSetMultimap.
end_comment

unit|}
end_unit

