begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
operator|.
name|FilteredCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArraySet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Set} instances. Also see this  * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets">  * {@code Sets}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @author Chris Povirk  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Sets
specifier|public
specifier|final
class|class
name|Sets
block|{
DECL|method|Sets ()
specifier|private
name|Sets
parameter_list|()
block|{}
comment|/**    * {@link AbstractSet} substitute without the potentially-quadratic    * {@code removeAll} implementation.    */
DECL|class|ImprovedAbstractSet
specifier|abstract
specifier|static
class|class
name|ImprovedAbstractSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|removeAllImpl
argument_list|(
name|this
argument_list|,
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
comment|// GWT compatibility
block|}
block|}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements are provided to the method.    *    * @param anElement one of the elements the set should contain    * @param otherElements the rest of the elements the set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet ( E anElement, E... otherElements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|E
name|anElement
parameter_list|,
name|E
modifier|...
name|otherElements
parameter_list|)
block|{
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|anElement
argument_list|,
name|otherElements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements appear in the given collection.    *    * @param elements the elements, all of the same {@code enum} type, that the    *     set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet (Iterable<E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|ImmutableEnumSet
condition|)
block|{
return|return
operator|(
name|ImmutableEnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|elements
return|;
block|}
elseif|else
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|elements
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|EnumSet
operator|.
name|copyOf
argument_list|(
name|collection
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|Iterator
argument_list|<
name|E
argument_list|>
name|itr
init|=
name|elements
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|enumSet
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|itr
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|enumSet
argument_list|,
name|itr
argument_list|)
expr_stmt|;
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|enumSet
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
block|}
block|}
DECL|class|Accumulator
specifier|private
specifier|static
specifier|final
class|class
name|Accumulator
parameter_list|<
name|E
extends|extends
name|Enum
parameter_list|<
name|E
parameter_list|>
parameter_list|>
block|{
specifier|static
specifier|final
name|Collector
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|?
argument_list|,
name|ImmutableSet
argument_list|<
name|?
extends|extends
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
DECL|field|TO_IMMUTABLE_ENUM_SET
name|TO_IMMUTABLE_ENUM_SET
init|=
operator|(
name|Collector
operator|)
name|Collector
operator|.
expr|<
name|Enum
decl_stmt|,
name|Accumulator
decl_stmt|,
name|ImmutableSet
argument_list|<
name|?
argument_list|>
decl|>
name|of
argument_list|(
name|Accumulator
operator|::
operator|new
argument_list|,
name|Accumulator
operator|::
name|add
argument_list|,
name|Accumulator
operator|::
name|combine
argument_list|,
name|Accumulator
operator|::
name|toImmutableSet
argument_list|,
name|Collector
operator|.
name|Characteristics
operator|.
name|UNORDERED
argument_list|)
decl_stmt|;
DECL|field|set
specifier|private
name|EnumSet
argument_list|<
name|E
argument_list|>
name|set
decl_stmt|;
DECL|method|add (E e)
name|void
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
name|EnumSet
operator|.
name|of
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|combine (Accumulator<E> other)
name|Accumulator
argument_list|<
name|E
argument_list|>
name|combine
parameter_list|(
name|Accumulator
argument_list|<
name|E
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|set
operator|==
literal|null
condition|)
block|{
return|return
name|other
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|set
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
name|this
operator|.
name|set
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|set
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
DECL|method|toImmutableSet ()
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|toImmutableSet
parameter_list|()
block|{
return|return
operator|(
name|set
operator|==
literal|null
operator|)
condition|?
name|ImmutableSet
operator|.
expr|<
name|E
operator|>
name|of
argument_list|()
else|:
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|set
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableSet}    * with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the    * resulting set will iterate over elements in their enum definition order, not encounter order.    *    * @since 21.0    */
annotation|@
name|Beta
DECL|method|toImmutableEnumSet ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Collector
argument_list|<
name|E
argument_list|,
name|?
argument_list|,
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|toImmutableEnumSet
parameter_list|()
block|{
return|return
operator|(
name|Collector
operator|)
name|Accumulator
operator|.
name|TO_IMMUTABLE_ENUM_SET
return|;
block|}
comment|/**    * Returns a new,<i>mutable</i> {@code EnumSet} instance containing the given elements in their    * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also    * accepts non-{@code Collection} iterables and empty iterables.    */
DECL|method|newEnumSet ( Iterable<E> iterable, Class<E> elementType)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|newEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|elementType
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|elementType
argument_list|)
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|iterable
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// HashSet
comment|/**    * Creates a<i>mutable</i>, initially empty {@code HashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If    * {@code E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly    * consider using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to    * get deterministic iteration behavior.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code HashSet} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    */
DECL|method|newHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance initially containing the given elements.    *    *<p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use    * {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an    * {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider    * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get    * deterministic iteration behavior.    *    *<p>This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList    * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.    * This method is not actually very useful and will likely be deprecated in the future.    */
DECL|method|newHashSet (E... elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSetWithExpectedSize
argument_list|(
name|elements
operator|.
name|length
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Returns a new hash set using the smallest initial table size that can hold {@code expectedSize}    * elements without resizing. Note that this is not what {@link HashSet#HashSet(int)} does, but it    * is what most users want and expect it to do.    *    *<p>This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.    *    * @param expectedSize the number of elements you expect to add to the returned set    * @return a new, empty hash set with enough capacity to hold {@code expectedSize} elements    *     without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|newHashSetWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSetWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given elements. A very thin    * convenience for creating an empty set then calling {@link Collection#addAll} or {@link    * Iterables#addAll}.    *    *<p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link    * ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link    * FluentIterable} and call {@code elements.toSet()}.)    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}    * instead.    *    *<p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't    * need this method. Instead, use the {@code HashSet} constructor directly, taking advantage of    * the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    *<p>Overall, this method is not very useful and will likely be deprecated in the future.    */
DECL|method|newHashSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
else|:
name|newHashSet
argument_list|(
name|elements
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given elements. A very thin    * convenience for creating an empty set and then calling {@link Iterators#addAll}.    *    *<p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link    * ImmutableSet#copyOf(Iterator)} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}    * instead.    *    *<p>Overall, this method is not very useful and will likely be deprecated in the future.    */
DECL|method|newHashSet (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSet
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a thread-safe set backed by a hash map. The set is backed by a    * {@link ConcurrentHashMap} instance, and thus carries the same concurrency    * guarantees.    *    *<p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be    * used as an element. The set is serializable.    *    * @return a new, empty thread-safe {@code Set}    * @since 15.0    */
DECL|method|newConcurrentHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newConcurrentHashSet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a thread-safe set backed by a hash map and containing the given    * elements. The set is backed by a {@link ConcurrentHashMap} instance, and    * thus carries the same concurrency guarantees.    *    *<p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be    * used as an element. The set is serializable.    *    * @param elements the elements that the set should contain    * @return a new thread-safe set containing those elements (minus duplicates)    * @throws NullPointerException if {@code elements} or any of its contents is    *      null    * @since 15.0    */
DECL|method|newConcurrentHashSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newConcurrentHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|Set
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newConcurrentHashSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// LinkedHashSet
comment|/**    * Creates a<i>mutable</i>, empty {@code LinkedHashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code LinkedHashSet} constructor directly, taking advantage of    * the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code LinkedHashSet}    */
DECL|method|newLinkedHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code LinkedHashSet} instance, with a high enough "initial capacity" that it    *<i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be    * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed    * that the method isn't inadvertently<i>oversizing</i> the returned set.    *    * @param expectedSize the number of elements you expect to add to the returned set    * @return a new, empty {@code LinkedHashSet} with enough capacity to hold {@code expectedSize}    *         elements without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    * @since 11.0    */
DECL|method|newLinkedHashSetWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSetWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code LinkedHashSet} instance containing the given elements in order.    *    *<p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link    * ImmutableSet#copyOf(Iterable)} instead.    *    *<p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't    * need this method. Instead, use the {@code LinkedHashSet} constructor directly, taking advantage    * of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    *<p>Overall, this method is not very useful and will likely be deprecated in the future.    *    * @param elements the elements that the set should contain, in order    * @return a new {@code LinkedHashSet} containing those elements (minus duplicates)    */
DECL|method|newLinkedHashSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// TreeSet
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance sorted by the natural sort ordering of    * its elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#of()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code TreeSet}    */
DECL|method|newTreeSet ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code TreeSet} instance containing the given elements sorted by their    * natural ordering.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#copyOf(Iterable)}    * instead.    *    *<p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit comparator, this    * method has different behavior than {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code    * TreeSet} with that comparator.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    *<p>This method is just a small convenience for creating an empty set and then calling {@link    * Iterables#addAll}. This method is not very useful and will likely be deprecated in the future.    *    * @param elements the elements that the set should contain    * @return a new {@code TreeSet} containing those elements (minus duplicates)    */
DECL|method|newTreeSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newTreeSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance with the given comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedSet.orderedBy(comparator).build()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>. One caveat to this is that the {@code    * TreeSet} constructor uses a null {@code Comparator} to mean "natural ordering," whereas this    * factory rejects null. Clean your code accordingly.    *    * @param comparator the comparator to use to sort the set    * @return a new, empty {@code TreeSet}    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|newTreeSet (Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an empty {@code Set} that uses identity to determine equality. It    * compares object references, instead of calling {@code equals}, to    * determine whether a provided object matches an element in the set. For    * example, {@code contains} returns {@code false} when passed an object that    * equals a set member, but isn't the same instance. This behavior is similar    * to the way {@code IdentityHashMap} handles key lookups.    *    * @since 8.0    */
DECL|method|newIdentityHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newIdentityHashSet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|newSetFromMap
argument_list|(
name|Maps
operator|.
expr|<
name|E
argument_list|,
name|Boolean
operator|>
name|newIdentityHashMap
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates an empty {@code CopyOnWriteArraySet} instance.    *    *<p><b>Note:</b> if you need an immutable empty {@link Set}, use    * {@link Collections#emptySet} instead.    *    * @return a new, empty {@code CopyOnWriteArraySet}    * @since 12.0    */
annotation|@
name|GwtIncompatible
comment|// CopyOnWriteArraySet
DECL|method|newCopyOnWriteArraySet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|CopyOnWriteArraySet
argument_list|<
name|E
argument_list|>
name|newCopyOnWriteArraySet
parameter_list|()
block|{
return|return
operator|new
name|CopyOnWriteArraySet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code CopyOnWriteArraySet} instance containing the given elements.    *    * @param elements the elements that the set should contain, in order    * @return a new {@code CopyOnWriteArraySet} containing those elements    * @since 12.0    */
annotation|@
name|GwtIncompatible
comment|// CopyOnWriteArraySet
DECL|method|newCopyOnWriteArraySet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|CopyOnWriteArraySet
argument_list|<
name|E
argument_list|>
name|newCopyOnWriteArraySet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// We copy elements to an ArrayList first, rather than incurring the
comment|// quadratic cost of adding them to the COWAS directly.
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elementsCollection
init|=
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
else|:
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
decl_stmt|;
return|return
operator|new
name|CopyOnWriteArraySet
argument_list|<
name|E
argument_list|>
argument_list|(
name|elementsCollection
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. If the collection is an {@link EnumSet}, this    * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,    * the specified collection must contain at least one element, in order to    * determine the element type. If the collection could be empty, use    * {@link #complementOf(Collection, Class)} instead of this method.    *    * @param collection the collection whose complement should be stored in the    *     enum set    * @return a new, modifiable {@code EnumSet} containing all values of the enum    *     that aren't present in the given collection    * @throws IllegalArgumentException if {@code collection} is not an    *     {@code EnumSet} instance and contains no elements    */
DECL|method|complementOf (Collection<E> collection)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|EnumSet
condition|)
block|{
return|return
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
operator|!
name|collection
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"collection is empty; use the other version of this method"
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|E
argument_list|>
name|type
init|=
name|collection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
return|return
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. This is equivalent to    * {@link EnumSet#complementOf}, but can act on any input collection, as long    * as the elements are of enum type.    *    * @param collection the collection whose complement should be stored in the    *     {@code EnumSet}    * @param type the type of the elements in the set    * @return a new, modifiable {@code EnumSet} initially containing all the    *     values of the enum not present in the given collection    */
DECL|method|complementOf ( Collection<E> collection, Class<E> type)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
operator|(
name|collection
operator|instanceof
name|EnumSet
operator|)
condition|?
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
else|:
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|makeComplementByHand ( Collection<E> collection, Class<E> type)
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|makeComplementByHand
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|result
operator|.
name|removeAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns a set backed by the specified map. The resulting set displays    * the same ordering, concurrency, and performance characteristics as the    * backing map. In essence, this factory method provides a {@link Set}    * implementation corresponding to any {@link Map} implementation. There is no    * need to use this method on a {@link Map} implementation that already has a    * corresponding {@link Set} implementation (such as {@link java.util.HashMap}    * or {@link java.util.TreeMap}).    *    *<p>Each method invocation on the set returned by this method results in    * exactly one method invocation on the backing map or its {@code keySet}    * view, with one exception. The {@code addAll} method is implemented as a    * sequence of {@code put} invocations on the backing map.    *    *<p>The specified map must be empty at the time this method is invoked,    * and should not be accessed directly after this method returns. These    * conditions are ensured if the map is created empty, passed directly    * to this method, and no reference to the map is retained, as illustrated    * in the following code fragment:<pre>  {@code    *    *   Set<Object> identityHashSet = Sets.newSetFromMap(    *       new IdentityHashMap<Object, Boolean>());}</pre>    *    *<p>The returned set is serializable if the backing map is.    *    * @param map the backing map    * @return the set backed by the map    * @throws IllegalArgumentException if {@code map} is not empty    * @deprecated Use {@link Collections#newSetFromMap} instead. This method    *     will be removed in December 2017.    */
annotation|@
name|Deprecated
DECL|method|newSetFromMap (Map<E, Boolean> map)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newSetFromMap
parameter_list|(
name|Map
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
name|map
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|newSetFromMap
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * An unmodifiable view of a set which may be backed by other sets; this view    * will change as the backing sets do. Contains methods to copy the data into    * a new set which will then remain stable. There is usually no reason to    * retain a reference of type {@code SetView}; typically, you either use it    * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or    * {@link #copyInto} and forget the {@code SetView} itself.    *    * @since 2.0    */
DECL|class|SetView
specifier|public
specifier|abstract
specifier|static
class|class
name|SetView
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|SetView ()
specifier|private
name|SetView
parameter_list|()
block|{}
comment|// no subclasses but our own
comment|/**      * Returns an immutable copy of the current contents of this set view.      * Does not support null elements.      *      *<p><b>Warning:</b> this may have unexpected results if a backing set of      * this view uses a nonstandard notion of equivalence, for example if it is      * a {@link TreeSet} using a comparator that is inconsistent with {@link      * Object#equals(Object)}.      */
DECL|method|immutableCopy ()
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Copies the current contents of this set view into an existing set. This      * method has equivalent behavior to {@code set.addAll(this)}, assuming that      * all the sets involved are based on the same notion of equivalence.      *      * @return a reference to {@code set}, for convenience      */
comment|// Note: S should logically extend Set<? super E> but can't due to either
comment|// some javac bug or some weirdness in the spec, not sure which.
annotation|@
name|CanIgnoreReturnValue
DECL|method|copyInto (S set)
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|add (E e)
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|remove (Object object)
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|addAll (Collection<? extends E> newElements)
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|newElements
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|removeAll (Collection<?> oldElements)
specifier|public
specifier|final
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|oldElements
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|removeIf (java.util.function.Predicate<? super E> filter)
specifier|public
specifier|final
name|boolean
name|removeIf
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|filter
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|retainAll (Collection<?> elementsToKeep)
specifier|public
specifier|final
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToKeep
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Guaranteed to throw an exception and leave the collection unmodified.      *      * @throws UnsupportedOperationException always      * @deprecated Unsupported operation.      */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|clear ()
specifier|public
specifier|final
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Scope the return type to {@link UnmodifiableIterator} to ensure this is an unmodifiable view.      *      * @since 20.0 (present with return type {@link Iterator} since 2.0)      */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
specifier|abstract
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
function_decl|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the union of two sets. The returned    * set contains all elements that are contained in either backing set.    * Iterating over the returned set iterates first over all the elements of    * {@code set1}, then over each element of {@code set2}, in order, that is not    * contained in {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based on    * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and    * the {@link Map#keySet} of an {@code IdentityHashMap} all are).    */
DECL|method|union (final Set<? extends E> set1, final Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|union
parameter_list|(
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2minus1
init|=
name|difference
argument_list|(
name|set2
argument_list|,
name|set1
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|IntMath
operator|.
name|saturatedAdd
argument_list|(
name|set1
operator|.
name|size
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set1
operator|.
name|isEmpty
argument_list|()
operator|&&
name|set2
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|Iterators
operator|.
name|concat
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|stream
parameter_list|()
block|{
return|return
name|Stream
operator|.
name|concat
argument_list|(
name|set1
operator|.
name|stream
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|stream
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|parallelStream
parameter_list|()
block|{
return|return
name|Stream
operator|.
name|concat
argument_list|(
name|set1
operator|.
name|parallelStream
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|parallelStream
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|||
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
operator|new
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|()
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the intersection of two sets. The    * returned set contains all elements that are contained by both backing sets.    * The iteration order of the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    *<p><b>Note:</b> The returned view performs slightly better when {@code    * set1} is the smaller of the two sets. If you have reason to believe one of    * your sets will generally be smaller than the other, pass it first.    * Unfortunately, since this method sets the generic type of the returned set    * based on the type of the first set passed, this could in rare cases force    * you to make a cast, for example:<pre>   {@code    *    *   Set<Object> aFewBadObjects = ...    *   Set<String> manyBadStrings = ...    *    *   // impossible for a non-String to be in the intersection    *   SuppressWarnings("unchecked")    *   Set<String> badStrings = (Set) Sets.intersection(    *       aFewBadObjects, manyBadStrings);}</pre>    *    *<p>This is unfortunate, but should come up only very rarely.    */
DECL|method|intersection (final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|intersection
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|inSet2
init|=
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|inSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|stream
parameter_list|()
block|{
return|return
name|set1
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|inSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|parallelStream
parameter_list|()
block|{
return|return
name|set1
operator|.
name|parallelStream
argument_list|()
operator|.
name|filter
argument_list|(
name|inSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|set1
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
operator|&&
name|set2
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the difference of two sets. The    * returned set contains all elements that are contained by {@code set1} and    * not contained by {@code set2}. {@code set2} may also contain elements not    * present in {@code set1}; these are simply ignored. The iteration order of    * the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    */
DECL|method|difference (final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|difference
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|notInSet2
init|=
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|notInSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|stream
parameter_list|()
block|{
return|return
name|set1
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|notInSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|E
argument_list|>
name|parallelStream
parameter_list|()
block|{
return|return
name|set1
operator|.
name|parallelStream
argument_list|()
operator|.
name|filter
argument_list|(
name|notInSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set2
operator|.
name|containsAll
argument_list|(
name|set1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|element
argument_list|)
operator|&&
operator|!
name|set2
operator|.
name|contains
argument_list|(
name|element
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the symmetric difference of two    * sets. The returned set contains all elements that are contained in either    * {@code set1} or {@code set2} but not in both. The iteration order of the    * returned set is undefined.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    * @since 3.0    */
DECL|method|symmetricDifference ( final Set<? extends E> set1, final Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|symmetricDifference
parameter_list|(
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|itr1
init|=
name|set1
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|itr2
init|=
name|set2
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractIterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|E
name|computeNext
parameter_list|()
block|{
while|while
condition|(
name|itr1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|E
name|elem1
init|=
name|itr1
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|set2
operator|.
name|contains
argument_list|(
name|elem1
argument_list|)
condition|)
block|{
return|return
name|elem1
return|;
block|}
block|}
while|while
condition|(
name|itr2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|E
name|elem2
init|=
name|itr2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|set1
operator|.
name|contains
argument_list|(
name|elem2
argument_list|)
condition|)
block|{
return|return
name|elem2
return|;
block|}
block|}
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set1
operator|.
name|equals
argument_list|(
name|set2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|element
argument_list|)
operator|^
name|set2
operator|.
name|contains
argument_list|(
name|element
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate. The    * returned set is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as {@code    * removeAll()} and {@code clear()} are called on the filtered set, only    * elements that satisfy the filter will be removed from the underlying set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate    * across every element in the underlying set and determine which elements    * satisfy the filter. When a live view is<i>not</i> needed, it may be faster    * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such    * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent    * with equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    *    *<p><b>Java 8 users:</b> many use cases for this method are better    * addressed by {@link java.util.stream.Stream#filter}. This method is not    * being deprecated, but we gently encourage you to migrate to streams.    */
comment|// TODO(kevinb): how to omit that last sentence when building GWT javadoc?
DECL|method|filter (Set<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|filter
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FilteredSet
specifier|private
specifier|static
class|class
name|FilteredSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredCollection
argument_list|<
name|E
argument_list|>
implements|implements
name|Set
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredSet (Set<E> unfiltered, Predicate<? super E> predicate)
name|FilteredSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that    * satisfy a predicate. The returned set is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as    * {@code removeAll()} and {@code clear()} are called on the filtered set,    * only elements that satisfy the filter will be removed from the underlying    * set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate across    * every element in the underlying set and determine which elements satisfy    * the filter. When a live view is<i>not</i> needed, it may be faster to copy    * {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such as    * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with    * equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    *    * @since 11.0    */
DECL|method|filter (SortedSet<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FilteredSortedSet
specifier|private
specifier|static
class|class
name|FilteredSortedSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredSet
argument_list|<
name|E
argument_list|>
implements|implements
name|SortedSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredSortedSet (SortedSet<E> unfiltered, Predicate<? super E> predicate)
name|FilteredSortedSet
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
return|return
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|E
argument_list|>
name|sortedUnfiltered
init|=
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|E
name|element
init|=
name|sortedUnfiltered
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
name|element
return|;
block|}
name|sortedUnfiltered
operator|=
name|sortedUnfiltered
operator|.
name|headSet
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that    * satisfy a predicate. The returned set is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as    * {@code removeAll()} and {@code clear()} are called on the filtered set,    * only elements that satisfy the filter will be removed from the underlying    * set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate across    * every element in the underlying set and determine which elements satisfy    * the filter. When a live view is<i>not</i> needed, it may be faster to copy    * {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such as    * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with    * equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    *    * @since 14.0    */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|filter ( NavigableSet<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|class|FilteredNavigableSet
specifier|private
specifier|static
class|class
name|FilteredNavigableSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredNavigableSet (NavigableSet<E> unfiltered, Predicate<? super E> predicate)
name|FilteredNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
DECL|method|unfiltered ()
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|lower (E e)
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|floor (E e)
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (E e)
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (E e)
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|descendingSet
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|descendingSet
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|descendingIterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
return|return
name|descendingIterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|unfiltered
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(ImmutableList.of(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C")))}</pre>    *    *<p>returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    *<p>The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : sets.get(0)) {    *     for (B b1 : sets.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    *<p>Note that if any input set is empty, the Cartesian product will also be    * empty. If no sets at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since 2.0    */
DECL|method|cartesianProduct (List<? extends Set<? extends B>> sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
return|return
name|CartesianSet
operator|.
name|create
argument_list|(
name|sets
argument_list|)
return|;
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C"))}</pre>    *    *<p>returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    *<p>The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : sets.get(0)) {    *     for (B b1 : sets.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    *<p>Note that if any input set is empty, the Cartesian product will also be    * empty. If no sets at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since 2.0    */
DECL|method|cartesianProduct (Set<? extends B>.... sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
modifier|...
name|sets
parameter_list|)
block|{
return|return
name|cartesianProduct
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|sets
argument_list|)
argument_list|)
return|;
block|}
DECL|class|CartesianSet
specifier|private
specifier|static
specifier|final
class|class
name|CartesianSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
implements|implements
name|Set
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|axes
specifier|private
specifier|final
specifier|transient
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
specifier|transient
name|CartesianList
argument_list|<
name|E
argument_list|>
name|delegate
decl_stmt|;
DECL|method|create (List<? extends Set<? extends E>> sets)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|create
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axesBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
name|sets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set
range|:
name|sets
control|)
block|{
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|copy
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
name|axesBuilder
operator|.
name|add
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
init|=
name|axesBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|listAxes
init|=
operator|new
name|ImmutableList
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|axes
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|axes
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|asList
argument_list|()
return|;
block|}
annotation|@
name|Override
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|CartesianSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|axes
argument_list|,
operator|new
name|CartesianList
argument_list|<
name|E
argument_list|>
argument_list|(
name|listAxes
argument_list|)
argument_list|)
return|;
block|}
DECL|method|CartesianSet (ImmutableList<ImmutableSet<E>> axes, CartesianList<E> delegate)
specifier|private
name|CartesianSet
parameter_list|(
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
parameter_list|,
name|CartesianList
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|axes
operator|=
name|axes
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Collection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
if|if
condition|(
name|object
operator|instanceof
name|CartesianSet
condition|)
block|{
name|CartesianSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|CartesianSet
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|axes
operator|.
name|equals
argument_list|(
name|that
operator|.
name|axes
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
comment|// It's a weird formula, but tests prove it works.
name|int
name|adjust
init|=
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|axes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|adjust
operator|*=
literal|31
expr_stmt|;
name|adjust
operator|=
operator|~
operator|~
name|adjust
expr_stmt|;
comment|// in GWT, we have to deal with integer overflow carefully
block|}
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|E
argument_list|>
name|axis
range|:
name|axes
control|)
block|{
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|size
argument_list|()
operator|/
name|axis
operator|.
name|size
argument_list|()
operator|*
name|axis
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|hash
operator|=
operator|~
operator|~
name|hash
expr_stmt|;
block|}
name|hash
operator|+=
name|adjust
expr_stmt|;
return|return
operator|~
operator|~
name|hash
return|;
block|}
block|}
comment|/**    * Returns the set of all possible subsets of {@code set}. For example,    * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},    * {1}, {2}, {1, 2}}}.    *    *<p>Elements appear in these subsets in the same iteration order as they    * appeared in the input set. The order in which these subsets appear in the    * outer set is undefined. Note that the power set of the empty set is not the    * empty set, but a one-element set containing the empty set.    *    *<p>The returned set and its constituent sets use {@code equals} to decide    * whether two elements are identical, even if the input set uses a different    * concept of equivalence.    *    *<p><i>Performance notes:</i> while the power set of a set with size {@code    * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the    * power set is constructed, the input set is merely copied. Only as the    * power set is iterated are the individual subsets created, and these subsets    * themselves occupy only a small constant amount of memory.    *    * @param set the set of elements to construct a power set from    * @return the power set, as an immutable set of immutable sets    * @throws IllegalArgumentException if {@code set} has more than 30 unique    *     elements (causing the power set size to exceed the {@code int} range)    * @throws NullPointerException if {@code set} is or contains {@code null}    * @see<a href="http://en.wikipedia.org/wiki/Power_set">Power set article at    *      Wikipedia</a>    * @since 4.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|false
argument_list|)
DECL|method|powerSet (Set<E> set)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|powerSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|PowerSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|set
argument_list|)
return|;
block|}
DECL|class|SubSet
specifier|private
specifier|static
specifier|final
class|class
name|SubSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
DECL|field|inputSet
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|inputSet
decl_stmt|;
DECL|field|mask
specifier|private
specifier|final
name|int
name|mask
decl_stmt|;
DECL|method|SubSet (ImmutableMap<E, Integer> inputSet, int mask)
name|SubSet
parameter_list|(
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|inputSet
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|this
operator|.
name|inputSet
operator|=
name|inputSet
expr_stmt|;
name|this
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|elements
init|=
name|inputSet
operator|.
name|keySet
argument_list|()
operator|.
name|asList
argument_list|()
decl_stmt|;
name|int
name|remainingSetBits
init|=
name|mask
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|remainingSetBits
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|E
name|next
parameter_list|()
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|remainingSetBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|32
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|remainingSetBits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
return|return
name|elements
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|bitCount
argument_list|(
name|mask
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullable Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|Integer
name|index
init|=
name|inputSet
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
name|index
operator|!=
literal|null
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
block|}
DECL|class|PowerSet
specifier|private
specifier|static
specifier|final
class|class
name|PowerSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|inputSet
specifier|final
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|inputSet
decl_stmt|;
DECL|method|PowerSet (Set<E> input)
name|PowerSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|input
parameter_list|)
block|{
name|this
operator|.
name|inputSet
operator|=
name|Maps
operator|.
name|indexMap
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|inputSet
operator|.
name|size
argument_list|()
operator|<=
literal|30
argument_list|,
literal|"Too many elements to create power set: %s> 30"
argument_list|,
name|inputSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
literal|1
operator|<<
name|inputSet
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIndexedListIterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|get
parameter_list|(
specifier|final
name|int
name|setBits
parameter_list|)
block|{
return|return
operator|new
name|SubSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|inputSet
argument_list|,
name|setBits
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullable Object obj)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|set
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|PowerSet
condition|)
block|{
name|PowerSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|PowerSet
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|equals
argument_list|(
name|that
operator|.
name|inputSet
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|/*        * The sum of the sums of the hash codes in each subset is just the sum of        * each input element's hash code times the number of sets that element        * appears in. Each element appears in exactly half of the 2^n sets, so:        */
return|return
name|inputSet
operator|.
name|keySet
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|<<
operator|(
name|inputSet
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"powerSet("
operator|+
name|inputSet
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code    * combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}.    *    *<p>Elements appear in these subsets in the same iteration order as they appeared in the input    * set. The order in which these subsets appear in the outer set is undefined.    *    *<p>The returned set and its constituent sets use {@code equals} to decide whether two elements    * are identical, even if the input set uses a different concept of equivalence.    *    *<p><i>Performance notes:</i> the memory usage of the returned set is only {@code O(n)}. When    * the result set is constructed, the input set is merely copied. Only as the result set is    * iterated are the individual subsets created. Each of these subsets occupies an additional O(n)    * memory but only for as long as the user retains a reference to it. That is, the set returned by    * {@code combinations} does not retain the individual subsets.    *    * @param set the set of elements to take combinations of    * @param size the number of elements per combination    * @return the set of all combinations of {@code size} elements from {@code set}    * @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()}    *     inclusive    * @throws NullPointerException if {@code set} is or contains {@code null}    * @since 23.0    */
annotation|@
name|Beta
DECL|method|combinations (Set<E> set, final int size)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|combinations
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
specifier|final
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|index
init|=
name|Maps
operator|.
name|indexMap
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|checkNonnegative
argument_list|(
name|size
argument_list|,
literal|"size"
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|<=
name|index
operator|.
name|size
argument_list|()
argument_list|,
literal|"size (%s) must be<= set.size() (%s)"
argument_list|,
name|size
argument_list|,
name|index
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableSet
operator|.
expr|<
name|Set
argument_list|<
name|E
argument_list|>
operator|>
name|of
argument_list|(
name|ImmutableSet
operator|.
expr|<
name|E
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
name|index
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
expr|<
name|Set
argument_list|<
name|E
argument_list|>
operator|>
name|of
argument_list|(
name|index
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|AbstractSet
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|s
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|s
operator|.
name|size
argument_list|()
operator|==
name|size
operator|&&
name|index
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|s
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|final
name|BitSet
name|bits
init|=
operator|new
name|BitSet
argument_list|(
name|index
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|bits
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bits
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|firstSetBit
init|=
name|bits
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|bitToFlip
init|=
name|bits
operator|.
name|nextClearBit
argument_list|(
name|firstSetBit
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitToFlip
operator|==
name|index
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
comment|/*                * The current set in sorted order looks like                * {firstSetBit, firstSetBit + 1, ..., bitToFlip - 1, ...}                * where it does *not* contain bitToFlip.                *                * The next combination is                *                * {0, 1, ..., bitToFlip - firstSetBit - 2, bitToFlip, ...}                *                * This is lexicographically next if you look at the combinations in descending order                * e.g. {2, 1, 0}, {3, 1, 0}, {3, 2, 0}, {3, 2, 1}, {4, 1, 0}...                */
name|bits
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|bitToFlip
operator|-
name|firstSetBit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bits
operator|.
name|clear
argument_list|(
name|bitToFlip
operator|-
name|firstSetBit
operator|-
literal|1
argument_list|,
name|bitToFlip
argument_list|)
expr_stmt|;
name|bits
operator|.
name|set
argument_list|(
name|bitToFlip
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BitSet
name|copy
init|=
operator|(
name|BitSet
operator|)
name|bits
operator|.
name|clone
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|Integer
name|i
init|=
name|index
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
name|i
operator|!=
literal|null
operator|&&
name|copy
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|E
name|computeNext
parameter_list|()
block|{
name|i
operator|=
name|copy
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
return|return
name|index
operator|.
name|keySet
argument_list|()
operator|.
name|asList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|IntMath
operator|.
name|binomial
argument_list|(
name|index
operator|.
name|size
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Sets.combinations("
operator|+
name|index
operator|.
name|keySet
argument_list|()
operator|+
literal|", "
operator|+
name|size
operator|+
literal|")"
return|;
block|}
block|}
return|;
block|}
comment|/**    * An implementation for {@link Set#hashCode()}.    */
DECL|method|hashCodeImpl (Set<?> s)
specifier|static
name|int
name|hashCodeImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|)
block|{
name|int
name|hashCode
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|s
control|)
block|{
name|hashCode
operator|+=
name|o
operator|!=
literal|null
condition|?
name|o
operator|.
name|hashCode
argument_list|()
else|:
literal|0
expr_stmt|;
name|hashCode
operator|=
operator|~
operator|~
name|hashCode
expr_stmt|;
comment|// Needed to deal with unusual integer overflow in GWT.
block|}
return|return
name|hashCode
return|;
block|}
comment|/**    * An implementation for {@link Set#equals(Object)}.    */
DECL|method|equalsImpl (Set<?> s, @Nullable Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|,
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|o
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
try|try
block|{
return|return
name|s
operator|.
name|size
argument_list|()
operator|==
name|o
operator|.
name|size
argument_list|()
operator|&&
name|s
operator|.
name|containsAll
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified navigable set. This method    * allows modules to provide users with "read-only" access to internal    * navigable sets. Query operations on the returned set "read through" to the    * specified set, and attempts to modify the returned set, whether direct or    * via its collection views, result in an    * {@code UnsupportedOperationException}.    *    *<p>The returned navigable set will be serializable if the specified    * navigable set is serializable.    *    * @param set the navigable set for which an unmodifiable view is to be    *        returned    * @return an unmodifiable view of the specified navigable set    * @since 12.0    */
DECL|method|unmodifiableNavigableSet (NavigableSet<E> set)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|unmodifiableNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
if|if
condition|(
name|set
operator|instanceof
name|ImmutableSortedSet
operator|||
name|set
operator|instanceof
name|UnmodifiableNavigableSet
condition|)
block|{
return|return
name|set
return|;
block|}
return|return
operator|new
name|UnmodifiableNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|set
argument_list|)
return|;
block|}
DECL|class|UnmodifiableNavigableSet
specifier|static
specifier|final
class|class
name|UnmodifiableNavigableSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ForwardingSortedSet
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|delegate
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableNavigableSet (NavigableSet<E> delegate)
name|UnmodifiableNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|SortedSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|delegate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lower (E e)
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|lower
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (E e)
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|floor
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (E e)
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|ceiling
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (E e)
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|higher
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|descendingSet
specifier|private
specifier|transient
name|UnmodifiableNavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
decl_stmt|;
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
name|UnmodifiableNavigableSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|descendingSet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|descendingSet
operator|=
operator|new
name|UnmodifiableNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|delegate
operator|.
name|descendingSet
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|descendingSet
operator|=
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|delegate
operator|.
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) navigable set backed by the specified    * navigable set.  In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing navigable set is accomplished    * through the returned navigable set (or its views).    *    *<p>It is imperative that the user manually synchronize on the returned    * sorted set when iterating over it or any of its {@code descendingSet},    * {@code subSet}, {@code headSet}, or {@code tailSet} views.<pre>   {@code    *    *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());    *    ...    *   synchronized (set) {    *     // Must be in the synchronized block    *     Iterator<E> it = set.iterator();    *     while (it.hasNext()) {    *       foo(it.next());    *     }    *   }}</pre>    *    *<p>or:<pre>   {@code    *    *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());    *   NavigableSet<E> set2 = set.descendingSet().headSet(foo);    *    ...    *   synchronized (set) { // Note: set, not set2!!!    *     // Must be in the synchronized block    *     Iterator<E> it = set2.descendingIterator();    *     while (it.hasNext())    *       foo(it.next());    *     }    *   }}</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned navigable set will be serializable if the specified    * navigable set is serializable.    *    * @param navigableSet the navigable set to be "wrapped" in a synchronized    *    navigable set.    * @return a synchronized view of the specified navigable set.    * @since 13.0    */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|method|synchronizedNavigableSet (NavigableSet<E> navigableSet)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|synchronizedNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|navigableSet
argument_list|(
name|navigableSet
argument_list|)
return|;
block|}
comment|/**    * Remove each element in an iterable from a set.    */
DECL|method|removeAllImpl (Set<?> set, Iterator<?> iterator)
specifier|static
name|boolean
name|removeAllImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|set
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|changed
operator||=
name|set
operator|.
name|remove
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
DECL|method|removeAllImpl (Set<?> set, Collection<?> collection)
specifier|static
name|boolean
name|removeAllImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|set
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// for GWT
if|if
condition|(
name|collection
operator|instanceof
name|Multiset
condition|)
block|{
name|collection
operator|=
operator|(
operator|(
name|Multiset
argument_list|<
name|?
argument_list|>
operator|)
name|collection
operator|)
operator|.
name|elementSet
argument_list|()
expr_stmt|;
block|}
comment|/*      * AbstractSet.removeAll(List) has quadratic behavior if the list size      * is just less than the set's size.  We augment the test by      * assuming that sets have fast contains() performance, and other      * collections don't.  See      * http://code.google.com/p/guava-libraries/issues/detail?id=1013      */
if|if
condition|(
name|collection
operator|instanceof
name|Set
operator|&&
name|collection
operator|.
name|size
argument_list|()
operator|>
name|set
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|Iterators
operator|.
name|removeAll
argument_list|(
name|set
operator|.
name|iterator
argument_list|()
argument_list|,
name|collection
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|removeAllImpl
argument_list|(
name|set
argument_list|,
name|collection
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|class|DescendingSet
specifier|static
class|class
name|DescendingSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ForwardingNavigableSet
argument_list|<
name|E
argument_list|>
block|{
DECL|field|forward
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|forward
decl_stmt|;
DECL|method|DescendingSet (NavigableSet<E> forward)
name|DescendingSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|forward
parameter_list|)
block|{
name|this
operator|.
name|forward
operator|=
name|forward
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|forward
return|;
block|}
annotation|@
name|Override
DECL|method|lower (E e)
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|forward
operator|.
name|higher
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (E e)
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|forward
operator|.
name|ceiling
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (E e)
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|forward
operator|.
name|floor
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (E e)
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|forward
operator|.
name|lower
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
return|return
name|forward
operator|.
name|pollLast
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
return|return
name|forward
operator|.
name|pollFirst
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|forward
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|forward
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|forward
operator|.
name|subSet
argument_list|(
name|toElement
argument_list|,
name|toInclusive
argument_list|,
name|fromElement
argument_list|,
name|fromInclusive
argument_list|)
operator|.
name|descendingSet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
operator|.
name|tailSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingSet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
operator|.
name|headSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingSet
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|forwardComparator
init|=
name|forward
operator|.
name|comparator
argument_list|()
decl_stmt|;
if|if
condition|(
name|forwardComparator
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|Comparator
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|reverse
argument_list|(
name|forwardComparator
argument_list|)
return|;
block|}
block|}
comment|// If we inline this, we get a javac error.
DECL|method|reverse (Comparator<T> forward)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|forward
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|from
argument_list|(
name|forward
argument_list|)
operator|.
name|reverse
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
return|return
name|forward
operator|.
name|last
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|standardHeadSet
argument_list|(
name|toElement
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
return|return
name|forward
operator|.
name|first
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|standardSubSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|standardTailSet
argument_list|(
name|fromElement
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|forward
operator|.
name|descendingIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|standardToArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (T[] array)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|standardToArray
argument_list|(
name|array
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|standardToString
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns a view of the portion of {@code set} whose elements are contained by {@code range}.    *    *<p>This method delegates to the appropriate methods of {@link NavigableSet} (namely    * {@link NavigableSet#subSet(Object, boolean, Object, boolean) subSet()},    * {@link NavigableSet#tailSet(Object, boolean) tailSet()}, and    * {@link NavigableSet#headSet(Object, boolean) headSet()}) to actually construct the view.    * Consult these methods for a full description of the returned view's behavior.    *    *<p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural    * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a    * {@link Comparator}, which can violate the natural ordering. Using this method (or in general    * using {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined    * behavior.    *    * @since 20.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|method|subSet ( NavigableSet<K> set, Range<K> range)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|>
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Range
argument_list|<
name|K
argument_list|>
name|range
parameter_list|)
block|{
if|if
condition|(
name|set
operator|.
name|comparator
argument_list|()
operator|!=
literal|null
operator|&&
name|set
operator|.
name|comparator
argument_list|()
operator|!=
name|Ordering
operator|.
name|natural
argument_list|()
operator|&&
name|range
operator|.
name|hasLowerBound
argument_list|()
operator|&&
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
name|checkArgument
argument_list|(
name|set
operator|.
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|)
operator|<=
literal|0
argument_list|,
literal|"set is using a custom comparator which is inconsistent with the natural ordering."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
operator|&&
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
return|return
name|set
operator|.
name|subSet
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|lowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|,
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
return|return
name|set
operator|.
name|tailSet
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|lowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
return|return
name|set
operator|.
name|headSet
argument_list|(
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
return|return
name|checkNotNull
argument_list|(
name|set
argument_list|)
return|;
block|}
block|}
end_class

end_unit

