begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the  * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * An immutable {@code SortedMultiset} that stores its elements in a sorted array. Some instances  * are ordered by an explicit comparator, while others follow the natural sort ordering of their  * elements. Either way, null elements are not supported.  *  *<p>Unlike {@link Multisets#unmodifiableSortedMultiset}, which is a<i>view</i> of a separate  * collection that can still change, an instance of {@code ImmutableSortedMultiset} contains its  * own private data and will<i>never</i> change. This class is convenient for {@code public static  * final} multisets ("constant multisets") and also lets you easily make a "defensive copy" of a  * set provided to your class by a caller.  *  *<p>The multisets returned by the {@link #headMultiset}, {@link #tailMultiset}, and  * {@link #subMultiset} methods share the same array as the original multiset, preventing that  * array from being garbage collected. If this is a concern, the data may be copied into a  * correctly-sized array by calling {@link #copyOfSorted}.  *  *<p><b>Note on element equivalence:</b> The {@link #contains(Object)},  * {@link #containsAll(Collection)}, and {@link #equals(Object)} implementations must check whether  * a provided object is equivalent to an element in the collection. Unlike most collections, an  * {@code ImmutableSortedMultiset} doesn't use {@link Object#equals} to determine if two elements  * are equivalent. Instead, with an explicit comparator, the following relation determines whether  * elements {@code x} and {@code y} are equivalent:  *  *<pre>   {@code  *  *   {(x, y) | comparator.compare(x, y) == 0}}</pre>  *  * With natural ordering of elements, the following relation determines whether two elements are  * equivalent:  *  *<pre>   {@code  *  *   {(x, y) | x.compareTo(y) == 0}}</pre>  *  *<b>Warning:</b> Like most multisets, an {@code ImmutableSortedMultiset} will not function  * correctly if an element is modified after being placed in the multiset. For this reason, and to  * avoid general confusion, it is strongly recommended to place only immutable objects into this  * collection.  *  *<p><b>Note:</b> Although this class is not final, it cannot be subclassed as it has no public or  * protected constructors. Thus, instances of this type are guaranteed to be immutable.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">  * immutable collections</a>.  *  * @author Louis Wasserman  * @since 12.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
argument_list|(
literal|"hasn't been tested yet"
argument_list|)
DECL|class|ImmutableSortedMultiset
specifier|public
specifier|abstract
class|class
name|ImmutableSortedMultiset
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSortedMultisetFauxverideShim
argument_list|<
name|E
argument_list|>
implements|implements
name|SortedMultiset
argument_list|<
name|E
argument_list|>
block|{
comment|// TODO(user): GWT compatibility
DECL|field|NATURAL_ORDER
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Comparable
argument_list|>
name|NATURAL_ORDER
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
DECL|field|NATURAL_EMPTY_MULTISET
specifier|private
specifier|static
specifier|final
name|ImmutableSortedMultiset
argument_list|<
name|Comparable
argument_list|>
name|NATURAL_EMPTY_MULTISET
init|=
operator|new
name|EmptyImmutableSortedMultiset
argument_list|<
name|Comparable
argument_list|>
argument_list|(
name|NATURAL_ORDER
argument_list|)
decl_stmt|;
comment|/**    * Returns the empty immutable sorted multiset.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|()
block|{
return|return
operator|(
name|ImmutableSortedMultiset
operator|)
name|NATURAL_EMPTY_MULTISET
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing a single element.    */
DECL|method|of (E element)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|element
parameter_list|)
block|{
return|return
name|RegularImmutableSortedMultiset
operator|.
name|createFromSorted
argument_list|(
name|NATURAL_ORDER
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Multisets
operator|.
name|immutableEntry
argument_list|(
name|checkNotNull
argument_list|(
name|element
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2, E e3)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|,
name|E
name|e6
parameter_list|,
name|E
modifier|...
name|remaining
parameter_list|)
block|{
name|int
name|size
init|=
name|remaining
operator|.
name|length
operator|+
literal|6
decl_stmt|;
name|List
argument_list|<
name|E
argument_list|>
name|all
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|all
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|all
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|all
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (E[] elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|E
index|[]
name|elements
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering. To create a copy of a {@code SortedMultiset} that preserves the    * comparator, call {@link #copyOfSorted} instead. This method iterates over {@code elements} at    * most once.    *    *<p>Note that if {@code s} is a {@code multiset<String>}, then {@code    * ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}    * containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}    * returns an {@code ImmutableSortedMultiset<multiset<String>>} containing one element (the given    * multiset itself).    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedMultisetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by their natural    * ordering.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedMultisetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOfInternal
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by the given {@code    * Comparator}.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
return|return
name|copyOfInternal
argument_list|(
name|comparator
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the given elements sorted by the given {@code    * Comparator}. This method iterates over {@code elements} at most once.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
return|return
name|copyOfInternal
argument_list|(
name|comparator
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by    * the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which    * always uses the natural ordering of the elements.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent    * collection that is currently being modified by another thread.    *    * @throws NullPointerException if {@code sortedMultiset} or any of its elements is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|copyOfSorted (SortedMultiset<E> sortedMultiset)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOfSorted
parameter_list|(
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|sortedMultiset
parameter_list|)
block|{
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
init|=
name|sortedMultiset
operator|.
name|comparator
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
block|{
name|comparator
operator|=
operator|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
operator|)
name|NATURAL_ORDER
expr_stmt|;
block|}
return|return
name|copyOfInternal
argument_list|(
name|comparator
argument_list|,
name|sortedMultiset
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|copyOfInternal ( Comparator<? super E> comparator, Iterable<? extends E> iterable)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOfInternal
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|SortedIterables
operator|.
name|hasSameComparator
argument_list|(
name|comparator
argument_list|,
name|iterable
argument_list|)
operator|&&
name|iterable
operator|instanceof
name|ImmutableSortedMultiset
condition|)
block|{
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
operator|(
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
operator|!
name|multiset
operator|.
name|isPartialView
argument_list|()
condition|)
block|{
return|return
operator|(
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
return|;
block|}
block|}
name|ImmutableList
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entries
init|=
operator|(
name|ImmutableList
operator|)
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|SortedIterables
operator|.
name|sortedCounts
argument_list|(
name|comparator
argument_list|,
name|iterable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|emptyMultiset
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|verifyEntries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return
name|RegularImmutableSortedMultiset
operator|.
name|createFromSorted
argument_list|(
name|comparator
argument_list|,
name|entries
argument_list|)
return|;
block|}
DECL|method|copyOfInternal ( Comparator<? super E> comparator, Iterator<? extends E> iterator)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|copyOfInternal
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// We can safely cast from IL<Entry<? extends E>> to IL<Entry<E>>
name|ImmutableList
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entries
init|=
operator|(
name|ImmutableList
operator|)
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|SortedIterables
operator|.
name|sortedCounts
argument_list|(
name|comparator
argument_list|,
name|iterator
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|emptyMultiset
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|verifyEntries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return
name|RegularImmutableSortedMultiset
operator|.
name|createFromSorted
argument_list|(
name|comparator
argument_list|,
name|entries
argument_list|)
return|;
block|}
DECL|method|verifyEntries (Collection<Entry<E>> entries)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|void
name|verifyEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|E
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|checkNotNull
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyMultiset (Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|emptyMultiset
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|NATURAL_ORDER
operator|.
name|equals
argument_list|(
name|comparator
argument_list|)
condition|)
block|{
return|return
operator|(
name|ImmutableSortedMultiset
operator|)
name|NATURAL_EMPTY_MULTISET
return|;
block|}
return|return
operator|new
name|EmptyImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
DECL|field|comparator
specifier|private
specifier|final
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|method|ImmutableSortedMultiset (Comparator<? super E> comparator)
name|ImmutableSortedMultiset
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
comment|// Pretend the comparator can compare anything. If it turns out it can't
comment|// compare two elements, it'll throw a CCE. Only methods that are specified to
comment|// throw CCE should call this.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|unsafeComparator ()
name|Comparator
argument_list|<
name|Object
argument_list|>
name|unsafeComparator
parameter_list|()
block|{
return|return
operator|(
name|Comparator
argument_list|<
name|Object
argument_list|>
operator|)
name|comparator
return|;
block|}
DECL|field|reverseComparator
specifier|private
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|reverseComparator
decl_stmt|;
DECL|method|reverseComparator ()
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|reverseComparator
parameter_list|()
block|{
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|result
init|=
name|reverseComparator
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|reverseComparator
operator|=
name|Ordering
operator|.
name|from
argument_list|(
name|comparator
argument_list|)
operator|.
operator|<
name|E
operator|>
name|reverse
argument_list|()
return|;
block|}
return|return
name|result
return|;
block|}
DECL|field|elementSet
specifier|private
specifier|transient
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|elementSet
decl_stmt|;
annotation|@
name|Override
DECL|method|elementSet ()
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|elementSet
parameter_list|()
block|{
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|elementSet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|elementSet
operator|=
name|createElementSet
argument_list|()
return|;
block|}
return|return
name|result
return|;
block|}
DECL|method|createElementSet ()
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|createElementSet
parameter_list|()
function_decl|;
DECL|method|createDescendingElementSet ()
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|createDescendingElementSet
parameter_list|()
function_decl|;
DECL|field|descendingMultiset
specifier|transient
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|descendingMultiset
decl_stmt|;
annotation|@
name|Override
DECL|method|descendingMultiset ()
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|descendingMultiset
parameter_list|()
block|{
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|result
init|=
name|descendingMultiset
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|descendingMultiset
operator|=
operator|new
name|DescendingImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.    *    * @throws UnsupportedOperationException always    */
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|E
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.    *    * @throws UnsupportedOperationException always    */
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|E
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|headMultiset (E upperBound, BoundType boundType)
specifier|public
specifier|abstract
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|headMultiset
parameter_list|(
name|E
name|upperBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|subMultiset ( E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType)
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|subMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|lowerBoundType
parameter_list|,
name|E
name|upperBound
parameter_list|,
name|BoundType
name|upperBoundType
parameter_list|)
block|{
return|return
name|tailMultiset
argument_list|(
name|lowerBound
argument_list|,
name|lowerBoundType
argument_list|)
operator|.
name|headMultiset
argument_list|(
name|upperBound
argument_list|,
name|upperBoundType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMultiset (E lowerBound, BoundType boundType)
specifier|public
specifier|abstract
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|tailMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
function_decl|;
comment|/**    * Returns a builder that creates immutable sorted multisets with an explicit comparator. If the    * comparator has a more general type than the set being generated, such as creating a {@code    * SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder}    * constructor instead.    *    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|orderedBy (Comparator<E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|orderedBy
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted multisets whose elements are ordered by the    * reverse of their natural ordering.    *    *<p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather than {@code    * Comparable<? super E>} as a workaround for javac<a    * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.    */
DECL|method|reverseOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|reverseOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted multisets whose elements are ordered by their    * natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This    * method provides more type-safety than {@link #builder}, as it can be called only for classes    * that implement {@link Comparable}.    *    *<p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather than {@code    * Comparable<? super E>} as a workaround for javac<a    * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.    */
DECL|method|naturalOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|naturalOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * A builder for creating immutable multiset instances, especially {@code public static final}    * multisets ("constant multisets"). Example:    *    *<pre> {@code    *    *   public static final ImmutableSortedMultiset<Bean> BEANS =    *       new ImmutableSortedMultiset.Builder<Bean>()    *           .addCopies(Bean.COCOA, 4)    *           .addCopies(Bean.GARDEN, 6)    *           .addCopies(Bean.RED, 8)    *           .addCopies(Bean.BLACK_EYED, 10)    *           .build();}</pre>    *    * Builder instances can be reused; it is safe to call {@link #build} multiple times to build    * multiple multisets in series.    *    * @since 12.0    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableMultiset
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
block|{
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
comment|/**      * Creates a new builder. The returned builder is equivalent to the builder generated by      * {@link ImmutableSortedMultiset#orderedBy(Comparator)}.      */
DECL|method|Builder (Comparator<? super E> comparator)
specifier|public
name|Builder
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|super
argument_list|(
name|TreeMultiset
operator|.
expr|<
name|E
operator|>
name|create
argument_list|(
name|comparator
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds {@code element} to the {@code ImmutableSortedMultiset}.      *      * @param element the element to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      */
annotation|@
name|Override
DECL|method|add (E element)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|super
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.      *      * @param element the element to add      * @param occurrences the number of occurrences of the element to add. May be zero, in which      *        case no change will be made.      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation      *         would result in more than {@link Integer#MAX_VALUE} occurrences of the element      */
annotation|@
name|Override
DECL|method|addCopies (E element, int occurrences)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addCopies
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|super
operator|.
name|addCopies
argument_list|(
name|element
argument_list|,
name|occurrences
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds or removes the necessary occurrences of an element such that the element attains the      * desired count.      *      * @param element the element to add or remove occurrences of      * @param count the desired count of the element in this multiset      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      * @throws IllegalArgumentException if {@code count} is negative      */
annotation|@
name|Override
DECL|method|setCount (E element, int count)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|super
operator|.
name|setCount
argument_list|(
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the elements to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|Override
DECL|method|add (E... elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|super
operator|.
name|add
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|Override
DECL|method|addAll (Iterable<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.      *      * @param elements the elements to add to the {@code ImmutableSortedMultiset}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} is null or contains a null element      */
annotation|@
name|Override
DECL|method|addAll (Iterator<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code      * Builder}.      */
annotation|@
name|Override
DECL|method|build ()
specifier|public
name|ImmutableSortedMultiset
argument_list|<
name|E
argument_list|>
name|build
parameter_list|()
block|{
return|return
name|copyOf
argument_list|(
name|comparator
argument_list|,
name|contents
argument_list|)
return|;
block|}
block|}
DECL|class|SerializedForm
specifier|private
specifier|static
specifier|final
class|class
name|SerializedForm
implements|implements
name|Serializable
block|{
DECL|field|comparator
name|Comparator
name|comparator
decl_stmt|;
DECL|field|elements
name|Object
index|[]
name|elements
decl_stmt|;
DECL|field|counts
name|int
index|[]
name|counts
decl_stmt|;
DECL|method|SerializedForm (SortedMultiset<?> multiset)
name|SerializedForm
parameter_list|(
name|SortedMultiset
argument_list|<
name|?
argument_list|>
name|multiset
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|multiset
operator|.
name|comparator
argument_list|()
expr_stmt|;
name|int
name|n
init|=
name|multiset
operator|.
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|elements
operator|=
operator|new
name|Object
index|[
name|n
index|]
expr_stmt|;
name|counts
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|?
argument_list|>
name|entry
range|:
name|multiset
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|elements
index|[
name|i
index|]
operator|=
name|entry
operator|.
name|getElement
argument_list|()
expr_stmt|;
name|counts
index|[
name|i
index|]
operator|=
name|entry
operator|.
name|getCount
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
name|int
name|n
init|=
name|elements
operator|.
name|length
decl_stmt|;
name|Builder
argument_list|<
name|Object
argument_list|>
name|builder
init|=
name|orderedBy
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|addCopies
argument_list|(
name|elements
index|[
name|i
index|]
argument_list|,
name|counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializedForm
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

end_unit

