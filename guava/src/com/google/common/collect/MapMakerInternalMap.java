begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|Dummy
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * The concurrent hash map implementation built by {@link MapMaker}.  *  *<p>This implementation is heavily derived from revision 1.96 of<a  * href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.  *  * @param<K> the type of the keys in the map  * @param<V> the type of the values in the map  * @param<E> the type of the {@link InternalEntry} entry implementation used internally  * @param<S> the type of the {@link Segment} entry implementation used internally  * @author Bob Lee  * @author Charles Fry  * @author Doug Lea ({@code ConcurrentHashMap})  */
end_comment

begin_comment
comment|// TODO(kak/cpovirk): Consider removing @CanIgnoreReturnValue from this class.
end_comment

begin_class
annotation|@
name|GwtIncompatible
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GuardedBy"
argument_list|)
comment|// TODO(b/35466881): Fix or suppress.
DECL|class|MapMakerInternalMap
class|class
name|MapMakerInternalMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|MapMakerInternalMap
operator|.
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|,
name|S
extends|extends
name|MapMakerInternalMap
operator|.
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|,
name|S
parameter_list|>
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*    * The basic strategy is to subdivide the table among Segments, each of which itself is a    * concurrently readable hash table. The map supports non-blocking reads and concurrent writes    * across different segments.    *    * The page replacement algorithm's data structures are kept casually consistent with the map. The    * ordering of writes to a segment is sequentially consistent. An update to the map and recording    * of reads may not be immediately reflected on the algorithm's data structures. These structures    * are guarded by a lock and operations are applied in batches to avoid lock contention. The    * penalty of applying the batches is spread across threads so that the amortized cost is slightly    * higher than performing just the operation without enforcing the capacity constraint.    *    * This implementation uses a per-segment queue to record a memento of the additions, removals,    * and accesses that were performed on the map. The queue is drained on writes and when it exceeds    * its capacity threshold.    *    * The Least Recently Used page replacement algorithm was chosen due to its simplicity, high hit    * rate, and ability to be implemented with O(1) time complexity. The initial LRU implementation    * operates per-segment rather than globally for increased implementation simplicity. We expect    * the cache hit rate to be similar to that of a global LRU algorithm.    */
comment|// Constants
comment|/**    * The maximum capacity, used if a higher value is implicitly specified by either of the    * constructors with arguments. MUST be a power of two no greater than {@code 1<<30} to ensure    * that entries are indexable using ints.    */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
name|Ints
operator|.
name|MAX_POWER_OF_TWO
decl_stmt|;
comment|/** The maximum number of segments to allow; used to bound constructor arguments. */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/** Number of (unsynchronized) retries in the containsValue method. */
DECL|field|CONTAINS_VALUE_RETRIES
specifier|static
specifier|final
name|int
name|CONTAINS_VALUE_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Number of cache access operations that can be buffered per segment before the cache's recency    * ordering information is updated. This is used to avoid lock contention by recording a memento    * of reads and delaying a lock acquisition until the threshold is crossed or a mutation occurs.    *    *<p>This must be a (2^n)-1 as it is used as a mask.    */
DECL|field|DRAIN_THRESHOLD
specifier|static
specifier|final
name|int
name|DRAIN_THRESHOLD
init|=
literal|0x3F
decl_stmt|;
comment|/**    * Maximum number of entries to be drained in a single cleanup run. This applies independently to    * the cleanup queue and both reference queues.    */
comment|// TODO(fry): empirically optimize this
DECL|field|DRAIN_MAX
specifier|static
specifier|final
name|int
name|DRAIN_MAX
init|=
literal|16
decl_stmt|;
DECL|field|CLEANUP_EXECUTOR_DELAY_SECS
specifier|static
specifier|final
name|long
name|CLEANUP_EXECUTOR_DELAY_SECS
init|=
literal|60
decl_stmt|;
comment|// Fields
comment|/**    * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose    * the segment.    */
DECL|field|segmentMask
specifier|final
specifier|transient
name|int
name|segmentMask
decl_stmt|;
comment|/**    * Shift value for indexing within segments. Helps prevent entries that end up in the same segment    * from also ending up in the same bucket.    */
DECL|field|segmentShift
specifier|final
specifier|transient
name|int
name|segmentShift
decl_stmt|;
comment|/** The segments, each of which is a specialized hash table. */
DECL|field|segments
specifier|final
specifier|transient
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/** The concurrency level. */
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|/** Strategy for comparing keys. */
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
comment|/** Strategy for handling entries and segments in a type-safe and efficient manner. */
DECL|field|entryHelper
specifier|final
specifier|transient
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|entryHelper
decl_stmt|;
comment|/**    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.    */
DECL|method|MapMakerInternalMap (MapMaker builder, InternalEntryHelper<K, V, E, S> entryHelper)
specifier|private
name|MapMakerInternalMap
parameter_list|(
name|MapMaker
name|builder
parameter_list|,
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|entryHelper
parameter_list|)
block|{
name|concurrencyLevel
operator|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|,
name|MAX_SEGMENTS
argument_list|)
expr_stmt|;
name|keyEquivalence
operator|=
name|builder
operator|.
name|getKeyEquivalence
argument_list|()
expr_stmt|;
name|this
operator|.
name|entryHelper
operator|=
name|entryHelper
expr_stmt|;
name|int
name|initialCapacity
init|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getInitialCapacity
argument_list|()
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
decl_stmt|;
comment|// Find power-of-two sizes best matching arguments. Constraints:
comment|// (segmentCount> concurrencyLevel)
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|MapMaker
operator|.
name|UNSET_INT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns a fresh {@link MapMakerInternalMap} as specified by the given {@code builder}. */
DECL|method|create ( MapMaker builder)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
argument_list|,
name|?
argument_list|>
name|create
parameter_list|(
name|MapMaker
name|builder
parameter_list|)
block|{
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|StrongKeyStrongValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|StrongKeyWeakValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|WeakKeyStrongValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|WeakKeyWeakValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**    * Returns a fresh {@link MapMakerInternalMap} with {@link MapMaker.Dummy} values but otherwise as    * specified by the given {@code builder}. The returned {@link MapMakerInternalMap} will be    * optimized to saved memory. Since {@link MapMaker.Dummy} is a singleton, we don't need to store    * any values at all. Because of this optimization, {@code build.getValueStrength()} must    * be {@link Strength#STRONG}.    *    *<p>This method is intended to only be used by the internal implementation of {@link Interners},    * since a map of dummy values is the exact use case there.    */
specifier|static
parameter_list|<
name|K
parameter_list|>
DECL|method|createWithDummyValues ( MapMaker builder)
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|?
argument_list|>
argument_list|,
name|?
argument_list|>
name|createWithDummyValues
parameter_list|(
name|MapMaker
name|builder
parameter_list|)
block|{
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|StrongKeyDummyValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|builder
operator|.
name|getKeyStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
operator|&&
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|STRONG
condition|)
block|{
return|return
operator|new
name|MapMakerInternalMap
argument_list|<>
argument_list|(
name|builder
argument_list|,
name|WeakKeyDummyValueEntry
operator|.
name|Helper
operator|.
expr|<
name|K
operator|>
name|instance
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|builder
operator|.
name|getValueStrength
argument_list|()
operator|==
name|Strength
operator|.
name|WEAK
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Map cannot have both weak and dummy values"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
DECL|enum|Strength
enum|enum
name|Strength
block|{
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|equals
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|;
comment|/**      * Returns the default equivalence strategy used to compare and hash keys or values referenced      * at this strength. This strategy will be used unless the user explicitly specifies an      * alternate strategy.      */
DECL|method|defaultEquivalence ()
specifier|abstract
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
function_decl|;
block|}
comment|/**    * A helper object for operating on {@link InternalEntry} instances in a type-safe and efficient    * manner.    *    *<p>For each of the four combinations of strong/weak key and strong/weak value, there are    * corresponding {@link InternalEntry}, {@link Segment}, and {@link InternalEntryHelper}    * implementations.    *    * @param<K> the type of the key in each entry    * @param<V> the type of the value in each entry    * @param<E> the type of the {@link InternalEntry} entry implementation    * @param<S> the type of the {@link Segment} entry implementation    */
DECL|interface|InternalEntryHelper
interface|interface
name|InternalEntryHelper
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|,
name|S
extends|extends
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|,
name|S
parameter_list|>
parameter_list|>
block|{
comment|/** The strength of the key type in each entry. */
DECL|method|keyStrength ()
name|Strength
name|keyStrength
parameter_list|()
function_decl|;
comment|/** The strength of the value type in each entry. */
DECL|method|valueStrength ()
name|Strength
name|valueStrength
parameter_list|()
function_decl|;
comment|/** Returns a freshly created segment, typed at the {@code S} type. */
DECL|method|newSegment (MapMakerInternalMap<K, V, E, S> map, int initialCapacity, int maxSegmentSize)
name|S
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
function_decl|;
comment|/**      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment}.      */
DECL|method|newEntry (S segment, K key, int hash, @Nullable E next)
name|E
name|newEntry
parameter_list|(
name|S
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|E
name|next
parameter_list|)
function_decl|;
comment|/**      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment},      * that is a copy of the given {@code entry}.      */
DECL|method|copy (S segment, E entry, @Nullable E newNext)
name|E
name|copy
parameter_list|(
name|S
name|segment
parameter_list|,
name|E
name|entry
parameter_list|,
annotation|@
name|Nullable
name|E
name|newNext
parameter_list|)
function_decl|;
comment|/**      * Sets the value of the given {@code entry} in the given {@code segment} to be the given {@code      * value}      */
DECL|method|setValue (S segment, E entry, V value)
name|void
name|setValue
parameter_list|(
name|S
name|segment
parameter_list|,
name|E
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
block|}
comment|/**    * An entry in a hash table of a {@link Segment}.    *    *<p>Entries in the map can be in the following states:    *    *<p>Valid: - Live: valid key/value are set    *    *<p>Invalid: - Collected: key/value was partially collected, but not yet cleaned up    */
DECL|interface|InternalEntry
interface|interface
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
block|{
comment|/** Gets the next entry in the chain. */
DECL|method|getNext ()
name|E
name|getNext
parameter_list|()
function_decl|;
comment|/**      * Gets the entry's hash.      */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/**      * Gets the key for this entry.      */
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
function_decl|;
comment|/** Gets the value for the entry. */
DECL|method|getValue ()
name|V
name|getValue
parameter_list|()
function_decl|;
block|}
comment|/*    * Note: the following classes have a lot of duplicate code. It sucks, but it saves a lot of    * memory. If only Java had mixins!    */
comment|/** Base class for {@link InternalEntry} implementations for strong keys. */
DECL|class|AbstractStrongKeyEntry
specifier|abstract
specifier|static
class|class
name|AbstractStrongKeyEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
implements|implements
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|E
name|next
decl_stmt|;
DECL|method|AbstractStrongKeyEntry (K key, int hash, @Nullable E next)
name|AbstractStrongKeyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|E
name|next
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|E
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/** Marker interface for {@link InternalEntry} implementations for strong values. */
DECL|interface|StrongValueEntry
interface|interface
name|StrongValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{}
comment|/** Marker interface for {@link InternalEntry} implementations for weak values. */
DECL|interface|WeakValueEntry
interface|interface
name|WeakValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
comment|/** Gets the weak value reference held by entry. */
DECL|method|getValueReference ()
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Clears the weak value reference held by the entry. Should be used when the entry's value is      * overwritten.      */
DECL|method|clearValue ()
name|void
name|clearValue
parameter_list|()
function_decl|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
parameter_list|>
DECL|method|unsetWeakValueReference ()
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|unsetWeakValueReference
parameter_list|()
block|{
return|return
operator|(
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
operator|)
name|UNSET_WEAK_VALUE_REFERENCE
return|;
block|}
comment|/** Concrete implementation of {@link InternalEntry} for strong keys and strong values. */
DECL|class|StrongKeyStrongValueEntry
specifier|static
specifier|final
class|class
name|StrongKeyStrongValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractStrongKeyEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|implements
name|StrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|value
annotation|@
name|Nullable
specifier|private
specifier|volatile
name|V
name|value
init|=
literal|null
decl_stmt|;
DECL|method|StrongKeyStrongValueEntry (K key, int hash, @Nullable StrongKeyStrongValueEntry<K, V> next)
name|StrongKeyStrongValueEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|setValue (V value)
name|void
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|copy (StrongKeyStrongValueEntry<K, V> newNext)
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
operator|new
name|StrongKeyStrongValueEntry
argument_list|<>
argument_list|(
name|this
operator|.
name|key
argument_list|,
name|this
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|value
operator|=
name|this
operator|.
name|value
expr_stmt|;
return|return
name|newEntry
return|;
block|}
comment|/** Concrete implementation of {@link InternalEntryHelper} for strong keys and strong values. */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap< K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyStrongValueSegment
argument_list|<>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( StrongKeyStrongValueSegment<K, V> segment, StrongKeyStrongValueEntry<K, V> entry, @Nullable StrongKeyStrongValueEntry<K, V> newNext)
specifier|public
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|entry
operator|.
name|copy
argument_list|(
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( StrongKeyStrongValueSegment<K, V> segment, StrongKeyStrongValueEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newEntry ( StrongKeyStrongValueSegment<K, V> segment, K key, int hash, @Nullable StrongKeyStrongValueEntry<K, V> next)
specifier|public
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyStrongValueEntry
argument_list|<>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Concrete implementation of {@link InternalEntry} for strong keys and weak values. */
DECL|class|StrongKeyWeakValueEntry
specifier|static
specifier|final
class|class
name|StrongKeyWeakValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractStrongKeyEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|implements
name|WeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|valueReference
specifier|private
specifier|volatile
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|valueReference
init|=
name|unsetWeakValueReference
argument_list|()
decl_stmt|;
DECL|method|StrongKeyWeakValueEntry (K key, int hash, @Nullable StrongKeyWeakValueEntry<K, V> next)
name|StrongKeyWeakValueEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|valueReference
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clearValue ()
specifier|public
name|void
name|clearValue
parameter_list|()
block|{
name|valueReference
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|setValue (V value, ReferenceQueue<V> queueForValues)
name|void
name|setValue
parameter_list|(
name|V
name|value
parameter_list|,
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
parameter_list|)
block|{
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
operator|new
name|WeakValueReferenceImpl
argument_list|<>
argument_list|(
name|queueForValues
argument_list|,
name|value
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|copy ( ReferenceQueue<V> queueForValues, StrongKeyWeakValueEntry<K, V> newNext)
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
parameter_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
operator|new
name|StrongKeyWeakValueEntry
argument_list|<>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|valueReference
operator|=
name|valueReference
operator|.
name|copyFor
argument_list|(
name|queueForValues
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
comment|/** Concrete implementation of {@link InternalEntryHelper} for strong keys and weak values. */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|WEAK
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap<K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyWeakValueSegment
argument_list|<>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( StrongKeyWeakValueSegment<K, V> segment, StrongKeyWeakValueEntry<K, V> entry, @Nullable StrongKeyWeakValueEntry<K, V> newNext)
specifier|public
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|Segment
operator|.
name|isCollected
argument_list|(
name|entry
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|entry
operator|.
name|copy
argument_list|(
name|segment
operator|.
name|queueForValues
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( StrongKeyWeakValueSegment<K, V> segment, StrongKeyWeakValueEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|value
argument_list|,
name|segment
operator|.
name|queueForValues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newEntry ( StrongKeyWeakValueSegment<K, V> segment, K key, int hash, @Nullable StrongKeyWeakValueEntry<K, V> next)
specifier|public
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyWeakValueEntry
argument_list|<>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Concrete implementation of {@link InternalEntry} for strong keys and {@link Dummy} values. */
DECL|class|StrongKeyDummyValueEntry
specifier|static
specifier|final
class|class
name|StrongKeyDummyValueEntry
parameter_list|<
name|K
parameter_list|>
extends|extends
name|AbstractStrongKeyEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|>
implements|implements
name|StrongValueEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|method|StrongKeyDummyValueEntry (K key, int hash, @Nullable StrongKeyDummyValueEntry<K> next)
name|StrongKeyDummyValueEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|Dummy
name|getValue
parameter_list|()
block|{
return|return
name|Dummy
operator|.
name|VALUE
return|;
block|}
DECL|method|setValue (Dummy value)
name|void
name|setValue
parameter_list|(
name|Dummy
name|value
parameter_list|)
block|{}
DECL|method|copy (StrongKeyDummyValueEntry<K> newNext)
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|copy
parameter_list|(
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|(
name|this
operator|.
name|key
argument_list|,
name|this
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|/**      * Concrete implementation of {@link InternalEntryHelper} for strong keys and {@link Dummy}      * values.      */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap<K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( StrongKeyDummyValueSegment<K> segment, StrongKeyDummyValueEntry<K> entry, @Nullable StrongKeyDummyValueEntry<K> newNext)
specifier|public
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|copy
parameter_list|(
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|entry
operator|.
name|copy
argument_list|(
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( StrongKeyDummyValueSegment<K> segment, StrongKeyDummyValueEntry<K> entry, Dummy value)
specifier|public
name|void
name|setValue
parameter_list|(
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|entry
parameter_list|,
name|Dummy
name|value
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|newEntry ( StrongKeyDummyValueSegment<K> segment, K key, int hash, @Nullable StrongKeyDummyValueEntry<K> next)
specifier|public
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newEntry
parameter_list|(
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Base class for {@link InternalEntry} implementations for weak keys. */
DECL|class|AbstractWeakKeyEntry
specifier|abstract
specifier|static
class|class
name|AbstractWeakKeyEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|E
name|next
decl_stmt|;
DECL|method|AbstractWeakKeyEntry (ReferenceQueue<K> queue, K key, int hash, @Nullable E next)
name|AbstractWeakKeyEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|E
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|E
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/** Concrete implementation of {@link InternalEntry} for weak keys and {@link Dummy} values. */
DECL|class|WeakKeyDummyValueEntry
specifier|static
specifier|final
class|class
name|WeakKeyDummyValueEntry
parameter_list|<
name|K
parameter_list|>
extends|extends
name|AbstractWeakKeyEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|>
implements|implements
name|StrongValueEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|method|WeakKeyDummyValueEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyDummyValueEntry<K> next)
name|WeakKeyDummyValueEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|Dummy
name|getValue
parameter_list|()
block|{
return|return
name|Dummy
operator|.
name|VALUE
return|;
block|}
DECL|method|setValue (Dummy value)
name|void
name|setValue
parameter_list|(
name|Dummy
name|value
parameter_list|)
block|{}
DECL|method|copy ( ReferenceQueue<K> queueForKeys, WeakKeyDummyValueEntry<K> newNext)
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|copy
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
parameter_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|(
name|queueForKeys
argument_list|,
name|getKey
argument_list|()
argument_list|,
name|this
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|/**      * Concrete implementation of {@link InternalEntryHelper} for weak keys and {@link Dummy}      * values.      */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|WEAK
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap<K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( WeakKeyDummyValueSegment<K> segment, WeakKeyDummyValueEntry<K> entry, @Nullable WeakKeyDummyValueEntry<K> newNext)
specifier|public
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|copy
parameter_list|(
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// key collected
return|return
literal|null
return|;
block|}
return|return
name|entry
operator|.
name|copy
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( WeakKeyDummyValueSegment<K> segment, WeakKeyDummyValueEntry<K> entry, Dummy value)
specifier|public
name|void
name|setValue
parameter_list|(
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|entry
parameter_list|,
name|Dummy
name|value
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|newEntry ( WeakKeyDummyValueSegment<K> segment, K key, int hash, @Nullable WeakKeyDummyValueEntry<K> next)
specifier|public
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|newEntry
parameter_list|(
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Concrete implementation of {@link InternalEntry} for weak keys and strong values. */
DECL|class|WeakKeyStrongValueEntry
specifier|static
specifier|final
class|class
name|WeakKeyStrongValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractWeakKeyEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|implements
name|StrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|value
annotation|@
name|Nullable
specifier|private
specifier|volatile
name|V
name|value
init|=
literal|null
decl_stmt|;
DECL|method|WeakKeyStrongValueEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next)
name|WeakKeyStrongValueEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|setValue (V value)
name|void
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|copy ( ReferenceQueue<K> queueForKeys, WeakKeyStrongValueEntry<K, V> newNext)
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
parameter_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
operator|new
name|WeakKeyStrongValueEntry
argument_list|<>
argument_list|(
name|queueForKeys
argument_list|,
name|getKey
argument_list|()
argument_list|,
name|this
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
comment|/** Concrete implementation of {@link InternalEntryHelper} for weak keys and strong values. */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|WEAK
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|STRONG
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap<K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyStrongValueSegment
argument_list|<>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( WeakKeyStrongValueSegment<K, V> segment, WeakKeyStrongValueEntry<K, V> entry, @Nullable WeakKeyStrongValueEntry<K, V> newNext)
specifier|public
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// key collected
return|return
literal|null
return|;
block|}
return|return
name|entry
operator|.
name|copy
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( WeakKeyStrongValueSegment<K, V> segment, WeakKeyStrongValueEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newEntry ( WeakKeyStrongValueSegment<K, V> segment, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next)
specifier|public
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyStrongValueEntry
argument_list|<>
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Concrete implementation of {@link InternalEntry} for weak keys and weak values. */
DECL|class|WeakKeyWeakValueEntry
specifier|static
specifier|final
class|class
name|WeakKeyWeakValueEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractWeakKeyEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|implements
name|WeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|valueReference
specifier|private
specifier|volatile
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|valueReference
init|=
name|unsetWeakValueReference
argument_list|()
decl_stmt|;
DECL|method|WeakKeyWeakValueEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyWeakValueEntry<K, V> next)
name|WeakKeyWeakValueEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|valueReference
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|copy ( ReferenceQueue<K> queueForKeys, ReferenceQueue<V> queueForValues, WeakKeyWeakValueEntry<K, V> newNext)
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
parameter_list|,
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
parameter_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
operator|new
name|WeakKeyWeakValueEntry
argument_list|<>
argument_list|(
name|queueForKeys
argument_list|,
name|getKey
argument_list|()
argument_list|,
name|this
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|valueReference
operator|=
name|valueReference
operator|.
name|copyFor
argument_list|(
name|queueForValues
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
annotation|@
name|Override
DECL|method|clearValue ()
specifier|public
name|void
name|clearValue
parameter_list|()
block|{
name|valueReference
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|setValue (V value, ReferenceQueue<V> queueForValues)
name|void
name|setValue
parameter_list|(
name|V
name|value
parameter_list|,
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
parameter_list|)
block|{
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
operator|new
name|WeakValueReferenceImpl
argument_list|<>
argument_list|(
name|queueForValues
argument_list|,
name|value
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
comment|/** Concrete implementation of {@link InternalEntryHelper} for weak keys and weak values. */
DECL|class|Helper
specifier|static
specifier|final
class|class
name|Helper
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|InternalEntryHelper
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Helper
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|INSTANCE
init|=
operator|new
name|Helper
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instance ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|instance
parameter_list|()
block|{
return|return
operator|(
name|Helper
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|keyStrength ()
specifier|public
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|WEAK
return|;
block|}
annotation|@
name|Override
DECL|method|valueStrength ()
specifier|public
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|Strength
operator|.
name|WEAK
return|;
block|}
annotation|@
name|Override
DECL|method|newSegment ( MapMakerInternalMap<K, V, WeakKeyWeakValueEntry<K, V>, WeakKeyWeakValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
specifier|public
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyWeakValueSegment
argument_list|<>
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copy ( WeakKeyWeakValueSegment<K, V> segment, WeakKeyWeakValueEntry<K, V> entry, @Nullable WeakKeyWeakValueEntry<K, V> newNext)
specifier|public
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
parameter_list|(
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// key collected
return|return
literal|null
return|;
block|}
if|if
condition|(
name|Segment
operator|.
name|isCollected
argument_list|(
name|entry
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|entry
operator|.
name|copy
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|segment
operator|.
name|queueForValues
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue ( WeakKeyWeakValueSegment<K, V> segment, WeakKeyWeakValueEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|value
argument_list|,
name|segment
operator|.
name|queueForValues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newEntry ( WeakKeyWeakValueSegment<K, V> segment, K key, int hash, @Nullable WeakKeyWeakValueEntry<K, V> next)
specifier|public
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakKeyWeakValueEntry
argument_list|<>
argument_list|(
name|segment
operator|.
name|queueForKeys
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|}
comment|/** A weakly referenced value that also has a reference to its containing entry. */
DECL|interface|WeakValueReference
interface|interface
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
block|{
comment|/**      * Returns the current value being referenced, or {@code null} if there is none (e.g. because      * either it got collected, or {@link #clear} was called, or it wasn't set in the first place).      */
annotation|@
name|Nullable
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/** Returns the entry which contains this {@link WeakValueReference}. */
DECL|method|getEntry ()
name|E
name|getEntry
parameter_list|()
function_decl|;
comment|/** Unsets the referenced value. Subsequent calls to {@link #get} will return {@code null}. */
DECL|method|clear ()
name|void
name|clear
parameter_list|()
function_decl|;
comment|/**      * Returns a freshly created {@link WeakValueReference} for the given {@code entry} (and on the      * given {@code queue} with the same value as this {@link WeakValueReference}.      */
DECL|method|copyFor (ReferenceQueue<V> queue, E entry)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|E
name|entry
parameter_list|)
function_decl|;
block|}
comment|/**    * A dummy implementation of {@link InternalEntry}, solely for use in the type signature of {@link    * #UNSET_WEAK_VALUE_REFERENCE} below.    */
DECL|class|DummyInternalEntry
specifier|static
specifier|final
class|class
name|DummyInternalEntry
implements|implements
name|InternalEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|DummyInternalEntry
argument_list|>
block|{
DECL|method|DummyInternalEntry ()
specifier|private
name|DummyInternalEntry
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|DummyInternalEntry
name|getNext
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|Object
name|getKey
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|Object
name|getValue
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**    * A singleton {@link WeakValueReference} used to denote an unset value in a entry with weak    * values.    */
DECL|field|UNSET_WEAK_VALUE_REFERENCE
specifier|static
specifier|final
name|WeakValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|DummyInternalEntry
argument_list|>
name|UNSET_WEAK_VALUE_REFERENCE
init|=
operator|new
name|WeakValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|DummyInternalEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|DummyInternalEntry
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|WeakValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|DummyInternalEntry
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
name|queue
parameter_list|,
name|DummyInternalEntry
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
block|}
decl_stmt|;
comment|/** Concrete implementation of {@link WeakValueReference}. */
DECL|class|WeakValueReferenceImpl
specifier|static
specifier|final
class|class
name|WeakValueReferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
DECL|field|entry
annotation|@
name|Weak
specifier|final
name|E
name|entry
decl_stmt|;
DECL|method|WeakValueReferenceImpl (ReferenceQueue<V> queue, V referent, E entry)
name|WeakValueReferenceImpl
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|E
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|E
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor (ReferenceQueue<V> queue, E entry)
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|E
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReferenceImpl
argument_list|<>
argument_list|(
name|queue
argument_list|,
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends against poor quality    * hash functions. This is critical when the concurrent hash map uses power-of-two length hash    * tables, that otherwise encounter collisions for hash codes that do not differ in lower or    * upper bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
comment|// TODO(kevinb): use Hashing/move this to Hashing?
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|copyEntry (E original, E newNext)
name|E
name|copyEntry
parameter_list|(
name|E
name|original
parameter_list|,
name|E
name|newNext
parameter_list|)
block|{
name|int
name|hash
init|=
name|original
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|copyEntry
argument_list|(
name|original
argument_list|,
name|newNext
argument_list|)
return|;
block|}
DECL|method|hash (Object key)
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|keyEquivalence
operator|.
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|method|reclaimValue (WeakValueReference<K, V, E> valueReference)
name|void
name|reclaimValue
parameter_list|(
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|valueReference
parameter_list|)
block|{
name|E
name|entry
init|=
name|valueReference
operator|.
name|getEntry
argument_list|()
decl_stmt|;
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|)
expr_stmt|;
block|}
DECL|method|reclaimKey (E entry)
name|void
name|reclaimKey
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}    * instead.    */
annotation|@
name|VisibleForTesting
DECL|method|isLiveForTesting (InternalEntry<K, V, ?> entry)
name|boolean
name|isLiveForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|entry
operator|.
name|getHash
argument_list|()
argument_list|)
operator|.
name|getLiveValueForTesting
argument_list|(
name|entry
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the segment that should be used for a key with the given hash.    *    * @param hash the hash code for the key    * @return the segment    */
DECL|method|segmentFor (int hash)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// TODO(fry): Lazily create segments?
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
DECL|method|createSegment (int initialCapacity, int maxSegmentSize)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|createSegment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
name|entryHelper
operator|.
name|newSegment
argument_list|(
name|this
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
comment|/**    * Gets the value from an entry. Returns {@code null} if the entry is invalid, partially-collected    * or computing.    */
DECL|method|getLiveValue (E entry)
name|V
name|getLiveValue
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
return|return
operator|new
name|Segment
index|[
name|ssize
index|]
return|;
block|}
comment|// Inner Classes
comment|/**    * Segments are specialized versions of hash tables. This subclass inherits from ReentrantLock    * opportunistically, just to simplify some locking and avoid separate construction.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|abstract
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
parameter_list|,
name|S
extends|extends
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|,
name|S
parameter_list|>
parameter_list|>
extends|extends
name|ReentrantLock
block|{
comment|/*      * Segments maintain a table of entry lists that are ALWAYS kept in a consistent state, so can      * be read without locking. Next fields of nodes are immutable (final). All list additions are      * performed at the front of each bin. This makes it easy to check changes, and also fast to      * traverse. When nodes would otherwise be changed, new nodes are created to replace them. This      * works well for hash tables since the bin lists tend to be short. (The average length is less      * than two.)      *      * Read operations can thus proceed without locking, but rely on selected uses of volatiles to      * ensure that completed write operations performed by other threads are noticed. For most      * purposes, the "count" field, tracking the number of elements, serves as that volatile      * variable ensuring visibility. This is convenient because this field needs to be read in many      * read operations anyway:      *      * - All (unsynchronized) read operations must first read the "count" field, and should not      * look at table entries if it is 0.      *      * - All (synchronized) write operations should write to the "count" field after structurally      * changing any bin. The operations must not take any action that could even momentarily      * cause a concurrent read operation to see inconsistent data. This is made easier by the      * nature of the read operations in Map. For example, no operation can reveal that the table      * has grown but the threshold has not yet been updated, so there are no atomicity requirements      * for this with respect to reads.      *      * As a guide, all critical volatile reads and writes to the count field are marked in code      * comments.      */
DECL|field|map
annotation|@
name|Weak
specifier|final
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|map
decl_stmt|;
comment|/**      * The number of live elements in this segment's region. This does not include unset elements      * which are awaiting cleanup.      */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**      * Number of updates that alter the size of the table. This is used during bulk-read methods to      * make sure they see a consistent snapshot: If modCounts change during a traversal of segments      * computing size or checking containsValue, then we might have an inconsistent view of state      * so (usually) must retry.      */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**      * The table is expanded when its size exceeds this threshold. (The value of this field is      * always {@code (int) (capacity * 0.75)}.)      */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/** The per-segment table. */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
decl_stmt|;
comment|/**      * The maximum size of this map. MapMaker.UNSET_INT if there is no maximum.      */
DECL|field|maxSegmentSize
specifier|final
name|int
name|maxSegmentSize
decl_stmt|;
comment|/**      * A counter of the number of reads since the last write, used to drain queues on a small      * fraction of read operations.      */
DECL|field|readCount
specifier|final
name|AtomicInteger
name|readCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|method|Segment (MapMakerInternalMap<K, V, E, S> map, int initialCapacity, int maxSegmentSize)
name|Segment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|maxSegmentSize
operator|=
name|maxSegmentSize
expr_stmt|;
name|initTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns {@code this} up-casted to the specific {@link Segment} implementation type {@code S}.      *      *<p>This method exists so that the {@link Segment} code can be generic in terms of {@code S},      * the type of the concrete implementation.      */
DECL|method|self ()
specifier|abstract
name|S
name|self
parameter_list|()
function_decl|;
comment|/** Drains the reference queues used by this segment, if any. */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|maybeDrainReferenceQueues ()
name|void
name|maybeDrainReferenceQueues
parameter_list|()
block|{}
comment|/** Clears the reference queues used by this segment, if any. */
DECL|method|maybeClearReferenceQueues ()
name|void
name|maybeClearReferenceQueues
parameter_list|()
block|{}
comment|/** Sets the value of the given {@code entry}. */
DECL|method|setValue (E entry, V value)
name|void
name|setValue
parameter_list|(
name|E
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|map
operator|.
name|entryHelper
operator|.
name|setValue
argument_list|(
name|self
argument_list|()
argument_list|,
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Returns a copy of the given {@code entry}. */
DECL|method|copyEntry (E original, E newNext)
name|E
name|copyEntry
parameter_list|(
name|E
name|original
parameter_list|,
name|E
name|newNext
parameter_list|)
block|{
return|return
name|this
operator|.
name|map
operator|.
name|entryHelper
operator|.
name|copy
argument_list|(
name|self
argument_list|()
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
return|;
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
DECL|method|initTable (AtomicReferenceArray<E> newTable)
name|void
name|initTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
comment|// 0.75
if|if
condition|(
name|this
operator|.
name|threshold
operator|==
name|maxSegmentSize
condition|)
block|{
comment|// prevent spurious expansion before eviction
name|this
operator|.
name|threshold
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
comment|// Convenience methods for testing
comment|/**      * Unsafe cast of the given entry to {@code E}, the type of the specific {@link InternalEntry}      * implementation type.      *      *<p>This method is provided as a convenience for tests. Otherwise they'd need to be      * knowledgable about all the implementation details of our type system trickery.      */
DECL|method|castForTesting (InternalEntry<K, V, ?> entry)
specifier|abstract
name|E
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/** Unsafely extracts the key reference queue used by this segment. */
DECL|method|getKeyReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|getKeyReferenceQueueForTesting
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/** Unsafely extracts the value reference queue used by this segment. */
DECL|method|getValueReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|getValueReferenceQueueForTesting
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/** Unsafely extracts the weak value reference inside of the given {@code entry}. */
DECL|method|getWeakValueReferenceForTesting (InternalEntry<K, V, ?> entry)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|getWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**      * Unsafely creates of a fresh {@link WeakValueReference}, referencing the given {@code value},      * for the given {@code entry}      */
DECL|method|newWeakValueReferenceForTesting ( InternalEntry<K, V, ?> entry, V value)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|newWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**      * Unsafely sets the weak value reference inside the given {@code entry} to be the given {@code      * valueReference}      */
DECL|method|setWeakValueReferenceForTesting ( InternalEntry<K, V, ?> entry, WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference)
name|void
name|setWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|,
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
argument_list|>
name|valueReference
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**      * Unsafely sets the given index of this segment's internal hash table to be the given entry.      */
DECL|method|setTableEntryForTesting (int i, InternalEntry<K, V, ?> entry)
name|void
name|setTableEntryForTesting
parameter_list|(
name|int
name|i
parameter_list|,
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unsafely returns a copy of the given entry. */
DECL|method|copyForTesting (InternalEntry<K, V, ?> entry, @Nullable InternalEntry<K, V, ?> newNext)
name|E
name|copyForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|this
operator|.
name|map
operator|.
name|entryHelper
operator|.
name|copy
argument_list|(
name|self
argument_list|()
argument_list|,
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|,
name|castForTesting
argument_list|(
name|newNext
argument_list|)
argument_list|)
return|;
block|}
comment|/** Unsafely sets the value of the given entry. */
DECL|method|setValueForTesting (InternalEntry<K, V, ?> entry, V value)
name|void
name|setValueForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|map
operator|.
name|entryHelper
operator|.
name|setValue
argument_list|(
name|self
argument_list|()
argument_list|,
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Unsafely returns a fresh entry. */
DECL|method|newEntryForTesting (K key, int hash, @Nullable InternalEntry<K, V, ?> next)
name|E
name|newEntryForTesting
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|this
operator|.
name|map
operator|.
name|entryHelper
operator|.
name|newEntry
argument_list|(
name|self
argument_list|()
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|castForTesting
argument_list|(
name|next
argument_list|)
argument_list|)
return|;
block|}
comment|/** Unsafely removes the given entry from this segment's hash table. */
annotation|@
name|CanIgnoreReturnValue
DECL|method|removeTableEntryForTesting (InternalEntry<K, V, ?> entry)
name|boolean
name|removeTableEntryForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|removeEntryForTesting
argument_list|(
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
block|}
comment|/** Unsafely removes the given entry from the given chain in this segment's hash table. */
DECL|method|removeFromChainForTesting (InternalEntry<K, V, ?> first, InternalEntry<K, V, ?> entry)
name|E
name|removeFromChainForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|first
parameter_list|,
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|removeFromChain
argument_list|(
name|castForTesting
argument_list|(
name|first
argument_list|)
argument_list|,
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Unsafely returns the value of the given entry if it's still live, or {@code null} otherwise.      */
annotation|@
name|Nullable
DECL|method|getLiveValueForTesting (InternalEntry<K, V, ?> entry)
name|V
name|getLiveValueForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|getLiveValue
argument_list|(
name|castForTesting
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
block|}
comment|// reference queues, for garbage collection cleanup
comment|/**      * Cleanup collected entries when the lock is available.      */
DECL|method|tryDrainReferenceQueues ()
name|void
name|tryDrainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|maybeDrainReferenceQueues
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainKeyReferenceQueue (ReferenceQueue<K> keyReferenceQueue)
name|void
name|drainKeyReferenceQueue
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|keyReferenceQueue
parameter_list|)
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|entry
init|=
operator|(
name|E
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainValueReferenceQueue (ReferenceQueue<V> valueReferenceQueue)
name|void
name|drainValueReferenceQueue
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|valueReferenceQueue
parameter_list|)
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|valueReference
init|=
operator|(
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimValue
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
DECL|method|clearReferenceQueue (ReferenceQueue<T> referenceQueue)
parameter_list|<
name|T
parameter_list|>
name|void
name|clearReferenceQueue
parameter_list|(
name|ReferenceQueue
argument_list|<
name|T
argument_list|>
name|referenceQueue
parameter_list|)
block|{
while|while
condition|(
name|referenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
comment|/** Returns first entry of bin for given hash. */
DECL|method|getFirst (int hash)
name|E
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// read this volatile field only once
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|// Specialized implementations of map methods
DECL|method|getEntry (Object key, int hash)
name|E
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|E
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getLiveEntry (Object key, int hash)
name|E
name|getLiveEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
return|return
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
name|E
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|E
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method is a convenience for testing. Code should call {@link      * MapMakerInternalMap#containsValue} directly.      */
annotation|@
name|VisibleForTesting
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|E
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|entryValue
init|=
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
argument_list|()
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
expr_stmt|;
comment|// count remains unchanged
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|onlyIfAbsent
condition|)
block|{
comment|// Mimic
comment|// "if (!map.containsKey(key)) ...
comment|// else return map.get(key);
return|return
name|entryValue
return|;
block|}
else|else
block|{
comment|// clobber existing entry, count remains unchanged
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|E
name|newEntry
init|=
name|map
operator|.
name|entryHelper
operator|.
name|newEntry
argument_list|(
name|self
argument_list|()
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Expands the table if possible.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*        * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the        * elements from each bin must either stay at same index, or move with a power of two offset.        * We eliminate unnecessary node creation by catching cases where old nodes can be reused        * because their next fields won't change. Statistically, at the default threshold, only        * about one-sixth of them need cloning when a table doubles. The nodes they replace will be        * garbage collectable as soon as they are no longer referenced by any reader thread that may        * be in the midst of traversing table right now.        */
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
operator|++
name|oldIndex
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|E
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|E
name|next
init|=
name|head
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|int
name|headIndex
init|=
name|head
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|E
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|next
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|E
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
name|E
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|E
name|newFirst
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFirst
operator|!=
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newCount
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
argument_list|()
operator|.
name|equivalent
argument_list|(
name|oldValue
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Mimic
comment|// "if (map.containsKey(key)&& map.get(key).equals(oldValue))..."
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|CanIgnoreReturnValue
DECL|method|remove (Object key, int hash)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|!=
literal|null
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|explicitRemoval
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|valueEquivalence
argument_list|()
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
name|explicitRemoval
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|explicitRemoval
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|maybeClearReferenceQueues
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes an entry from within a table. All entries following the removed node can stay, but      * all preceding ones need to be cloned.      *      *<p>This method does not decrement count for the removed entry, but does decrement count for      * all partially collected entries which are skipped. As such callers which are modifying count      * must re-read it after calling removeFromChain.      *      * @param first the first entry of the table      * @param entry the entry being removed from the table      * @return the new first entry for the table      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeFromChain (E first, E entry)
name|E
name|removeFromChain
parameter_list|(
name|E
name|first
parameter_list|,
name|E
name|entry
parameter_list|)
block|{
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|E
name|newFirst
init|=
name|entry
operator|.
name|getNext
argument_list|()
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
name|entry
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|E
name|next
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newFirst
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|newCount
operator|--
expr_stmt|;
block|}
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
return|return
name|newFirst
return|;
block|}
comment|/** Removes an entry whose key has been garbage collected. */
annotation|@
name|CanIgnoreReturnValue
DECL|method|reclaimKey (E entry, int hash)
name|boolean
name|reclaimKey
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Removes an entry whose value has been garbage collected. */
annotation|@
name|CanIgnoreReturnValue
DECL|method|reclaimValue (K key, int hash, WeakValueReference<K, V, E> valueReference)
name|boolean
name|reclaimValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|v
init|=
operator|(
operator|(
name|WeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
operator|)
name|e
operator|)
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Clears a value that has not yet been set, and thus does not require count to be modified. */
annotation|@
name|CanIgnoreReturnValue
DECL|method|clearValueForTesting ( K key, int hash, WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference)
name|boolean
name|clearValueForTesting
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|v
init|=
operator|(
operator|(
name|WeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
operator|)
name|e
operator|)
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeEntryForTesting (E entry)
name|boolean
name|removeEntryForTesting
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns {@code true} if the value has been partially collected, meaning that the value is      * null.      */
DECL|method|isCollected (E entry)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
parameter_list|>
name|boolean
name|isCollected
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**      * Gets the value from an entry. Returns {@code null} if the entry is invalid or      * partially-collected.      */
annotation|@
name|Nullable
DECL|method|getLiveValue (E entry)
name|V
name|getLiveValue
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs routine cleanup following a read. Normally cleanup happens during writes, or from      * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try      * cleaning up from the read thread.      */
DECL|method|postReadCleanup ()
name|void
name|postReadCleanup
parameter_list|()
block|{
if|if
condition|(
operator|(
name|readCount
operator|.
name|incrementAndGet
argument_list|()
operator|&
name|DRAIN_THRESHOLD
operator|)
operator|==
literal|0
condition|)
block|{
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs routine cleanup prior to executing a write. This should be called every time a      * write thread acquires the segment lock, immediately after acquiring the lock.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|preWriteCleanup ()
name|void
name|preWriteCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runCleanup ()
name|void
name|runCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runLockedCleanup ()
name|void
name|runLockedCleanup
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|maybeDrainReferenceQueues
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for strong keys and strong values. */
DECL|class|StrongKeyStrongValueSegment
specifier|static
specifier|final
class|class
name|StrongKeyStrongValueSegment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|StrongKeyStrongValueSegment ( MapMakerInternalMap< K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
name|StrongKeyStrongValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|StrongKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, V, ?> entry)
specifier|public
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|StrongKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|entry
return|;
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for strong keys and weak values. */
DECL|class|StrongKeyWeakValueSegment
specifier|static
specifier|final
class|class
name|StrongKeyWeakValueSegment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|queueForValues
specifier|private
specifier|final
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
init|=
operator|new
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|StrongKeyWeakValueSegment ( MapMakerInternalMap<K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
name|StrongKeyWeakValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|StrongKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getValueReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|getValueReferenceQueueForTesting
parameter_list|()
block|{
return|return
name|queueForValues
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, V, ?> entry)
specifier|public
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|getWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e)
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|getWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|)
block|{
return|return
name|castForTesting
argument_list|(
name|e
argument_list|)
operator|.
name|getValueReference
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|newWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e, V value)
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReferenceImpl
argument_list|<>
argument_list|(
name|queueForValues
argument_list|,
name|value
argument_list|,
name|castForTesting
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e, WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference)
specifier|public
name|void
name|setWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|,
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
argument_list|>
name|valueReference
parameter_list|)
block|{
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|castForTesting
argument_list|(
name|e
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newValueReference
init|=
operator|(
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
operator|)
name|valueReference
decl_stmt|;
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|StrongKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|previous
init|=
name|entry
operator|.
name|valueReference
decl_stmt|;
name|entry
operator|.
name|valueReference
operator|=
name|newValueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeDrainReferenceQueues ()
name|void
name|maybeDrainReferenceQueues
parameter_list|()
block|{
name|drainValueReferenceQueue
argument_list|(
name|queueForValues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeClearReferenceQueues ()
name|void
name|maybeClearReferenceQueues
parameter_list|()
block|{
name|clearReferenceQueue
argument_list|(
name|queueForValues
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for strong keys and {@link Dummy} values. */
DECL|class|StrongKeyDummyValueSegment
specifier|static
specifier|final
class|class
name|StrongKeyDummyValueSegment
parameter_list|<
name|K
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|method|StrongKeyDummyValueSegment ( MapMakerInternalMap<K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>> map, int initialCapacity, int maxSegmentSize)
name|StrongKeyDummyValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|StrongKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, Dummy, ?> entry)
specifier|public
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|StrongKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
operator|)
name|entry
return|;
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for weak keys and strong values. */
DECL|class|WeakKeyStrongValueSegment
specifier|static
specifier|final
class|class
name|WeakKeyStrongValueSegment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|queueForKeys
specifier|private
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
init|=
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|WeakKeyStrongValueSegment ( MapMakerInternalMap<K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
name|WeakKeyStrongValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|WeakKeyStrongValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getKeyReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|getKeyReferenceQueueForTesting
parameter_list|()
block|{
return|return
name|queueForKeys
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, V, ?> entry)
specifier|public
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|WeakKeyStrongValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|maybeDrainReferenceQueues ()
name|void
name|maybeDrainReferenceQueues
parameter_list|()
block|{
name|drainKeyReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeClearReferenceQueues ()
name|void
name|maybeClearReferenceQueues
parameter_list|()
block|{
name|clearReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for weak keys and weak values. */
DECL|class|WeakKeyWeakValueSegment
specifier|static
specifier|final
class|class
name|WeakKeyWeakValueSegment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|queueForKeys
specifier|private
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
init|=
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|queueForValues
specifier|private
specifier|final
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queueForValues
init|=
operator|new
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|WeakKeyWeakValueSegment ( MapMakerInternalMap<K, V, WeakKeyWeakValueEntry<K, V>, WeakKeyWeakValueSegment<K, V>> map, int initialCapacity, int maxSegmentSize)
name|WeakKeyWeakValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|WeakKeyWeakValueSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getKeyReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|getKeyReferenceQueueForTesting
parameter_list|()
block|{
return|return
name|queueForKeys
return|;
block|}
annotation|@
name|Override
DECL|method|getValueReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|getValueReferenceQueueForTesting
parameter_list|()
block|{
return|return
name|queueForValues
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, V, ?> entry)
specifier|public
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|getWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e)
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|getWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|)
block|{
return|return
operator|(
name|castForTesting
argument_list|(
name|e
argument_list|)
operator|)
operator|.
name|getValueReference
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|newWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e, V value)
specifier|public
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReferenceImpl
argument_list|<>
argument_list|(
name|queueForValues
argument_list|,
name|value
argument_list|,
name|castForTesting
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setWeakValueReferenceForTesting ( InternalEntry<K, V, ?> e, WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference)
specifier|public
name|void
name|setWeakValueReferenceForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|e
parameter_list|,
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
extends|extends
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
argument_list|>
name|valueReference
parameter_list|)
block|{
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|castForTesting
argument_list|(
name|e
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newValueReference
init|=
operator|(
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
operator|)
name|valueReference
decl_stmt|;
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|WeakKeyWeakValueEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|previous
init|=
name|entry
operator|.
name|valueReference
decl_stmt|;
name|entry
operator|.
name|valueReference
operator|=
name|newValueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeDrainReferenceQueues ()
name|void
name|maybeDrainReferenceQueues
parameter_list|()
block|{
name|drainKeyReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
name|drainValueReferenceQueue
argument_list|(
name|queueForValues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeClearReferenceQueues ()
name|void
name|maybeClearReferenceQueues
parameter_list|()
block|{
name|clearReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Concrete implementation of {@link Segment} for weak keys and {@link Dummy} values. */
DECL|class|WeakKeyDummyValueSegment
specifier|static
specifier|final
class|class
name|WeakKeyDummyValueSegment
parameter_list|<
name|K
parameter_list|>
extends|extends
name|Segment
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
block|{
DECL|field|queueForKeys
specifier|private
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queueForKeys
init|=
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|WeakKeyDummyValueSegment ( MapMakerInternalMap<K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> map, int initialCapacity, int maxSegmentSize)
name|WeakKeyDummyValueSegment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
argument_list|,
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|self ()
name|WeakKeyDummyValueSegment
argument_list|<
name|K
argument_list|>
name|self
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getKeyReferenceQueueForTesting ()
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|getKeyReferenceQueueForTesting
parameter_list|()
block|{
return|return
name|queueForKeys
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|castForTesting (InternalEntry<K, Dummy, ?> entry)
specifier|public
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
name|castForTesting
parameter_list|(
name|InternalEntry
argument_list|<
name|K
argument_list|,
name|Dummy
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|WeakKeyDummyValueEntry
argument_list|<
name|K
argument_list|>
operator|)
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|maybeDrainReferenceQueues ()
name|void
name|maybeDrainReferenceQueues
parameter_list|()
block|{
name|drainKeyReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|maybeClearReferenceQueues ()
name|void
name|maybeClearReferenceQueues
parameter_list|()
block|{
name|clearReferenceQueue
argument_list|(
name|queueForKeys
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|CleanupMapTask
specifier|static
specifier|final
class|class
name|CleanupMapTask
implements|implements
name|Runnable
block|{
DECL|field|mapReference
specifier|final
name|WeakReference
argument_list|<
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|mapReference
decl_stmt|;
DECL|method|CleanupMapTask (MapMakerInternalMap<?, ?, ?, ?> map)
specifier|public
name|CleanupMapTask
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|mapReference
operator|=
operator|new
name|WeakReference
argument_list|<>
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|mapReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
block|}
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|segment
operator|.
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|keyStrength ()
name|Strength
name|keyStrength
parameter_list|()
block|{
return|return
name|entryHelper
operator|.
name|keyStrength
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|valueStrength ()
name|Strength
name|valueStrength
parameter_list|()
block|{
return|return
name|entryHelper
operator|.
name|valueStrength
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|valueEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|()
block|{
return|return
name|entryHelper
operator|.
name|valueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
return|;
block|}
comment|// ConcurrentMap methods
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
comment|/*      * Sum per-segment modCounts to avoid mis-reporting when elements are concurrently added and      * removed in one segment while checking another, in which case the table was never actually      * empty at any point. (The sum ensures accuracy up through at least 1<<31 per-segment      * modifications before recheck.)  Method containsValue() uses similar constructions for      * stability checks.      */
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
comment|// recheck unless no modifications
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|-=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|sum
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**    * Returns the internal entry for the specified key. The entry may be computing or partially    * collected. Does not impact recency ordering.    */
DECL|method|getEntry (@ullable Object key)
name|E
name|getEntry
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// This implementation is patterned after ConcurrentHashMap, but without the locking. The only
comment|// way for it to return a false negative would be for the target value to jump around in the map
comment|// such that none of the subsequent iterations observed it, despite the fact that at every point
comment|// in time it was present somewhere int the map. This becomes increasingly unlikely as
comment|// CONTAINS_VALUE_RETRIES increases, though without locking it is theoretically possible.
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONTAINS_VALUE_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
comment|// ensure visibility of most recent completed write
name|int
name|unused
init|=
name|segment
operator|.
name|count
decl_stmt|;
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|E
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|j
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|segment
operator|.
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
argument_list|()
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
name|sum
operator|+=
name|segment
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
name|last
condition|)
block|{
break|break;
block|}
name|last
operator|=
name|sum
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|keySet
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
DECL|field|values
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
DECL|field|entrySet
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|// Iterator Support
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentSegment
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|,
name|S
argument_list|>
name|currentSegment
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|E
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
specifier|abstract
name|T
name|next
parameter_list|()
function_decl|;
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|currentSegment
operator|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|currentSegment
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|currentSegment
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Finds the next entry in the current chain. Returns {@code true} if an entry was found.      */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Finds the next entry in the current table. Returns {@code true} if an entry was found.      */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Advances to the given entry. Returns {@code true} if the entry was valid, {@code false} if it      * should be skipped.      */
DECL|method|advanceTo (E entry)
name|boolean
name|advanceTo
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
try|try
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getLiveValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip stale entry.
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|currentSegment
operator|.
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|lastReturned
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the    * underlying map.    */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|value
name|V
name|value
decl_stmt|;
comment|// non-null
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Cannot use key and value equivalence
if|if
condition|(
name|object
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|key
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Cannot use key and value equivalence
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (V newValue)
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|V
name|oldValue
init|=
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
comment|// only if put succeeds
return|return
name|oldValue
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|SafeToArraySet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
comment|// https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (E[] a)
specifier|public
parameter_list|<
name|E
parameter_list|>
name|E
index|[]
name|toArray
parameter_list|(
name|E
index|[]
name|a
parameter_list|)
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|SafeToArraySet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
argument_list|()
operator|.
name|equivalent
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|SafeToArraySet
specifier|private
specifier|abstract
specifier|static
class|class
name|SafeToArraySet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
comment|// super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
comment|// https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (E[] a)
specifier|public
parameter_list|<
name|E
parameter_list|>
name|E
index|[]
name|toArray
parameter_list|(
name|E
index|[]
name|a
parameter_list|)
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
block|}
DECL|method|toArrayList (Collection<E> c)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|toArrayList
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|c
parameter_list|)
block|{
comment|// Avoid calling ArrayList(Collection), which may call back into toArray.
name|ArrayList
argument_list|<
name|E
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|result
argument_list|,
name|c
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Serialization Support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5
decl_stmt|;
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializationProxy
argument_list|<>
argument_list|(
name|entryHelper
operator|.
name|keyStrength
argument_list|()
argument_list|,
name|entryHelper
operator|.
name|valueStrength
argument_list|()
argument_list|,
name|keyEquivalence
argument_list|,
name|entryHelper
operator|.
name|valueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|,
name|concurrencyLevel
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|AbstractSerializationProxy
specifier|abstract
specifier|static
class|class
name|AbstractSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
DECL|field|delegate
specifier|transient
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|AbstractSerializationProxy ( Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|AbstractSerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|valueStrength
expr_stmt|;
name|this
operator|.
name|keyEquivalence
operator|=
name|keyEquivalence
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|valueEquivalence
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|writeMapTo (ObjectOutputStream out)
name|void
name|writeMapTo
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|delegate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|delegate
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// terminate entries
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// serialization of deprecated feature
DECL|method|readMapMaker (ObjectInputStream in)
name|MapMaker
name|readMapMaker
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
return|return
operator|new
name|MapMaker
argument_list|()
operator|.
name|initialCapacity
argument_list|(
name|size
argument_list|)
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|setValueStrength
argument_list|(
name|valueStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|keyEquivalence
argument_list|)
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readEntries (ObjectInputStream in)
name|void
name|readEntries
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
break|break;
comment|// terminator
block|}
name|V
name|value
init|=
operator|(
name|V
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|delegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|SerializationProxy
specifier|private
specifier|static
specifier|final
class|class
name|SerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|method|SerializationProxy ( Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|SerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|concurrencyLevel
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|writeObject (ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|writeMapTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|MapMaker
name|mapMaker
init|=
name|readMapMaker
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|delegate
operator|=
name|mapMaker
operator|.
name|makeMap
argument_list|()
expr_stmt|;
name|readEntries
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
block|}
end_class

end_unit

