begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * The concurrent hash map implementation built by {@link MapMaker}.  *  *<p>This implementation is heavily derived from revision 1.96 of<a  * href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.  *  * @author Bob Lee  * @author Charles Fry  * @author Doug Lea ({@code ConcurrentHashMap})  */
end_comment

begin_comment
comment|// TODO(kak/cpovirk): Consider removing @CanIgnoreReturnValue from this class.
end_comment

begin_class
annotation|@
name|GwtIncompatible
DECL|class|MapMakerInternalMap
class|class
name|MapMakerInternalMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*    * The basic strategy is to subdivide the table among Segments, each of which itself is a    * concurrently readable hash table. The map supports non-blocking reads and concurrent writes    * across different segments.    *    * The page replacement algorithm's data structures are kept casually consistent with the map. The    * ordering of writes to a segment is sequentially consistent. An update to the map and recording    * of reads may not be immediately reflected on the algorithm's data structures. These structures    * are guarded by a lock and operations are applied in batches to avoid lock contention. The    * penalty of applying the batches is spread across threads so that the amortized cost is slightly    * higher than performing just the operation without enforcing the capacity constraint.    *    * This implementation uses a per-segment queue to record a memento of the additions, removals,    * and accesses that were performed on the map. The queue is drained on writes and when it exceeds    * its capacity threshold.    *    * The Least Recently Used page replacement algorithm was chosen due to its simplicity, high hit    * rate, and ability to be implemented with O(1) time complexity. The initial LRU implementation    * operates per-segment rather than globally for increased implementation simplicity. We expect    * the cache hit rate to be similar to that of a global LRU algorithm.    */
comment|// Constants
comment|/**    * The maximum capacity, used if a higher value is implicitly specified by either of the    * constructors with arguments. MUST be a power of two<= 1<<30 to ensure that entries are    * indexable using ints.    */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
name|Ints
operator|.
name|MAX_POWER_OF_TWO
decl_stmt|;
comment|/** The maximum number of segments to allow; used to bound constructor arguments. */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/** Number of (unsynchronized) retries in the containsValue method. */
DECL|field|CONTAINS_VALUE_RETRIES
specifier|static
specifier|final
name|int
name|CONTAINS_VALUE_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Number of cache access operations that can be buffered per segment before the cache's recency    * ordering information is updated. This is used to avoid lock contention by recording a memento    * of reads and delaying a lock acquisition until the threshold is crossed or a mutation occurs.    *    *<p>This must be a (2^n)-1 as it is used as a mask.    */
DECL|field|DRAIN_THRESHOLD
specifier|static
specifier|final
name|int
name|DRAIN_THRESHOLD
init|=
literal|0x3F
decl_stmt|;
comment|/**    * Maximum number of entries to be drained in a single cleanup run. This applies independently to    * the cleanup queue and both reference queues.    */
comment|// TODO(fry): empirically optimize this
DECL|field|DRAIN_MAX
specifier|static
specifier|final
name|int
name|DRAIN_MAX
init|=
literal|16
decl_stmt|;
DECL|field|CLEANUP_EXECUTOR_DELAY_SECS
specifier|static
specifier|final
name|long
name|CLEANUP_EXECUTOR_DELAY_SECS
init|=
literal|60
decl_stmt|;
comment|// Fields
comment|/**    * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose    * the segment.    */
DECL|field|segmentMask
specifier|final
specifier|transient
name|int
name|segmentMask
decl_stmt|;
comment|/**    * Shift value for indexing within segments. Helps prevent entries that end up in the same segment    * from also ending up in the same bucket.    */
DECL|field|segmentShift
specifier|final
specifier|transient
name|int
name|segmentShift
decl_stmt|;
comment|/** The segments, each of which is a specialized hash table. */
DECL|field|segments
specifier|final
specifier|transient
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/** The concurrency level. */
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|/** Strategy for comparing keys. */
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
comment|/** Strategy for comparing values. */
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
comment|/** Strategy for referencing keys. */
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
comment|/** Strategy for referencing values. */
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
comment|/** Factory used to create new entries. */
DECL|field|entryFactory
specifier|final
specifier|transient
name|EntryFactory
name|entryFactory
decl_stmt|;
comment|/**    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.    */
DECL|method|MapMakerInternalMap (MapMaker builder)
name|MapMakerInternalMap
parameter_list|(
name|MapMaker
name|builder
parameter_list|)
block|{
name|concurrencyLevel
operator|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|,
name|MAX_SEGMENTS
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|builder
operator|.
name|getKeyStrength
argument_list|()
expr_stmt|;
name|valueStrength
operator|=
name|builder
operator|.
name|getValueStrength
argument_list|()
expr_stmt|;
name|keyEquivalence
operator|=
name|builder
operator|.
name|getKeyEquivalence
argument_list|()
expr_stmt|;
name|valueEquivalence
operator|=
name|valueStrength
operator|.
name|defaultEquivalence
argument_list|()
expr_stmt|;
name|entryFactory
operator|=
name|EntryFactory
operator|.
name|getFactory
argument_list|(
name|keyStrength
argument_list|)
expr_stmt|;
name|int
name|initialCapacity
init|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getInitialCapacity
argument_list|()
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
decl_stmt|;
comment|// Find power-of-two sizes best matching arguments. Constraints:
comment|// (segmentCount> concurrencyLevel)
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|MapMaker
operator|.
name|UNSET_INT
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|usesKeyReferences ()
name|boolean
name|usesKeyReferences
parameter_list|()
block|{
return|return
name|keyStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|method|usesValueReferences ()
name|boolean
name|usesValueReferences
parameter_list|()
block|{
return|return
name|valueStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|enum|Strength
enum|enum
name|Strength
block|{
comment|/*      * TODO(kevinb): If we strongly reference the value and aren't computing, we needn't wrap the      * value. This could save ~8 bytes per entry.      */
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|equals
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalence
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|;
comment|/**      * Creates a reference for the given value according to this value strength.      */
DECL|method|referenceValue ( Segment<K, V> segment, ReferenceEntry<K, V> entry, V value)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Returns the default equivalence strategy used to compare and hash keys or values referenced      * at this strength. This strategy will be used unless the user explicitly specifies an      * alternate strategy.      */
DECL|method|defaultEquivalence ()
specifier|abstract
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
function_decl|;
block|}
comment|/**    * Creates new entries.    */
DECL|enum|EntryFactory
enum|enum
name|EntryFactory
block|{
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|;
DECL|method|getFactory (Strength keyStrength)
specifier|static
name|EntryFactory
name|getFactory
parameter_list|(
name|Strength
name|keyStrength
parameter_list|)
block|{
switch|switch
condition|(
name|keyStrength
condition|)
block|{
case|case
name|STRONG
case|:
return|return
name|EntryFactory
operator|.
name|STRONG
return|;
case|case
name|WEAK
case|:
return|return
name|EntryFactory
operator|.
name|WEAK
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**      * Creates a new entry.      *      * @param segment to create the entry for      * @param key of the entry      * @param hash of the key      * @param next entry in the same bucket      */
DECL|method|newEntry ( Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Copies an entry, assigning it a new {@code next} entry.      *      * @param original the entry to copy      * @param newNext entry in the same bucket      */
comment|// Guarded By Segment.this
DECL|method|copyEntry ( Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|newEntry
argument_list|(
name|segment
argument_list|,
name|original
operator|.
name|getKey
argument_list|()
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
return|;
block|}
block|}
comment|/**    * A reference to a value.    */
DECL|interface|ValueReference
interface|interface
name|ValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value. Does not block or throw exceptions.      */
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/**      * Waits for a value that may still be computing. Unlike get(), this method can block (in the      * case of FutureValueReference).      *      * @throws ExecutionException if the computing thread throws an exception      */
DECL|method|waitForValue ()
name|V
name|waitForValue
parameter_list|()
throws|throws
name|ExecutionException
function_decl|;
comment|/**      * Returns the entry associated with this value reference, or {@code null} if this value      * reference is independent of any entry.      */
DECL|method|getEntry ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
function_decl|;
comment|/**      * Creates a copy of this reference for the given entry.      *      *<p>{@code value} may be null only for a loading reference.      */
DECL|method|copyFor ( ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/**      * Clears this reference object.      *      * @param newValue the new value reference which will replace this one; this is only used during      *     computation to immediately notify blocked threads of the new value      */
DECL|method|clear (@ullable ValueReference<K, V> newValue)
name|void
name|clear
parameter_list|(
annotation|@
name|Nullable
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
function_decl|;
comment|/**      * Returns {@code true} if the value type is a computing reference (regardless of whether or not      * computation has completed). This is necessary to distiguish between partially-collected      * entries and computing entries, which need to be cleaned up differently.      */
DECL|method|isComputingReference ()
name|boolean
name|isComputingReference
parameter_list|()
function_decl|;
block|}
comment|/**    * Placeholder. Indicates that the value hasn't been set yet.    */
DECL|field|UNSET
specifier|static
specifier|final
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|UNSET
init|=
operator|new
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
name|queue
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|waitForValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newValue
parameter_list|)
block|{}
block|}
decl_stmt|;
comment|/**    * Singleton placeholder that indicates a value is being computed.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|unset ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unset
parameter_list|()
block|{
return|return
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|UNSET
return|;
block|}
comment|/**    * An entry in a reference map.    *    * Entries in the map can be in the following states:    *    * Valid:    * - Live: valid key/value are set    * - Computing: computation is pending    *    * Invalid:    * - Collected: key/value was partially collected, but not yet cleaned up    */
DECL|interface|ReferenceEntry
interface|interface
name|ReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value reference from this entry.      */
DECL|method|getValueReference ()
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Sets the value reference for this entry.      */
DECL|method|setValueReference (ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
function_decl|;
comment|/**      * Gets the next entry in the chain.      */
DECL|method|getNext ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
function_decl|;
comment|/**      * Gets the entry's hash.      */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/**      * Gets the key for this entry.      */
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
function_decl|;
block|}
DECL|enum|NullEntry
specifier|private
enum|enum
name|NullEntry
implements|implements
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<Object, Object> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|valueReference
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|Object
name|getKey
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|class|AbstractReferenceEntry
specifier|abstract
specifier|static
class|class
name|AbstractReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|nullEntry ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
parameter_list|()
block|{
return|return
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
comment|/*    * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!    */
comment|/**    * Used for strongly-referenced keys.    */
DECL|class|StrongEntry
specifier|static
class|class
name|StrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|method|StrongEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/**    * Used for weakly-referenced keys.    */
DECL|class|WeakEntry
specifier|static
class|class
name|WeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEntry (ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/**    * References a weak value.    */
DECL|class|WeakValueReference
specifier|static
specifier|final
class|class
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|WeakValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry)
name|WeakValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|clear (ValueReference<K, V> newValue)
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isComputingReference ()
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * References a strong value.    */
DECL|class|StrongValueReference
specifier|static
specifier|final
class|class
name|StrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|referent
specifier|final
name|V
name|referent
decl_stmt|;
DECL|method|StrongValueReference (V referent)
name|StrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|)
block|{
name|this
operator|.
name|referent
operator|=
name|referent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|referent
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|value
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|isComputingReference ()
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear (ValueReference<K, V> newValue)
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
block|{}
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends against poor quality    * hash functions. This is critical when the concurrent hash map uses power-of-two length hash    * tables, that otherwise encounter collisions for hash codes that do not differ in lower or    * upper bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
comment|// TODO(kevinb): use Hashing/move this to Hashing?
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|int
name|hash
init|=
name|original
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|copyEntry
argument_list|(
name|original
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#setValue} instead.    */
comment|// Guarded By Segment.this
annotation|@
name|VisibleForTesting
DECL|method|newValueReference (ReferenceEntry<K, V> entry, V value)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|segmentFor
argument_list|(
name|hash
argument_list|)
argument_list|,
name|entry
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|hash (Object key)
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|keyEquivalence
operator|.
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|method|reclaimValue (ValueReference<K, V> valueReference)
name|void
name|reclaimValue
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|valueReference
operator|.
name|getEntry
argument_list|()
decl_stmt|;
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|)
expr_stmt|;
block|}
DECL|method|reclaimKey (ReferenceEntry<K, V> entry)
name|void
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}    * instead.    */
annotation|@
name|VisibleForTesting
DECL|method|isLive (ReferenceEntry<K, V> entry)
name|boolean
name|isLive
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|entry
operator|.
name|getHash
argument_list|()
argument_list|)
operator|.
name|getLiveValue
argument_list|(
name|entry
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the segment that should be used for a key with the given hash.    *    * @param hash the hash code for the key    * @return the segment    */
DECL|method|segmentFor (int hash)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// TODO(fry): Lazily create segments?
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
DECL|method|createSegment (int initialCapacity, int maxSegmentSize)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|createSegment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
comment|/**    * Gets the value from an entry. Returns {@code null} if the entry is invalid,    * partially-collected or computing. Unlike {@link Segment#getLiveValue} this method    * does not attempt to clean up stale entries.    */
DECL|method|getLiveValue (ReferenceEntry<K, V> entry)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
return|return
operator|new
name|Segment
index|[
name|ssize
index|]
return|;
block|}
comment|// Inner Classes
comment|/**    * Segments are specialized versions of hash tables. This subclass inherits from ReentrantLock    * opportunistically, just to simplify some locking and avoid separate construction.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ReentrantLock
block|{
comment|/*      * Segments maintain a table of entry lists that are ALWAYS kept in a consistent state, so can      * be read without locking. Next fields of nodes are immutable (final). All list additions are      * performed at the front of each bin. This makes it easy to check changes, and also fast to      * traverse. When nodes would otherwise be changed, new nodes are created to replace them. This      * works well for hash tables since the bin lists tend to be short. (The average length is less      * than two.)      *      * Read operations can thus proceed without locking, but rely on selected uses of volatiles to      * ensure that completed write operations performed by other threads are noticed. For most      * purposes, the "count" field, tracking the number of elements, serves as that volatile      * variable ensuring visibility. This is convenient because this field needs to be read in many      * read operations anyway:      *      * - All (unsynchronized) read operations must first read the "count" field, and should not      * look at table entries if it is 0.      *      * - All (synchronized) write operations should write to the "count" field after structurally      * changing any bin. The operations must not take any action that could even momentarily      * cause a concurrent read operation to see inconsistent data. This is made easier by the      * nature of the read operations in Map. For example, no operation can reveal that the table      * has grown but the threshold has not yet been updated, so there are no atomicity requirements      * for this with respect to reads.      *      * As a guide, all critical volatile reads and writes to the count field are marked in code      * comments.      */
DECL|field|map
annotation|@
name|Weak
specifier|final
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
comment|/**      * The number of live elements in this segment's region. This does not include unset elements      * which are awaiting cleanup.      */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**      * Number of updates that alter the size of the table. This is used during bulk-read methods to      * make sure they see a consistent snapshot: If modCounts change during a traversal of segments      * computing size or checking containsValue, then we might have an inconsistent view of state      * so (usually) must retry.      */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**      * The table is expanded when its size exceeds this threshold. (The value of this field is      * always {@code (int) (capacity * 0.75)}.)      */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**      * The per-segment table.      */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
decl_stmt|;
comment|/**      * The maximum size of this map. MapMaker.UNSET_INT if there is no maximum.      */
DECL|field|maxSegmentSize
specifier|final
name|int
name|maxSegmentSize
decl_stmt|;
comment|/**      * The key reference queue contains entries whose keys have been garbage collected, and which      * need to be cleaned up internally.      */
DECL|field|keyReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|keyReferenceQueue
decl_stmt|;
comment|/**      * The value reference queue contains value references whose values have been garbage collected,      * and which need to be cleaned up internally.      */
DECL|field|valueReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|valueReferenceQueue
decl_stmt|;
comment|/**      * A counter of the number of reads since the last write, used to drain queues on a small      * fraction of read operations.      */
DECL|field|readCount
specifier|final
name|AtomicInteger
name|readCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|method|Segment (MapMakerInternalMap<K, V> map, int initialCapacity, int maxSegmentSize)
name|Segment
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|maxSegmentSize
operator|=
name|maxSegmentSize
expr_stmt|;
name|initTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
name|keyReferenceQueue
operator|=
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
name|valueReferenceQueue
operator|=
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
DECL|method|initTable (AtomicReferenceArray<ReferenceEntry<K, V>> newTable)
name|void
name|initTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
comment|// 0.75
if|if
condition|(
name|this
operator|.
name|threshold
operator|==
name|maxSegmentSize
condition|)
block|{
comment|// prevent spurious expansion before eviction
name|this
operator|.
name|threshold
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|map
operator|.
name|entryFactory
operator|.
name|newEntry
argument_list|(
name|this
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/**      * Copies {@code original} into a new entry chained to {@code newNext}. Returns the new entry,      * or {@code null} if {@code original} was already garbage collected.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
if|if
condition|(
name|original
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// key collected
return|return
literal|null
return|;
block|}
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|original
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
literal|null
operator|)
operator|&&
operator|!
name|valueReference
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
comment|// value collected
return|return
literal|null
return|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|map
operator|.
name|entryFactory
operator|.
name|copyEntry
argument_list|(
name|this
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|copyFor
argument_list|(
name|this
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
comment|/**      * Sets a new value of an entry.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|setValue (ReferenceEntry<K, V> entry, V value)
name|void
name|setValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|map
operator|.
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|this
argument_list|,
name|entry
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setValueReference
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
comment|// reference queues, for garbage collection cleanup
comment|/**      * Cleanup collected entries when the lock is available.      */
DECL|method|tryDrainReferenceQueues ()
name|void
name|tryDrainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Drain the key and value reference queues, cleaning up internal entries containing garbage      * collected keys or values.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainReferenceQueues ()
name|void
name|drainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|drainKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|drainValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainKeyReferenceQueue ()
name|void
name|drainKeyReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|drainValueReferenceQueue ()
name|void
name|drainValueReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimValue
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/**      * Clears all entries from the key and value reference queues.      */
DECL|method|clearReferenceQueues ()
name|void
name|clearReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|clearKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|clearValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clearKeyReferenceQueue ()
name|void
name|clearKeyReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
DECL|method|clearValueReferenceQueue ()
name|void
name|clearValueReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
comment|/**      * Returns first entry of bin for given hash.      */
DECL|method|getFirst (int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// read this volatile field only once
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|// Specialized implementations of map methods
DECL|method|getEntry (Object key, int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getLiveEntry (Object key, int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getLiveEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|e
return|;
block|}
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method is a convenience for testing. Code should call {@link      * MapMakerInternalMap#containsValue} directly.      */
annotation|@
name|VisibleForTesting
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|entryValue
init|=
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valueReference
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
name|newCount
operator|=
name|this
operator|.
name|count
expr_stmt|;
comment|// count remains unchanged
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|onlyIfAbsent
condition|)
block|{
comment|// Mimic
comment|// "if (!map.containsKey(key)) ...
comment|// else return map.get(key);
return|return
name|entryValue
return|;
block|}
else|else
block|{
comment|// clobber existing entry, count remains unchanged
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Expands the table if possible.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*        * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the        * elements from each bin must either stay at same index, or move with a power of two offset.        * We eliminate unnecessary node creation by catching cases where old nodes can be reused        * because their next fields won't change. Statistically, at the default threshold, only        * about one-sixth of them need cloning when a table doubles. The nodes they replace will be        * garbage collectable as soon as they are no longer referenced by any reader thread that may        * be in the midst of traversing table right now.        */
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
operator|++
name|oldIndex
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|int
name|headIndex
init|=
name|head
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|next
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFirst
operator|!=
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newCount
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|oldValue
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Mimic
comment|// "if (map.containsKey(key)&& map.get(key).equals(oldValue))..."
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|CanIgnoreReturnValue
DECL|method|remove (Object key, int hash)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|!=
literal|null
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|boolean
name|explicitRemoval
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
name|explicitRemoval
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
comment|// TODO(kak): Remove this branch
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|explicitRemoval
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|clearReferenceQueues
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes an entry from within a table. All entries following the removed node can stay, but      * all preceding ones need to be cloned.      *      *<p>This method does not decrement count for the removed entry, but does decrement count for      * all partially collected entries which are skipped. As such callers which are modifying count      * must re-read it after calling removeFromChain.      *      * @param first the first entry of the table      * @param entry the entry being removed from the table      * @return the new first entry for the table      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeFromChain (ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeFromChain
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|entry
operator|.
name|getNext
argument_list|()
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
name|entry
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newFirst
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|newCount
operator|--
expr_stmt|;
block|}
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
return|return
name|newFirst
return|;
block|}
comment|/**      * Removes an entry whose key has been garbage collected.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|reclaimKey (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Removes an entry whose value has been garbage collected.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|reclaimValue (K key, int hash, ValueReference<K, V> valueReference)
name|boolean
name|reclaimValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Clears a value that has not yet been set, and thus does not require count to be modified.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|clearValue (K key, int hash, ValueReference<K, V> valueReference)
name|boolean
name|clearValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|removeEntry (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|removeEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns {@code true} if the value has been partially collected, meaning that the value is      * null and it is not computing.      */
DECL|method|isCollected (ValueReference<K, V> valueReference)
name|boolean
name|isCollected
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
if|if
condition|(
name|valueReference
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|valueReference
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|)
return|;
block|}
comment|/**      * Gets the value from an entry. Returns {@code null} if the entry is invalid,      * partially-collected or computing.      */
DECL|method|getLiveValue (ReferenceEntry<K, V> entry)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs routine cleanup following a read. Normally cleanup happens during writes, or from      * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try      * cleaning up from the read thread.      */
DECL|method|postReadCleanup ()
name|void
name|postReadCleanup
parameter_list|()
block|{
if|if
condition|(
operator|(
name|readCount
operator|.
name|incrementAndGet
argument_list|()
operator|&
name|DRAIN_THRESHOLD
operator|)
operator|==
literal|0
condition|)
block|{
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs routine cleanup prior to executing a write. This should be called every time a      * write thread acquires the segment lock, immediately after acquiring the lock.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"this"
argument_list|)
DECL|method|preWriteCleanup ()
name|void
name|preWriteCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runCleanup ()
name|void
name|runCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runLockedCleanup ()
name|void
name|runLockedCleanup
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|CleanupMapTask
specifier|static
specifier|final
class|class
name|CleanupMapTask
implements|implements
name|Runnable
block|{
DECL|field|mapReference
specifier|final
name|WeakReference
argument_list|<
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|mapReference
decl_stmt|;
DECL|method|CleanupMapTask (MapMakerInternalMap<?, ?> map)
specifier|public
name|CleanupMapTask
parameter_list|(
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|mapReference
operator|=
operator|new
name|WeakReference
argument_list|<
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MapMakerInternalMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|mapReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
block|}
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|segment
operator|.
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// ConcurrentMap methods
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
comment|/*      * Sum per-segment modCounts to avoid mis-reporting when elements are concurrently added and      * removed in one segment while checking another, in which case the table was never actually      * empty at any point. (The sum ensures accuracy up through at least 1<<31 per-segment      * modifications before recheck.)  Method containsValue() uses similar constructions for      * stability checks.      */
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
comment|// recheck unless no modifications
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|-=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|sum
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**    * Returns the internal entry for the specified key. The entry may be computing or    * partially collected. Does not impact recency ordering.    */
DECL|method|getEntry (@ullable Object key)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// This implementation is patterned after ConcurrentHashMap, but without the locking. The only
comment|// way for it to return a false negative would be for the target value to jump around in the map
comment|// such that none of the subsequent iterations observed it, despite the fact that at every point
comment|// in time it was present somewhere int the map. This becomes increasingly unlikely as
comment|// CONTAINS_VALUE_RETRIES increases, though without locking it is theoretically possible.
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONTAINS_VALUE_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
comment|// ensure visibility of most recent completed write
name|int
name|unused
init|=
name|segment
operator|.
name|count
decl_stmt|;
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|j
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|segment
operator|.
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
name|sum
operator|+=
name|segment
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
name|last
condition|)
block|{
break|break;
block|}
name|last
operator|=
name|sum
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|keySet
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
DECL|field|values
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
DECL|field|entrySet
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|// Iterator Support
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentSegment
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|currentSegment
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
specifier|abstract
name|E
name|next
parameter_list|()
function_decl|;
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|currentSegment
operator|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|currentSegment
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|currentSegment
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Finds the next entry in the current chain. Returns {@code true} if an entry was found.      */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Finds the next entry in the current table. Returns {@code true} if an entry was found.      */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Advances to the given entry. Returns {@code true} if the entry was valid, {@code false} if it      * should be skipped.      */
DECL|method|advanceTo (ReferenceEntry<K, V> entry)
name|boolean
name|advanceTo
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
try|try
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getLiveValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip stale entry.
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|currentSegment
operator|.
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|lastReturned
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the    * underlying map.    */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|value
name|V
name|value
decl_stmt|;
comment|// non-null
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Cannot use key and value equivalence
if|if
condition|(
name|object
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|key
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Cannot use key and value equivalence
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (V newValue)
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|V
name|oldValue
init|=
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
comment|// only if put succeeds
return|return
name|oldValue
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|SafeToArraySet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
comment|// https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (E[] a)
specifier|public
parameter_list|<
name|E
parameter_list|>
name|E
index|[]
name|toArray
parameter_list|(
name|E
index|[]
name|a
parameter_list|)
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
block|}
annotation|@
name|WeakOuter
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|SafeToArraySet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|MapMakerInternalMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|SafeToArraySet
specifier|private
specifier|abstract
specifier|static
class|class
name|SafeToArraySet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
comment|// super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
comment|// https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (E[] a)
specifier|public
parameter_list|<
name|E
parameter_list|>
name|E
index|[]
name|toArray
parameter_list|(
name|E
index|[]
name|a
parameter_list|)
block|{
return|return
name|toArrayList
argument_list|(
name|this
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
block|}
DECL|method|toArrayList (Collection<E> c)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|toArrayList
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|c
parameter_list|)
block|{
comment|// Avoid calling ArrayList(Collection), which may call back into toArray.
name|ArrayList
argument_list|<
name|E
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|result
argument_list|,
name|c
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Serialization Support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5
decl_stmt|;
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|concurrencyLevel
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|AbstractSerializationProxy
specifier|abstract
specifier|static
class|class
name|AbstractSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
DECL|field|delegate
specifier|transient
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|AbstractSerializationProxy ( Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|AbstractSerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|valueStrength
expr_stmt|;
name|this
operator|.
name|keyEquivalence
operator|=
name|keyEquivalence
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|valueEquivalence
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|writeMapTo (ObjectOutputStream out)
name|void
name|writeMapTo
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|delegate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|delegate
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// terminate entries
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// serialization of deprecated feature
DECL|method|readMapMaker (ObjectInputStream in)
name|MapMaker
name|readMapMaker
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
return|return
operator|new
name|MapMaker
argument_list|()
operator|.
name|initialCapacity
argument_list|(
name|size
argument_list|)
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|setValueStrength
argument_list|(
name|valueStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|keyEquivalence
argument_list|)
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readEntries (ObjectInputStream in)
name|void
name|readEntries
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
break|break;
comment|// terminator
block|}
name|V
name|value
init|=
operator|(
name|V
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|delegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|SerializationProxy
specifier|private
specifier|static
specifier|final
class|class
name|SerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|method|SerializationProxy ( Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|SerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|concurrencyLevel
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|writeObject (ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|writeMapTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|MapMaker
name|mapMaker
init|=
name|readMapMaker
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|delegate
operator|=
name|mapMaker
operator|.
name|makeMap
argument_list|()
expr_stmt|;
name|readEntries
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
block|}
end_class

end_unit

