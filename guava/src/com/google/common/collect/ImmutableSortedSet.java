begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ObjectArrays
operator|.
name|checkElementsNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|LazyInit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InvalidObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterators
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A {@link NavigableSet} whose contents will never change, with many other important properties  * detailed at {@link ImmutableCollection}.  *  *<p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link  * Comparator} or {@link Comparable} type whose comparison behavior is<i>inconsistent with  * equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero  *<i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting  * collection will not correctly obey its specification.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained"> immutable collections</a>.  *  * @author Jared Levy  * @author Louis Wasserman  * @since 2.0 (implements {@code NavigableSet} since 12.0)  */
end_comment

begin_comment
comment|// TODO(benyu): benchmark and optimize all creation paths, which are a mess now
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|,
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// we're overriding default serialization
DECL|class|ImmutableSortedSet
specifier|public
specifier|abstract
class|class
name|ImmutableSortedSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSortedSetFauxverideShim
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
implements|,
name|SortedIterable
argument_list|<
name|E
argument_list|>
block|{
DECL|field|SPLITERATOR_CHARACTERISTICS
specifier|static
specifier|final
name|int
name|SPLITERATOR_CHARACTERISTICS
init|=
name|ImmutableSet
operator|.
name|SPLITERATOR_CHARACTERISTICS
operator||
name|Spliterator
operator|.
name|SORTED
decl_stmt|;
comment|/**    * Returns a {@code Collector} that accumulates the input elements into a new {@code    * ImmutableSortedSet}, ordered by the specified comparator.    *    *<p>If the elements contain duplicates (according to the comparator), only the first duplicate    * in encounter order will appear in the result.    *    * @since 21.0    */
DECL|method|toImmutableSortedSet ( Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collector
argument_list|<
name|E
argument_list|,
name|?
argument_list|,
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|toImmutableSortedSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|CollectCollectors
operator|.
name|toImmutableSortedSet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
DECL|method|emptySet (Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|emptySet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|equals
argument_list|(
name|comparator
argument_list|)
condition|)
block|{
return|return
operator|(
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|RegularImmutableSortedSet
operator|.
name|NATURAL_EMPTY_SET
return|;
block|}
else|else
block|{
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
expr|<
name|E
operator|>
name|of
argument_list|()
argument_list|,
name|comparator
argument_list|)
return|;
block|}
block|}
comment|/** Returns the empty immutable sorted set. */
DECL|method|of ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|()
block|{
return|return
operator|(
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|RegularImmutableSortedSet
operator|.
name|NATURAL_EMPTY_SET
return|;
block|}
comment|/** Returns an immutable sorted set containing a single element. */
DECL|method|of (E element)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|element
parameter_list|)
block|{
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|element
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|2
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2, E e3)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|3
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of (E e1, E e2, E e3, E e4)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|4
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|5
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any element is null    * @since 3.0 (source-compatible since 2.0)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|,
name|E
name|e6
parameter_list|,
name|E
modifier|...
name|remaining
parameter_list|)
block|{
name|Comparable
index|[]
name|contents
init|=
operator|new
name|Comparable
index|[
literal|6
operator|+
name|remaining
operator|.
name|length
index|]
decl_stmt|;
name|contents
index|[
literal|0
index|]
operator|=
name|e1
expr_stmt|;
name|contents
index|[
literal|1
index|]
operator|=
name|e2
expr_stmt|;
name|contents
index|[
literal|2
index|]
operator|=
name|e3
expr_stmt|;
name|contents
index|[
literal|3
index|]
operator|=
name|e4
expr_stmt|;
name|contents
index|[
literal|4
index|]
operator|=
name|e5
expr_stmt|;
name|contents
index|[
literal|5
index|]
operator|=
name|e6
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|remaining
argument_list|,
literal|0
argument_list|,
name|contents
argument_list|,
literal|6
argument_list|,
name|remaining
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|contents
operator|.
name|length
argument_list|,
operator|(
name|E
index|[]
operator|)
name|contents
argument_list|)
return|;
block|}
comment|// TODO(kevinb): Consider factory methods that reject duplicates
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first    * one specified is included.    *    * @throws NullPointerException if any of {@code elements} is null    * @since 3.0    */
DECL|method|copyOf (E[] elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|E
index|[]
name|elements
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|elements
operator|.
name|length
argument_list|,
name|elements
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@code compareTo()}, only the first one    * specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,    * call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.    *    *<p>Note that if {@code s} is a {@code Set<String>}, then {@code ImmutableSortedSet.copyOf(s)}    * returns an {@code ImmutableSortedSet<String>} containing each of the strings in {@code s},    * while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet<Set<String>>}    * containing one element (the given set itself).    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@code compareTo()}, only the first one    * specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,    * call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.    *    *<p>Note that if {@code s} is a {@code Set<String>}, then {@code ImmutableSortedSet.copyOf(s)}    * returns an {@code ImmutableSortedSet<String>} containing each of the strings in {@code s},    * while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet<Set<String>>}    * containing one element (the given set itself).    *    *<p><b>Note:</b> Despite what the method name suggests, if {@code elements} is an {@code    * ImmutableSortedSet}, it may be returned instead of a copy.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    *<p>This method is safe to use even when {@code elements} is a synchronized or concurrent    * collection that is currently being modified by another thread.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    * @since 7.0 (source-compatible since 2.0)    */
DECL|method|copyOf (Collection<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by their natural ordering.    * When multiple elements are equivalent according to {@code compareTo()}, only the first one    * specified is included.    *    *<p>This method is not type-safe, as it may be called on elements that are not mutually    * comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by the given {@code    * Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the    * first one specified is included.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by the given {@code    * Comparator}. When multiple elements are equivalent according to {@code compare()}, only the    * first one specified is included. This method iterates over {@code elements} at most once.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|boolean
name|hasSameComparator
init|=
name|SortedIterables
operator|.
name|hasSameComparator
argument_list|(
name|comparator
argument_list|,
name|elements
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasSameComparator
operator|&&
operator|(
name|elements
operator|instanceof
name|ImmutableSortedSet
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|original
init|=
operator|(
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|elements
decl_stmt|;
if|if
condition|(
operator|!
name|original
operator|.
name|isPartialView
argument_list|()
condition|)
block|{
return|return
name|original
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// elements only contains E's; it's safe.
name|E
index|[]
name|array
init|=
operator|(
name|E
index|[]
operator|)
name|Iterables
operator|.
name|toArray
argument_list|(
name|elements
argument_list|)
decl_stmt|;
return|return
name|construct
argument_list|(
name|comparator
argument_list|,
name|array
operator|.
name|length
argument_list|,
name|array
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by the given {@code    * Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the    * first one specified is included.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is safe to use even when {@code elements} is a synchronized or concurrent    * collection that is currently being modified by another thread.    *    * @throws NullPointerException if {@code comparator} or any of {@code elements} is null    * @since 7.0 (source-compatible since 2.0)    */
DECL|method|copyOf ( Comparator<? super E> comparator, Collection<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|comparator
argument_list|,
operator|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
operator|)
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the elements of a sorted set, sorted by the same    * {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always uses the    * natural ordering of the elements.    *    *<p>Despite the method name, this method attempts to avoid actually copying the data when it is    * safe to do so. The exact circumstances under which a copy will or will not be performed are    * undocumented and subject to change.    *    *<p>This method is safe to use even when {@code sortedSet} is a synchronized or concurrent    * collection that is currently being modified by another thread.    *    * @throws NullPointerException if {@code sortedSet} or any of its elements is null    */
DECL|method|copyOfSorted (SortedSet<E> sortedSet)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOfSorted
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|sortedSet
parameter_list|)
block|{
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
init|=
name|SortedIterables
operator|.
name|comparator
argument_list|(
name|sortedSet
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|sortedSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|emptySet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|,
name|comparator
argument_list|)
return|;
block|}
block|}
comment|/**    * Constructs an {@code ImmutableSortedSet} from the first {@code n} elements of {@code contents}.    * If {@code k} is the size of the returned {@code ImmutableSortedSet}, then the sorted unique    * elements are in the first {@code k} positions of {@code contents}, and {@code contents[i] ==    * null} for {@code k<= i< n}.    *    *<p>If {@code k == contents.length}, then {@code contents} may no longer be safe for    * modification.    *    * @throws NullPointerException if any of the first {@code n} elements of {@code contents} is null    */
DECL|method|construct ( Comparator<? super E> comparator, int n, E... contents)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|construct
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|int
name|n
parameter_list|,
name|E
modifier|...
name|contents
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|emptySet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|checkElementsNotNull
argument_list|(
name|contents
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|int
name|uniques
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|E
name|cur
init|=
name|contents
index|[
name|i
index|]
decl_stmt|;
name|E
name|prev
init|=
name|contents
index|[
name|uniques
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|cur
argument_list|,
name|prev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|contents
index|[
name|uniques
operator|++
index|]
operator|=
name|cur
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|contents
argument_list|,
name|uniques
argument_list|,
name|n
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
expr|<
name|E
operator|>
name|asImmutableList
argument_list|(
name|contents
argument_list|,
name|uniques
argument_list|)
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets with an explicit comparator. If the    * comparator has a more general type than the set being generated, such as creating a {@code    * SortedSet<Integer>} with a {@code Comparator<Number>}, use the {@link Builder} constructor    * instead.    *    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|orderedBy (Comparator<E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|orderedBy
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets whose elements are ordered by the reverse    * of their natural ordering.    */
DECL|method|reverseOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|reverseOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets whose elements are ordered by their    * natural ordering. The sorted sets use {@link Ordering#natural()} as the comparator. This method    * provides more type-safety than {@link #builder}, as it can be called only for classes that    * implement {@link Comparable}.    */
DECL|method|naturalOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|naturalOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * A builder for creating immutable sorted set instances, especially {@code public static final}    * sets ("constant sets"), with a given comparator. Example:    *    *<pre>{@code    * public static final ImmutableSortedSet<Number> LUCKY_NUMBERS =    *     new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR)    *         .addAll(SINGLE_DIGIT_PRIMES)    *         .add(42)    *         .build();    * }</pre>    *    *<p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build    * multiple sets in series. Each set is a superset of the set created before it.    *    * @since 2.0    */
DECL|class|Builder
specifier|public
specifier|static
specifier|final
class|class
name|Builder
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
block|{
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|elements
specifier|private
name|E
index|[]
name|elements
decl_stmt|;
DECL|field|n
specifier|private
name|int
name|n
decl_stmt|;
comment|/**      * Creates a new builder. The returned builder is equivalent to the builder generated by {@link      * ImmutableSortedSet#orderedBy}.      */
DECL|method|Builder (Comparator<? super E> comparator)
specifier|public
name|Builder
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// don't construct guts of hash-based set builder
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|elements
operator|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|ImmutableCollection
operator|.
name|Builder
operator|.
name|DEFAULT_INITIAL_CAPACITY
index|]
expr_stmt|;
name|this
operator|.
name|n
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copy ()
name|void
name|copy
parameter_list|()
block|{
name|elements
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|,
name|elements
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|sortAndDedup ()
specifier|private
name|void
name|sortAndDedup
parameter_list|()
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|int
name|unique
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|elements
index|[
name|unique
operator|-
literal|1
index|]
argument_list|,
name|elements
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|elements
index|[
name|unique
operator|++
index|]
operator|=
name|elements
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Comparator "
operator|+
name|comparator
operator|+
literal|" compare method violates its contract"
argument_list|)
throw|;
block|}
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|elements
argument_list|,
name|unique
argument_list|,
name|n
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|n
operator|=
name|unique
expr_stmt|;
block|}
comment|/**      * Adds {@code element} to the {@code ImmutableSortedSet}. If the {@code ImmutableSortedSet}      * already contains {@code element}, then {@code add} has no effect. (only the previously added      * element is retained).      *      * @param element the element to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|add (E element)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|copyIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|elements
operator|.
name|length
condition|)
block|{
name|sortAndDedup
argument_list|()
expr_stmt|;
comment|/*          * Sorting operations can only be allowed to occur once every O(n) operations to keep          * amortized O(n log n) performance.  Therefore, ensure there are at least O(n) *unused*          * spaces in the builder array.          */
name|int
name|newLength
init|=
name|ImmutableCollection
operator|.
name|Builder
operator|.
name|expandedCapacity
argument_list|(
name|n
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLength
operator|>
name|elements
operator|.
name|length
condition|)
block|{
name|elements
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
block|}
name|elements
index|[
name|n
operator|++
index|]
operator|=
name|element
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate      * elements (only the first duplicate element is added).      *      * @param elements the elements to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|add (E... elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|checkElementsNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
for|for
control|(
name|E
name|e
range|:
name|elements
control|)
block|{
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate      * elements (only the first duplicate element is added).      *      * @param elements the elements to add to the {@code ImmutableSortedSet}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|addAll (Iterable<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate      * elements (only the first duplicate element is added).      *      * @param elements the elements to add to the {@code ImmutableSortedSet}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|addAll (Iterator<? extends E> elements)
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|combine (ImmutableSet.Builder<E> builder)
name|Builder
argument_list|<
name|E
argument_list|>
name|combine
parameter_list|(
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|builder
parameter_list|)
block|{
name|copyIfNecessary
argument_list|()
expr_stmt|;
name|Builder
argument_list|<
name|E
argument_list|>
name|other
init|=
operator|(
name|Builder
argument_list|<
name|E
argument_list|>
operator|)
name|builder
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|n
condition|;
name|i
operator|++
control|)
block|{
name|add
argument_list|(
name|other
operator|.
name|elements
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Returns a newly-created {@code ImmutableSortedSet} based on the contents of the {@code      * Builder} and its comparator.      */
annotation|@
name|Override
DECL|method|build ()
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|build
parameter_list|()
block|{
name|sortAndDedup
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|emptySet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
else|else
block|{
name|forceCopy
operator|=
literal|true
expr_stmt|;
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|asImmutableList
argument_list|(
name|elements
argument_list|,
name|n
argument_list|)
argument_list|,
name|comparator
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|unsafeCompare (Object a, Object b)
name|int
name|unsafeCompare
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|unsafeCompare
argument_list|(
name|comparator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|unsafeCompare (Comparator<?> comparator, Object a, Object b)
specifier|static
name|int
name|unsafeCompare
parameter_list|(
name|Comparator
argument_list|<
name|?
argument_list|>
name|comparator
parameter_list|,
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
comment|// Pretend the comparator can compare anything. If it turns out it can't
comment|// compare a and b, we should get a CCE on the subsequent line. Only methods
comment|// that are spec'd to throw CCE should call this.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Comparator
argument_list|<
name|Object
argument_list|>
name|unsafeComparator
init|=
operator|(
name|Comparator
argument_list|<
name|Object
argument_list|>
operator|)
name|comparator
decl_stmt|;
return|return
name|unsafeComparator
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|field|comparator
specifier|final
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|method|ImmutableSortedSet (Comparator<? super E> comparator)
name|ImmutableSortedSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
comment|/**    * Returns the comparator that orders the elements, which is {@link Ordering#natural()} when the    * natural ordering of the elements is used. Note that its behavior is not consistent with {@link    * SortedSet#comparator()}, which returns {@code null} to indicate natural ordering.    */
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
annotation|@
name|Override
comment|// needed to unify the iterator() methods in Collection and SortedIterable
DECL|method|iterator ()
specifier|public
specifier|abstract
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
function_decl|;
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#headSet} documentation states that a subset of a subset throws an    * {@link IllegalArgumentException} if passed a {@code toElement} greater than an earlier {@code    * toElement}. However, this method doesn't throw an exception in that situation, but instead    * keeps the original {@code toElement}.    */
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|headSet (E toElement, boolean inclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|headSetImpl
argument_list|(
name|checkNotNull
argument_list|(
name|toElement
argument_list|)
argument_list|,
name|inclusive
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#subSet} documentation states that a subset of a subset throws an {@link    * IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code    * fromElement}. However, this method doesn't throw an exception in that situation, but instead    * keeps the original {@code fromElement}. Similarly, this method keeps the original {@code    * toElement}, instead of throwing an exception, if passed a {@code toElement} greater than an    * earlier {@code toElement}.    */
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|subSet ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fromElement
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|toElement
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
return|return
name|subSetImpl
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#tailSet} documentation states that a subset of a subset throws an    * {@link IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code    * fromElement}. However, this method doesn't throw an exception in that situation, but instead    * keeps the original {@code fromElement}.    */
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|tailSet (E fromElement, boolean inclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|tailSetImpl
argument_list|(
name|checkNotNull
argument_list|(
name|fromElement
argument_list|)
argument_list|,
name|inclusive
argument_list|)
return|;
block|}
comment|/*    * These methods perform most headSet, subSet, and tailSet logic, besides    * parameter validation.    */
DECL|method|headSetImpl (E toElement, boolean inclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSetImpl
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
DECL|method|subSetImpl ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSetImpl
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
function_decl|;
DECL|method|tailSetImpl (E fromElement, boolean inclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSetImpl
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|lower (E e)
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|Override
DECL|method|floor (E e)
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|Override
DECL|method|ceiling (E e)
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|higher (E e)
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
return|return
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
return|return
name|descendingIterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the set unmodified.    *    * @since 12.0    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
specifier|final
name|E
name|pollFirst
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the set unmodified.    *    * @since 12.0    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
specifier|final
name|E
name|pollLast
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|LazyInit
DECL|field|descendingSet
specifier|transient
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|descendingSet
decl_stmt|;
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
comment|// racy single-check idiom
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|descendingSet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|descendingSet
operator|=
name|createDescendingSet
argument_list|()
expr_stmt|;
name|result
operator|.
name|descendingSet
operator|=
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// Most classes should implement this as new DescendingImmutableSortedSet<E>(this),
comment|// but we push down that implementation because ProGuard can't eliminate it even when it's always
comment|// overridden.
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|method|createDescendingSet ()
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|createDescendingSet
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|E
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
operator|new
name|Spliterators
operator|.
name|AbstractSpliterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|,
name|SPLITERATOR_CHARACTERISTICS
operator||
name|Spliterator
operator|.
name|SIZED
argument_list|)
block|{
specifier|final
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
init|=
name|iterator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|E
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
block|}
return|;
block|}
comment|/** @since 12.0 */
annotation|@
name|GwtIncompatible
comment|// NavigableSet
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
specifier|abstract
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
function_decl|;
comment|/** Returns the position of an element within the set, or -1 if not present. */
DECL|method|indexOf (@ullable Object target)
specifier|abstract
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|target
parameter_list|)
function_decl|;
comment|/*    * This class is used to serialize all ImmutableSortedSet instances,    * regardless of implementation type. It captures their "logical contents"    * only. This is necessary to ensure that the existence of a particular    * implementation type is an implementation detail.    */
DECL|class|SerializedForm
specifier|private
specifier|static
class|class
name|SerializedForm
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|comparator
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|elements
specifier|final
name|Object
index|[]
name|elements
decl_stmt|;
DECL|method|SerializedForm (Comparator<? super E> comparator, Object[] elements)
specifier|public
name|SerializedForm
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Object
index|[]
name|elements
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|elements
operator|=
name|elements
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|add
argument_list|(
operator|(
name|E
index|[]
operator|)
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|readObject (ObjectInputStream unused)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|unused
parameter_list|)
throws|throws
name|InvalidObjectException
block|{
throw|throw
operator|new
name|InvalidObjectException
argument_list|(
literal|"Use SerializedForm"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializedForm
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|,
name|toArray
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

