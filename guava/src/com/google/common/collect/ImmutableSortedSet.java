begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ObjectArrays
operator|.
name|checkElementsNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InvalidObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An immutable {@code SortedSet} that stores its elements in a sorted array.  * Some instances are ordered by an explicit comparator, while others follow the  * natural sort ordering of their elements. Either way, null elements are not  * supported.  *  *<p>Unlike {@link Collections#unmodifiableSortedSet}, which is a<i>view</i>  * of a separate collection that can still change, an instance of {@code  * ImmutableSortedSet} contains its own private data and will<i>never</i>  * change. This class is convenient for {@code public static final} sets  * ("constant sets") and also lets you easily make a "defensive copy" of a set  * provided to your class by a caller.  *  *<p>The sets returned by the {@link #headSet}, {@link #tailSet}, and  * {@link #subSet} methods share the same array as the original set, preventing  * that array from being garbage collected. If this is a concern, the data may  * be copied into a correctly-sized array by calling {@link #copyOfSorted}.  *  *<p><b>Note on element equivalence:</b> The {@link #contains(Object)},  * {@link #containsAll(Collection)}, and {@link #equals(Object)}  * implementations must check whether a provided object is equivalent to an  * element in the collection. Unlike most collections, an  * {@code ImmutableSortedSet} doesn't use {@link Object#equals} to determine if  * two elements are equivalent. Instead, with an explicit comparator, the  * following relation determines whether elements {@code x} and {@code y} are  * equivalent:<pre>   {@code  *  *   {(x, y) | comparator.compare(x, y) == 0}}</pre>  *  * With natural ordering of elements, the following relation determines whether  * two elements are equivalent:<pre>   {@code  *  *   {(x, y) | x.compareTo(y) == 0}}</pre>  *  *<b>Warning:</b> Like most sets, an {@code ImmutableSortedSet} will not  * function correctly if an element is modified after being placed in the set.  * For this reason, and to avoid general confusion, it is strongly recommended  * to place only immutable objects into this collection.  *  *<p><b>Note:</b> Although this class is not final, it cannot be subclassed as  * it has no public or protected constructors. Thus, instances of this type are  * guaranteed to be immutable.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">  * immutable collections</a>.  *  * @see ImmutableSet  * @author Jared Levy  * @author Louis Wasserman  * @since 2.0 (imported from Google Collections Library; implements {@code NavigableSet} since 12.0)  */
end_comment

begin_comment
comment|// TODO(benyu): benchmark and optimize all creation paths, which are a mess now
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|,
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// we're overriding default serialization
DECL|class|ImmutableSortedSet
specifier|public
specifier|abstract
class|class
name|ImmutableSortedSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSortedSetFauxverideShim
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
implements|,
name|SortedIterable
argument_list|<
name|E
argument_list|>
block|{
DECL|field|NATURAL_ORDER
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Comparable
argument_list|>
name|NATURAL_ORDER
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
DECL|field|NATURAL_EMPTY_SET
specifier|private
specifier|static
specifier|final
name|ImmutableSortedSet
argument_list|<
name|Comparable
argument_list|>
name|NATURAL_EMPTY_SET
init|=
operator|new
name|EmptyImmutableSortedSet
argument_list|<
name|Comparable
argument_list|>
argument_list|(
name|NATURAL_ORDER
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptySet ()
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|emptySet
parameter_list|()
block|{
return|return
operator|(
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|NATURAL_EMPTY_SET
return|;
block|}
DECL|method|emptySet ( Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|emptySet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|NATURAL_ORDER
operator|.
name|equals
argument_list|(
name|comparator
argument_list|)
condition|)
block|{
return|return
name|emptySet
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|EmptyImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the empty immutable sorted set.    */
DECL|method|of ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|()
block|{
return|return
name|emptySet
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable sorted set containing a single element.    */
DECL|method|of ( E element)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|element
parameter_list|)
block|{
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|element
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|2
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|3
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|4
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any element is null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
literal|5
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any element is null    * @since 3.0 (source-compatible since 2.0)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ( E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|of
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|,
name|E
name|e3
parameter_list|,
name|E
name|e4
parameter_list|,
name|E
name|e5
parameter_list|,
name|E
name|e6
parameter_list|,
name|E
modifier|...
name|remaining
parameter_list|)
block|{
name|Comparable
index|[]
name|contents
init|=
operator|new
name|Comparable
index|[
literal|6
operator|+
name|remaining
operator|.
name|length
index|]
decl_stmt|;
name|contents
index|[
literal|0
index|]
operator|=
name|e1
expr_stmt|;
name|contents
index|[
literal|1
index|]
operator|=
name|e2
expr_stmt|;
name|contents
index|[
literal|2
index|]
operator|=
name|e3
expr_stmt|;
name|contents
index|[
literal|3
index|]
operator|=
name|e4
expr_stmt|;
name|contents
index|[
literal|4
index|]
operator|=
name|e5
expr_stmt|;
name|contents
index|[
literal|5
index|]
operator|=
name|e6
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|remaining
argument_list|,
literal|0
argument_list|,
name|contents
argument_list|,
literal|6
argument_list|,
name|remaining
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|contents
operator|.
name|length
argument_list|,
operator|(
name|E
index|[]
operator|)
name|contents
argument_list|)
return|;
block|}
comment|// TODO(kevinb): Consider factory methods that reject duplicates
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@link Comparable#compareTo}, only the first one specified is included.    *    * @throws NullPointerException if any of {@code elements} is null    * @since 3.0    */
DECL|method|copyOf ( E[] elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|E
index|[]
name|elements
parameter_list|)
block|{
return|return
name|construct
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|elements
operator|.
name|length
argument_list|,
name|elements
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@code compareTo()}, only the first one specified is included. To create a    * copy of a {@code SortedSet} that preserves the comparator, call {@link    * #copyOfSorted} instead. This method iterates over {@code elements} at most    * once.     *    *<p>Note that if {@code s} is a {@code Set<String>}, then {@code    * ImmutableSortedSet.copyOf(s)} returns an {@code ImmutableSortedSet<String>}    * containing each of the strings in {@code s}, while {@code    * ImmutableSortedSet.of(s)} returns an {@code    * ImmutableSortedSet<Set<String>>} containing one element (the given set    * itself).    *    *<p>Despite the method name, this method attempts to avoid actually copying    * the data when it is safe to do so. The exact circumstances under which a    * copy will or will not be performed are undocumented and subject to change.    *    *<p>This method is not type-safe, as it may be called on elements that are    * not mutually comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@code compareTo()}, only the first one specified is included. To create a    * copy of a {@code SortedSet} that preserves the comparator, call    * {@link #copyOfSorted} instead. This method iterates over {@code elements}    * at most once.    *    *<p>Note that if {@code s} is a {@code Set<String>}, then    * {@code ImmutableSortedSet.copyOf(s)} returns an    * {@code ImmutableSortedSet<String>} containing each of the strings in    * {@code s}, while {@code ImmutableSortedSet.of(s)} returns an    * {@code ImmutableSortedSet<Set<String>>} containing one element (the given    * set itself).    *    *<p><b>Note:</b> Despite what the method name suggests, if {@code elements}    * is an {@code ImmutableSortedSet}, it may be returned instead of a copy.    *    *<p>This method is not type-safe, as it may be called on elements that are    * not mutually comparable.    *    *<p>This method is safe to use even when {@code elements} is a synchronized    * or concurrent collection that is currently being modified by another    * thread.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    * @since 7.0 (source-compatible since 2.0)    */
DECL|method|copyOf ( Collection<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * their natural ordering. When multiple elements are equivalent according to    * {@code compareTo()}, only the first one specified is included.    *    *<p>This method is not type-safe, as it may be called on elements that are    * not mutually comparable.    *    * @throws ClassCastException if the elements are not mutually comparable    * @throws NullPointerException if any of {@code elements} is null    */
DECL|method|copyOf ( Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
comment|// Hack around E not being a subtype of Comparable.
comment|// Unsafe, see ImmutableSortedSetFauxverideShim.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Ordering
argument_list|<
name|E
argument_list|>
name|naturalOrder
init|=
operator|(
name|Ordering
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
expr|<
name|Comparable
operator|>
name|natural
argument_list|()
decl_stmt|;
return|return
name|copyOf
argument_list|(
name|naturalOrder
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * the given {@code Comparator}. When multiple elements are equivalent    * according to {@code compareTo()}, only the first one specified is    * included.    *    * @throws NullPointerException if {@code comparator} or any of    *     {@code elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * the given {@code Comparator}. When multiple elements are equivalent    * according to {@code compare()}, only the first one specified is    * included. This method iterates over {@code elements} at most once.    *    *<p>Despite the method name, this method attempts to avoid actually copying    * the data when it is safe to do so. The exact circumstances under which a    * copy will or will not be performed are undocumented and subject to change.    *    * @throws NullPointerException if {@code comparator} or any of {@code    *         elements} is null    */
DECL|method|copyOf ( Comparator<? super E> comparator, Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|boolean
name|hasSameComparator
init|=
name|SortedIterables
operator|.
name|hasSameComparator
argument_list|(
name|comparator
argument_list|,
name|elements
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasSameComparator
operator|&&
operator|(
name|elements
operator|instanceof
name|ImmutableSortedSet
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|original
init|=
operator|(
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|elements
decl_stmt|;
if|if
condition|(
operator|!
name|original
operator|.
name|isPartialView
argument_list|()
condition|)
block|{
return|return
name|original
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// elements only contains E's; it's safe.
name|E
index|[]
name|array
init|=
operator|(
name|E
index|[]
operator|)
name|Iterables
operator|.
name|toArray
argument_list|(
name|elements
argument_list|)
decl_stmt|;
return|return
name|construct
argument_list|(
name|comparator
argument_list|,
name|array
operator|.
name|length
argument_list|,
name|array
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the given elements sorted by    * the given {@code Comparator}. When multiple elements are equivalent    * according to {@code compareTo()}, only the first one specified is    * included.    *    *<p>Despite the method name, this method attempts to avoid actually copying    * the data when it is safe to do so. The exact circumstances under which a    * copy will or will not be performed are undocumented and subject to change.    *    *<p>This method is safe to use even when {@code elements} is a synchronized    * or concurrent collection that is currently being modified by another    * thread.    *    * @throws NullPointerException if {@code comparator} or any of    *     {@code elements} is null    * @since 7.0 (source-compatible since 2.0)    */
DECL|method|copyOf ( Comparator<? super E> comparator, Collection<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOf
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|comparator
argument_list|,
operator|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
operator|)
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable sorted set containing the elements of a sorted set,    * sorted by the same {@code Comparator}. That behavior differs from {@link    * #copyOf(Iterable)}, which always uses the natural ordering of the    * elements.    *    *<p>Despite the method name, this method attempts to avoid actually copying    * the data when it is safe to do so. The exact circumstances under which a    * copy will or will not be performed are undocumented and subject to change.    *    *<p>This method is safe to use even when {@code sortedSet} is a synchronized    * or concurrent collection that is currently being modified by another    * thread.    *    * @throws NullPointerException if {@code sortedSet} or any of its elements    *     is null    */
DECL|method|copyOfSorted (SortedSet<E> sortedSet)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|copyOfSorted
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|sortedSet
parameter_list|)
block|{
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
init|=
name|SortedIterables
operator|.
name|comparator
argument_list|(
name|sortedSet
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|sortedSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|emptySet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|,
name|comparator
argument_list|)
return|;
block|}
block|}
comment|/**    * Constructs an {@code ImmutableSortedSet} from the first {@code n} elements of    * {@code contents}.  If {@code k} is the size of the returned {@code ImmutableSortedSet}, then    * the sorted unique elements are in the first {@code k} positions of {@code contents}, and    * {@code contents[i] == null} for {@code k<= i< n}.    *    *<p>If {@code k == contents.length}, then {@code contents} may no longer be safe for    * modification.    *    * @throws NullPointerException if any of the first {@code n} elements of {@code contents} is    *          null    */
DECL|method|construct ( Comparator<? super E> comparator, int n, E... contents)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|construct
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|int
name|n
parameter_list|,
name|E
modifier|...
name|contents
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|emptySet
argument_list|(
name|comparator
argument_list|)
return|;
block|}
name|checkElementsNotNull
argument_list|(
name|contents
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|int
name|uniques
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|E
name|cur
init|=
name|contents
index|[
name|i
index|]
decl_stmt|;
name|E
name|prev
init|=
name|contents
index|[
name|uniques
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|cur
argument_list|,
name|prev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|contents
index|[
name|uniques
operator|++
index|]
operator|=
name|cur
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|contents
argument_list|,
name|uniques
argument_list|,
name|n
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
expr|<
name|E
operator|>
name|asImmutableList
argument_list|(
name|contents
argument_list|,
name|uniques
argument_list|)
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets with an explicit    * comparator. If the comparator has a more general type than the set being    * generated, such as creating a {@code SortedSet<Integer>} with a    * {@code Comparator<Number>}, use the {@link Builder} constructor instead.    *    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|orderedBy (Comparator<E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|orderedBy
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets whose elements are    * ordered by the reverse of their natural ordering.    */
DECL|method|reverseOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|reverseOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a builder that creates immutable sorted sets whose elements are    * ordered by their natural ordering. The sorted sets use {@link    * Ordering#natural()} as the comparator. This method provides more    * type-safety than {@link #builder}, as it can be called only for classes    * that implement {@link Comparable}.    */
DECL|method|naturalOrder ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|E
argument_list|>
name|naturalOrder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * A builder for creating immutable sorted set instances, especially {@code    * public static final} sets ("constant sets"), with a given comparator.    * Example:<pre>   {@code    *    *   public static final ImmutableSortedSet<Number> LUCKY_NUMBERS =    *       new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR)    *           .addAll(SINGLE_DIGIT_PRIMES)    *           .add(42)    *           .build();}</pre>    *    * Builder instances can be reused; it is safe to call {@link #build} multiple    * times to build multiple sets in series. Each set is a superset of the set    * created before it.    *    * @since 2.0 (imported from Google Collections Library)    */
DECL|class|Builder
specifier|public
specifier|static
specifier|final
class|class
name|Builder
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
block|{
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
comment|/**      * Creates a new builder. The returned builder is equivalent to the builder      * generated by {@link ImmutableSortedSet#orderedBy}.      */
DECL|method|Builder (Comparator<? super E> comparator)
specifier|public
name|Builder
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds {@code element} to the {@code ImmutableSortedSet}.  If the      * {@code ImmutableSortedSet} already contains {@code element}, then      * {@code add} has no effect. (only the previously added element      * is retained).      *      * @param element the element to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code element} is null      */
DECL|method|add (E element)
annotation|@
name|Override
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|super
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet},      * ignoring duplicate elements (only the first duplicate element is added).      *      * @param elements the elements to add      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
DECL|method|add (E... elements)
annotation|@
name|Override
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|super
operator|.
name|add
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet},      * ignoring duplicate elements (only the first duplicate element is added).      *      * @param elements the elements to add to the {@code ImmutableSortedSet}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
DECL|method|addAll (Iterable<? extends E> elements)
annotation|@
name|Override
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Adds each element of {@code elements} to the {@code ImmutableSortedSet},      * ignoring duplicate elements (only the first duplicate element is added).      *      * @param elements the elements to add to the {@code ImmutableSortedSet}      * @return this {@code Builder} object      * @throws NullPointerException if {@code elements} contains a null element      */
DECL|method|addAll (Iterator<? extends E> elements)
annotation|@
name|Override
specifier|public
name|Builder
argument_list|<
name|E
argument_list|>
name|addAll
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|super
operator|.
name|addAll
argument_list|(
name|elements
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns a newly-created {@code ImmutableSortedSet} based on the contents      * of the {@code Builder} and its comparator.      */
DECL|method|build ()
annotation|@
name|Override
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|build
parameter_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// we're careful to put only E's in here
name|E
index|[]
name|contentsArray
init|=
operator|(
name|E
index|[]
operator|)
name|contents
decl_stmt|;
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|construct
argument_list|(
name|comparator
argument_list|,
name|size
argument_list|,
name|contentsArray
argument_list|)
decl_stmt|;
name|this
operator|.
name|size
operator|=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// we eliminated duplicates in-place in contentsArray
return|return
name|result
return|;
block|}
block|}
DECL|method|unsafeCompare (Object a, Object b)
name|int
name|unsafeCompare
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|unsafeCompare
argument_list|(
name|comparator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|unsafeCompare ( Comparator<?> comparator, Object a, Object b)
specifier|static
name|int
name|unsafeCompare
parameter_list|(
name|Comparator
argument_list|<
name|?
argument_list|>
name|comparator
parameter_list|,
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
comment|// Pretend the comparator can compare anything. If it turns out it can't
comment|// compare a and b, we should get a CCE on the subsequent line. Only methods
comment|// that are spec'd to throw CCE should call this.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Comparator
argument_list|<
name|Object
argument_list|>
name|unsafeComparator
init|=
operator|(
name|Comparator
argument_list|<
name|Object
argument_list|>
operator|)
name|comparator
decl_stmt|;
return|return
name|unsafeComparator
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|field|comparator
specifier|final
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|method|ImmutableSortedSet (Comparator<? super E> comparator)
name|ImmutableSortedSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
comment|/**    * Returns the comparator that orders the elements, which is    * {@link Ordering#natural()} when the natural ordering of the    * elements is used. Note that its behavior is not consistent with    * {@link SortedSet#comparator()}, which returns {@code null} to indicate    * natural ordering.    */
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
annotation|@
name|Override
comment|// needed to unify the iterator() methods in Collection and SortedIterable
DECL|method|iterator ()
specifier|public
specifier|abstract
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
function_decl|;
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#headSet} documentation states that a subset of a    * subset throws an {@link IllegalArgumentException} if passed a    * {@code toElement} greater than an earlier {@code toElement}. However, this    * method doesn't throw an exception in that situation, but instead keeps the    * original {@code toElement}.    */
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|headSet (E toElement, boolean inclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|headSetImpl
argument_list|(
name|checkNotNull
argument_list|(
name|toElement
argument_list|)
argument_list|,
name|inclusive
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#subSet} documentation states that a subset of a    * subset throws an {@link IllegalArgumentException} if passed a    * {@code fromElement} smaller than an earlier {@code fromElement}. However,    * this method doesn't throw an exception in that situation, but instead keeps    * the original {@code fromElement}. Similarly, this method keeps the    * original {@code toElement}, instead of throwing an exception, if passed a    * {@code toElement} greater than an earlier {@code toElement}.    */
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|subSet ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fromElement
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|toElement
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
return|return
name|subSetImpl
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>This method returns a serializable {@code ImmutableSortedSet}.    *    *<p>The {@link SortedSet#tailSet} documentation states that a subset of a    * subset throws an {@link IllegalArgumentException} if passed a    * {@code fromElement} smaller than an earlier {@code fromElement}. However,    * this method doesn't throw an exception in that situation, but instead keeps    * the original {@code fromElement}.    */
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|tailSet (E fromElement, boolean inclusive)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|tailSetImpl
argument_list|(
name|checkNotNull
argument_list|(
name|fromElement
argument_list|)
argument_list|,
name|inclusive
argument_list|)
return|;
block|}
comment|/*    * These methods perform most headSet, subSet, and tailSet logic, besides    * parameter validation.    */
DECL|method|headSetImpl (E toElement, boolean inclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|headSetImpl
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
DECL|method|subSetImpl ( E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|subSetImpl
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
function_decl|;
DECL|method|tailSetImpl (E fromElement, boolean inclusive)
specifier|abstract
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|tailSetImpl
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|lower (E e)
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|floor (E e)
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|headSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
operator|.
name|descendingIterator
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|ceiling (E e)
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|higher (E e)
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|getFirst
argument_list|(
name|tailSet
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
return|return
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
return|return
name|descendingIterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the set unmodified.    *    * @since 12.0    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
specifier|final
name|E
name|pollFirst
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the set unmodified.    *    * @since 12.0    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
specifier|final
name|E
name|pollLast
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|field|descendingSet
specifier|transient
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|descendingSet
decl_stmt|;
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
comment|// racy single-check idiom
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|descendingSet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|descendingSet
operator|=
name|createDescendingSet
argument_list|()
expr_stmt|;
name|result
operator|.
name|descendingSet
operator|=
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|method|createDescendingSet ()
name|ImmutableSortedSet
argument_list|<
name|E
argument_list|>
name|createDescendingSet
parameter_list|()
block|{
return|return
operator|new
name|DescendingImmutableSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
specifier|abstract
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
function_decl|;
comment|/**    * Returns the position of an element within the set, or -1 if not present.    */
DECL|method|indexOf (@ullable Object target)
specifier|abstract
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|target
parameter_list|)
function_decl|;
comment|/*    * This class is used to serialize all ImmutableSortedSet instances,    * regardless of implementation type. It captures their "logical contents"    * only. This is necessary to ensure that the existence of a particular    * implementation type is an implementation detail.    */
DECL|class|SerializedForm
specifier|private
specifier|static
class|class
name|SerializedForm
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|comparator
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|elements
specifier|final
name|Object
index|[]
name|elements
decl_stmt|;
DECL|method|SerializedForm (Comparator<? super E> comparator, Object[] elements)
specifier|public
name|SerializedForm
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
name|Object
index|[]
name|elements
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|elements
operator|=
name|elements
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
operator|.
name|add
argument_list|(
operator|(
name|E
index|[]
operator|)
name|elements
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|InvalidObjectException
block|{
throw|throw
operator|new
name|InvalidObjectException
argument_list|(
literal|"Use SerializedForm"
argument_list|)
throw|;
block|}
DECL|method|writeReplace ()
annotation|@
name|Override
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializedForm
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|,
name|toArray
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

