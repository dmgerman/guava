begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkElementIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndexes
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSequentialList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link List} instances. Also see this  * class's counterparts {@link Sets} and {@link Maps}.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Louis Wasserman  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Lists
specifier|public
specifier|final
class|class
name|Lists
block|{
DECL|method|Lists ()
specifier|private
name|Lists
parameter_list|()
block|{}
comment|// ArrayList
comment|/**    * Creates a<i>mutable</i>, empty {@code ArrayList} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableList#of()} instead.    *    * @return a new, empty {@code ArrayList}    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use an overload of {@link ImmutableList#of()} (for varargs) or    * {@link ImmutableList#copyOf(Object[])} (for an array) instead.    *    * @param elements the elements that the list should contain, in order    * @return a new {@code ArrayList} containing those elements    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (E... elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
comment|// for GWT
comment|// Avoid integer overflow when a large array is passed in
name|int
name|capacity
init|=
name|computeArrayListCapacity
argument_list|(
name|elements
operator|.
name|length
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|capacity
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|list
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|computeArrayListCapacity (int arraySize)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|computeArrayListCapacity
parameter_list|(
name|int
name|arraySize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|arraySize
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// TODO(kevinb): Figure out the right behavior, and document it
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
literal|5L
operator|+
name|arraySize
operator|+
operator|(
name|arraySize
operator|/
literal|10
operator|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.    *    * @param elements the elements that the list should contain, in order    * @return a new {@code ArrayList} containing those elements    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
comment|// for GWT
comment|// Let ArrayList's sizing logic work, if possible
return|return
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
else|:
name|newArrayList
argument_list|(
name|elements
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.    *    * @param elements the elements that the list should contain, in order    * @return a new {@code ArrayList} containing those elements    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
comment|// for GWT
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|newArrayList
argument_list|()
decl_stmt|;
while|while
condition|(
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|elements
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Creates an {@code ArrayList} instance backed by an array of the    *<i>exact</i> size specified; equivalent to    * {@link ArrayList#ArrayList(int)}.    *    *<p><b>Note:</b> if you know the exact size your list will be, consider    * using a fixed-size list ({@link Arrays#asList(Object[])}) or an {@link    * ImmutableList} instead of a growable {@link ArrayList}.    *    *<p><b>Note:</b> If you have only an<i>estimate</i> of the eventual size of    * the list, consider padding this estimate by a suitable amount, or simply    * use {@link #newArrayListWithExpectedSize(int)} instead.    *    * @param initialArraySize the exact size of the initial backing array for    *     the returned array list ({@code ArrayList} documentation calls this    *     value the "capacity")    * @return a new, empty {@code ArrayList} which is guaranteed not to resize    *     itself unless its size reaches {@code initialArraySize + 1}    * @throws IllegalArgumentException if {@code initialArraySize} is negative    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayListWithCapacity ( int initialArraySize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayListWithCapacity
parameter_list|(
name|int
name|initialArraySize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|initialArraySize
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// for GWT.
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|initialArraySize
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code ArrayList} instance sized appropriately to hold an    *<i>estimated</i> number of elements without resizing. A small amount of    * padding is added in case the estimate is low.    *    *<p><b>Note:</b> If you know the<i>exact</i> number of elements the list    * will hold, or prefer to calculate your own amount of padding, refer to    * {@link #newArrayListWithCapacity(int)}.    *    * @param estimatedSize an estimate of the eventual {@link List#size()} of    *     the new list    * @return a new, empty {@code ArrayList}, sized appropriately to hold the    *     estimated number of elements    * @throws IllegalArgumentException if {@code estimatedSize} is negative    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayListWithExpectedSize ( int estimatedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayListWithExpectedSize
parameter_list|(
name|int
name|estimatedSize
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|computeArrayListCapacity
argument_list|(
name|estimatedSize
argument_list|)
argument_list|)
return|;
block|}
comment|// LinkedList
comment|/**    * Creates an empty {@code LinkedList} instance.    *    *<p><b>Note:</b> if you need an immutable empty {@link List}, use    * {@link ImmutableList#of()} instead.    *    * @return a new, empty {@code LinkedList}    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newLinkedList ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedList
argument_list|<
name|E
argument_list|>
name|newLinkedList
parameter_list|()
block|{
return|return
operator|new
name|LinkedList
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code LinkedList} instance containing the given elements.    *    * @param elements the elements that the list should contain, in order    * @return a new {@code LinkedList} containing those elements    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newLinkedList ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedList
argument_list|<
name|E
argument_list|>
name|newLinkedList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|newLinkedList
argument_list|()
decl_stmt|;
for|for
control|(
name|E
name|element
range|:
name|elements
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Returns an unmodifiable list containing the specified first element and    * backed by the specified array of additional elements. Changes to the {@code    * rest} array will be reflected in the returned list. Unlike {@link    * Arrays#asList}, the returned list is unmodifiable.    *    *<p>This is useful when a varargs method needs to use a signature such as    * {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload    * ambiguity or to enforce a minimum argument count.    *    *<p>The returned list is serializable and implements {@link RandomAccess}.    *    * @param first the first element    * @param rest an array of additional elements, possibly empty    * @return an unmodifiable list containing the specified elements    */
DECL|method|asList (@ullable E first, E[] rest)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|asList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
return|return
operator|new
name|OnePlusArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|first
argument_list|,
name|rest
argument_list|)
return|;
block|}
comment|/** @see Lists#asList(Object, Object[]) */
DECL|class|OnePlusArrayList
specifier|private
specifier|static
class|class
name|OnePlusArrayList
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
implements|implements
name|Serializable
implements|,
name|RandomAccess
block|{
DECL|field|first
specifier|final
name|E
name|first
decl_stmt|;
DECL|field|rest
specifier|final
name|E
index|[]
name|rest
decl_stmt|;
DECL|method|OnePlusArrayList (@ullable E first, E[] rest)
name|OnePlusArrayList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
name|this
operator|.
name|rest
operator|=
name|checkNotNull
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rest
operator|.
name|length
operator|+
literal|1
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|// check explicitly so the IOOBE will have the right message
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|index
operator|==
literal|0
operator|)
condition|?
name|first
else|:
name|rest
index|[
name|index
operator|-
literal|1
index|]
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns an unmodifiable list containing the specified first and second    * element, and backed by the specified array of additional elements. Changes    * to the {@code rest} array will be reflected in the returned list. Unlike    * {@link Arrays#asList}, the returned list is unmodifiable.    *    *<p>This is useful when a varargs method needs to use a signature such as    * {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid    * overload ambiguity or to enforce a minimum argument count.    *    *<p>The returned list is serializable and implements {@link RandomAccess}.    *    * @param first the first element    * @param second the second element    * @param rest an array of additional elements, possibly empty    * @return an unmodifiable list containing the specified elements    */
DECL|method|asList ( @ullable E first, @Nullable E second, E[] rest)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|asList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
annotation|@
name|Nullable
name|E
name|second
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
return|return
operator|new
name|TwoPlusArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|rest
argument_list|)
return|;
block|}
comment|/** @see Lists#asList(Object, Object, Object[]) */
DECL|class|TwoPlusArrayList
specifier|private
specifier|static
class|class
name|TwoPlusArrayList
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
implements|implements
name|Serializable
implements|,
name|RandomAccess
block|{
DECL|field|first
specifier|final
name|E
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|E
name|second
decl_stmt|;
DECL|field|rest
specifier|final
name|E
index|[]
name|rest
decl_stmt|;
DECL|method|TwoPlusArrayList (@ullable E first, @Nullable E second, E[] rest)
name|TwoPlusArrayList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
annotation|@
name|Nullable
name|E
name|second
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
name|this
operator|.
name|second
operator|=
name|second
expr_stmt|;
name|this
operator|.
name|rest
operator|=
name|checkNotNull
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rest
operator|.
name|length
operator|+
literal|2
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
return|return
name|first
return|;
case|case
literal|1
case|:
return|return
name|second
return|;
default|default:
comment|// check explicitly so the IOOBE will have the right message
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rest
index|[
name|index
operator|-
literal|2
index|]
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a list that applies {@code function} to each element of {@code    * fromList}. The returned list is a transformed view of {@code fromList};    * changes to {@code fromList} will be reflected in the returned list and vice    * versa.    *    *<p>Since functions are not reversible, the transform is one-way and new    * items cannot be stored in the returned list. The {@code add},    * {@code addAll} and {@code set} methods are unsupported in the returned    * list.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned list to be a view, but it means that the function will be    * applied many times for bulk operations like {@link List#contains} and    * {@link List#hashCode}. For this to perform well, {@code function} should be    * fast. To avoid lazy evaluation when the returned list doesn't need to be a    * view, copy the returned list into a new list of your choosing.    *    *<p>If {@code fromList} implements {@link RandomAccess}, so will the    * returned list. The returned list always implements {@link Serializable},    * but serialization will succeed only when {@code fromList} and    * {@code function} are serializable. The returned list is threadsafe if the    * supplied list and function are.    *    *<p>If only a {@code Collection} or {@code Iterable} input is available, use    * {@link Collections2#transform} or {@link Iterables#transform}.    */
DECL|method|transform ( List<F> fromList, Function<? super F, ? extends T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|(
name|fromList
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|TransformingRandomAccessList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
argument_list|,
name|function
argument_list|)
else|:
operator|new
name|TransformingSequentialList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**    * Implementation of a sequential transforming list.    *    * @see Lists#transform    */
DECL|class|TransformingSequentialList
specifier|private
specifier|static
class|class
name|TransformingSequentialList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractSequentialList
argument_list|<
name|T
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|fromList
specifier|final
name|List
argument_list|<
name|F
argument_list|>
name|fromList
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformingSequentialList ( List<F> fromList, Function<? super F, ? extends T> function)
name|TransformingSequentialList
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromList
operator|=
name|checkNotNull
argument_list|(
name|fromList
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
comment|/**      * The default implementation inherited is based on iteration and removal of      * each element which can be overkill. That's why we forward this call      * directly to the backing list.      */
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|listIterator (final int index)
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
specifier|final
name|ListIterator
argument_list|<
name|F
argument_list|>
name|delegate
init|=
name|fromList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
operator|new
name|ListIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|T
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hasPrevious
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|delegate
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|nextIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|previous
parameter_list|()
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|delegate
operator|.
name|previous
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|previousIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegate
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|T
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"not supported"
argument_list|)
throw|;
block|}
block|}
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Implementation of a transforming random access list. We try to make as many    * of these methods pass-through to the source list as possible so that the    * performance characteristics of the source list and transformed list are    * similar.    *    * @see Lists#transform    */
DECL|class|TransformingRandomAccessList
specifier|private
specifier|static
class|class
name|TransformingRandomAccessList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
implements|,
name|Serializable
block|{
DECL|field|fromList
specifier|final
name|List
argument_list|<
name|F
argument_list|>
name|fromList
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformingRandomAccessList ( List<F> fromList, Function<? super F, ? extends T> function)
name|TransformingRandomAccessList
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromList
operator|=
name|checkNotNull
argument_list|(
name|fromList
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|fromList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|T
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|fromList
operator|.
name|remove
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,    * each of the same size (the final list may be smaller). For example,    * partitioning a list containing {@code [a, b, c, d, e]} with a partition    * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing    * two inner lists of three and two elements, all in the original order.    *    *<p>The outer list is unmodifiable, but reflects the latest state of the    * source list. The inner lists are sublist views of the original list,    * produced on demand using {@link List#subList(int, int)}, and are subject    * to all the usual caveats about modification as explained in that API.    *    * @param list the list to return consecutive sublists of    * @param size the desired size of each sublist (the last may be    *     smaller)    * @return a list of consecutive sublists    * @throws IllegalArgumentException if {@code partitionSize} is nonpositive    */
DECL|method|partition (List<T> list, int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|RandomAccessPartition
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
else|:
operator|new
name|Partition
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
return|;
block|}
DECL|class|Partition
specifier|private
specifier|static
class|class
name|Partition
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|list
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|Partition (List<T> list, int size)
name|Partition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|listSize
init|=
name|size
argument_list|()
decl_stmt|;
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|listSize
argument_list|)
expr_stmt|;
name|int
name|start
init|=
name|index
operator|*
name|size
decl_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|start
operator|+
name|size
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
comment|// TODO(user): refactor to common.math.IntMath.divide
name|int
name|result
init|=
name|list
operator|.
name|size
argument_list|()
operator|/
name|size
decl_stmt|;
if|if
condition|(
name|result
operator|*
name|size
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|list
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
DECL|class|RandomAccessPartition
specifier|private
specifier|static
class|class
name|RandomAccessPartition
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Partition
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessPartition (List<T> list, int size)
name|RandomAccessPartition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a view of the specified string as an immutable list of {@code    * Character} values.    *    * @since 7.0    */
DECL|method|charactersOf (String string)
annotation|@
name|Beta
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|Character
argument_list|>
name|charactersOf
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
operator|new
name|StringAsImmutableList
argument_list|(
name|checkNotNull
argument_list|(
name|string
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// serialized using ImmutableList serialization
DECL|class|StringAsImmutableList
specifier|private
specifier|static
specifier|final
class|class
name|StringAsImmutableList
extends|extends
name|ImmutableList
argument_list|<
name|Character
argument_list|>
block|{
DECL|field|string
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
DECL|method|StringAsImmutableList (String string)
name|StringAsImmutableList
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
block|}
DECL|method|contains (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|object
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|indexOf (@ullable Object object)
annotation|@
name|Override
specifier|public
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
operator|(
name|object
operator|instanceof
name|Character
operator|)
condition|?
name|string
operator|.
name|indexOf
argument_list|(
operator|(
name|Character
operator|)
name|object
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|lastIndexOf (@ullable Object object)
annotation|@
name|Override
specifier|public
name|int
name|lastIndexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
operator|(
name|object
operator|instanceof
name|Character
operator|)
condition|?
name|string
operator|.
name|lastIndexOf
argument_list|(
operator|(
name|Character
operator|)
name|object
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|listIterator ( int index)
annotation|@
name|Override
specifier|public
name|UnmodifiableListIterator
argument_list|<
name|Character
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|AbstractIndexedListIterator
argument_list|<
name|Character
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|,
name|index
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Character
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|string
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|subList ( int fromIndex, int toIndex)
annotation|@
name|Override
specifier|public
name|ImmutableList
argument_list|<
name|Character
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
return|return
name|charactersOf
argument_list|(
name|string
operator|.
name|substring
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
argument_list|)
return|;
block|}
DECL|method|isPartialView ()
annotation|@
name|Override
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|Character
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|string
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|string
operator|.
name|length
argument_list|()
return|;
block|}
DECL|method|equals (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|List
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
name|int
name|n
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|elem
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|elem
operator|instanceof
name|Character
operator|)
operator|||
operator|(
operator|(
name|Character
operator|)
name|elem
operator|)
operator|.
name|charValue
argument_list|()
operator|!=
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|field|hash
name|int
name|hash
init|=
literal|0
decl_stmt|;
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
name|hash
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|h
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|string
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|h
operator|*
literal|31
operator|+
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|h
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
block|}
comment|/**    * Returns a view of the specified {@code CharSequence} as a {@code    * List<Character>}, viewing {@code sequence} as a sequence of Unicode code    * units. The view does not support any modification operations, but reflects    * any changes to the underlying character sequence.    *    * @param sequence the character sequence to view as a {@code List} of    *        characters    * @return an {@code List<Character>} view of the character sequence    * @since 7.0    */
DECL|method|charactersOf (CharSequence sequence)
annotation|@
name|Beta
specifier|public
specifier|static
name|List
argument_list|<
name|Character
argument_list|>
name|charactersOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|new
name|CharSequenceAsList
argument_list|(
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
argument_list|)
return|;
block|}
DECL|class|CharSequenceAsList
specifier|private
specifier|static
specifier|final
class|class
name|CharSequenceAsList
extends|extends
name|AbstractList
argument_list|<
name|Character
argument_list|>
block|{
DECL|field|sequence
specifier|private
specifier|final
name|CharSequence
name|sequence
decl_stmt|;
DECL|method|CharSequenceAsList (CharSequence sequence)
name|CharSequenceAsList
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|this
operator|.
name|sequence
operator|=
name|sequence
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|Character
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|o
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|indexOf (@ullable Object o)
annotation|@
name|Override
specifier|public
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Character
condition|)
block|{
name|char
name|c
init|=
operator|(
name|Character
operator|)
name|o
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
name|c
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|lastIndexOf (@ullable Object o)
annotation|@
name|Override
specifier|public
name|int
name|lastIndexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Character
condition|)
block|{
name|char
name|c
init|=
operator|(
operator|(
name|Character
operator|)
name|o
operator|)
operator|.
name|charValue
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
name|c
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
return|;
block|}
DECL|method|subList (int fromIndex, int toIndex)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Character
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
return|return
name|charactersOf
argument_list|(
name|sequence
operator|.
name|subSequence
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|31
operator|+
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
DECL|method|equals (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|List
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|int
name|n
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|elem
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|elem
operator|instanceof
name|Character
operator|)
operator|||
operator|(
operator|(
name|Character
operator|)
name|elem
operator|)
operator|.
name|charValue
argument_list|()
operator|!=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Returns a reversed view of the specified list. For example, {@code    * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,    * 2, 1}. The returned list is backed by this list, so changes in the returned    * list are reflected in this list, and vice-versa. The returned list supports    * all of the optional list operations supported by this list.    *    *<p>The returned list is random-access if the specified list is random    * access.    *    * @since 7.0    */
DECL|method|reverse (List<T> list)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|ReverseList
condition|)
block|{
return|return
operator|(
operator|(
name|ReverseList
argument_list|<
name|T
argument_list|>
operator|)
name|list
operator|)
operator|.
name|getForwardList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|new
name|RandomAccessReverseList
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReverseList
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
DECL|class|ReverseList
specifier|private
specifier|static
class|class
name|ReverseList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
block|{
DECL|field|forwardList
specifier|private
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
decl_stmt|;
DECL|method|ReverseList (List<T> forwardList)
name|ReverseList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
parameter_list|)
block|{
name|this
operator|.
name|forwardList
operator|=
name|checkNotNull
argument_list|(
name|forwardList
argument_list|)
expr_stmt|;
block|}
DECL|method|getForwardList ()
name|List
argument_list|<
name|T
argument_list|>
name|getForwardList
parameter_list|()
block|{
return|return
name|forwardList
return|;
block|}
DECL|method|reverseIndex (int index)
specifier|private
name|int
name|reverseIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|-
literal|1
operator|)
operator|-
name|index
return|;
block|}
DECL|method|reversePosition (int index)
specifier|private
name|int
name|reversePosition
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkPositionIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
operator|-
name|index
return|;
block|}
DECL|method|add (int index, @Nullable T element)
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|Nullable
name|T
name|element
parameter_list|)
block|{
name|forwardList
operator|.
name|add
argument_list|(
name|reversePosition
argument_list|(
name|index
argument_list|)
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|forwardList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|T
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|remove
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeRange (int fromIndex, int toIndex)
annotation|@
name|Override
specifier|protected
name|void
name|removeRange
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|set (int index, @Nullable T element)
annotation|@
name|Override
specifier|public
name|T
name|set
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|Nullable
name|T
name|element
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|set
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|,
name|element
argument_list|)
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|get
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|forwardList
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|forwardList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|subList (int fromIndex, int toIndex)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|checkPositionIndexes
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reverse
argument_list|(
name|forwardList
operator|.
name|subList
argument_list|(
name|reversePosition
argument_list|(
name|toIndex
argument_list|)
argument_list|,
name|reversePosition
argument_list|(
name|fromIndex
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|indexOf (@ullable Object o)
annotation|@
name|Override
specifier|public
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|int
name|index
init|=
name|forwardList
operator|.
name|lastIndexOf
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
operator|(
name|index
operator|>=
literal|0
operator|)
condition|?
name|reverseIndex
argument_list|(
name|index
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|lastIndexOf (@ullable Object o)
annotation|@
name|Override
specifier|public
name|int
name|lastIndexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|int
name|index
init|=
name|forwardList
operator|.
name|indexOf
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
operator|(
name|index
operator|>=
literal|0
operator|)
condition|?
name|reverseIndex
argument_list|(
name|index
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|listIterator
argument_list|()
return|;
block|}
DECL|method|listIterator (int index)
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|start
init|=
name|reversePosition
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|ListIterator
argument_list|<
name|T
argument_list|>
name|forwardIterator
init|=
name|forwardList
operator|.
name|listIterator
argument_list|(
name|start
argument_list|)
decl_stmt|;
return|return
operator|new
name|ListIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|canRemove
decl_stmt|;
name|boolean
name|canSet
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|T
name|e
parameter_list|)
block|{
name|forwardIterator
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|previous
argument_list|()
expr_stmt|;
name|canSet
operator|=
name|canRemove
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|forwardIterator
operator|.
name|hasPrevious
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|forwardIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|canSet
operator|=
name|canRemove
operator|=
literal|true
expr_stmt|;
return|return
name|forwardIterator
operator|.
name|previous
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|reversePosition
argument_list|(
name|forwardIterator
operator|.
name|nextIndex
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|previous
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasPrevious
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|canSet
operator|=
name|canRemove
operator|=
literal|true
expr_stmt|;
return|return
name|forwardIterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|nextIndex
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|canRemove
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|canRemove
operator|=
name|canSet
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|T
name|e
parameter_list|)
block|{
name|checkState
argument_list|(
name|canSet
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|set
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
DECL|class|RandomAccessReverseList
specifier|private
specifier|static
class|class
name|RandomAccessReverseList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ReverseList
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessReverseList (List<T> forwardList)
name|RandomAccessReverseList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
parameter_list|)
block|{
name|super
argument_list|(
name|forwardList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * An implementation of {@link List#hashCode()}.    */
DECL|method|hashCodeImpl (List<?> list)
specifier|static
name|int
name|hashCodeImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|)
block|{
name|int
name|hashCode
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|list
control|)
block|{
name|hashCode
operator|=
literal|31
operator|*
name|hashCode
operator|+
operator|(
name|o
operator|==
literal|null
condition|?
literal|0
else|:
name|o
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
block|}
return|return
name|hashCode
return|;
block|}
comment|/**    * An implementation of {@link List#equals(Object)}.    */
DECL|method|equalsImpl (List<?> list, @Nullable Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|checkNotNull
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|object
operator|instanceof
name|List
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|o
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|list
operator|.
name|size
argument_list|()
operator|==
name|o
operator|.
name|size
argument_list|()
operator|&&
name|Iterators
operator|.
name|elementsEqual
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|o
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * An implementation of {@link List#addAll(int, Collection)}.    */
DECL|method|addAllImpl ( List<E> list, int index, Iterable<? extends E> elements)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|addAllImpl
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|elements
control|)
block|{
name|listIterator
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
comment|/**    * An implementation of {@link List#indexOf(Object)}.    */
DECL|method|indexOfImpl (List<?> list, @Nullable Object element)
specifier|static
name|int
name|indexOfImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
name|ListIterator
argument_list|<
name|?
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|listIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|element
argument_list|,
name|listIterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|listIterator
operator|.
name|previousIndex
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * An implementation of {@link List#lastIndexOf(Object)}.    */
DECL|method|lastIndexOfImpl (List<?> list, @Nullable Object element)
specifier|static
name|int
name|lastIndexOfImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
name|ListIterator
argument_list|<
name|?
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|listIterator
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|element
argument_list|,
name|listIterator
operator|.
name|previous
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|listIterator
operator|.
name|nextIndex
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns an implementation of {@link List#listIterator(int)}.    */
DECL|method|listIteratorImpl (List<E> list, int index)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIteratorImpl
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * An implementation of {@link List#subList(int, int)}.    */
DECL|method|subListImpl ( final List<E> list, int fromIndex, int toIndex)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|subListImpl
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|List
argument_list|<
name|E
argument_list|>
name|wrapper
decl_stmt|;
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
name|wrapper
operator|=
operator|new
name|RandomAccessListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
expr_stmt|;
block|}
else|else
block|{
name|wrapper
operator|=
operator|new
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
expr_stmt|;
block|}
return|return
name|wrapper
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
return|;
block|}
DECL|class|AbstractListWrapper
specifier|private
specifier|static
class|class
name|AbstractListWrapper
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
block|{
DECL|field|backingList
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|backingList
decl_stmt|;
DECL|method|AbstractListWrapper (List<E> backingList)
name|AbstractListWrapper
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|backingList
parameter_list|)
block|{
name|this
operator|.
name|backingList
operator|=
name|checkNotNull
argument_list|(
name|backingList
argument_list|)
expr_stmt|;
block|}
DECL|method|add (int index, E element)
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
name|backingList
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
DECL|method|addAll (int index, Collection<? extends E> c)
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|addAll
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|E
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|remove
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|set (int index, E element)
annotation|@
name|Override
specifier|public
name|E
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|backingList
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|class|RandomAccessListWrapper
specifier|private
specifier|static
class|class
name|RandomAccessListWrapper
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessListWrapper (List<E> backingList)
name|RandomAccessListWrapper
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|backingList
parameter_list|)
block|{
name|super
argument_list|(
name|backingList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

