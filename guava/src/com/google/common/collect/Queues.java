begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Queue} and {@link Deque} instances. Also see this  * class's counterparts {@link Lists}, {@link Sets}, and {@link Maps}.  *  * @author Kurt Alfred Kluever  * @since 11.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|Queues
specifier|public
specifier|final
class|class
name|Queues
block|{
DECL|method|Queues ()
specifier|private
name|Queues
parameter_list|()
block|{}
comment|// ArrayBlockingQueue
comment|/**    * Creates an empty {@code ArrayBlockingQueue} instance.    *    * @return a new, empty {@code ArrayBlockingQueue}    */
DECL|method|newArrayBlockingQueue (int capacity)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayBlockingQueue
argument_list|<
name|E
argument_list|>
name|newArrayBlockingQueue
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
return|return
operator|new
name|ArrayBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|capacity
argument_list|)
return|;
block|}
comment|// ArrayDeque
comment|/**    * Creates an empty {@code ArrayDeque} instance.    *    * @return a new, empty {@code ArrayDeque}    */
DECL|method|newArrayDeque ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayDeque
argument_list|<
name|E
argument_list|>
name|newArrayDeque
parameter_list|()
block|{
return|return
operator|new
name|ArrayDeque
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code ArrayDeque} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code ArrayDeque} containing those elements    */
DECL|method|newArrayDeque (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayDeque
argument_list|<
name|E
argument_list|>
name|newArrayDeque
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|ArrayDeque
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|ArrayDeque
argument_list|<
name|E
argument_list|>
name|deque
init|=
operator|new
name|ArrayDeque
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|deque
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|deque
return|;
block|}
comment|// ConcurrentLinkedQueue
comment|/**    * Creates an empty {@code ConcurrentLinkedQueue} instance.    *    * @return a new, empty {@code ConcurrentLinkedQueue}    */
DECL|method|newConcurrentLinkedQueue ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
name|newConcurrentLinkedQueue
parameter_list|()
block|{
return|return
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code ConcurrentLinkedQueue} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code ConcurrentLinkedQueue} containing those elements    */
DECL|method|newConcurrentLinkedQueue ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
name|newConcurrentLinkedQueue
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
name|queue
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|queue
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|queue
return|;
block|}
comment|// LinkedBlockingDeque
comment|/**    * Creates an empty {@code LinkedBlockingDeque} instance.    *    * @return a new, empty {@code LinkedBlockingDeque}    */
DECL|method|newLinkedBlockingDeque ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingDeque
parameter_list|()
block|{
return|return
operator|new
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code LinkedBlockingDeque} with the given (fixed) capacity.    *    * @param capacity the capacity of this deque    * @return a new, empty {@code LinkedBlockingDeque}    * @throws IllegalArgumentException if {@code capacity} is less than 1    */
DECL|method|newLinkedBlockingDeque (int capacity)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingDeque
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
return|return
operator|new
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
argument_list|(
name|capacity
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code LinkedBlockingDeque} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code LinkedBlockingDeque} containing those elements    */
DECL|method|newLinkedBlockingDeque (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingDeque
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
name|deque
init|=
operator|new
name|LinkedBlockingDeque
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|deque
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|deque
return|;
block|}
comment|// LinkedBlockingQueue
comment|/**    * Creates an empty {@code LinkedBlockingQueue} instance.    *    * @return a new, empty {@code LinkedBlockingQueue}    */
DECL|method|newLinkedBlockingQueue ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingQueue
parameter_list|()
block|{
return|return
operator|new
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.    *    * @param capacity the capacity of this queue    * @return a new, empty {@code LinkedBlockingQueue}    * @throws IllegalArgumentException if {@code capacity} is less than 1    */
DECL|method|newLinkedBlockingQueue (int capacity)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingQueue
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
return|return
operator|new
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|capacity
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code LinkedBlockingQueue} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code LinkedBlockingQueue} containing those elements    */
DECL|method|newLinkedBlockingQueue (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
name|newLinkedBlockingQueue
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
name|queue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|queue
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|queue
return|;
block|}
comment|// LinkedList: see {@link com.google.common.collect.Lists}
comment|// PriorityBlockingQueue
comment|/**    * Creates an empty {@code PriorityBlockingQueue} instance.    *    * @return a new, empty {@code PriorityBlockingQueue}    */
DECL|method|newPriorityBlockingQueue ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
name|newPriorityBlockingQueue
parameter_list|()
block|{
return|return
operator|new
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code PriorityBlockingQueue} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code PriorityBlockingQueue} containing those elements    */
DECL|method|newPriorityBlockingQueue ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
name|newPriorityBlockingQueue
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
name|queue
init|=
operator|new
name|PriorityBlockingQueue
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|queue
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|queue
return|;
block|}
comment|// PriorityQueue
comment|/**    * Creates an empty {@code PriorityQueue} instance.    *    * @return a new, empty {@code PriorityQueue}    */
DECL|method|newPriorityQueue ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|PriorityQueue
argument_list|<
name|E
argument_list|>
name|newPriorityQueue
parameter_list|()
block|{
return|return
operator|new
name|PriorityQueue
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code PriorityQueue} instance containing the given elements.    *    * @param elements the elements that the queue should contain, in order    * @return a new {@code PriorityQueue} containing those elements    */
DECL|method|newPriorityQueue (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|PriorityQueue
argument_list|<
name|E
argument_list|>
name|newPriorityQueue
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|PriorityQueue
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|PriorityQueue
argument_list|<
name|E
argument_list|>
name|queue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|queue
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|queue
return|;
block|}
comment|// SynchronousQueue
comment|/**    * Creates an empty {@code SynchronousQueue} instance.    *    * @return a new, empty {@code SynchronousQueue}    */
DECL|method|newSynchronousQueue ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SynchronousQueue
argument_list|<
name|E
argument_list|>
name|newSynchronousQueue
parameter_list|()
block|{
return|return
operator|new
name|SynchronousQueue
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * As {@link BlockingQueue#drainTo(Collection, int)}, but waiting up to the specified wait time     * if necessary for {@code maxElements} elements to become available.    *     * @param q the blocking queue to be drained    * @param buffer where to add the transferred elements    * @param maxElements the maximum number of elements to be transferred    * @param timeout how long to wait before giving up, in units of {@code unit}    * @param unit a {@code TimeUnit} determining how to interpret the timeout parameter    * @return the number of elements transferred    * @throws InterruptedException if interrupted while waiting    */
DECL|method|drain (BlockingQueue<E> q, Collection<? super E> buffer, int maxElements, long timeout, TimeUnit unit)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|int
name|drain
parameter_list|(
name|BlockingQueue
argument_list|<
name|E
argument_list|>
name|q
parameter_list|,
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|buffer
parameter_list|,
name|int
name|maxElements
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|long
name|remainingNanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|added
operator|<
name|maxElements
condition|)
block|{
comment|// we could rely solely on #poll, but #drainTo might be more efficient when there are multiple
comment|// elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)
name|added
operator|+=
name|q
operator|.
name|drainTo
argument_list|(
name|buffer
argument_list|,
name|maxElements
operator|-
name|added
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
operator|<
name|maxElements
condition|)
block|{
comment|// not enough elements immediately available; will have to poll
name|E
name|e
init|=
name|q
operator|.
name|poll
argument_list|(
name|remainingNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
break|break;
comment|// we already waited enough, and there are no more elements in sight
block|}
name|buffer
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
if|if
condition|(
name|added
operator|>=
name|maxElements
condition|)
block|{
break|break;
comment|// simply avoiding an extra nanoTime() invocation
block|}
name|remainingNanos
operator|=
name|end
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|added
return|;
block|}
comment|/**    * As {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)}, but with a different    * behavior in case it is interrupted while waiting. In that case, the operation will continue as    * usual, and in the end the thread's interruption status will be set (no {@code     * InterruptedException} is thrown).     *     * @param q the blocking queue to be drained    * @param buffer where to add the transferred elements    * @param maxElements the maximum number of elements to be transferred    * @param timeout how long to wait before giving up, in units of {@code unit}    * @param unit a {@code TimeUnit} determining how to interpret the timeout parameter    * @return the number of elements transferred    */
DECL|method|drainUninterruptibly (BlockingQueue<E> q, Collection<? super E> buffer, int maxElements, long timeout, TimeUnit unit)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|int
name|drainUninterruptibly
parameter_list|(
name|BlockingQueue
argument_list|<
name|E
argument_list|>
name|q
parameter_list|,
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|buffer
parameter_list|,
name|int
name|maxElements
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|long
name|remainingNanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
name|added
operator|<
name|maxElements
condition|)
block|{
comment|// we could rely solely on #poll, but #drainTo might be more efficient when there are
comment|// multiple elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)
name|added
operator|+=
name|q
operator|.
name|drainTo
argument_list|(
name|buffer
argument_list|,
name|maxElements
operator|-
name|added
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
operator|<
name|maxElements
condition|)
block|{
comment|// not enough elements immediately available; will have to poll
name|E
name|e
decl_stmt|;
comment|// written exactly once, by a successful (uninterrupted) invocation of #poll
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|e
operator|=
name|q
operator|.
name|poll
argument_list|(
name|remainingNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
comment|// note interruption and retry
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
break|break;
comment|// we already waited enough, and there are no more elements in sight
block|}
name|buffer
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
if|if
condition|(
name|added
operator|>=
name|maxElements
condition|)
block|{
break|break;
comment|// simply avoiding an extra nanoTime() invocation
block|}
name|remainingNanos
operator|=
name|end
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|added
return|;
block|}
block|}
end_class

end_unit

