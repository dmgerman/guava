begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * Provides static methods for working with {@code Collection} instances.  *  *<p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for  * comparisons. These methods are not being deprecated, but we gently encourage you to migrate to  * streams.  *  * @author Chris Povirk  * @author Mike Bostock  * @author Jared Levy  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Collections2
specifier|public
specifier|final
class|class
name|Collections2
block|{
DECL|method|Collections2 ()
specifier|private
name|Collections2
parameter_list|()
block|{}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned collection is    * a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting collection's iterator does not support {@code remove()}, but all other    * collection methods are supported. When given an element that doesn't satisfy the predicate, the    * collection's {@code add()} and {@code addAll()} methods throw an {@link    * IllegalArgumentException}. When methods such as {@code removeAll()} and {@code clear()} are    * called on the filtered collection, only elements that satisfy the filter will be removed from    * the underlying collection.    *    *<p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered collection's methods, such as {@code size()}, iterate across every    * element in the underlying collection and determine which elements satisfy the filter. When a    * live view is<i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered,    * predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link    * Iterables#filter(Iterable, Class)} for related functionality.)    *    *<p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#filter Stream.filter}.    */
comment|// TODO(kevinb): how can we omit that Iterables link when building gwt
comment|// javadoc?
DECL|method|filter (Collection<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredCollection
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
return|return
operator|(
operator|(
name|FilteredCollection
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|createCombined
argument_list|(
name|predicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredCollection
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Delegates to {@link Collection#contains}. Returns {@code false} if the {@code contains} method    * throws a {@code ClassCastException} or {@code NullPointerException}.    */
DECL|method|safeContains (Collection<?> collection, @NullableDecl Object object)
specifier|static
name|boolean
name|safeContains
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|object
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|collection
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Delegates to {@link Collection#remove}. Returns {@code false} if the {@code remove} method    * throws a {@code ClassCastException} or {@code NullPointerException}.    */
DECL|method|safeRemove (Collection<?> collection, @NullableDecl Object object)
specifier|static
name|boolean
name|safeRemove
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|object
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|collection
operator|.
name|remove
argument_list|(
name|object
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|class|FilteredCollection
specifier|static
class|class
name|FilteredCollection
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|E
argument_list|>
block|{
DECL|field|unfiltered
specifier|final
name|Collection
argument_list|<
name|E
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
decl_stmt|;
DECL|method|FilteredCollection (Collection<E> unfiltered, Predicate<? super E> predicate)
name|FilteredCollection
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|createCombined (Predicate<? super E> newPredicate)
name|FilteredCollection
argument_list|<
name|E
argument_list|>
name|createCombined
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|newPredicate
parameter_list|)
block|{
return|return
operator|new
name|FilteredCollection
argument_list|<
name|E
argument_list|>
argument_list|(
name|unfiltered
argument_list|,
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|predicate
argument_list|,
name|newPredicate
argument_list|)
argument_list|)
return|;
comment|// .<E> above needed to compile in JDK 5
block|}
annotation|@
name|Override
DECL|method|add (E element)
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
operator|.
name|add
argument_list|(
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|addAll (Collection<? extends E> collection)
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|collection
parameter_list|)
block|{
for|for
control|(
name|E
name|element
range|:
name|collection
control|)
block|{
name|checkArgument
argument_list|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|unfiltered
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Iterables
operator|.
name|removeIf
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullableDecl Object element)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|safeContains
argument_list|(
name|unfiltered
argument_list|,
name|element
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// element is in unfiltered, so it must be an E
name|E
name|e
init|=
operator|(
name|E
operator|)
name|element
decl_stmt|;
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|containsAll (Collection<?> collection)
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|containsAllImpl
argument_list|(
name|this
argument_list|,
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|Iterables
operator|.
name|any
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|E
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|spliterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (Consumer<? super E> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|E
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|forEach
argument_list|(
parameter_list|(
name|E
name|e
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|remove (Object element)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|element
argument_list|)
operator|&&
name|unfiltered
operator|.
name|remove
argument_list|(
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (final Collection<?> collection)
specifier|public
name|boolean
name|removeAll
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|collection
operator|::
name|contains
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (final Collection<?> collection)
specifier|public
name|boolean
name|retainAll
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|element
lambda|->
operator|!
name|collection
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|removeIf (java.util.function.Predicate<? super E> filter)
specifier|public
name|boolean
name|removeIf
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|filter
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return
name|unfiltered
operator|.
name|removeIf
argument_list|(
name|element
lambda|->
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
operator|&&
name|filter
operator|.
name|test
argument_list|(
name|element
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|unfiltered
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (T[] array)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a collection that applies {@code function} to each element of {@code fromCollection}.    * The returned collection is a live view of {@code fromCollection}; changes to one affect the    * other.    *    *<p>The returned collection's {@code add()} and {@code addAll()} methods throw an {@link    * UnsupportedOperationException}. All other collection methods are supported, as long as {@code    * fromCollection} supports them.    *    *<p>The returned collection isn't threadsafe or serializable, even if {@code fromCollection} is.    *    *<p>When a live view is<i>not</i> needed, it may be faster to copy the transformed collection    * and use the copy.    *    *<p>If the input {@code Collection} is known to be a {@code List}, consider {@link    * Lists#transform}. If only an {@code Iterable} is available, use {@link Iterables#transform}.    *    *<p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#map Stream.map}.    */
DECL|method|transform ( Collection<F> fromCollection, Function<? super F, T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|Collection
argument_list|<
name|F
argument_list|>
name|fromCollection
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|TransformedCollection
argument_list|<>
argument_list|(
name|fromCollection
argument_list|,
name|function
argument_list|)
return|;
block|}
DECL|class|TransformedCollection
specifier|static
class|class
name|TransformedCollection
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|T
argument_list|>
block|{
DECL|field|fromCollection
specifier|final
name|Collection
argument_list|<
name|F
argument_list|>
name|fromCollection
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformedCollection (Collection<F> fromCollection, Function<? super F, ? extends T> function)
name|TransformedCollection
parameter_list|(
name|Collection
argument_list|<
name|F
argument_list|>
name|fromCollection
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromCollection
operator|=
name|checkNotNull
argument_list|(
name|fromCollection
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromCollection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|fromCollection
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromCollection
operator|.
name|iterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|fromCollection
operator|.
name|spliterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (Consumer<? super T> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|fromCollection
operator|.
name|forEach
argument_list|(
parameter_list|(
name|F
name|f
parameter_list|)
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeIf (java.util.function.Predicate<? super T> filter)
specifier|public
name|boolean
name|removeIf
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|filter
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return
name|fromCollection
operator|.
name|removeIf
argument_list|(
name|element
lambda|->
name|filter
operator|.
name|test
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|element
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromCollection
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns {@code true} if the collection {@code self} contains all of the elements in the    * collection {@code c}.    *    *<p>This method iterates over the specified collection {@code c}, checking each element returned    * by the iterator in turn to see if it is contained in the specified collection {@code self}. If    * all elements are so contained, {@code true} is returned, otherwise {@code false}.    *    * @param self a collection which might contain all elements in {@code c}    * @param c a collection whose elements might be contained by {@code self}    */
DECL|method|containsAllImpl (Collection<?> self, Collection<?> c)
specifier|static
name|boolean
name|containsAllImpl
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|self
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
for|for
control|(
name|Object
name|o
range|:
name|c
control|)
block|{
if|if
condition|(
operator|!
name|self
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** An implementation of {@link Collection#toString()}. */
DECL|method|toStringImpl (final Collection<?> collection)
specifier|static
name|String
name|toStringImpl
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
name|newStringBuilderForCollection
argument_list|(
name|collection
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|collection
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|collection
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"(this Collection)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns best-effort-sized StringBuilder based on the given collection size. */
DECL|method|newStringBuilderForCollection (int size)
specifier|static
name|StringBuilder
name|newStringBuilderForCollection
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|size
argument_list|,
literal|"size"
argument_list|)
expr_stmt|;
return|return
operator|new
name|StringBuilder
argument_list|(
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|size
operator|*
literal|8L
argument_list|,
name|Ints
operator|.
name|MAX_POWER_OF_TWO
argument_list|)
argument_list|)
return|;
block|}
comment|/** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
DECL|method|cast (Iterable<T> iterable)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
comment|/**    * Returns a {@link Collection} of all the permutations of the specified {@link Iterable}.    *    *<p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations    * Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,    * Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the    * first permutation will be in ascending order, and the last will be in descending order.    *    *<p>Duplicate elements are considered equal. For example, the list [1, 1] will have only one    * permutation, instead of two. This is why the elements have to implement {@link Comparable}.    *    *<p>An empty iterable has only one permutation, which is an empty list.    *    *<p>This method is equivalent to {@code Collections2.orderedPermutations(list,    * Ordering.natural())}.    *    * @param elements the original iterable whose elements have to be permuted.    * @return an immutable {@link Collection} containing all the different permutations of the    *     original iterable.    * @throws NullPointerException if the specified iterable is null or has any null elements.    * @since 12.0    */
annotation|@
name|Beta
DECL|method|orderedPermutations ( Iterable<E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
name|Collection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|orderedPermutations
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
name|orderedPermutations
argument_list|(
name|elements
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a {@link Collection} of all the permutations of the specified {@link Iterable} using    * the specified {@link Comparator} for establishing the lexicographical ordering.    *    *<p>Examples:    *    *<pre>{@code    * for (List<String> perm : orderedPermutations(asList("b", "c", "a"))) {    *   println(perm);    * }    * // -> ["a", "b", "c"]    * // -> ["a", "c", "b"]    * // -> ["b", "a", "c"]    * // -> ["b", "c", "a"]    * // -> ["c", "a", "b"]    * // -> ["c", "b", "a"]    *    * for (List<Integer> perm : orderedPermutations(asList(1, 2, 2, 1))) {    *   println(perm);    * }    * // -> [1, 1, 2, 2]    * // -> [1, 2, 1, 2]    * // -> [1, 2, 2, 1]    * // -> [2, 1, 1, 2]    * // -> [2, 1, 2, 1]    * // -> [2, 2, 1, 1]    * }</pre>    *    *<p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations    * Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,    * Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the    * first permutation will be in ascending order, and the last will be in descending order.    *    *<p>Elements that compare equal are considered equal and no new permutations are created by    * swapping them.    *    *<p>An empty iterable has only one permutation, which is an empty list.    *    * @param elements the original iterable whose elements have to be permuted.    * @param comparator a comparator for the iterable's elements.    * @return an immutable {@link Collection} containing all the different permutations of the    *     original iterable.    * @throws NullPointerException If the specified iterable is null, has any null elements, or if    *     the specified comparator is null.    * @since 12.0    */
annotation|@
name|Beta
DECL|method|orderedPermutations ( Iterable<E> elements, Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|orderedPermutations
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|OrderedPermutationCollection
argument_list|<
name|E
argument_list|>
argument_list|(
name|elements
argument_list|,
name|comparator
argument_list|)
return|;
block|}
DECL|class|OrderedPermutationCollection
specifier|private
specifier|static
specifier|final
class|class
name|OrderedPermutationCollection
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|inputList
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|inputList
decl_stmt|;
DECL|field|comparator
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|OrderedPermutationCollection (Iterable<E> input, Comparator<? super E> comparator)
name|OrderedPermutationCollection
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|input
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|inputList
operator|=
name|ImmutableList
operator|.
name|sortedCopyOf
argument_list|(
name|comparator
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|calculateSize
argument_list|(
name|inputList
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * The number of permutations with repeated elements is calculated as follows:      *      *<ul>      *<li>For an empty list, it is 1 (base case).      *<li>When r numbers are added to a list of n-r elements, the number of permutations is      *       increased by a factor of (n choose r).      *</ul>      */
DECL|method|calculateSize ( List<E> sortedInputList, Comparator<? super E> comparator)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|int
name|calculateSize
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|sortedInputList
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|int
name|permutations
init|=
literal|1
decl_stmt|;
name|int
name|n
init|=
literal|1
decl_stmt|;
name|int
name|r
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|sortedInputList
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|comparison
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|sortedInputList
operator|.
name|get
argument_list|(
name|n
operator|-
literal|1
argument_list|)
argument_list|,
name|sortedInputList
operator|.
name|get
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|<
literal|0
condition|)
block|{
comment|// We move to the next non-repeated element.
name|permutations
operator|=
name|IntMath
operator|.
name|saturatedMultiply
argument_list|(
name|permutations
argument_list|,
name|IntMath
operator|.
name|binomial
argument_list|(
name|n
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|permutations
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
block|}
name|n
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
return|return
name|IntMath
operator|.
name|saturatedMultiply
argument_list|(
name|permutations
argument_list|,
name|IntMath
operator|.
name|binomial
argument_list|(
name|n
argument_list|,
name|r
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|OrderedPermutationIterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|inputList
argument_list|,
name|comparator
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullableDecl Object obj)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|isPermutation
argument_list|(
name|inputList
argument_list|,
name|list
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"orderedPermutationCollection("
operator|+
name|inputList
operator|+
literal|")"
return|;
block|}
block|}
DECL|class|OrderedPermutationIterator
specifier|private
specifier|static
specifier|final
class|class
name|OrderedPermutationIterator
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractIterator
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|nextPermutation
annotation|@
name|NullableDecl
name|List
argument_list|<
name|E
argument_list|>
name|nextPermutation
decl_stmt|;
DECL|field|comparator
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|method|OrderedPermutationIterator (List<E> list, Comparator<? super E> comparator)
name|OrderedPermutationIterator
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|nextPermutation
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|computeNext ()
specifier|protected
name|List
argument_list|<
name|E
argument_list|>
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|nextPermutation
operator|==
literal|null
condition|)
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|next
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nextPermutation
argument_list|)
decl_stmt|;
name|calculateNextPermutation
argument_list|()
expr_stmt|;
return|return
name|next
return|;
block|}
DECL|method|calculateNextPermutation ()
name|void
name|calculateNextPermutation
parameter_list|()
block|{
name|int
name|j
init|=
name|findNextJ
argument_list|()
decl_stmt|;
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
block|{
name|nextPermutation
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|int
name|l
init|=
name|findNextL
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|swap
argument_list|(
name|nextPermutation
argument_list|,
name|j
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|nextPermutation
operator|.
name|size
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|nextPermutation
operator|.
name|subList
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|findNextJ ()
name|int
name|findNextJ
parameter_list|()
block|{
for|for
control|(
name|int
name|k
init|=
name|nextPermutation
operator|.
name|size
argument_list|()
operator|-
literal|2
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|nextPermutation
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|,
name|nextPermutation
operator|.
name|get
argument_list|(
name|k
operator|+
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|k
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|findNextL (int j)
name|int
name|findNextL
parameter_list|(
name|int
name|j
parameter_list|)
block|{
name|E
name|ak
init|=
name|nextPermutation
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|l
init|=
name|nextPermutation
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|l
operator|>
name|j
condition|;
name|l
operator|--
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|ak
argument_list|,
name|nextPermutation
operator|.
name|get
argument_list|(
name|l
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|l
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"this statement should be unreachable"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a {@link Collection} of all the permutations of the specified {@link Collection}.    *    *<p><i>Notes:</i> This is an implementation of the Plain Changes algorithm for permutations    * generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,    * Section 7.2.1.2.    *    *<p>If the input list contains equal elements, some of the generated permutations will be equal.    *    *<p>An empty collection has only one permutation, which is an empty list.    *    * @param elements the original collection whose elements have to be permuted.    * @return an immutable {@link Collection} containing all the different permutations of the    *     original collection.    * @throws NullPointerException if the specified collection is null or has any null elements.    * @since 12.0    */
annotation|@
name|Beta
DECL|method|permutations (Collection<E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|permutations
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|new
name|PermutationCollection
argument_list|<
name|E
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
DECL|class|PermutationCollection
specifier|private
specifier|static
specifier|final
class|class
name|PermutationCollection
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|inputList
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|inputList
decl_stmt|;
DECL|method|PermutationCollection (ImmutableList<E> input)
name|PermutationCollection
parameter_list|(
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|input
parameter_list|)
block|{
name|this
operator|.
name|inputList
operator|=
name|input
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|IntMath
operator|.
name|factorial
argument_list|(
name|inputList
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|PermutationIterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|inputList
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullableDecl Object obj)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|isPermutation
argument_list|(
name|inputList
argument_list|,
name|list
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"permutations("
operator|+
name|inputList
operator|+
literal|")"
return|;
block|}
block|}
DECL|class|PermutationIterator
specifier|private
specifier|static
class|class
name|PermutationIterator
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractIterator
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|list
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
decl_stmt|;
DECL|field|c
specifier|final
name|int
index|[]
name|c
decl_stmt|;
DECL|field|o
specifier|final
name|int
index|[]
name|o
decl_stmt|;
DECL|field|j
name|int
name|j
decl_stmt|;
DECL|method|PermutationIterator (List<E> list)
name|PermutationIterator
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|c
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|o
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|o
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|computeNext ()
specifier|protected
name|List
argument_list|<
name|E
argument_list|>
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|next
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|calculateNextPermutation
argument_list|()
expr_stmt|;
return|return
name|next
return|;
block|}
DECL|method|calculateNextPermutation ()
name|void
name|calculateNextPermutation
parameter_list|()
block|{
name|j
operator|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
comment|// Handle the special case of an empty list. Skip the calculation of the
comment|// next permutation.
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|q
init|=
name|c
index|[
name|j
index|]
operator|+
name|o
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|q
operator|<
literal|0
condition|)
block|{
name|switchDirection
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|q
operator|==
name|j
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|s
operator|++
expr_stmt|;
name|switchDirection
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|Collections
operator|.
name|swap
argument_list|(
name|list
argument_list|,
name|j
operator|-
name|c
index|[
name|j
index|]
operator|+
name|s
argument_list|,
name|j
operator|-
name|q
operator|+
name|s
argument_list|)
expr_stmt|;
name|c
index|[
name|j
index|]
operator|=
name|q
expr_stmt|;
break|break;
block|}
block|}
DECL|method|switchDirection ()
name|void
name|switchDirection
parameter_list|()
block|{
name|o
index|[
name|j
index|]
operator|=
operator|-
name|o
index|[
name|j
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
comment|/** Returns {@code true} if the second list is a permutation of the first. */
DECL|method|isPermutation (List<?> first, List<?> second)
specifier|private
specifier|static
name|boolean
name|isPermutation
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|first
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|.
name|size
argument_list|()
operator|!=
name|second
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Multiset
argument_list|<
name|?
argument_list|>
name|firstMultiset
init|=
name|HashMultiset
operator|.
name|create
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|Multiset
argument_list|<
name|?
argument_list|>
name|secondMultiset
init|=
name|HashMultiset
operator|.
name|create
argument_list|(
name|second
argument_list|)
decl_stmt|;
return|return
name|firstMultiset
operator|.
name|equals
argument_list|(
name|secondMultiset
argument_list|)
return|;
block|}
block|}
end_class

end_unit

