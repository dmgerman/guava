begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
operator|.
name|firstNonNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ascii
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ComputingConcurrentHashMap
operator|.
name|ComputingMapAdapter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CustomConcurrentHashMap
operator|.
name|Strength
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  *<p>A builder of {@link ConcurrentMap} instances having any combination of the following features:  *  *<ul>  *<li>keys or values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain  *     SoftReference soft} references  *<li>least-recently-used eviction when a maximum size is exceeded  *<li>time-based expiration of entries, measured since last access or last write  *<li>notification of evicted (or otherwise removed) entries  *<li>on-demand computation of values for keys not already present  *</ul>  *  *<p>Usage example:<pre>   {@code  *  *   ConcurrentMap<Key, Graph> graphs = new MapMaker()  *       .concurrencyLevel(4)  *       .weakKeys()  *       .maximumSize(10000)  *       .expireAfterWrite(10, TimeUnit.MINUTES)  *       .makeComputingMap(  *           new Function<Key, Graph>() {  *             public Graph apply(Key key) {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  *  * These features are all optional; {@code new MapMaker().makeMap()} returns a valid concurrent map  * that behaves similarly to a {@link ConcurrentHashMap}.  *  *<p>The returned map is implemented as a hash table with similar performance characteristics to  * {@link ConcurrentHashMap}. It supports all optional operations of the {@code ConcurrentMap}  * interface. It does not permit null keys or values.  *  *<p><b>Note:</b> by default, the returned map uses equality comparisons (the {@link Object#equals  * equals} method) to determine equality for keys or values. However, if {@link #weakKeys} or {@link  * #softKeys} was specified, the map uses identity ({@code ==}) comparisons instead for keys.  * Likewise, if {@link #weakValues} or {@link #softValues} was specified, the map uses identity  * comparisons for values.  *  *<p>The view collections of the returned map have<i>weakly consistent iterators</i>. This means  * that they are safe for concurrent use, but if other threads modify the map after the iterator is  * created, it is undefined which of these changes, if any, are reflected in that iterator. These  * iterators never throw {@link ConcurrentModificationException}.  *  *<p>If soft or weak references were requested, it is possible for a key or value present in the  * the map to be reclaimed by the garbage collector. If this happens, the entry automatically  * disappears from the map. A partially-reclaimed entry is never exposed to the user. Any {@link  * java.util.Map.Entry} instance retrieved from the map's {@linkplain Map#entrySet entry set} is a  * snapshot of that entry's state at the time of retrieval; such entries do, however, support {@link  * java.util.Map.Entry#setValue}, which simply calls {@link Map#put} on the entry's key.  *  *<p>The maps produced by {@code MapMaker} are serializable, and the deserialized maps retain all  * the configuration properties of the original map. During deserialization, if the original map had  * used soft or weak references, the entries are reconstructed as they were, but it's not unlikely  * they'll be quickly garbage-collected before they are ever accessed.  *  *<p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link  * java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code  * WeakHashMap} uses {@link Object#equals}.  *  * @author Bob Lee  * @author Charles Fry  * @author Kevin Bourrillion  * @since Guava release 02 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|MapMaker
specifier|public
specifier|final
class|class
name|MapMaker
extends|extends
name|GenericMapMaker
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|4
decl_stmt|;
DECL|field|DEFAULT_EXPIRATION_NANOS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_EXPIRATION_NANOS
init|=
literal|0
decl_stmt|;
DECL|field|UNSET_INT
specifier|static
specifier|final
name|int
name|UNSET_INT
init|=
operator|-
literal|1
decl_stmt|;
comment|// TODO(kevinb): dispense with this after benchmarking
DECL|field|useCustomMap
name|boolean
name|useCustomMap
decl_stmt|;
DECL|field|initialCapacity
name|int
name|initialCapacity
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|concurrencyLevel
name|int
name|concurrencyLevel
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|maximumSize
name|int
name|maximumSize
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|keyStrength
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|expireAfterWriteNanos
name|long
name|expireAfterWriteNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|expireAfterAccessNanos
name|long
name|expireAfterAccessNanos
init|=
name|UNSET_INT
decl_stmt|;
DECL|field|nullRemovalCause
name|RemovalCause
name|nullRemovalCause
decl_stmt|;
DECL|field|keyEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|ticker
name|Ticker
name|ticker
decl_stmt|;
comment|/**    * Constructs a new {@code MapMaker} instance with default settings, including strong keys, strong    * values, and no automatic eviction of any kind.    */
DECL|method|MapMaker ()
specifier|public
name|MapMaker
parameter_list|()
block|{}
DECL|method|useNullMap ()
specifier|private
name|boolean
name|useNullMap
parameter_list|()
block|{
return|return
operator|(
name|nullRemovalCause
operator|==
literal|null
operator|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing keys.    *    *<p>By default, the map uses {@link Equivalences#identity} to determine key equality when    * {@link #weakKeys} or {@link #softKeys} is specified, and {@link Equivalences#equals()}    * otherwise.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
annotation|@
name|Override
DECL|method|keyEquivalence (Equivalence<Object> equivalence)
name|MapMaker
name|keyEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyEquivalence
operator|==
literal|null
argument_list|,
literal|"key equivalence was already set to %s"
argument_list|,
name|keyEquivalence
argument_list|)
expr_stmt|;
name|keyEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getKeyEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getKeyEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyEquivalence
argument_list|,
name|getKeyStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets a custom {@code Equivalence} strategy for comparing values.    *    *<p>By default, the map uses {@link Equivalences#identity} to determine value equality when    * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalences#equals()}    * otherwise.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
annotation|@
name|Override
DECL|method|valueEquivalence (Equivalence<Object> equivalence)
name|MapMaker
name|valueEquivalence
parameter_list|(
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|equivalence
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueEquivalence
operator|==
literal|null
argument_list|,
literal|"value equivalence was already set to %s"
argument_list|,
name|valueEquivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|checkNotNull
argument_list|(
name|equivalence
argument_list|)
expr_stmt|;
name|this
operator|.
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getValueEquivalence ()
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|getValueEquivalence
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueEquivalence
argument_list|,
name|getValueStrength
argument_list|()
operator|.
name|defaultEquivalence
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sets the minimum total size for the internal hash tables. For example, if the initial capacity    * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each    * having a hash table of size eight. Providing a large enough estimate at construction time    * avoids the need for expensive resizing operations later, but setting this value unnecessarily    * high wastes memory.    *    * @throws IllegalArgumentException if {@code initialCapacity} is negative    * @throws IllegalStateException if an initial capacity was already set    */
annotation|@
name|Override
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|MapMaker
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|initialCapacity
operator|==
name|UNSET_INT
argument_list|,
literal|"initial capacity was already set to %s"
argument_list|,
name|this
operator|.
name|initialCapacity
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|initialCapacity
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getInitialCapacity ()
name|int
name|getInitialCapacity
parameter_list|()
block|{
return|return
operator|(
name|initialCapacity
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_INITIAL_CAPACITY
else|:
name|initialCapacity
return|;
block|}
comment|/**    * Specifies the maximum number of entries the map may contain. Note that the map<b>may evict an    * entry before this limit is exceeded</b>. As the map size grows close to the maximum, the map    * evicts entries that are less likely to be used again. For example, the map may evict an entry    * because it hasn't been used recently or very often.    *    *<p>When {@code size} is zero, elements can be successfully added to the map, but are evicted    * immediately. This has the same effect as invoking {@link #expireAfterWrite    * expireAfterWrite}{@code (0, unit)} or {@link #expireAfterAccess expireAfterAccess}{@code (0,    * unit)}. It can be useful in testing, or to disable caching temporarily without a code change.    *    *<p>Caching functionality in {@code MapMaker} is being moved to    * {@link com.google.common.cache.CacheBuilder}.    *<b>This method is scheduled for deletion in Guava release 11.</b>    *    * @param size the maximum size of the map    * @throws IllegalArgumentException if {@code size} is negative    * @throws IllegalStateException if a maximum size was already set    * @since Guava release 08    */
annotation|@
name|Beta
annotation|@
name|Override
annotation|@
name|Deprecated
DECL|method|maximumSize (int size)
specifier|public
name|MapMaker
name|maximumSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|maximumSize
operator|==
name|UNSET_INT
argument_list|,
literal|"maximum size was already set to %s"
argument_list|,
name|this
operator|.
name|maximumSize
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"maximum size must not be negative"
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|useCustomMap
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|maximumSize
operator|==
literal|0
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|SIZE
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The    * table is internally partitioned to try to permit the indicated number of concurrent updates    * without contention. Because assignment of entries to these partitions is not necessarily    * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to    * accommodate as many threads as will ever concurrently modify the table. Using a significantly    * higher value than you need can waste space and time, and a significantly lower value can lead    * to thread contention. But overestimates and underestimates within an order of magnitude do not    * usually have much noticeable impact. A value of one permits only one thread to modify the map    * at a time, but since read operations can proceed concurrently, this still yields higher    * concurrency than full synchronization. Defaults to 4.    *    *<p><b>Note:</b> Prior to Guava release 09, the default was 16. It is possible the default will    * change again in the future. If you care about this value, you should always choose it    * explicitly.    *    * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive    * @throws IllegalStateException if a concurrency level was already set    */
annotation|@
name|Override
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|MapMaker
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|concurrencyLevel
operator|==
name|UNSET_INT
argument_list|,
literal|"concurrency level was already set to %s"
argument_list|,
name|this
operator|.
name|concurrencyLevel
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|concurrencyLevel
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getConcurrencyLevel ()
name|int
name|getConcurrencyLevel
parameter_list|()
block|{
return|return
operator|(
name|concurrencyLevel
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_CONCURRENCY_LEVEL
else|:
name|concurrencyLevel
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the map should be strongly referenced.    *    * @throws IllegalStateException if the key strength was already set    */
annotation|@
name|Override
DECL|method|strongKeys ()
name|MapMaker
name|strongKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the map should be wrapped in a {@link    * WeakReference} (by default, strong references are used).    *    *<p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})    * comparison to determine equality of keys, which is a technical violation of the {@link Map}    * specification, and may not be what you expect.    *    * @throws IllegalStateException if the key strength was already set    * @see WeakReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
annotation|@
name|Override
DECL|method|weakKeys ()
specifier|public
name|MapMaker
name|weakKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the map should be wrapped in a    * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will    * be garbage-collected in a<i>globally</i> least-recently-used manner, in response to memory    * demand.    *    *<p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})    * comparison to determine equality of keys, which is a technical violation of the {@link Map}    * specification, and may not be what you expect.    *    * @throws IllegalStateException if the key strength was already set    * @see SoftReference    * @deprecated use {@link #softValues} to create a memory-sensitive map, or {@link #weakKeys} to    *     create a map that doesn't hold strong references to the keys.    *<b>This method is scheduled for deletion in January 2013.</b>    */
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.SoftReference"
argument_list|)
annotation|@
name|Override
DECL|method|softKeys ()
specifier|public
name|MapMaker
name|softKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setKeyStrength (Strength strength)
name|MapMaker
name|setKeyStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|keyStrength
operator|==
literal|null
argument_list|,
literal|"Key strength was already set to %s"
argument_list|,
name|keyStrength
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
if|if
condition|(
name|strength
operator|!=
name|Strength
operator|.
name|STRONG
condition|)
block|{
comment|// STRONG could be used during deserialization.
name|useCustomMap
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|getKeyStrength ()
name|Strength
name|getKeyStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|keyStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the map should be strongly referenced.    *    * @throws IllegalStateException if the value strength was already set    */
annotation|@
name|Override
DECL|method|strongValues ()
name|MapMaker
name|strongValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the map should be wrapped in a    * {@link WeakReference} (by default, strong references are used).    *    *<p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor    * candidate for caching; consider {@link #softValues} instead.    *    *<p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})    * comparison to determine equality of values. This technically violates the specifications of    * the methods {@link Map#containsValue containsValue},    * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and    * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you    * expect.    *    * @throws IllegalStateException if the value strength was already set    * @see WeakReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
annotation|@
name|Override
DECL|method|weakValues ()
specifier|public
name|MapMaker
name|weakValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the map should be wrapped in a    * {@link SoftReference} (by default, strong references are used). Softly-referenced objects will    * be garbage-collected in a<i>globally</i> least-recently-used manner, in response to memory    * demand.    *    *<p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain    * #maximumSize maximum size} instead of using soft references. You should only use this method if    * you are well familiar with the practical consequences of soft references.    *    *<p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})    * comparison to determine equality of values. This technically violates the specifications of    * the methods {@link Map#containsValue containsValue},    * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and    * {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you    * expect.    *    * @throws IllegalStateException if the value strength was already set    * @see SoftReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.SoftReference"
argument_list|)
annotation|@
name|Override
DECL|method|softValues ()
specifier|public
name|MapMaker
name|softValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setValueStrength (Strength strength)
name|MapMaker
name|setValueStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
name|checkState
argument_list|(
name|valueStrength
operator|==
literal|null
argument_list|,
literal|"Value strength was already set to %s"
argument_list|,
name|valueStrength
argument_list|)
expr_stmt|;
name|valueStrength
operator|=
name|checkNotNull
argument_list|(
name|strength
argument_list|)
expr_stmt|;
if|if
condition|(
name|strength
operator|!=
name|Strength
operator|.
name|STRONG
condition|)
block|{
comment|// STRONG could be used during deserialization.
name|useCustomMap
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|getValueStrength ()
name|Strength
name|getValueStrength
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|valueStrength
argument_list|,
name|Strength
operator|.
name|STRONG
argument_list|)
return|;
block|}
comment|/**    * Old name of {@link #expireAfterWrite}.    *    * @deprecated Caching functionality in {@code MapMaker} is being moved to    *     {@link com.google.common.cache.CacheBuilder}. Functionality equivalent to    *     {@link MapMaker#expiration} is provided by    *     {@link com.google.common.cache.CacheBuilder#expireAfterWrite}.    *<b>This method is scheduled for deletion in July 2012.</b>    */
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
DECL|method|expiration (long duration, TimeUnit unit)
name|MapMaker
name|expiration
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|expireAfterWrite
argument_list|(
name|duration
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the map once a fixed duration    * has elapsed after the entry's creation, or the most recent replacement of its value.    *    *<p>When {@code duration} is zero, elements can be successfully added to the map, but are    * evicted immediately. This has a very similar effect to invoking {@link #maximumSize    * maximumSize}{@code (0)}. It can be useful in testing, or to disable caching temporarily without    * a code change.    *    *<p>Expired entries may be counted by {@link Map#size}, but will never be visible to read or    * write operations. Expired entries are currently cleaned up during write operations, or during    * occasional read operations in the absense of writes; though this behavior may change in the    * future.    *    *<p>Caching functionality in {@code MapMaker} is being moved to    * {@link com.google.common.cache.CacheBuilder}.    *<b>This method is scheduled for deletion in Guava release 11.</b>    *    * @param duration the length of time after an entry is created that it should be automatically    *     removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to live or time to idle was already set    * @since Guava release 08    */
annotation|@
name|Override
annotation|@
name|Deprecated
DECL|method|expireAfterWrite (long duration, TimeUnit unit)
specifier|public
name|MapMaker
name|expireAfterWrite
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkExpiration
argument_list|(
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|==
literal|0
operator|&&
name|this
operator|.
name|nullRemovalCause
operator|==
literal|null
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|EXPIRED
expr_stmt|;
block|}
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|checkExpiration (long duration, TimeUnit unit)
specifier|private
name|void
name|checkExpiration
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkState
argument_list|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterWrite was already set to %s ns"
argument_list|,
name|expireAfterWriteNanos
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
argument_list|,
literal|"expireAfterAccess was already set to %s ns"
argument_list|,
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|duration
operator|>=
literal|0
argument_list|,
literal|"duration cannot be negative: %s %s"
argument_list|,
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
DECL|method|getExpireAfterWriteNanos ()
name|long
name|getExpireAfterWriteNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterWriteNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterWriteNanos
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the map once a fixed duration    * has elapsed after the entry's last read or write access.    *    *<p>When {@code duration} is zero, elements can be successfully added to the map, but are    * evicted immediately. This has a very similar effect to invoking {@link #maximumSize    * maximumSize}{@code (0)}. It can be useful in testing, or to disable caching temporarily without    * a code change.    *    *<p>Expired entries may be counted by {@link Map#size}, but will never be visible to read or    * write operations. Expired entries are currently cleaned up during write operations, or during    * occasional read operations in the absense of writes; though this behavior may change in the    * future.    *    *<p>Caching functionality in {@code MapMaker} is being moved to    * {@link com.google.common.cache.CacheBuilder}.    *<b>This method is scheduled for deletion in Guava release 11.</b>    *    * @param duration the length of time after an entry is last accessed that it should be    *     automatically removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is negative    * @throws IllegalStateException if the time to idle or time to live was already set    * @since Guava release 08    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
annotation|@
name|Override
annotation|@
name|Deprecated
DECL|method|expireAfterAccess (long duration, TimeUnit unit)
specifier|public
name|MapMaker
name|expireAfterAccess
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|checkExpiration
argument_list|(
name|duration
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|==
literal|0
operator|&&
name|this
operator|.
name|nullRemovalCause
operator|==
literal|null
condition|)
block|{
comment|// SIZE trumps EXPIRED
name|this
operator|.
name|nullRemovalCause
operator|=
name|RemovalCause
operator|.
name|EXPIRED
expr_stmt|;
block|}
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getExpireAfterAccessNanos ()
name|long
name|getExpireAfterAccessNanos
parameter_list|()
block|{
return|return
operator|(
name|expireAfterAccessNanos
operator|==
name|UNSET_INT
operator|)
condition|?
name|DEFAULT_EXPIRATION_NANOS
else|:
name|expireAfterAccessNanos
return|;
block|}
DECL|method|getTicker ()
name|Ticker
name|getTicker
parameter_list|()
block|{
return|return
name|firstNonNull
argument_list|(
name|ticker
argument_list|,
name|Ticker
operator|.
name|systemTicker
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Specifies a listener instance, which all maps built using this {@code MapMaker} will notify    * each time an entry is removed from the map by any means.    *    *<p>Each map built by this map maker after this method is called invokes the supplied listener    * after removing an element for any reason (see removal causes in {@link RemovalCause}). It will    * invoke the listener during invocations of any of that map's public methods (even read-only    * methods).    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code MapMaker} instance,    * this method returns {@code GenericMapMaker<K, V>}. From this point on, either the original    * reference or the returned reference may be used to complete configuration and build the map,    * but only the "generic" one is type-safe. That is, it will properly prevent you from building    * maps whose key or value types are incompatible with the types accepted by the listener already    * provided; the {@code MapMaker} type cannot do this. For best results, simply use the standard    * method-chaining idiom, as illustrated in the documentation at top, configuring a {@code    * MapMaker} and building your {@link Map} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code MapMaker} to build a map    * or cache whose key or value type is incompatible with the listener, you will likely experience    * a {@link ClassCastException} at some<i>undefined</i> point in the future.    *    * @throws IllegalStateException if a removal listener was already set    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
DECL|method|removalListener (RemovalListener<K, V> listener)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
parameter_list|(
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|removalListener
operator|==
literal|null
argument_list|)
expr_stmt|;
comment|// safely limiting the kinds of maps this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|me
init|=
operator|(
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|removalListener
operator|=
name|checkNotNull
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|me
return|;
block|}
comment|/**    * Specifies a listener instance, which all maps built using this {@code MapMaker} will notify    * each time an entry is evicted.    *    *<p>A map built by this map maker will invoke the supplied listener after it evicts an entry,    * whether it does so due to timed expiration, exceeding the maximum size, or discovering that the    * key or value has been reclaimed by the garbage collector. It will invoke the listener    * during invocations of any of that map's public methods (even read-only methods). The listener    * will<i>not</i> be invoked on manual removal.    *    *<p><b>Important note:</b> Instead of returning<em>this</em> as a {@code MapMaker} instance,    * this method returns {@code GenericMapMaker<K, V>}. From this point on, either the original    * reference or the returned reference may be used to complete configuration and build the map,    * but only the "generic" one is type-safe. That is, it will properly prevent you from building    * maps whose key or value types are incompatible with the types accepted by the listener already    * provided; the {@code MapMaker} type cannot do this. For best results, simply use the standard    * method-chaining idiom, as illustrated in the documentation at top, configuring a {@code    * MapMaker} and building your {@link Map} all in a single statement.    *    *<p><b>Warning:</b> if you ignore the above advice, and use this {@code MapMaker} to build maps    * whose key or value types are incompatible with the listener, you will likely experience a    * {@link ClassCastException} at an undefined point in the future.    *    * @throws IllegalStateException if an eviction listener was already set    * @deprecated Caching functionality in {@code MapMaker} is being moved to    *     {@link com.google.common.cache.CacheBuilder}. Functionality similar to    *     {@link MapMaker#evictionListener} is provided by {@link    *  com.google.common.cache.CacheBuilder#removalListener(com.google.common.cache.RemovalListener)}    *     which also provides    *     additional information about the entry being evicted; note that {@code evictionListener}    *     only notifies on removals due to eviction, while {@code removalListener} also notifies on    *     explicit removal (providing the {@link com.google.common.cache.RemovalCause} to    *     indicate the specific cause of removal.<b>This method is scheduled for deletion in Guava    *     release 11.</b>    * @since Guava release 07    */
annotation|@
name|Beta
annotation|@
name|Deprecated
annotation|@
name|GwtIncompatible
argument_list|(
literal|"To be supported"
argument_list|)
specifier|public
DECL|method|evictionListener (final MapEvictionListener<K, V> listener)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evictionListener
parameter_list|(
specifier|final
name|MapEvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
parameter_list|)
block|{
name|checkState
argument_list|(
name|this
operator|.
name|removalListener
operator|==
literal|null
argument_list|)
expr_stmt|;
comment|// safely limiting the kinds of maps this can produce
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|me
init|=
operator|(
name|GenericMapMaker
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|this
decl_stmt|;
name|me
operator|.
name|removalListener
operator|=
operator|new
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
parameter_list|)
block|{
if|if
condition|(
name|notification
operator|.
name|wasEvicted
argument_list|()
condition|)
block|{
name|listener
operator|.
name|onEviction
argument_list|(
name|notification
operator|.
name|getKey
argument_list|()
argument_list|,
name|notification
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|me
return|;
block|}
comment|/**    * Builds a thread-safe map, without on-demand computation of values. This method does not alter    * the state of this {@code MapMaker} instance, so it can be invoked again to create multiple    * independent maps.    *    *<p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to    * be performed atomically on the returned map. Additionally, {@code size} and {@code    * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent    * writes.    *    * @return a serializable concurrent map having the requested features    */
annotation|@
name|Override
DECL|method|makeMap ()
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeMap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|useCustomMap
condition|)
block|{
return|return
operator|new
name|ConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|getInitialCapacity
argument_list|()
argument_list|,
literal|0.75f
argument_list|,
name|getConcurrencyLevel
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|(
name|nullRemovalCause
operator|==
literal|null
operator|)
condition|?
operator|new
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
else|:
operator|new
name|NullConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns a CustomConcurrentHashMap for the benefit of internal callers that use features of    * that class not exposed through ConcurrentMap.    */
annotation|@
name|Override
annotation|@
name|GwtIncompatible
argument_list|(
literal|"CustomConcurrentHashMap"
argument_list|)
DECL|method|makeCustomMap ()
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeCustomMap
parameter_list|()
block|{
return|return
operator|new
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Builds a map that supports atomic, on-demand computation of values. {@link Map#get} either    * returns an already-computed value for the given key, atomically computes it using the supplied    * function, or, if another thread is currently computing the value for this key, simply waits for    * that thread to finish and returns its computed value. Note that the function may be executed    * concurrently by multiple threads, but only for distinct keys.    *    *<p>New code should use {@link com.google.common.cache.CacheBuilder}, which supports    * {@linkplain com.google.common.cache.CacheStats statistics} collection, introduces the    * {@link com.google.common.cache.CacheLoader} interface for loading entries into the cache    * (allowing checked exceptions to be thrown in the process), and more cleanly separates    * computation from the cache's {@code Map} view.    *    *<p>If an entry's value has not finished computing yet, query methods besides {@code get} return    * immediately as if an entry doesn't exist. In other words, an entry isn't externally visible    * until the value's computation completes.    *    *<p>{@link Map#get} on the returned map will never return {@code null}. It may throw:    *    *<ul>    *<li>{@link NullPointerException} if the key is null or the computing function returns null    *<li>{@link ComputationException} if an exception was thrown by the computing function. If that    * exception is already of type {@link ComputationException} it is propagated directly; otherwise    * it is wrapped.    *</ul>    *    *<p><b>Note:</b> Callers of {@code get}<i>must</i> ensure that the key argument is of type    * {@code K}. The {@code get} method accepts {@code Object}, so the key type is not checked at    * compile time. Passing an object of a type other than {@code K} can result in that object being    * unsafely passed to the computing function as type {@code K}, and unsafely stored in the map.    *    *<p>If {@link Map#put} is called before a computation completes, other threads waiting on the    * computation will wake up and return the stored value.    *    *<p>This method does not alter the state of this {@code MapMaker} instance, so it can be invoked    * again to create multiple independent maps.    *    *<p>Insertion, removal, update, and access operations on the returned map safely execute    * concurrently by multiple threads. Iterators on the returned map are weakly consistent,    * returning elements reflecting the state of the map at some point at or since the creation of    * the iterator. They do not throw {@link ConcurrentModificationException}, and may proceed    * concurrently with other operations.    *    *<p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to    * be performed atomically on the returned map. Additionally, {@code size} and {@code    * containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent    * writes.    *    * @param computingFunction the function used to compute new values    * @return a serializable concurrent map having the requested features    */
annotation|@
name|Override
DECL|method|makeComputingMap ( Function<? super K, ? extends V> computingFunction)
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeComputingMap
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computingFunction
parameter_list|)
block|{
return|return
name|useNullMap
argument_list|()
condition|?
operator|new
name|ComputingMapAdapter
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|computingFunction
argument_list|)
else|:
operator|new
name|NullComputingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|computingFunction
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation for this MapMaker instance. The exact form of the returned    * string is not specificed.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Objects
operator|.
name|ToStringHelper
name|s
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialCapacity
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"initialCapacity"
argument_list|,
name|initialCapacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"concurrencyLevel"
argument_list|,
name|concurrencyLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumSize
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"maximumSize"
argument_list|,
name|maximumSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterWriteNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterWrite"
argument_list|,
name|expireAfterWriteNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|!=
name|UNSET_INT
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"expireAfterAccess"
argument_list|,
name|expireAfterAccessNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"keyStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|keyStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueStrength
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|add
argument_list|(
literal|"valueStrength"
argument_list|,
name|Ascii
operator|.
name|toLowerCase
argument_list|(
name|valueStrength
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"keyEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueEquivalence
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"valueEquivalence"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removalListener
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|addValue
argument_list|(
literal|"removalListener"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * An object that can receive a notification when an entry is removed from a map. The removal    * resulting in notification could have occured to an entry being manually removed or replaced, or    * due to eviction resulting from timed expiration, exceeding a maximum size, or garbage    * collection.    *    *<p>An instance may be called concurrently by multiple threads to process different entries.    * Implementations of this interface should avoid performing blocking calls or synchronizing on    * shared resources.    *    * @param<K> the most general type of keys this listener can listen for; for    *     example {@code Object} if any key is acceptable    * @param<V> the most general type of values this listener can listen for; for    *     example {@code Object} if any key is acceptable    */
DECL|interface|RemovalListener
interface|interface
name|RemovalListener
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Notifies the listener that a removal occurred at some point in the past.      */
DECL|method|onRemoval (RemovalNotification<K, V> notification)
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
parameter_list|)
function_decl|;
block|}
comment|/**    * A notification of the removal of a single entry. The key and/or value may be {@code null} if    * they were already garbage collected.    *    *<p>Like other {Map.Entry} instances associated with MapMaker this class holds strong references    * to the key and value, regardless of the type of references the map may be using.    */
DECL|class|RemovalNotification
specifier|static
specifier|final
class|class
name|RemovalNotification
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ImmutableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|cause
specifier|private
specifier|final
name|RemovalCause
name|cause
decl_stmt|;
DECL|method|RemovalNotification (K key, V value, RemovalCause cause)
name|RemovalNotification
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|this
operator|.
name|cause
operator|=
name|cause
expr_stmt|;
block|}
comment|/**      * Returns the cause for which the entry was removed.      */
DECL|method|getCause ()
specifier|public
name|RemovalCause
name|getCause
parameter_list|()
block|{
return|return
name|cause
return|;
block|}
comment|/**      * Returns {@code true} if there was an automatic removal due to eviction (the cause is neither      * {@link RemovalCause#EXPLICIT} nor {@link RemovalCause#REPLACED}).      */
DECL|method|wasEvicted ()
specifier|public
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
name|cause
operator|.
name|wasEvicted
argument_list|()
return|;
block|}
block|}
comment|/**    * The reason why an entry was removed.    */
DECL|enum|RemovalCause
enum|enum
name|RemovalCause
block|{
comment|/**      * The entry was manually removed by the user. This can result from the user invoking      * {@link Map#remove}, {@link ConcurrentMap#remove}, or {@link java.util.Iterator#remove}.      */
DECL|enumConstant|EXPLICIT
name|EXPLICIT
block|{
annotation|@
name|Override
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
block|,
comment|/**      * The entry itself was not actually removed, but its value was replaced by the user. This can      * result from the user invoking {@link Map#put}, {@link Map#putAll},      * {@link ConcurrentMap#replace(Object, Object)}, or      * {@link ConcurrentMap#replace(Object, Object, Object)}.      */
DECL|enumConstant|REPLACED
name|REPLACED
block|{
annotation|@
name|Override
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
block|,
comment|/**      * The entry was removed automatically because its key or value was garbage-collected. This      * can occur when using {@link #softKeys}, {@link #softValues}, {@link #weakKeys}, or {@link      * #weakValues}.      */
DECL|enumConstant|COLLECTED
name|COLLECTED
block|{
annotation|@
name|Override
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
block|,
comment|/**      * The entry's expiration timestamp has passed. This can occur when using {@link      * #expireAfterWrite} or {@link #expireAfterAccess}.      */
DECL|enumConstant|EXPIRED
name|EXPIRED
block|{
annotation|@
name|Override
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
block|,
comment|/**      * The entry was evicted due to size constraints. This can occur when using {@link      * #maximumSize}.      */
DECL|enumConstant|SIZE
name|SIZE
block|{
annotation|@
name|Override
name|boolean
name|wasEvicted
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
block|;
comment|/**      * Returns {@code true} if there was an automatic removal due to eviction (the cause is neither      * {@link #EXPLICIT} nor {@link #REPLACED}).      */
DECL|method|wasEvicted ()
specifier|abstract
name|boolean
name|wasEvicted
parameter_list|()
function_decl|;
block|}
comment|/** A map that is always empty and evicts on insertion. */
DECL|class|NullConcurrentMap
specifier|static
class|class
name|NullConcurrentMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|removalListener
specifier|private
specifier|final
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|removalCause
specifier|private
specifier|final
name|RemovalCause
name|removalCause
decl_stmt|;
DECL|method|NullConcurrentMap (MapMaker mapMaker)
name|NullConcurrentMap
parameter_list|(
name|MapMaker
name|mapMaker
parameter_list|)
block|{
name|removalListener
operator|=
name|mapMaker
operator|.
name|getRemovalListener
argument_list|()
expr_stmt|;
name|removalCause
operator|=
name|mapMaker
operator|.
name|nullRemovalCause
expr_stmt|;
block|}
comment|// implements ConcurrentMap
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
DECL|method|notifyRemoval (K key, V value)
name|void
name|notifyRemoval
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
init|=
operator|new
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|removalCause
argument_list|)
decl_stmt|;
name|removalListener
operator|.
name|onRemoval
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|notifyRemoval
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
comment|/** Computes on retrieval and evicts the result. */
DECL|class|NullComputingConcurrentMap
specifier|static
specifier|final
class|class
name|NullComputingConcurrentMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|NullConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|computingFunction
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computingFunction
decl_stmt|;
DECL|method|NullComputingConcurrentMap ( MapMaker mapMaker, Function<? super K, ? extends V> computingFunction)
name|NullComputingConcurrentMap
parameter_list|(
name|MapMaker
name|mapMaker
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computingFunction
parameter_list|)
block|{
name|super
argument_list|(
name|mapMaker
argument_list|)
expr_stmt|;
name|this
operator|.
name|computingFunction
operator|=
name|checkNotNull
argument_list|(
name|computingFunction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, which is why Cache is preferred
annotation|@
name|Override
DECL|method|get (Object k)
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|k
decl_stmt|;
name|V
name|value
init|=
name|compute
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|,
name|computingFunction
operator|+
literal|" returned null for key "
operator|+
name|key
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|notifyRemoval
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|compute (K key)
specifier|private
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|computingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ComputationException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|ComputationException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

