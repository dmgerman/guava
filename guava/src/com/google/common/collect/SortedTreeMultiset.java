begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BstSide
operator|.
name|LEFT
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BstSide
operator|.
name|RIGHT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An implementation of a sorted multiset based on size balanced binary trees, as described in  * Stephen Adams, "Efficient sets: a balancing act", Journal of Functional Programming  * 3(4):553-562, October 1993,<a href="http://www.swiss.ai.mit.edu/~adams/BB/">  * http://www.swiss.ai.mit.edu/~adams/BB/</a>. It does not support null elements.  *  *<p>This implementation provides guaranteed log(n) time cost for the {@code contains}, {@code  * count}, {@code add}, {@code remove}, {@code setCount} {@code firstEntry}, {@code lastEntry},  * {@code pollFirstEntry}, and {@code pollLastEntry} operations, where n is the number of distinct  * elements.  *  *<p>The iterators returned by {@code iterator()} and the {@code iterator()} methods of the  * various collection views will, on a best-effort basis, throw a {@code  * ConcurrentModificationException} in the event that the multiset is modified in any way while  * iteration is in progress, except through the iterator's own {@code remove()} method.  *  *<p>The entries returned by {@code firstEntry}, {@code lastEntry}, {@code pollFirstEntry}, {@code  * pollLastEntry}, and {@code entrySet().iterator()} are all snapshots of entries at the time they  * were produced.  *  * @author Louis Wasserman  */
end_comment

begin_class
DECL|class|SortedTreeMultiset
specifier|final
class|class
name|SortedTreeMultiset
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSortedMultiset
argument_list|<
name|E
argument_list|>
block|{
comment|/**    * Returns an empty {@code SortedTreeMultiset} ordered by the natural ordering of its elements.    */
DECL|method|create ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|()
block|{
return|return
operator|new
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an empty {@code SortedTreeMultiset} ordered by the specified comparator.    */
DECL|method|create (Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code SortedTreeMultiset} ordered by the natural ordering of its elements,    * initialized to contain the specified elements.    */
DECL|method|create ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|create
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|multiset
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
DECL|method|SortedTreeMultiset (Comparator<? super E> comparator)
specifier|private
name|SortedTreeMultiset
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|super
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
name|GeneralRange
operator|.
name|all
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootReference
operator|=
operator|new
name|AtomicReference
argument_list|<
name|Node
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|SortedTreeMultiset (GeneralRange<E> range, AtomicReference<Node> root)
specifier|private
name|SortedTreeMultiset
parameter_list|(
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
parameter_list|,
name|AtomicReference
argument_list|<
name|Node
argument_list|>
name|root
parameter_list|)
block|{
name|super
argument_list|(
name|range
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
name|range
expr_stmt|;
name|this
operator|.
name|rootReference
operator|=
name|root
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|checkElement (Object o)
name|E
name|checkElement
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
name|E
operator|)
name|o
return|;
block|}
DECL|field|range
specifier|private
specifier|final
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
decl_stmt|;
DECL|field|rootReference
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Node
argument_list|>
name|rootReference
decl_stmt|;
annotation|@
name|Override
DECL|method|distinctElements ()
name|int
name|distinctElements
parameter_list|()
block|{
name|Node
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|BstRangeOps
operator|.
name|totalInRange
argument_list|(
name|distinctAggregate
argument_list|,
name|range
argument_list|,
name|root
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Node
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|BstRangeOps
operator|.
name|totalInRange
argument_list|(
name|sizeAggregate
argument_list|,
name|range
argument_list|,
name|root
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|count (@ullable Object element)
specifier|public
name|int
name|count
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
name|E
name|e
init|=
name|checkElement
argument_list|(
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|Node
name|node
init|=
name|BstOperations
operator|.
name|seek
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|rootReference
operator|.
name|get
argument_list|()
argument_list|,
name|e
argument_list|)
decl_stmt|;
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|elemOccurrences
return|;
block|}
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|mutate (E e, MultisetModifier modifier)
specifier|private
name|int
name|mutate
parameter_list|(
name|E
name|e
parameter_list|,
name|MultisetModifier
name|modifier
parameter_list|)
block|{
name|BstMutationRule
argument_list|<
name|E
argument_list|,
name|Node
argument_list|>
name|mutationRule
init|=
name|BstMutationRule
operator|.
name|createRule
argument_list|(
name|modifier
argument_list|,
name|BstCountBasedBalancePolicies
operator|.
expr|<
name|E
argument_list|,
name|Node
operator|>
name|singleRebalancePolicy
argument_list|(
name|distinctAggregate
argument_list|)
argument_list|,
name|nodeFactory
argument_list|)
decl_stmt|;
name|BstMutationResult
argument_list|<
name|E
argument_list|,
name|Node
argument_list|>
name|mutationResult
init|=
name|BstOperations
operator|.
name|mutate
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|mutationRule
argument_list|,
name|rootReference
operator|.
name|get
argument_list|()
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rootReference
operator|.
name|compareAndSet
argument_list|(
name|mutationResult
operator|.
name|getOriginalRoot
argument_list|()
argument_list|,
name|mutationResult
operator|.
name|getChangedRoot
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
name|Node
name|original
init|=
name|mutationResult
operator|.
name|getOriginalTarget
argument_list|()
decl_stmt|;
return|return
operator|(
name|original
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|original
operator|.
name|elemOccurrences
return|;
block|}
annotation|@
name|Override
DECL|method|add (E element, int occurrences)
specifier|public
name|int
name|add
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|AddModifier
argument_list|(
name|occurrences
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object element, int occurrences)
specifier|public
name|int
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
try|try
block|{
name|E
name|e
init|=
name|checkElement
argument_list|(
name|element
argument_list|)
decl_stmt|;
return|return
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|?
name|mutate
argument_list|(
name|e
argument_list|,
operator|new
name|RemoveModifier
argument_list|(
name|occurrences
argument_list|)
argument_list|)
else|:
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setCount (E element, int oldCount, int newCount)
specifier|public
name|boolean
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|oldCount
parameter_list|,
name|int
name|newCount
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|ConditionalSetCountModifier
argument_list|(
name|oldCount
argument_list|,
name|newCount
argument_list|)
argument_list|)
operator|==
name|oldCount
return|;
block|}
annotation|@
name|Override
DECL|method|setCount (E element, int count)
specifier|public
name|int
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|SetCountModifier
argument_list|(
name|count
argument_list|)
argument_list|)
return|;
block|}
DECL|field|pathFactory
specifier|private
specifier|transient
specifier|final
name|BstPathFactory
argument_list|<
name|Node
argument_list|,
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
argument_list|>
name|pathFactory
init|=
name|BstInOrderPath
operator|.
name|inOrderFactory
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
name|Node
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|startingPath
init|=
name|BstRangeOps
operator|.
name|furthestPath
argument_list|(
name|range
argument_list|,
name|LEFT
argument_list|,
name|pathFactory
argument_list|,
name|root
argument_list|)
decl_stmt|;
return|return
name|iteratorInDirection
argument_list|(
name|startingPath
argument_list|,
name|RIGHT
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
name|Node
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|startingPath
init|=
name|BstRangeOps
operator|.
name|furthestPath
argument_list|(
name|range
argument_list|,
name|RIGHT
argument_list|,
name|pathFactory
argument_list|,
name|root
argument_list|)
decl_stmt|;
return|return
name|iteratorInDirection
argument_list|(
name|startingPath
argument_list|,
name|LEFT
argument_list|)
return|;
block|}
DECL|method|iteratorInDirection ( @ullable BstInOrderPath<Node> start, final BstSide direction)
specifier|private
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|iteratorInDirection
parameter_list|(
annotation|@
name|Nullable
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|start
parameter_list|,
specifier|final
name|BstSide
name|direction
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
argument_list|>
name|pathIterator
init|=
operator|new
name|AbstractLinkedIterator
argument_list|<
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
argument_list|>
argument_list|(
name|start
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|computeNext
parameter_list|(
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|previous
parameter_list|)
block|{
if|if
condition|(
operator|!
name|previous
operator|.
name|hasNext
argument_list|(
name|direction
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|next
init|=
name|previous
operator|.
name|next
argument_list|(
name|direction
argument_list|)
decl_stmt|;
comment|// TODO(user): only check against one side
return|return
name|range
operator|.
name|contains
argument_list|(
name|next
operator|.
name|getTip
argument_list|()
operator|.
name|getKey
argument_list|()
argument_list|)
condition|?
name|next
else|:
literal|null
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
name|E
name|toRemove
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|pathIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|E
argument_list|>
name|next
parameter_list|()
block|{
name|BstInOrderPath
argument_list|<
name|Node
argument_list|>
name|path
init|=
name|pathIterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|Multisets
operator|.
name|immutableEntry
argument_list|(
name|toRemove
operator|=
name|path
operator|.
name|getTip
argument_list|()
operator|.
name|getKey
argument_list|()
argument_list|,
name|path
operator|.
name|getTip
argument_list|()
operator|.
name|elemOccurrences
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|toRemove
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|setCount
argument_list|(
name|toRemove
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toRemove
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Node
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|Node
name|cleared
init|=
name|BstRangeOps
operator|.
name|minusRange
argument_list|(
name|range
argument_list|,
name|BstCountBasedBalancePolicies
operator|.
expr|<
name|E
argument_list|,
name|Node
operator|>
name|fullRebalancePolicy
argument_list|(
name|distinctAggregate
argument_list|)
argument_list|,
name|nodeFactory
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rootReference
operator|.
name|compareAndSet
argument_list|(
name|root
argument_list|,
name|cleared
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|headMultiset (E upperBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|headMultiset
parameter_list|(
name|E
name|upperBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|upperBound
argument_list|)
expr_stmt|;
return|return
operator|new
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|upTo
argument_list|(
name|comparator
argument_list|,
name|upperBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|rootReference
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMultiset (E lowerBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|tailMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|lowerBound
argument_list|)
expr_stmt|;
return|return
operator|new
name|SortedTreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|downTo
argument_list|(
name|comparator
argument_list|,
name|lowerBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|rootReference
argument_list|)
return|;
block|}
DECL|class|Node
specifier|private
specifier|final
class|class
name|Node
extends|extends
name|BstNode
argument_list|<
name|E
argument_list|,
name|Node
argument_list|>
block|{
DECL|field|elemOccurrences
specifier|private
specifier|final
name|int
name|elemOccurrences
decl_stmt|;
DECL|field|size
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
DECL|field|distinct
specifier|private
specifier|final
name|int
name|distinct
decl_stmt|;
DECL|method|Node (E key, int elemCount, @Nullable Node left, @Nullable Node right)
specifier|private
name|Node
parameter_list|(
name|E
name|key
parameter_list|,
name|int
name|elemCount
parameter_list|,
annotation|@
name|Nullable
name|Node
name|left
parameter_list|,
annotation|@
name|Nullable
name|Node
name|right
parameter_list|)
block|{
name|super
argument_list|(
name|checkElement
argument_list|(
name|key
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|elemCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|elemOccurrences
operator|=
name|elemCount
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|elemCount
operator|+
name|sizeOrZero
argument_list|(
name|left
argument_list|)
operator|+
name|sizeOrZero
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
literal|1
operator|+
name|distinctOrZero
argument_list|(
name|left
argument_list|)
operator|+
name|distinctOrZero
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
DECL|method|Node (E key, int elemCount)
specifier|private
name|Node
parameter_list|(
name|E
name|key
parameter_list|,
name|int
name|elemCount
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
name|elemCount
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sizeOrZero (@ullable Node node)
specifier|private
name|int
name|sizeOrZero
parameter_list|(
annotation|@
name|Nullable
name|Node
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|size
return|;
block|}
DECL|method|distinctOrZero (@ullable Node node)
specifier|private
name|int
name|distinctOrZero
parameter_list|(
annotation|@
name|Nullable
name|Node
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|distinct
return|;
block|}
DECL|field|distinctAggregate
specifier|private
specifier|transient
specifier|final
name|BstAggregate
argument_list|<
name|Node
argument_list|>
name|distinctAggregate
init|=
operator|new
name|BstAggregate
argument_list|<
name|Node
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|entryValue
parameter_list|(
name|Node
name|entry
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|treeValue
parameter_list|(
annotation|@
name|Nullable
name|Node
name|tree
parameter_list|)
block|{
return|return
name|distinctOrZero
argument_list|(
name|tree
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|sizeAggregate
specifier|private
specifier|transient
specifier|final
name|BstAggregate
argument_list|<
name|Node
argument_list|>
name|sizeAggregate
init|=
operator|new
name|BstAggregate
argument_list|<
name|Node
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|entryValue
parameter_list|(
name|Node
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|elemOccurrences
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|treeValue
parameter_list|(
annotation|@
name|Nullable
name|Node
name|tree
parameter_list|)
block|{
return|return
name|sizeOrZero
argument_list|(
name|tree
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|nodeFactory
specifier|private
specifier|transient
specifier|final
name|BstNodeFactory
argument_list|<
name|Node
argument_list|>
name|nodeFactory
init|=
operator|new
name|BstNodeFactory
argument_list|<
name|Node
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Node
name|createNode
parameter_list|(
name|Node
name|source
parameter_list|,
annotation|@
name|Nullable
name|Node
name|left
parameter_list|,
annotation|@
name|Nullable
name|Node
name|right
parameter_list|)
block|{
return|return
operator|new
name|Node
argument_list|(
name|source
operator|.
name|getKey
argument_list|()
argument_list|,
name|source
operator|.
name|elemOccurrences
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|class|MultisetModifier
specifier|private
specifier|abstract
class|class
name|MultisetModifier
implements|implements
name|BstModifier
argument_list|<
name|E
argument_list|,
name|Node
argument_list|>
block|{
DECL|method|newCount (int oldCount)
specifier|abstract
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
function_decl|;
annotation|@
name|Nullable
annotation|@
name|Override
DECL|method|modify (E key, @Nullable Node originalEntry)
specifier|public
name|BstModificationResult
argument_list|<
name|Node
argument_list|>
name|modify
parameter_list|(
name|E
name|key
parameter_list|,
annotation|@
name|Nullable
name|Node
name|originalEntry
parameter_list|)
block|{
name|int
name|oldCount
init|=
operator|(
name|originalEntry
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|originalEntry
operator|.
name|elemOccurrences
decl_stmt|;
name|int
name|newCount
init|=
name|newCount
argument_list|(
name|oldCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldCount
operator|==
name|newCount
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|identity
argument_list|(
name|originalEntry
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|newCount
operator|==
literal|0
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|rebalancingChange
argument_list|(
name|originalEntry
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|oldCount
operator|==
literal|0
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|rebalancingChange
argument_list|(
literal|null
argument_list|,
operator|new
name|Node
argument_list|(
name|key
argument_list|,
name|newCount
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|BstModificationResult
operator|.
name|rebuildingChange
argument_list|(
name|originalEntry
argument_list|,
operator|new
name|Node
argument_list|(
name|key
argument_list|,
name|newCount
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|AddModifier
specifier|private
specifier|final
class|class
name|AddModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToAdd
specifier|private
specifier|final
name|int
name|countToAdd
decl_stmt|;
DECL|method|AddModifier (int countToAdd)
specifier|private
name|AddModifier
parameter_list|(
name|int
name|countToAdd
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToAdd
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToAdd
operator|=
name|countToAdd
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
name|oldCount
operator|+
name|countToAdd
return|;
block|}
block|}
DECL|class|RemoveModifier
specifier|private
specifier|final
class|class
name|RemoveModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToRemove
specifier|private
specifier|final
name|int
name|countToRemove
decl_stmt|;
DECL|method|RemoveModifier (int countToRemove)
specifier|private
name|RemoveModifier
parameter_list|(
name|int
name|countToRemove
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToRemove
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToRemove
operator|=
name|countToRemove
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|oldCount
operator|-
name|countToRemove
argument_list|)
return|;
block|}
block|}
DECL|class|SetCountModifier
specifier|private
specifier|final
class|class
name|SetCountModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToSet
specifier|private
specifier|final
name|int
name|countToSet
decl_stmt|;
DECL|method|SetCountModifier (int countToSet)
specifier|private
name|SetCountModifier
parameter_list|(
name|int
name|countToSet
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToSet
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToSet
operator|=
name|countToSet
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
name|countToSet
return|;
block|}
block|}
DECL|class|ConditionalSetCountModifier
specifier|private
specifier|final
class|class
name|ConditionalSetCountModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|expectedCount
specifier|private
specifier|final
name|int
name|expectedCount
decl_stmt|;
DECL|field|setCount
specifier|private
specifier|final
name|int
name|setCount
decl_stmt|;
DECL|method|ConditionalSetCountModifier (int expectedCount, int setCount)
specifier|private
name|ConditionalSetCountModifier
parameter_list|(
name|int
name|expectedCount
parameter_list|,
name|int
name|setCount
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|setCount
operator|>=
literal|0
operator|&
name|expectedCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|expectedCount
operator|=
name|expectedCount
expr_stmt|;
name|this
operator|.
name|setCount
operator|=
name|setCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
operator|(
name|oldCount
operator|==
name|expectedCount
operator|)
condition|?
name|setCount
else|:
name|oldCount
return|;
block|}
block|}
block|}
end_class

end_unit

