begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you  * may not use this file except in compliance with the License.  You may  * obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied.  See the License for the specific language governing  * permissions and limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|LongMath
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|OptionalDouble
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|OptionalInt
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|OptionalLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PrimitiveIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterators
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterators
operator|.
name|AbstractSpliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|DoubleConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|LongConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|DoubleStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|LongStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|StreamSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods related to {@code Stream} instances.  *  * @since 21.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Streams
specifier|public
specifier|final
class|class
name|Streams
block|{
comment|/**    * Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link    * Collection#stream} if possible.    */
DECL|method|stream (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|stream
argument_list|()
else|:
name|StreamSupport
operator|.
name|stream
argument_list|(
name|iterable
operator|.
name|spliterator
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns {@link Collection#stream}.    *    * @deprecated There is no reason to use this; just invoke {@code collection.stream()} directly.    */
annotation|@
name|Beta
annotation|@
name|Deprecated
DECL|method|stream (Collection<T> collection)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|collection
operator|.
name|stream
argument_list|()
return|;
block|}
comment|/**    * Returns a sequential {@link Stream} of the remaining contents of {@code iterator}. Do not use    * {@code iterator} directly after passing it to this method.    */
annotation|@
name|Beta
DECL|method|stream (Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
name|Spliterators
operator|.
name|spliteratorUnknownSize
argument_list|(
name|iterator
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * If a value is present in {@code optional}, returns a stream containing only that element,    * otherwise returns an empty stream.    */
annotation|@
name|Beta
DECL|method|stream (com.google.common.base.Optional<T> optional)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|(
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
argument_list|<
name|T
argument_list|>
name|optional
parameter_list|)
block|{
return|return
name|optional
operator|.
name|isPresent
argument_list|()
condition|?
name|Stream
operator|.
name|of
argument_list|(
name|optional
operator|.
name|get
argument_list|()
argument_list|)
else|:
name|Stream
operator|.
name|of
argument_list|()
return|;
block|}
comment|/**    * If a value is present in {@code optional}, returns a stream containing only that element,    * otherwise returns an empty stream.    *    *<p><b>Java 9 users:</b> use {@code optional.stream()} instead.    */
annotation|@
name|Beta
DECL|method|stream (java.util.Optional<T> optional)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|(
name|java
operator|.
name|util
operator|.
name|Optional
argument_list|<
name|T
argument_list|>
name|optional
parameter_list|)
block|{
return|return
name|optional
operator|.
name|isPresent
argument_list|()
condition|?
name|Stream
operator|.
name|of
argument_list|(
name|optional
operator|.
name|get
argument_list|()
argument_list|)
else|:
name|Stream
operator|.
name|of
argument_list|()
return|;
block|}
comment|/**    * If a value is present in {@code optional}, returns a stream containing only that element,    * otherwise returns an empty stream.    *    *<p><b>Java 9 users:</b> use {@code optional.stream()} instead.    */
annotation|@
name|Beta
DECL|method|stream (OptionalInt optional)
specifier|public
specifier|static
name|IntStream
name|stream
parameter_list|(
name|OptionalInt
name|optional
parameter_list|)
block|{
return|return
name|optional
operator|.
name|isPresent
argument_list|()
condition|?
name|IntStream
operator|.
name|of
argument_list|(
name|optional
operator|.
name|getAsInt
argument_list|()
argument_list|)
else|:
name|IntStream
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * If a value is present in {@code optional}, returns a stream containing only that element,    * otherwise returns an empty stream.    *    *<p><b>Java 9 users:</b> use {@code optional.stream()} instead.    */
annotation|@
name|Beta
DECL|method|stream (OptionalLong optional)
specifier|public
specifier|static
name|LongStream
name|stream
parameter_list|(
name|OptionalLong
name|optional
parameter_list|)
block|{
return|return
name|optional
operator|.
name|isPresent
argument_list|()
condition|?
name|LongStream
operator|.
name|of
argument_list|(
name|optional
operator|.
name|getAsLong
argument_list|()
argument_list|)
else|:
name|LongStream
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * If a value is present in {@code optional}, returns a stream containing only that element,    * otherwise returns an empty stream.    *    *<p><b>Java 9 users:</b> use {@code optional.stream()} instead.    */
annotation|@
name|Beta
DECL|method|stream (OptionalDouble optional)
specifier|public
specifier|static
name|DoubleStream
name|stream
parameter_list|(
name|OptionalDouble
name|optional
parameter_list|)
block|{
return|return
name|optional
operator|.
name|isPresent
argument_list|()
condition|?
name|DoubleStream
operator|.
name|of
argument_list|(
name|optional
operator|.
name|getAsDouble
argument_list|()
argument_list|)
else|:
name|DoubleStream
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * Returns a {@link Stream} containing the elements of the first stream, followed by the elements    * of the second stream, and so on.    *    *<p>This is equivalent to {@code Stream.of(streams).flatMap(stream -> stream)}, but the returned    * stream may perform better.    *    * @see Stream#concat(Stream, Stream)    */
annotation|@
name|SafeVarargs
DECL|method|concat (Stream<? extends T>.... streams)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Stream
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Stream
argument_list|<
name|?
extends|extends
name|T
argument_list|>
modifier|...
name|streams
parameter_list|)
block|{
comment|// TODO(lowasser): consider an implementation that can support SUBSIZED
name|boolean
name|isParallel
init|=
literal|false
decl_stmt|;
name|int
name|characteristics
init|=
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator||
name|Spliterator
operator|.
name|NONNULL
decl_stmt|;
name|long
name|estimatedSize
init|=
literal|0L
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Spliterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|splitrsBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|(
name|streams
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Stream
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|stream
range|:
name|streams
control|)
block|{
name|isParallel
operator||=
name|stream
operator|.
name|isParallel
argument_list|()
expr_stmt|;
name|Spliterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|splitr
init|=
name|stream
operator|.
name|spliterator
argument_list|()
decl_stmt|;
name|splitrsBuilder
operator|.
name|add
argument_list|(
name|splitr
argument_list|)
expr_stmt|;
name|characteristics
operator|&=
name|splitr
operator|.
name|characteristics
argument_list|()
expr_stmt|;
name|estimatedSize
operator|=
name|LongMath
operator|.
name|saturatedAdd
argument_list|(
name|estimatedSize
argument_list|,
name|splitr
operator|.
name|estimateSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
name|CollectSpliterators
operator|.
name|flatMap
argument_list|(
name|splitrsBuilder
operator|.
name|build
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|splitr
lambda|->
operator|(
name|Spliterator
argument_list|<
name|T
argument_list|>
operator|)
name|splitr
argument_list|,
name|characteristics
argument_list|,
name|estimatedSize
argument_list|)
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
parameter_list|()
lambda|->
block|{
for|for
control|(
name|Stream
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|stream
range|:
name|streams
control|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|)
class|;
end_class

begin_comment
unit|}
comment|/**    * Returns an {@link IntStream} containing the elements of the first stream, followed by the    * elements of the second stream, and so on.    *    *<p>This is equivalent to {@code Stream.of(streams).flatMapToInt(stream -> stream)}, but the    * returned stream may perform better.    *    * @see IntStream#concat(IntStream, IntStream)    */
end_comment

begin_function
DECL|method|concat (IntStream... streams)
unit|public
specifier|static
name|IntStream
name|concat
parameter_list|(
name|IntStream
modifier|...
name|streams
parameter_list|)
block|{
comment|// TODO(lowasser): optimize this later
return|return
name|Stream
operator|.
name|of
argument_list|(
name|streams
argument_list|)
operator|.
name|flatMapToInt
argument_list|(
name|stream
lambda|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a {@link LongStream} containing the elements of the first stream, followed by the    * elements of the second stream, and so on.    *    *<p>This is equivalent to {@code Stream.of(streams).flatMapToLong(stream -> stream)}, but the    * returned stream may perform better.    *    * @see LongStream#concat(LongStream, LongStream)    */
end_comment

begin_function
DECL|method|concat (LongStream... streams)
specifier|public
specifier|static
name|LongStream
name|concat
parameter_list|(
name|LongStream
modifier|...
name|streams
parameter_list|)
block|{
comment|// TODO(lowasser): optimize this later
return|return
name|Stream
operator|.
name|of
argument_list|(
name|streams
argument_list|)
operator|.
name|flatMapToLong
argument_list|(
name|stream
lambda|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a {@link DoubleStream} containing the elements of the first stream, followed by the    * elements of the second stream, and so on.    *    *<p>This is equivalent to {@code Stream.of(streams).flatMapToDouble(stream -> stream)}, but the    * returned stream may perform better.    *    * @see DoubleStream#concat(DoubleStream, DoubleStream)    */
end_comment

begin_function
DECL|method|concat (DoubleStream... streams)
specifier|public
specifier|static
name|DoubleStream
name|concat
parameter_list|(
name|DoubleStream
modifier|...
name|streams
parameter_list|)
block|{
comment|// TODO(lowasser): optimize this later
return|return
name|Stream
operator|.
name|of
argument_list|(
name|streams
argument_list|)
operator|.
name|flatMapToDouble
argument_list|(
name|stream
lambda|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a stream in which each element is the result of passing the corresponding elementY of    * each of {@code streamA} and {@code streamB} to {@code function}.    *    *<p>For example:    *    *<pre>{@code    * Streams.zip(    *   Stream.of("foo1", "foo2", "foo3"),    *   Stream.of("bar1", "bar2"),    *   (arg1, arg2) -> arg1 + ":" + arg2)    * }</pre>    *    *<p>will return {@code Stream.of("foo1:bar1", "foo2:bar2")}.    *    *<p>The resulting stream will only be as long as the shorter of the two input streams; if one    * stream is longer, its extra elements will be ignored.    *    *<p>Note that if you are calling {@link Stream#forEach} on the resulting stream, you might want    * to consider using {@link #forEachPair} instead of this method.    *    *<p><b>Performance note:</b> The resulting stream is not<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>.    * This may harm parallel performance.    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|zip ( Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function)
specifier|public
specifier|static
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|,
name|R
parameter_list|>
name|Stream
argument_list|<
name|R
argument_list|>
name|zip
parameter_list|(
name|Stream
argument_list|<
name|A
argument_list|>
name|streamA
parameter_list|,
name|Stream
argument_list|<
name|B
argument_list|>
name|streamB
parameter_list|,
name|BiFunction
argument_list|<
name|?
super|super
name|A
argument_list|,
name|?
super|super
name|B
argument_list|,
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|streamA
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|streamB
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|boolean
name|isParallel
init|=
name|streamA
operator|.
name|isParallel
argument_list|()
operator|||
name|streamB
operator|.
name|isParallel
argument_list|()
decl_stmt|;
comment|// same as Stream.concat
name|Spliterator
argument_list|<
name|A
argument_list|>
name|splitrA
init|=
name|streamA
operator|.
name|spliterator
argument_list|()
decl_stmt|;
name|Spliterator
argument_list|<
name|B
argument_list|>
name|splitrB
init|=
name|streamB
operator|.
name|spliterator
argument_list|()
decl_stmt|;
name|int
name|characteristics
init|=
name|splitrA
operator|.
name|characteristics
argument_list|()
operator|&
name|splitrB
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|SIZED
operator||
name|Spliterator
operator|.
name|ORDERED
operator|)
decl_stmt|;
name|Iterator
argument_list|<
name|A
argument_list|>
name|itrA
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|splitrA
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|B
argument_list|>
name|itrB
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|splitrB
argument_list|)
decl_stmt|;
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|AbstractSpliterator
argument_list|<
name|R
argument_list|>
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|splitrA
operator|.
name|estimateSize
argument_list|()
argument_list|,
name|splitrB
operator|.
name|estimateSize
argument_list|()
argument_list|)
argument_list|,
name|characteristics
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|itrA
operator|.
name|hasNext
argument_list|()
operator|&&
name|itrB
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|itrA
operator|.
name|next
argument_list|()
argument_list|,
name|itrB
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|streamA
operator|::
name|close
argument_list|)
operator|.
name|onClose
argument_list|(
name|streamB
operator|::
name|close
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes {@code consumer} once for each pair of<i>corresponding</i> elements in {@code streamA}    * and {@code streamB}. If one stream is longer than the other, the extra elements are silently    * ignored. Elements passed to the consumer are guaranteed to come from the same position in their    * respective source streams. For example:    *    *<pre>{@code    * Streams.forEachPair(    *   Stream.of("foo1", "foo2", "foo3"),    *   Stream.of("bar1", "bar2"),    *   (arg1, arg2) -> System.out.println(arg1 + ":" + arg2)    * }</pre>    *    *<p>will print:    *    *<pre>{@code    * foo1:bar1    * foo2:bar2    * }</pre>    *    *<p><b>Warning:</b> If either supplied stream is a parallel stream, the same correspondence    * between elements will be made, but the order in which those pairs of elements are passed to the    * consumer is<i>not</i> defined.    *    *<p>Note that many usages of this method can be replaced with simpler calls to {@link #zip}.    * This method behaves equivalently to {@linkplain #zip zipping} the stream elements into    * temporary pair objects and then using {@link Stream#forEach} on that stream.    *    * @since 22.0    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|forEachPair ( Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer)
specifier|public
specifier|static
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
name|void
name|forEachPair
parameter_list|(
name|Stream
argument_list|<
name|A
argument_list|>
name|streamA
parameter_list|,
name|Stream
argument_list|<
name|B
argument_list|>
name|streamB
parameter_list|,
name|BiConsumer
argument_list|<
name|?
super|super
name|A
argument_list|,
name|?
super|super
name|B
argument_list|>
name|consumer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamA
operator|.
name|isParallel
argument_list|()
operator|||
name|streamB
operator|.
name|isParallel
argument_list|()
condition|)
block|{
name|zip
argument_list|(
name|streamA
argument_list|,
name|streamB
argument_list|,
name|TemporaryPair
operator|::
operator|new
argument_list|)
operator|.
name|forEach
argument_list|(
name|pair
lambda|->
name|consumer
operator|.
name|accept
argument_list|(
name|pair
operator|.
name|a
argument_list|,
name|pair
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|A
argument_list|>
name|iterA
init|=
name|streamA
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|B
argument_list|>
name|iterB
init|=
name|streamB
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterA
operator|.
name|hasNext
argument_list|()
operator|&&
name|iterB
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
name|iterA
operator|.
name|next
argument_list|()
argument_list|,
name|iterB
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|// Use this carefully - it doesn't implement value semantics
end_comment

begin_class
DECL|class|TemporaryPair
specifier|private
specifier|static
class|class
name|TemporaryPair
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
DECL|field|a
specifier|final
name|A
name|a
decl_stmt|;
DECL|field|b
specifier|final
name|B
name|b
decl_stmt|;
DECL|method|TemporaryPair (A a, B b)
name|TemporaryPair
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
block|{
name|this
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns a stream consisting of the results of applying the given function to the elements of    * {@code stream} and their indices in the stream. For example,    *    *<pre>{@code    * mapWithIndex(    *     Stream.of("a", "b", "c"),    *     (str, index) -> str + ":" + index)    * }</pre>    *    *<p>would return {@code Stream.of("a:0", "b:1", "c:2")}.    *    *<p>The resulting stream is<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * if and only if {@code stream} was efficiently splittable and its underlying spliterator    * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream    * comes from a data structure supporting efficient indexed random access, typically an array or    * list.    *    *<p>The order of the resulting stream is defined if and only if the order of the original stream    * was defined.    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|mapWithIndex ( Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|R
parameter_list|>
name|Stream
argument_list|<
name|R
argument_list|>
name|mapWithIndex
parameter_list|(
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|,
name|FunctionWithIndex
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|boolean
name|isParallel
init|=
name|stream
operator|.
name|isParallel
argument_list|()
decl_stmt|;
name|Spliterator
argument_list|<
name|T
argument_list|>
name|fromSpliterator
init|=
name|stream
operator|.
name|spliterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromSpliterator
operator|.
name|hasCharacteristics
argument_list|(
name|Spliterator
operator|.
name|SUBSIZED
argument_list|)
condition|)
block|{
name|Iterator
argument_list|<
name|T
argument_list|>
name|fromIterator
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|fromSpliterator
argument_list|)
decl_stmt|;
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|AbstractSpliterator
argument_list|<
name|R
argument_list|>
argument_list|(
name|fromSpliterator
operator|.
name|estimateSize
argument_list|()
argument_list|,
name|fromSpliterator
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator|)
argument_list|)
block|{
name|long
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|fromIterator
operator|.
name|next
argument_list|()
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
class|class
name|Splitr
extends|extends
name|MapWithIndexSpliterator
argument_list|<
name|Spliterator
argument_list|<
name|T
argument_list|>
argument_list|,
name|R
argument_list|,
name|Splitr
argument_list|>
implements|implements
name|Consumer
argument_list|<
name|T
argument_list|>
block|{
annotation|@
name|Nullable
name|T
name|holder
decl_stmt|;
name|Splitr
parameter_list|(
name|Spliterator
argument_list|<
name|T
argument_list|>
name|splitr
parameter_list|,
name|long
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|splitr
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
annotation|@
name|Nullable
name|T
name|t
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromSpliterator
operator|.
name|tryAdvance
argument_list|(
name|this
argument_list|)
condition|)
block|{
try|try
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|holder
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|holder
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
name|Splitr
name|createSplit
parameter_list|(
name|Spliterator
argument_list|<
name|T
argument_list|>
name|from
parameter_list|,
name|long
name|i
parameter_list|)
block|{
return|return
operator|new
name|Splitr
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|Splitr
argument_list|(
name|fromSpliterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a stream consisting of the results of applying the given function to the elements of    * {@code stream} and their indexes in the stream. For example,    *    *<pre>{@code    * mapWithIndex(    *     IntStream.of(0, 1, 2),    *     (i, index) -> i + ":" + index)    * }</pre>    *    *<p>...would return {@code Stream.of("0:0", "1:1", "2:2")}.    *    *<p>The resulting stream is<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * if and only if {@code stream} was efficiently splittable and its underlying spliterator    * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream    * comes from a data structure supporting efficient indexed random access, typically an array or    * list.    *    *<p>The order of the resulting stream is defined if and only if the order of the original stream    * was defined.    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|mapWithIndex (IntStream stream, IntFunctionWithIndex<R> function)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|>
name|Stream
argument_list|<
name|R
argument_list|>
name|mapWithIndex
parameter_list|(
name|IntStream
name|stream
parameter_list|,
name|IntFunctionWithIndex
argument_list|<
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|boolean
name|isParallel
init|=
name|stream
operator|.
name|isParallel
argument_list|()
decl_stmt|;
name|Spliterator
operator|.
name|OfInt
name|fromSpliterator
init|=
name|stream
operator|.
name|spliterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromSpliterator
operator|.
name|hasCharacteristics
argument_list|(
name|Spliterator
operator|.
name|SUBSIZED
argument_list|)
condition|)
block|{
name|PrimitiveIterator
operator|.
name|OfInt
name|fromIterator
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|fromSpliterator
argument_list|)
decl_stmt|;
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|AbstractSpliterator
argument_list|<
name|R
argument_list|>
argument_list|(
name|fromSpliterator
operator|.
name|estimateSize
argument_list|()
argument_list|,
name|fromSpliterator
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator|)
argument_list|)
block|{
name|long
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|fromIterator
operator|.
name|nextInt
argument_list|()
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
class|class
name|Splitr
extends|extends
name|MapWithIndexSpliterator
argument_list|<
name|Spliterator
operator|.
name|OfInt
argument_list|,
name|R
argument_list|,
name|Splitr
argument_list|>
implements|implements
name|IntConsumer
implements|,
name|Spliterator
argument_list|<
name|R
argument_list|>
block|{
name|int
name|holder
decl_stmt|;
name|Splitr
parameter_list|(
name|Spliterator
operator|.
name|OfInt
name|splitr
parameter_list|,
name|long
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|splitr
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|int
name|t
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromSpliterator
operator|.
name|tryAdvance
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|holder
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
name|Splitr
name|createSplit
parameter_list|(
name|Spliterator
operator|.
name|OfInt
name|from
parameter_list|,
name|long
name|i
parameter_list|)
block|{
return|return
operator|new
name|Splitr
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|Splitr
argument_list|(
name|fromSpliterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a stream consisting of the results of applying the given function to the elements of    * {@code stream} and their indexes in the stream. For example,    *    *<pre>{@code    * mapWithIndex(    *     LongStream.of(0, 1, 2),    *     (i, index) -> i + ":" + index)    * }</pre>    *    *<p>...would return {@code Stream.of("0:0", "1:1", "2:2")}.    *    *<p>The resulting stream is<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * if and only if {@code stream} was efficiently splittable and its underlying spliterator    * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream    * comes from a data structure supporting efficient indexed random access, typically an array or    * list.    *    *<p>The order of the resulting stream is defined if and only if the order of the original stream    * was defined.    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|mapWithIndex (LongStream stream, LongFunctionWithIndex<R> function)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|>
name|Stream
argument_list|<
name|R
argument_list|>
name|mapWithIndex
parameter_list|(
name|LongStream
name|stream
parameter_list|,
name|LongFunctionWithIndex
argument_list|<
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|boolean
name|isParallel
init|=
name|stream
operator|.
name|isParallel
argument_list|()
decl_stmt|;
name|Spliterator
operator|.
name|OfLong
name|fromSpliterator
init|=
name|stream
operator|.
name|spliterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromSpliterator
operator|.
name|hasCharacteristics
argument_list|(
name|Spliterator
operator|.
name|SUBSIZED
argument_list|)
condition|)
block|{
name|PrimitiveIterator
operator|.
name|OfLong
name|fromIterator
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|fromSpliterator
argument_list|)
decl_stmt|;
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|AbstractSpliterator
argument_list|<
name|R
argument_list|>
argument_list|(
name|fromSpliterator
operator|.
name|estimateSize
argument_list|()
argument_list|,
name|fromSpliterator
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator|)
argument_list|)
block|{
name|long
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|fromIterator
operator|.
name|nextLong
argument_list|()
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
class|class
name|Splitr
extends|extends
name|MapWithIndexSpliterator
argument_list|<
name|Spliterator
operator|.
name|OfLong
argument_list|,
name|R
argument_list|,
name|Splitr
argument_list|>
implements|implements
name|LongConsumer
implements|,
name|Spliterator
argument_list|<
name|R
argument_list|>
block|{
name|long
name|holder
decl_stmt|;
name|Splitr
parameter_list|(
name|Spliterator
operator|.
name|OfLong
name|splitr
parameter_list|,
name|long
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|splitr
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|long
name|t
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromSpliterator
operator|.
name|tryAdvance
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|holder
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
name|Splitr
name|createSplit
parameter_list|(
name|Spliterator
operator|.
name|OfLong
name|from
parameter_list|,
name|long
name|i
parameter_list|)
block|{
return|return
operator|new
name|Splitr
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|Splitr
argument_list|(
name|fromSpliterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a stream consisting of the results of applying the given function to the elements of    * {@code stream} and their indexes in the stream. For example,    *    *<pre>{@code    * mapWithIndex(    *     DoubleStream.of(0, 1, 2),    *     (x, index) -> x + ":" + index)    * }</pre>    *    *<p>...would return {@code Stream.of("0.0:0", "1.0:1", "2.0:2")}.    *    *<p>The resulting stream is<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * if and only if {@code stream} was efficiently splittable and its underlying spliterator    * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream    * comes from a data structure supporting efficient indexed random access, typically an array or    * list.    *    *<p>The order of the resulting stream is defined if and only if the order of the original stream    * was defined.    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|mapWithIndex ( DoubleStream stream, DoubleFunctionWithIndex<R> function)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|>
name|Stream
argument_list|<
name|R
argument_list|>
name|mapWithIndex
parameter_list|(
name|DoubleStream
name|stream
parameter_list|,
name|DoubleFunctionWithIndex
argument_list|<
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|boolean
name|isParallel
init|=
name|stream
operator|.
name|isParallel
argument_list|()
decl_stmt|;
name|Spliterator
operator|.
name|OfDouble
name|fromSpliterator
init|=
name|stream
operator|.
name|spliterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromSpliterator
operator|.
name|hasCharacteristics
argument_list|(
name|Spliterator
operator|.
name|SUBSIZED
argument_list|)
condition|)
block|{
name|PrimitiveIterator
operator|.
name|OfDouble
name|fromIterator
init|=
name|Spliterators
operator|.
name|iterator
argument_list|(
name|fromSpliterator
argument_list|)
decl_stmt|;
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|AbstractSpliterator
argument_list|<
name|R
argument_list|>
argument_list|(
name|fromSpliterator
operator|.
name|estimateSize
argument_list|()
argument_list|,
name|fromSpliterator
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator|)
argument_list|)
block|{
name|long
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|fromIterator
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
class|class
name|Splitr
extends|extends
name|MapWithIndexSpliterator
argument_list|<
name|Spliterator
operator|.
name|OfDouble
argument_list|,
name|R
argument_list|,
name|Splitr
argument_list|>
implements|implements
name|DoubleConsumer
implements|,
name|Spliterator
argument_list|<
name|R
argument_list|>
block|{
name|double
name|holder
decl_stmt|;
name|Splitr
parameter_list|(
name|Spliterator
operator|.
name|OfDouble
name|splitr
parameter_list|,
name|long
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|splitr
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|double
name|t
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|R
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|fromSpliterator
operator|.
name|tryAdvance
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|holder
argument_list|,
name|index
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
name|Splitr
name|createSplit
parameter_list|(
name|Spliterator
operator|.
name|OfDouble
name|from
parameter_list|,
name|long
name|i
parameter_list|)
block|{
return|return
operator|new
name|Splitr
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
return|return
name|StreamSupport
operator|.
name|stream
argument_list|(
operator|new
name|Splitr
argument_list|(
name|fromSpliterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|isParallel
argument_list|)
operator|.
name|onClose
argument_list|(
name|stream
operator|::
name|close
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * An analogue of {@link java.util.function.Function} also accepting an index.    *    *<p>This interface is only intended for use by callers of {@link #mapWithIndex(Stream,    * FunctionWithIndex)}.    *    * @since 21.0    */
end_comment

begin_interface
annotation|@
name|Beta
DECL|interface|FunctionWithIndex
specifier|public
interface|interface
name|FunctionWithIndex
parameter_list|<
name|T
parameter_list|,
name|R
parameter_list|>
block|{
comment|/** Applies this function to the given argument and its index within a stream. */
DECL|method|apply (T from, long index)
name|R
name|apply
parameter_list|(
name|T
name|from
parameter_list|,
name|long
name|index
parameter_list|)
function_decl|;
block|}
end_interface

begin_class
DECL|class|MapWithIndexSpliterator
specifier|private
specifier|abstract
specifier|static
class|class
name|MapWithIndexSpliterator
parameter_list|<
name|F
extends|extends
name|Spliterator
parameter_list|<
name|?
parameter_list|>
parameter_list|,
name|R
parameter_list|,
name|S
extends|extends
name|MapWithIndexSpliterator
parameter_list|<
name|F
parameter_list|,
name|R
parameter_list|,
name|S
parameter_list|>
parameter_list|>
implements|implements
name|Spliterator
argument_list|<
name|R
argument_list|>
block|{
DECL|field|fromSpliterator
specifier|final
name|F
name|fromSpliterator
decl_stmt|;
DECL|field|index
name|long
name|index
decl_stmt|;
DECL|method|MapWithIndexSpliterator (F fromSpliterator, long index)
name|MapWithIndexSpliterator
parameter_list|(
name|F
name|fromSpliterator
parameter_list|,
name|long
name|index
parameter_list|)
block|{
name|this
operator|.
name|fromSpliterator
operator|=
name|fromSpliterator
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
DECL|method|createSplit (F from, long i)
specifier|abstract
name|S
name|createSplit
parameter_list|(
name|F
name|from
parameter_list|,
name|long
name|i
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|trySplit ()
specifier|public
name|S
name|trySplit
parameter_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|F
name|split
init|=
operator|(
name|F
operator|)
name|fromSpliterator
operator|.
name|trySplit
argument_list|()
decl_stmt|;
if|if
condition|(
name|split
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|S
name|result
init|=
name|createSplit
argument_list|(
name|split
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|this
operator|.
name|index
operator|+=
name|split
operator|.
name|getExactSizeIfKnown
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|estimateSize ()
specifier|public
name|long
name|estimateSize
parameter_list|()
block|{
return|return
name|fromSpliterator
operator|.
name|estimateSize
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|characteristics ()
specifier|public
name|int
name|characteristics
parameter_list|()
block|{
return|return
name|fromSpliterator
operator|.
name|characteristics
argument_list|()
operator|&
operator|(
name|Spliterator
operator|.
name|ORDERED
operator||
name|Spliterator
operator|.
name|SIZED
operator||
name|Spliterator
operator|.
name|SUBSIZED
operator|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * An analogue of {@link java.util.function.IntFunction} also accepting an index.    *    *<p>This interface is only intended for use by callers of {@link #mapWithIndex(IntStream,    * IntFunctionWithIndex)}.    *    * @since 21.0    */
end_comment

begin_interface
annotation|@
name|Beta
DECL|interface|IntFunctionWithIndex
specifier|public
interface|interface
name|IntFunctionWithIndex
parameter_list|<
name|R
parameter_list|>
block|{
comment|/** Applies this function to the given argument and its index within a stream. */
DECL|method|apply (int from, long index)
name|R
name|apply
parameter_list|(
name|int
name|from
parameter_list|,
name|long
name|index
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/**    * An analogue of {@link java.util.function.LongFunction} also accepting an index.    *    *<p>This interface is only intended for use by callers of {@link #mapWithIndex(LongStream,    * LongFunctionWithIndex)}.    *    * @since 21.0    */
end_comment

begin_interface
annotation|@
name|Beta
DECL|interface|LongFunctionWithIndex
specifier|public
interface|interface
name|LongFunctionWithIndex
parameter_list|<
name|R
parameter_list|>
block|{
comment|/** Applies this function to the given argument and its index within a stream. */
DECL|method|apply (long from, long index)
name|R
name|apply
parameter_list|(
name|long
name|from
parameter_list|,
name|long
name|index
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/**    * An analogue of {@link java.util.function.DoubleFunction} also accepting an index.    *    *<p>This interface is only intended for use by callers of {@link #mapWithIndex(DoubleStream,    * DoubleFunctionWithIndex)}.    *    * @since 21.0    */
end_comment

begin_interface
annotation|@
name|Beta
DECL|interface|DoubleFunctionWithIndex
specifier|public
interface|interface
name|DoubleFunctionWithIndex
parameter_list|<
name|R
parameter_list|>
block|{
comment|/** Applies this function to the given argument and its index within a stream. */
DECL|method|apply (double from, long index)
name|R
name|apply
parameter_list|(
name|double
name|from
parameter_list|,
name|long
name|index
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/**    * Returns the last element of the specified stream, or {@link java.util.Optional#empty} if the    * stream is empty.    *    *<p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This    * method's runtime will be between O(log n) and O(n), performing better on<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * streams.    *    *<p>If the stream has nondeterministic order, this has equivalent semantics to {@link    * Stream#findAny} (which you might as well use).    *    * @see Stream#findFirst()    * @throws NullPointerException if the last element of the stream is null    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|findLast (Stream<T> stream)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|java
operator|.
name|util
operator|.
name|Optional
argument_list|<
name|T
argument_list|>
name|findLast
parameter_list|(
name|Stream
argument_list|<
name|T
argument_list|>
name|stream
parameter_list|)
block|{
class|class
name|OptionalState
block|{
name|boolean
name|set
init|=
literal|false
decl_stmt|;
name|T
name|value
init|=
literal|null
decl_stmt|;
name|void
name|set
parameter_list|(
annotation|@
name|Nullable
name|T
name|value
parameter_list|)
block|{
name|this
operator|.
name|set
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
name|T
name|get
parameter_list|()
block|{
name|checkState
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
name|OptionalState
name|state
init|=
operator|new
name|OptionalState
argument_list|()
decl_stmt|;
name|Deque
argument_list|<
name|Spliterator
argument_list|<
name|T
argument_list|>
argument_list|>
name|splits
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|splits
operator|.
name|addLast
argument_list|(
name|stream
operator|.
name|spliterator
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|splits
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
init|=
name|splits
operator|.
name|removeLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|spliterator
operator|.
name|getExactSizeIfKnown
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|// drop this split
block|}
comment|// Many spliterators will have trySplits that are SUBSIZED even if they are not themselves
comment|// SUBSIZED.
if|if
condition|(
name|spliterator
operator|.
name|hasCharacteristics
argument_list|(
name|Spliterator
operator|.
name|SUBSIZED
argument_list|)
condition|)
block|{
comment|// we can drill down to exactly the smallest nonempty spliterator
while|while
condition|(
literal|true
condition|)
block|{
name|Spliterator
argument_list|<
name|T
argument_list|>
name|prefix
init|=
name|spliterator
operator|.
name|trySplit
argument_list|()
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|getExactSizeIfKnown
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|spliterator
operator|.
name|getExactSizeIfKnown
argument_list|()
operator|==
literal|0
condition|)
block|{
name|spliterator
operator|=
name|prefix
expr_stmt|;
break|break;
block|}
block|}
comment|// spliterator is known to be nonempty now
name|spliterator
operator|.
name|forEachRemaining
argument_list|(
name|state
operator|::
name|set
argument_list|)
expr_stmt|;
return|return
name|java
operator|.
name|util
operator|.
name|Optional
operator|.
name|of
argument_list|(
name|state
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
name|Spliterator
argument_list|<
name|T
argument_list|>
name|prefix
init|=
name|spliterator
operator|.
name|trySplit
argument_list|()
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|getExactSizeIfKnown
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// we can't split this any further
name|spliterator
operator|.
name|forEachRemaining
argument_list|(
name|state
operator|::
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|set
condition|)
block|{
return|return
name|java
operator|.
name|util
operator|.
name|Optional
operator|.
name|of
argument_list|(
name|state
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
comment|// fall back to the last split
continue|continue;
block|}
name|splits
operator|.
name|addLast
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|splits
operator|.
name|addLast
argument_list|(
name|spliterator
argument_list|)
expr_stmt|;
block|}
return|return
name|java
operator|.
name|util
operator|.
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of the specified stream, or {@link OptionalInt#empty} if the stream is    * empty.    *    *<p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This    * method's runtime will be between O(log n) and O(n), performing better on<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * streams.    *    * @see IntStream#findFirst()    * @throws NullPointerException if the last element of the stream is null    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|findLast (IntStream stream)
specifier|public
specifier|static
name|OptionalInt
name|findLast
parameter_list|(
name|IntStream
name|stream
parameter_list|)
block|{
comment|// findLast(Stream) does some allocation, so we might as well box some more
name|java
operator|.
name|util
operator|.
name|Optional
argument_list|<
name|Integer
argument_list|>
name|boxedLast
init|=
name|findLast
argument_list|(
name|stream
operator|.
name|boxed
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|boxedLast
operator|.
name|isPresent
argument_list|()
condition|?
name|OptionalInt
operator|.
name|of
argument_list|(
name|boxedLast
operator|.
name|get
argument_list|()
argument_list|)
else|:
name|OptionalInt
operator|.
name|empty
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of the specified stream, or {@link OptionalLong#empty} if the stream    * is empty.    *    *<p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This    * method's runtime will be between O(log n) and O(n), performing better on<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * streams.    *    * @see LongStream#findFirst()    * @throws NullPointerException if the last element of the stream is null    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|findLast (LongStream stream)
specifier|public
specifier|static
name|OptionalLong
name|findLast
parameter_list|(
name|LongStream
name|stream
parameter_list|)
block|{
comment|// findLast(Stream) does some allocation, so we might as well box some more
name|java
operator|.
name|util
operator|.
name|Optional
argument_list|<
name|Long
argument_list|>
name|boxedLast
init|=
name|findLast
argument_list|(
name|stream
operator|.
name|boxed
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|boxedLast
operator|.
name|isPresent
argument_list|()
condition|?
name|OptionalLong
operator|.
name|of
argument_list|(
name|boxedLast
operator|.
name|get
argument_list|()
argument_list|)
else|:
name|OptionalLong
operator|.
name|empty
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of the specified stream, or {@link OptionalDouble#empty} if the stream    * is empty.    *    *<p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This    * method's runtime will be between O(log n) and O(n), performing better on<a    * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>    * streams.    *    * @see DoubleStream#findFirst()    * @throws NullPointerException if the last element of the stream is null    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|findLast (DoubleStream stream)
specifier|public
specifier|static
name|OptionalDouble
name|findLast
parameter_list|(
name|DoubleStream
name|stream
parameter_list|)
block|{
comment|// findLast(Stream) does some allocation, so we might as well box some more
name|java
operator|.
name|util
operator|.
name|Optional
argument_list|<
name|Double
argument_list|>
name|boxedLast
init|=
name|findLast
argument_list|(
name|stream
operator|.
name|boxed
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|boxedLast
operator|.
name|isPresent
argument_list|()
condition|?
name|OptionalDouble
operator|.
name|of
argument_list|(
name|boxedLast
operator|.
name|get
argument_list|()
argument_list|)
else|:
name|OptionalDouble
operator|.
name|empty
argument_list|()
return|;
block|}
end_function

begin_constructor
DECL|method|Streams ()
specifier|private
name|Streams
parameter_list|()
block|{}
end_constructor

unit|}
end_unit

