begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Synchronized
operator|.
name|SynchronizedSortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link NavigableSet} instances.  *  * @author Louis Wasserman  * @see Sets  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
argument_list|(
name|value
operator|=
literal|"JDK 5 incompatibility"
argument_list|)
DECL|class|NavigableSets
specifier|final
class|class
name|NavigableSets
block|{
DECL|method|NavigableSets ()
specifier|private
name|NavigableSets
parameter_list|()
block|{}
comment|/**    * Returns an unmodifiable view of the specified navigable set. This method    * allows modules to provide users with "read-only" access to internal    * navigable sets. Query operations on the returned navigable set "read    * through" to the specified navigable set. Attempts to modify the returned    * navigable set, whether direct, via its iterator, or via its    * {@code descendingSet}, {@code subSet}, {@code headSet}, or    * {@code tailSet} views, result in an    * {@code UnsupportedOperationException}.    *    *<p>The returned navigable set will be serializable if the specified    * navigable set is serializable.    *    * @param navigableSet the navigable set for which an unmodifiable view is to    *        be returned.    * @return an unmodifiable view of the specified navigable set.    * @deprecated Use {@link Sets#unmodifiableNavigableSet}.    */
annotation|@
name|Deprecated
DECL|method|unmodifiableNavigableSet ( NavigableSet<E> navigableSet)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|unmodifiableNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|navigableSet
argument_list|)
return|;
block|}
DECL|class|UnmodifiableNavigableSet
specifier|private
specifier|static
class|class
name|UnmodifiableNavigableSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ForwardingSortedSet
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|navigableSet
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
decl_stmt|;
DECL|field|unmodifiableSortedSet
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unmodifiableSortedSet
decl_stmt|;
DECL|method|UnmodifiableNavigableSet (NavigableSet<E> navigableSet)
name|UnmodifiableNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
parameter_list|)
block|{
name|this
operator|.
name|navigableSet
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|navigableSet
argument_list|)
expr_stmt|;
name|this
operator|.
name|unmodifiableSortedSet
operator|=
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|navigableSet
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|SortedSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableSortedSet
return|;
block|}
DECL|method|ceiling (E e)
annotation|@
name|Override
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|navigableSet
operator|.
name|ceiling
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|descendingIterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|navigableSet
operator|.
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
DECL|field|descendingSet
specifier|private
specifier|transient
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
decl_stmt|;
DECL|method|descendingSet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
if|if
condition|(
name|descendingSet
operator|==
literal|null
condition|)
block|{
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|dS
init|=
name|unmodifiableNavigableSet
argument_list|(
name|navigableSet
operator|.
name|descendingSet
argument_list|()
argument_list|)
decl_stmt|;
name|descendingSet
operator|=
name|dS
expr_stmt|;
return|return
name|dS
return|;
block|}
return|return
name|descendingSet
return|;
block|}
DECL|method|floor (E e)
annotation|@
name|Override
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|navigableSet
operator|.
name|floor
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|headSet (E toElement, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|navigableSet
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|method|higher (E e)
annotation|@
name|Override
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|navigableSet
operator|.
name|higher
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|lower (E e)
annotation|@
name|Override
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|navigableSet
operator|.
name|lower
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|pollFirst ()
annotation|@
name|Override
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|pollLast ()
annotation|@
name|Override
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|subSet (E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|navigableSet
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|method|tailSet (E fromElement, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableSet
argument_list|(
name|navigableSet
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) navigable set backed by the specified    * navigable set.  In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing navigable set is accomplished    * through the returned navigable set (or its views).    *    *<p>It is imperative that the user manually synchronize on the returned    * sorted set when iterating over it or any of its {@code descendingSet},    * {@code subSet}, {@code headSet}, or {@code tailSet} views.<pre>   {@code    *    *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());    *    ...    *   synchronized (set) {    *     // Must be in the synchronized block    *     Iterator<E> it = set.iterator();    *     while (it.hasNext()){    *       foo(it.next());    *     }    *   }}</pre>    *    * or:<pre>   {@code    *    *   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());    *   NavigableSet<E> set2 = set.descendingSet().headSet(foo);    *    ...    *   synchronized (set) { // Note: set, not set2!!!    *     // Must be in the synchronized block    *     Iterator<E> it = set2.descendingIterator();    *     while (it.hasNext())    *       foo(it.next());    *     }    *   }}</pre>    *    * Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned navigable set will be serializable if the specified    * navigable set is serializable.    *    * @param navigableSet the navigable set to be "wrapped" in a synchronized    *    navigable set.    * @return a synchronized view of the specified navigable set.    * @deprecated Use {@link Sets#synchronizedNavigableSet}.    */
annotation|@
name|Deprecated
DECL|method|synchronizedNavigableSet ( NavigableSet<E> navigableSet)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|synchronizedNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
parameter_list|)
block|{
return|return
name|synchronizedNavigableSet
argument_list|(
name|navigableSet
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|synchronizedNavigableSet ( NavigableSet<E> navigableSet, @Nullable Object mutex)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|synchronizedNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|navigableSet
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
return|return
operator|new
name|SynchronizedNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|navigableSet
argument_list|,
name|mutex
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|class|SynchronizedNavigableSet
specifier|static
class|class
name|SynchronizedNavigableSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|SynchronizedSortedSet
argument_list|<
name|E
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|SynchronizedNavigableSet (NavigableSet<E> delegate, @Nullable Object mutex)
name|SynchronizedNavigableSet
parameter_list|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|E
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|ceiling (E e)
annotation|@
name|Override
specifier|public
name|E
name|ceiling
parameter_list|(
name|E
name|e
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|ceiling
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
DECL|method|descendingIterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|delegate
argument_list|()
operator|.
name|descendingIterator
argument_list|()
return|;
comment|// manually synchronized
block|}
DECL|field|descendingSet
specifier|transient
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
decl_stmt|;
DECL|method|descendingSet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|descendingSet
operator|==
literal|null
condition|)
block|{
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|dS
init|=
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|descendingSet
argument_list|()
argument_list|,
name|mutex
argument_list|)
decl_stmt|;
name|descendingSet
operator|=
name|dS
expr_stmt|;
return|return
name|dS
return|;
block|}
return|return
name|descendingSet
return|;
block|}
block|}
DECL|method|floor (E e)
annotation|@
name|Override
specifier|public
name|E
name|floor
parameter_list|(
name|E
name|e
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|floor
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
DECL|method|headSet (E toElement, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|higher (E e)
annotation|@
name|Override
specifier|public
name|E
name|higher
parameter_list|(
name|E
name|e
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|higher
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
DECL|method|lower (E e)
annotation|@
name|Override
specifier|public
name|E
name|lower
parameter_list|(
name|E
name|e
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|lower
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
DECL|method|pollFirst ()
annotation|@
name|Override
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|pollFirst
argument_list|()
return|;
block|}
block|}
DECL|method|pollLast ()
annotation|@
name|Override
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|pollLast
argument_list|()
return|;
block|}
block|}
DECL|method|subSet (E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|tailSet (E fromElement, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|headSet (E toElement)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|subSet (E fromElement, E toElement)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|tailSet (E fromElement)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
block|}
end_class

end_unit

