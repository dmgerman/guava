begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Ticker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|GenericMapMaker
operator|.
name|NullListener
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|RemovalCause
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|RemovalListener
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|RemovalNotification
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * The concurrent hash map implementation built by {@link MapMaker}.  *  *<p>This implementation is heavily derived from revision 1.96 of<a  * href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.  *  * @author Bob Lee  * @author Charles Fry  * @author Doug Lea ({@code ConcurrentHashMap})  */
end_comment

begin_class
DECL|class|CustomConcurrentHashMap
class|class
name|CustomConcurrentHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*    * The basic strategy is to subdivide the table among Segments, each of which itself is a    * concurrently readable hash table. The map supports non-blocking reads and concurrent writes    * across different segments.    *    * If a maximum size is specified, a best-effort bounding is performed per segment, using a    * page-replacement algorithm to determine which entries to evict when the capacity has been    * exceeded.    *    * The page replacement algorithm's data structures are kept casually consistent with the map. The    * ordering of writes to a segment is sequentially consistent. An update to the map and recording    * of reads may not be immediately reflected on the algorithm's data structures. These structures    * are guarded by a lock and operations are applied in batches to avoid lock contention. The    * penalty of applying the batches is spread across threads so that the amortized cost is slightly    * higher than performing just the operation without enforcing the capacity constraint.    *    * This implementation uses a per-segment queue to record a memento of the additions, removals,    * and accesses that were performed on the map. The queue is drained on writes and when it exceeds    * its capacity threshold.    *    * The Least Recently Used page replacement algorithm was chosen due to its simplicity, high hit    * rate, and ability to be implemented with O(1) time complexity. The initial LRU implementation    * operates per-segment rather than globally for increased implementation simplicity. We expect    * the cache hit rate to be similar to that of a global LRU algorithm.    */
comment|// Constants
comment|/**    * The maximum capacity, used if a higher value is implicitly specified by either of the    * constructors with arguments. MUST be a power of two<= 1<<30 to ensure that entries are    * indexable using ints.    */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
name|Ints
operator|.
name|MAX_POWER_OF_TWO
decl_stmt|;
comment|/** The maximum number of segments to allow; used to bound constructor arguments. */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/** Number of (unsynchronized) retries in the containsValue method. */
DECL|field|CONTAINS_VALUE_RETRIES
specifier|static
specifier|final
name|int
name|CONTAINS_VALUE_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Number of cache access operations that can be buffered per segment before the cache's recency    * ordering information is updated. This is used to avoid lock contention by recording a memento    * of reads and delaying a lock acquisition until the threshold is crossed or a mutation occurs.    *    *<p>This must be a (2^n)-1 as it is used as a mask.    */
DECL|field|DRAIN_THRESHOLD
specifier|static
specifier|final
name|int
name|DRAIN_THRESHOLD
init|=
literal|0x3F
decl_stmt|;
comment|/**    * Maximum number of entries to be drained in a single cleanup run. This applies independently to    * the cleanup queue and both reference queues.    */
comment|// TODO(fry): empirically optimize this
DECL|field|DRAIN_MAX
specifier|static
specifier|final
name|int
name|DRAIN_MAX
init|=
literal|16
decl_stmt|;
DECL|field|CLEANUP_EXECUTOR_DELAY_SECS
specifier|static
specifier|final
name|long
name|CLEANUP_EXECUTOR_DELAY_SECS
init|=
literal|60
decl_stmt|;
comment|// Fields
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CustomConcurrentHashMap
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose    * the segment.    */
DECL|field|segmentMask
specifier|final
specifier|transient
name|int
name|segmentMask
decl_stmt|;
comment|/**    * Shift value for indexing within segments. Helps prevent entries that end up in the same segment    * from also ending up in the same bucket.    */
DECL|field|segmentShift
specifier|final
specifier|transient
name|int
name|segmentShift
decl_stmt|;
comment|/** The segments, each of which is a specialized hash table. */
DECL|field|segments
specifier|final
specifier|transient
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/** The concurrency level. */
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|/** Strategy for comparing keys. */
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
comment|/** Strategy for comparing values. */
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
comment|/** Strategy for referencing keys. */
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
comment|/** Strategy for referencing values. */
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
comment|/** The maximum size of this map. MapMaker.UNSET_INT if there is no maximum. */
DECL|field|maximumSize
specifier|final
name|int
name|maximumSize
decl_stmt|;
comment|/** How long after the last access to an entry the map will retain that entry. */
DECL|field|expireAfterAccessNanos
specifier|final
name|long
name|expireAfterAccessNanos
decl_stmt|;
comment|/** How long after the last write to an entry the map will retain that entry. */
DECL|field|expireAfterWriteNanos
specifier|final
name|long
name|expireAfterWriteNanos
decl_stmt|;
comment|/** Entries waiting to be consumed by the removal listener. */
comment|// TODO(fry): define a new type which creates event objects and automates the clear logic
DECL|field|removalNotificationQueue
specifier|final
name|Queue
argument_list|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|removalNotificationQueue
decl_stmt|;
comment|/**    * A listener that is invoked when an entry is removed due to expiration or garbage collection of    * soft/weak entries.    */
DECL|field|removalListener
specifier|final
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
decl_stmt|;
comment|/** Factory used to create new entries. */
DECL|field|entryFactory
specifier|final
specifier|transient
name|EntryFactory
name|entryFactory
decl_stmt|;
comment|/** Measures time in a testable way. */
DECL|field|ticker
specifier|final
name|Ticker
name|ticker
decl_stmt|;
comment|/**    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.    */
DECL|method|CustomConcurrentHashMap (MapMaker builder)
name|CustomConcurrentHashMap
parameter_list|(
name|MapMaker
name|builder
parameter_list|)
block|{
name|concurrencyLevel
operator|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|,
name|MAX_SEGMENTS
argument_list|)
expr_stmt|;
name|keyStrength
operator|=
name|builder
operator|.
name|getKeyStrength
argument_list|()
expr_stmt|;
name|valueStrength
operator|=
name|builder
operator|.
name|getValueStrength
argument_list|()
expr_stmt|;
name|keyEquivalence
operator|=
name|builder
operator|.
name|getKeyEquivalence
argument_list|()
expr_stmt|;
name|valueEquivalence
operator|=
name|builder
operator|.
name|getValueEquivalence
argument_list|()
expr_stmt|;
name|maximumSize
operator|=
name|builder
operator|.
name|maximumSize
expr_stmt|;
name|expireAfterAccessNanos
operator|=
name|builder
operator|.
name|getExpireAfterAccessNanos
argument_list|()
expr_stmt|;
name|expireAfterWriteNanos
operator|=
name|builder
operator|.
name|getExpireAfterWriteNanos
argument_list|()
expr_stmt|;
name|entryFactory
operator|=
name|EntryFactory
operator|.
name|getFactory
argument_list|(
name|keyStrength
argument_list|,
name|expires
argument_list|()
argument_list|,
name|evictsBySize
argument_list|()
argument_list|)
expr_stmt|;
name|ticker
operator|=
name|builder
operator|.
name|getTicker
argument_list|()
expr_stmt|;
name|removalListener
operator|=
name|builder
operator|.
name|getRemovalListener
argument_list|()
expr_stmt|;
name|removalNotificationQueue
operator|=
operator|(
name|removalListener
operator|==
name|NullListener
operator|.
name|INSTANCE
operator|)
condition|?
name|CustomConcurrentHashMap
operator|.
expr|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
else|:
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|int
name|initialCapacity
init|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|getInitialCapacity
argument_list|()
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
decl_stmt|;
if|if
condition|(
name|evictsBySize
argument_list|()
condition|)
block|{
name|initialCapacity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|initialCapacity
argument_list|,
name|maximumSize
argument_list|)
expr_stmt|;
block|}
comment|// Find power-of-two sizes best matching arguments. Constraints:
comment|// (segmentCount<= maximumSize)
comment|//&& (concurrencyLevel> maximumSize || segmentCount> concurrencyLevel)
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
operator|&&
operator|(
operator|!
name|evictsBySize
argument_list|()
operator|||
name|segmentCount
operator|*
literal|2
operator|<=
name|maximumSize
operator|)
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|evictsBySize
argument_list|()
condition|)
block|{
comment|// Ensure sum of segment max sizes = overall max size
name|int
name|maximumSegmentSize
init|=
name|maximumSize
operator|/
name|segmentCount
operator|+
literal|1
decl_stmt|;
name|int
name|remainder
init|=
name|maximumSize
operator|%
name|segmentCount
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|remainder
condition|)
block|{
name|maximumSegmentSize
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|maximumSegmentSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
name|createSegment
argument_list|(
name|segmentSize
argument_list|,
name|MapMaker
operator|.
name|UNSET_INT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|evictsBySize ()
name|boolean
name|evictsBySize
parameter_list|()
block|{
return|return
name|maximumSize
operator|!=
name|MapMaker
operator|.
name|UNSET_INT
return|;
block|}
DECL|method|expires ()
name|boolean
name|expires
parameter_list|()
block|{
return|return
name|expiresAfterWrite
argument_list|()
operator|||
name|expiresAfterAccess
argument_list|()
return|;
block|}
DECL|method|expiresAfterWrite ()
name|boolean
name|expiresAfterWrite
parameter_list|()
block|{
return|return
name|expireAfterWriteNanos
operator|>
literal|0
return|;
block|}
DECL|method|expiresAfterAccess ()
name|boolean
name|expiresAfterAccess
parameter_list|()
block|{
return|return
name|expireAfterAccessNanos
operator|>
literal|0
return|;
block|}
DECL|method|usesKeyReferences ()
name|boolean
name|usesKeyReferences
parameter_list|()
block|{
return|return
name|keyStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|method|usesValueReferences ()
name|boolean
name|usesValueReferences
parameter_list|()
block|{
return|return
name|valueStrength
operator|!=
name|Strength
operator|.
name|STRONG
return|;
block|}
DECL|enum|Strength
enum|enum
name|Strength
block|{
comment|/*      * TODO(kevinb): If we strongly reference the value and aren't computing, we needn't wrap the      * value. This could save ~8 bytes per entry.      */
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|equals
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|valueReferenceQueue
argument_list|,
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|;
comment|/**      * Creates a reference for the given value according to this value strength.      */
DECL|method|referenceValue ( Segment<K, V> segment, ReferenceEntry<K, V> entry, V value)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Returns the default equivalence strategy used to compare and hash keys or values referenced      * at this strength. This strategy will be used unless the user explicitly specifies an      * alternate strategy.      */
DECL|method|defaultEquivalence ()
specifier|abstract
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
function_decl|;
block|}
comment|/**    * Creates new entries.    */
DECL|enum|EntryFactory
enum|enum
name|EntryFactory
block|{
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EXPIRABLE
name|STRONG_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EVICTABLE
name|STRONG_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EXPIRABLE_EVICTABLE
name|STRONG_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EXPIRABLE
name|SOFT_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EVICTABLE
name|SOFT_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EXPIRABLE_EVICTABLE
name|SOFT_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EXPIRABLE
name|WEAK_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EVICTABLE
name|WEAK_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EXPIRABLE_EVICTABLE
name|WEAK_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|segment
operator|.
name|keyReferenceQueue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|segment
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|;
comment|/**      * Masks used to compute indices in the following table.      */
DECL|field|EXPIRABLE_MASK
specifier|static
specifier|final
name|int
name|EXPIRABLE_MASK
init|=
literal|1
decl_stmt|;
DECL|field|EVICTABLE_MASK
specifier|static
specifier|final
name|int
name|EVICTABLE_MASK
init|=
literal|2
decl_stmt|;
comment|/**      * Look-up table for factories. First dimension is the reference type. The second dimension is      * the result of OR-ing the feature masks.      */
DECL|field|factories
specifier|static
specifier|final
name|EntryFactory
index|[]
index|[]
name|factories
init|=
block|{
block|{
name|STRONG
block|,
name|STRONG_EXPIRABLE
block|,
name|STRONG_EVICTABLE
block|,
name|STRONG_EXPIRABLE_EVICTABLE
block|}
block|,
block|{
name|SOFT
block|,
name|SOFT_EXPIRABLE
block|,
name|SOFT_EVICTABLE
block|,
name|SOFT_EXPIRABLE_EVICTABLE
block|}
block|,
block|{
name|WEAK
block|,
name|WEAK_EXPIRABLE
block|,
name|WEAK_EVICTABLE
block|,
name|WEAK_EXPIRABLE_EVICTABLE
block|}
block|}
decl_stmt|;
DECL|method|getFactory (Strength keyStrength, boolean expireAfterWrite, boolean evictsBySize)
specifier|static
name|EntryFactory
name|getFactory
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|boolean
name|expireAfterWrite
parameter_list|,
name|boolean
name|evictsBySize
parameter_list|)
block|{
name|int
name|flags
init|=
operator|(
name|expireAfterWrite
condition|?
name|EXPIRABLE_MASK
else|:
literal|0
operator|)
operator||
operator|(
name|evictsBySize
condition|?
name|EVICTABLE_MASK
else|:
literal|0
operator|)
decl_stmt|;
return|return
name|factories
index|[
name|keyStrength
operator|.
name|ordinal
argument_list|()
index|]
index|[
name|flags
index|]
return|;
block|}
comment|/**      * Creates a new entry.      *      * @param segment to create the entry for      * @param key of the entry      * @param hash of the key      * @param next entry in the same bucket      */
DECL|method|newEntry ( Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Copies an entry, assigning it a new {@code next} entry.      *      * @param original the entry to copy      * @param newNext entry in the same bucket      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyEntry ( Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|newEntry
argument_list|(
name|segment
argument_list|,
name|original
operator|.
name|getKey
argument_list|()
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyExpirableEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyExpirableEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
comment|// TODO(fry): when we link values instead of entries this method can go
comment|// away, as can connectExpirables, nullifyExpirable.
name|newEntry
operator|.
name|setExpirationTime
argument_list|(
name|original
operator|.
name|getExpirationTime
argument_list|()
argument_list|)
expr_stmt|;
name|connectExpirables
argument_list|(
name|original
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|connectExpirables
argument_list|(
name|newEntry
argument_list|,
name|original
operator|.
name|getNextExpirable
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyExpirable
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyEvictableEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyEvictableEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
comment|// TODO(fry): when we link values instead of entries this method can go
comment|// away, as can connectEvictables, nullifyEvictable.
name|connectEvictables
argument_list|(
name|original
operator|.
name|getPreviousEvictable
argument_list|()
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|connectEvictables
argument_list|(
name|newEntry
argument_list|,
name|original
operator|.
name|getNextEvictable
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyEvictable
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A reference to a value.    */
DECL|interface|ValueReference
interface|interface
name|ValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value. Does not block or throw exceptions.      */
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/**      * Waits for a value that may still be computing. Unlike get(), this method can block (in the      * case of FutureValueReference).      *      * @throws ExecutionException if the computing thread throws an exception      */
DECL|method|waitForValue ()
name|V
name|waitForValue
parameter_list|()
throws|throws
name|ExecutionException
function_decl|;
comment|/**      * Returns the entry associated with this value reference, or {@code null} if this value      * reference is independent of any entry.      */
DECL|method|getEntry ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
function_decl|;
comment|/**      * Creates a copy of this reference for the given entry.      */
DECL|method|copyFor (ReferenceQueue<V> queue, ReferenceEntry<K, V> entry)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/**      * Clears this reference object.      *      * @param newValue the new value reference which will replace this one; this is only used during      *     computation to immediately notify blocked threads of the new value      */
DECL|method|clear (@ullable ValueReference<K, V> newValue)
name|void
name|clear
parameter_list|(
annotation|@
name|Nullable
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
function_decl|;
comment|/**      * Returns {@code true} if the value type is a computing reference (regardless of whether or not      * computation has completed). This is necessary to distiguish between partially-collected      * entries and computing entries, which need to be cleaned up differently.      */
DECL|method|isComputingReference ()
name|boolean
name|isComputingReference
parameter_list|()
function_decl|;
block|}
comment|/**    * Placeholder. Indicates that the value hasn't been set yet.    */
DECL|field|UNSET
specifier|static
specifier|final
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|UNSET
init|=
operator|new
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
name|queue
parameter_list|,
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|waitForValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newValue
parameter_list|)
block|{}
block|}
decl_stmt|;
comment|/**    * Singleton placeholder that indicates a value is being computed.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|unset ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unset
parameter_list|()
block|{
return|return
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|UNSET
return|;
block|}
comment|/**    * An entry in a reference map.    *    * Entries in the map can be in the following states:    *    * Valid:    * - Live: valid key/value are set    * - Computing: computation is pending    *    * Invalid:    * - Expired: time expired (key/value may still be set)    * - Collected: key/value was partially collected, but not yet cleaned up    */
DECL|interface|ReferenceEntry
interface|interface
name|ReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value reference from this entry.      */
DECL|method|getValueReference ()
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Sets the value reference for this entry.      */
DECL|method|setValueReference (ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
function_decl|;
comment|/**      * Gets the next entry in the chain.      */
DECL|method|getNext ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
function_decl|;
comment|/**      * Gets the entry's hash.      */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/**      * Gets the key for this entry.      */
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
function_decl|;
comment|/*      * Used by entries that are expirable. Expirable entries are maintained in a doubly-linked list.      * New entries are added at the tail of the list at write time; stale entries are expired from      * the head of the list.      */
comment|/**      * Gets the entry expiration time in ns.      */
DECL|method|getExpirationTime ()
name|long
name|getExpirationTime
parameter_list|()
function_decl|;
comment|/**      * Sets the entry expiration time in ns.      */
DECL|method|setExpirationTime (long time)
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
function_decl|;
comment|/**      * Gets the next entry in the recency list.      */
DECL|method|getNextExpirable ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
function_decl|;
comment|/**      * Sets the next entry in the recency list.      */
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Gets the previous entry in the recency list.      */
DECL|method|getPreviousExpirable ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
function_decl|;
comment|/**      * Sets the previous entry in the recency list.      */
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
function_decl|;
comment|/*      * Implemented by entries that are evictable. Evictable entries are maintained in a      * doubly-linked list. New entries are added at the tail of the list at write time and stale      * entries are expired from the head of the list.      */
comment|/**      * Gets the next entry in the recency list.      */
DECL|method|getNextEvictable ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
function_decl|;
comment|/**      * Sets the next entry in the recency list.      */
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Gets the previous entry in the recency list.      */
DECL|method|getPreviousEvictable ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
function_decl|;
comment|/**      * Sets the previous entry in the recency list.      */
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
function_decl|;
block|}
DECL|enum|NullEntry
specifier|private
enum|enum
name|NullEntry
implements|implements
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<Object, Object> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|valueReference
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|Object
name|getKey
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<Object, Object> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|next
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<Object, Object> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|previous
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<Object, Object> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|next
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<Object, Object> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|previous
parameter_list|)
block|{}
block|}
DECL|class|AbstractReferenceEntry
specifier|static
specifier|abstract
class|class
name|AbstractReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|nullEntry ()
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
parameter_list|()
block|{
return|return
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
DECL|field|DISCARDING_QUEUE
specifier|static
specifier|final
name|Queue
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|DISCARDING_QUEUE
init|=
operator|new
name|AbstractQueue
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|offer
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|peek
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|poll
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|emptyIterator
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Queue that discards all elements.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// impl never uses a parameter or returns any non-null value
DECL|method|discardingQueue ()
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Queue
argument_list|<
name|E
argument_list|>
name|discardingQueue
parameter_list|()
block|{
return|return
operator|(
name|Queue
operator|)
name|DISCARDING_QUEUE
return|;
block|}
comment|/*    * Note: All of this duplicate code sucks, but it saves a lot of memory. If only Java had mixins!    * To maintain this code, make a change for the strong reference type. Then, cut and paste, and    * replace "Strong" with "Soft" or "Weak" within the pasted text. The primary difference is that    * strong entries store the key reference directly while soft and weak entries delegate to their    * respective superclasses.    */
comment|/**    * Used for strongly-referenced keys.    */
DECL|class|StrongEntry
specifier|static
class|class
name|StrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|method|StrongEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|// null expiration
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// null eviction
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|StrongExpirableEntry
specifier|static
specifier|final
class|class
name|StrongExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongExpirableEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongExpirableEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|StrongEvictableEntry
specifier|static
specifier|final
class|class
name|StrongEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongEvictableEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongEvictableEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|StrongExpirableEvictableEntry
specifier|static
specifier|final
class|class
name|StrongExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|StrongExpirableEvictableEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|StrongExpirableEvictableEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/**    * Used for softly-referenced keys.    */
DECL|class|SoftEntry
specifier|static
class|class
name|SoftEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftEntry (ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|SoftEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
comment|// null expiration
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// null eviction
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|SoftExpirableEntry
specifier|static
specifier|final
class|class
name|SoftExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftExpirableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|SoftExpirableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|SoftEvictableEntry
specifier|static
specifier|final
class|class
name|SoftEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftEvictableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|SoftEvictableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|SoftExpirableEvictableEntry
specifier|static
specifier|final
class|class
name|SoftExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftExpirableEvictableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|SoftExpirableEvictableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/**    * Used for weakly-referenced keys.    */
DECL|class|WeakEntry
specifier|static
class|class
name|WeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEntry (ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
comment|// null expiration
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// null eviction
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
annotation|@
name|Override
DECL|method|setValueReference (ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|this
operator|.
name|valueReference
decl_stmt|;
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
name|previous
operator|.
name|clear
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|WeakExpirableEntry
specifier|static
specifier|final
class|class
name|WeakExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakExpirableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakExpirableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|WeakEvictableEntry
specifier|static
specifier|final
class|class
name|WeakEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEvictableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakEvictableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|WeakExpirableEvictableEntry
specifier|static
specifier|final
class|class
name|WeakExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakExpirableEvictableEntry ( ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|WeakExpirableEvictableEntry
parameter_list|(
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|queue
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|time
specifier|volatile
name|long
name|time
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|time
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long time)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousExpirable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|nextEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setNextEvictable (ReferenceEntry<K, V> next)
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previousEvictable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|nullEntry
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPreviousEvictable ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousEvictable (ReferenceEntry<K, V> previous)
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/**    * References a weak value.    */
DECL|class|WeakValueReference
specifier|static
specifier|final
class|class
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|WeakValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry)
name|WeakValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|clear (ValueReference<K, V> newValue)
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyFor ( ReferenceQueue<V> queue, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isComputingReference ()
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * References a soft value.    */
DECL|class|SoftValueReference
specifier|static
specifier|final
class|class
name|SoftValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|SoftValueReference (ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry)
name|SoftValueReference
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
DECL|method|clear (ValueReference<K, V> newValue)
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyFor (ReferenceQueue<V> queue, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|queue
argument_list|,
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isComputingReference ()
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * References a strong value.    */
DECL|class|StrongValueReference
specifier|static
specifier|final
class|class
name|StrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|referent
specifier|final
name|V
name|referent
decl_stmt|;
DECL|method|StrongValueReference (V referent)
name|StrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|)
block|{
name|this
operator|.
name|referent
operator|=
name|referent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|referent
return|;
block|}
annotation|@
name|Override
DECL|method|getEntry ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|copyFor (ReferenceQueue<V> queue, ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|queue
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|isComputingReference ()
specifier|public
name|boolean
name|isComputingReference
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear (ValueReference<K, V> newValue)
specifier|public
name|void
name|clear
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValue
parameter_list|)
block|{}
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends against poor quality    * hash functions. This is critical when the concurrent hash map uses power-of-two length hash    * tables, that otherwise encounter collisions for hash codes that do not differ in lower or    * upper bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
comment|// TODO(kevinb): use Hashing/move this to Hashing?
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|int
name|hash
init|=
name|original
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|copyEntry
argument_list|(
name|original
argument_list|,
name|newNext
argument_list|)
return|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#setValue} instead.    */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|newValueReference (ReferenceEntry<K, V> entry, V value)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|segmentFor
argument_list|(
name|hash
argument_list|)
argument_list|,
name|entry
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|hash (Object key)
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|keyEquivalence
operator|.
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|method|reclaimValue (ValueReference<K, V> valueReference)
name|void
name|reclaimValue
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|valueReference
operator|.
name|getEntry
argument_list|()
decl_stmt|;
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|valueReference
argument_list|)
expr_stmt|;
block|}
DECL|method|reclaimKey (ReferenceEntry<K, V> entry)
name|void
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method is a convenience for testing. Code should call {@link Segment#getLiveValue}    * instead.    */
annotation|@
name|VisibleForTesting
DECL|method|isLive (ReferenceEntry<K, V> entry)
name|boolean
name|isLive
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|segmentFor
argument_list|(
name|entry
operator|.
name|getHash
argument_list|()
argument_list|)
operator|.
name|getLiveValue
argument_list|(
name|entry
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the segment that should be used for a key with the given hash.    *    * @param hash the hash code for the key    * @return the segment    */
DECL|method|segmentFor (int hash)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// TODO(fry): Lazily create segments?
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
DECL|method|createSegment (int initialCapacity, int maxSegmentSize)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|createSegment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
return|return
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|initialCapacity
argument_list|,
name|maxSegmentSize
argument_list|)
return|;
block|}
comment|/**    * Gets the value from an entry. Returns {@code null} if the entry is invalid,    * partially-collected, computing, or expired. Unlike {@link Segment#getLiveValue} this method    * does not attempt to clean up stale entries.    */
DECL|method|getLiveValue (ReferenceEntry<K, V> entry)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|expires
argument_list|()
operator|&&
name|isExpired
argument_list|(
name|entry
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|// expiration
comment|/**    * Returns {@code true} if the entry has expired.    */
DECL|method|isExpired (ReferenceEntry<K, V> entry)
name|boolean
name|isExpired
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|isExpired
argument_list|(
name|entry
argument_list|,
name|ticker
operator|.
name|read
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if the entry has expired.    */
DECL|method|isExpired (ReferenceEntry<K, V> entry, long now)
name|boolean
name|isExpired
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
comment|// if the expiration time had overflowed, this "undoes" the overflow
return|return
name|now
operator|-
name|entry
operator|.
name|getExpirationTime
argument_list|()
operator|>
literal|0
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|connectExpirables (ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|connectExpirables
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|previous
operator|.
name|setNextExpirable
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPreviousExpirable
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|nullifyExpirable (ReferenceEntry<K, V> nulled)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|nullifyExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nulled
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
init|=
name|nullEntry
argument_list|()
decl_stmt|;
name|nulled
operator|.
name|setNextExpirable
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
name|nulled
operator|.
name|setPreviousExpirable
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
block|}
comment|// eviction
comment|/**    * Notifies listeners that an entry has been automatically removed due to expiration, eviction,    * or eligibility for garbage collection. This should be called every time expireEntries or    * evictEntry is called (once the lock is released).    */
DECL|method|processPendingNotifications ()
name|void
name|processPendingNotifications
parameter_list|()
block|{
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
decl_stmt|;
while|while
condition|(
operator|(
name|notification
operator|=
name|removalNotificationQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|removalListener
operator|.
name|onRemoval
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Exception thrown by removal listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Links the evitables together. */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|connectEvictables (ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|connectEvictables
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|previous
operator|.
name|setNextEvictable
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPreviousEvictable
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|nullifyEvictable (ReferenceEntry<K, V> nulled)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|nullifyEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nulled
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullEntry
init|=
name|nullEntry
argument_list|()
decl_stmt|;
name|nulled
operator|.
name|setNextEvictable
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
name|nulled
operator|.
name|setPreviousEvictable
argument_list|(
name|nullEntry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
return|return
operator|new
name|Segment
index|[
name|ssize
index|]
return|;
block|}
comment|// Inner Classes
comment|/**    * Segments are specialized versions of hash tables. This subclass inherits from ReentrantLock    * opportunistically, just to simplify some locking and avoid separate construction.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ReentrantLock
block|{
comment|/*      * TODO(fry): Consider copying variables (like evictsBySize) from outer class into this class.      * It will require more memory but will reduce indirection.      */
comment|/*      * Segments maintain a table of entry lists that are ALWAYS kept in a consistent state, so can      * be read without locking. Next fields of nodes are immutable (final). All list additions are      * performed at the front of each bin. This makes it easy to check changes, and also fast to      * traverse. When nodes would otherwise be changed, new nodes are created to replace them. This      * works well for hash tables since the bin lists tend to be short. (The average length is less      * than two.)      *      * Read operations can thus proceed without locking, but rely on selected uses of volatiles to      * ensure that completed write operations performed by other threads are noticed. For most      * purposes, the "count" field, tracking the number of elements, serves as that volatile      * variable ensuring visibility. This is convenient because this field needs to be read in many      * read operations anyway:      *      * - All (unsynchronized) read operations must first read the "count" field, and should not      * look at table entries if it is 0.      *      * - All (synchronized) write operations should write to the "count" field after structurally      * changing any bin. The operations must not take any action that could even momentarily      * cause a concurrent read operation to see inconsistent data. This is made easier by the      * nature of the read operations in Map. For example, no operation can reveal that the table      * has grown but the threshold has not yet been updated, so there are no atomicity requirements      * for this with respect to reads.      *      * As a guide, all critical volatile reads and writes to the count field are marked in code      * comments.      */
DECL|field|map
specifier|final
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
comment|/**      * The number of live elements in this segment's region. This does not include unset elements      * which are awaiting cleanup.      */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**      * Number of updates that alter the size of the table. This is used during bulk-read methods to      * make sure they see a consistent snapshot: If modCounts change during a traversal of segments      * computing size or checking containsValue, then we might have an inconsistent view of state      * so (usually) must retry.      */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**      * The table is expanded when its size exceeds this threshold. (The value of this field is      * always {@code (int)(capacity * 0.75)}.)      */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**      * The per-segment table.      */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
decl_stmt|;
comment|/**      * The maximum size of this map. MapMaker.UNSET_INT if there is no maximum.      */
DECL|field|maxSegmentSize
specifier|final
name|int
name|maxSegmentSize
decl_stmt|;
comment|/**      * The key reference queue contains entries whose keys have been garbage collected, and which      * need to be cleaned up internally.      */
DECL|field|keyReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
name|keyReferenceQueue
decl_stmt|;
comment|/**      * The value reference queue contains value references whose values have been garbage collected,      * and which need to be cleaned up internally.      */
DECL|field|valueReferenceQueue
specifier|final
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
name|valueReferenceQueue
decl_stmt|;
comment|/**      * The recency queue is used to record which entries were accessed for updating the eviction      * list's ordering. It is drained as a batch operation when either the DRAIN_THRESHOLD is      * crossed or a write occurs on the segment.      */
DECL|field|recencyQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|recencyQueue
decl_stmt|;
comment|/**      * A counter of the number of reads since the last write, used to drain queues on a small      * fraction of read operations.      */
DECL|field|readCount
specifier|final
name|AtomicInteger
name|readCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * A queue of elements currently in the map, ordered by access time. Elements are added to the      * tail of the queue on access/write.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|evictionQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|evictionQueue
decl_stmt|;
comment|/**      * A queue of elements currently in the map, ordered by expiration time (either access or write      * time). Elements are added to the tail of the queue on access/write.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|expirationQueue
specifier|final
name|Queue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|expirationQueue
decl_stmt|;
DECL|method|Segment (CustomConcurrentHashMap<K, V> map, int initialCapacity, int maxSegmentSize)
name|Segment
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|maxSegmentSize
operator|=
name|maxSegmentSize
expr_stmt|;
name|initTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
name|keyReferenceQueue
operator|=
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|K
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
name|valueReferenceQueue
operator|=
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|?
operator|new
name|ReferenceQueue
argument_list|<
name|V
argument_list|>
argument_list|()
else|:
literal|null
expr_stmt|;
name|recencyQueue
operator|=
operator|(
name|map
operator|.
name|evictsBySize
argument_list|()
operator|||
name|map
operator|.
name|expiresAfterAccess
argument_list|()
operator|)
condition|?
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
else|:
name|CustomConcurrentHashMap
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
name|evictionQueue
operator|=
name|map
operator|.
name|evictsBySize
argument_list|()
condition|?
operator|new
name|EvictionQueue
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
else|:
name|CustomConcurrentHashMap
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
name|expirationQueue
operator|=
name|map
operator|.
name|expires
argument_list|()
condition|?
operator|new
name|ExpirationQueue
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
else|:
name|CustomConcurrentHashMap
operator|.
expr|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|discardingQueue
argument_list|()
expr_stmt|;
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
DECL|method|initTable (AtomicReferenceArray<ReferenceEntry<K, V>> newTable)
name|void
name|initTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
comment|// 0.75
if|if
condition|(
name|this
operator|.
name|threshold
operator|==
name|maxSegmentSize
condition|)
block|{
comment|// prevent spurious expansion before eviction
name|this
operator|.
name|threshold
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|newEntry (K key, int hash, @Nullable ReferenceEntry<K, V> next)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|map
operator|.
name|entryFactory
operator|.
name|newEntry
argument_list|(
name|this
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyEntry (ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|original
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|map
operator|.
name|entryFactory
operator|.
name|copyEntry
argument_list|(
name|this
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|copyFor
argument_list|(
name|this
operator|.
name|valueReferenceQueue
argument_list|,
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
comment|/**      * Sets a new value of an entry. Adds newly created entries at the end of the expiration queue.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|setValue (ReferenceEntry<K, V> entry, V value)
name|void
name|setValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|map
operator|.
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|this
argument_list|,
name|entry
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setValueReference
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
name|recordWrite
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|// reference queues, for garbage collection cleanup
comment|/**      * Cleanup collected entries when the lock is available.      */
DECL|method|tryDrainReferenceQueues ()
name|void
name|tryDrainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Drain the key and value reference queues, cleaning up internal entries containing garbage      * collected keys or values.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|drainReferenceQueues ()
name|void
name|drainReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|drainKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|drainValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|drainKeyReferenceQueue ()
name|void
name|drainKeyReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimKey
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|drainValueReferenceQueue ()
name|void
name|drainValueReferenceQueue
parameter_list|()
block|{
name|Reference
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|ref
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|ref
operator|=
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ref
decl_stmt|;
name|map
operator|.
name|reclaimValue
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|DRAIN_MAX
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/**      * Clears all entries from the key and value reference queues.      */
DECL|method|clearReferenceQueues ()
name|void
name|clearReferenceQueues
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|usesKeyReferences
argument_list|()
condition|)
block|{
name|clearKeyReferenceQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|usesValueReferences
argument_list|()
condition|)
block|{
name|clearValueReferenceQueue
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clearKeyReferenceQueue ()
name|void
name|clearKeyReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|keyReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
DECL|method|clearValueReferenceQueue ()
name|void
name|clearValueReferenceQueue
parameter_list|()
block|{
while|while
condition|(
name|valueReferenceQueue
operator|.
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{}
block|}
comment|// recency queue, shared by expiration and eviction
comment|/**      * Records the relative order in which this read was performed by adding {@code entry} to the      * recency queue. At write-time, or when the queue is full past the threshold, the queue will      * be drained and the entries therein processed.      *      *<p>Note: locked reads should use {@link #recordLockedRead}.      */
DECL|method|recordRead (ReferenceEntry<K, V> entry)
name|void
name|recordRead
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|expiresAfterAccess
argument_list|()
condition|)
block|{
name|recordExpirationTime
argument_list|(
name|entry
argument_list|,
name|map
operator|.
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
block|}
name|recencyQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Updates the eviction metadata that {@code entry} was just read. This currently amounts to      * adding {@code entry} to relevant eviction lists.      *      *<p>Note: this method should only be called under lock, as it directly manipulates the      * eviction queues. Unlocked reads should use {@link #recordRead}.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|recordLockedRead (ReferenceEntry<K, V> entry)
name|void
name|recordLockedRead
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|evictionQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|.
name|expiresAfterAccess
argument_list|()
condition|)
block|{
name|recordExpirationTime
argument_list|(
name|entry
argument_list|,
name|map
operator|.
name|expireAfterAccessNanos
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Updates eviction metadata that {@code entry} was just written. This currently amounts to      * adding {@code entry} to relevant eviction lists.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|recordWrite (ReferenceEntry<K, V> entry)
name|void
name|recordWrite
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
comment|// we are already under lock, so drain the recency queue immediately
name|drainRecencyQueue
argument_list|()
expr_stmt|;
name|evictionQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|.
name|expires
argument_list|()
condition|)
block|{
comment|// currently MapMaker ensures that expireAfterWrite and
comment|// expireAfterAccess are mutually exclusive
name|long
name|expiration
init|=
name|map
operator|.
name|expiresAfterAccess
argument_list|()
condition|?
name|map
operator|.
name|expireAfterAccessNanos
else|:
name|map
operator|.
name|expireAfterWriteNanos
decl_stmt|;
name|recordExpirationTime
argument_list|(
name|entry
argument_list|,
name|expiration
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Drains the recency queue, updating eviction metadata that the entries therein were read in      * the specified relative order. This currently amounts to adding them to relevant eviction      * lists (accounting for the fact that they could have been removed from the map since being      * added to the recency queue).      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|drainRecencyQueue ()
name|void
name|drainRecencyQueue
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|recencyQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// An entry may be in the recency queue despite it being removed from
comment|// the map . This can occur when the entry was concurrently read while a
comment|// writer is removing it from the segment or after a clear has removed
comment|// all of the segment's entries.
if|if
condition|(
name|evictionQueue
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|evictionQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|.
name|expiresAfterAccess
argument_list|()
operator|&&
name|expirationQueue
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|expirationQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// expiration
DECL|method|recordExpirationTime (ReferenceEntry<K, V> entry, long expirationNanos)
name|void
name|recordExpirationTime
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|expirationNanos
parameter_list|)
block|{
comment|// might overflow, but that's okay (see isExpired())
name|entry
operator|.
name|setExpirationTime
argument_list|(
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
operator|+
name|expirationNanos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Cleanup expired entries when the lock is available.      */
DECL|method|tryExpireEntries ()
name|void
name|tryExpireEntries
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
comment|// don't call postWriteCleanup as we're in a read
block|}
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|expireEntries ()
name|void
name|expireEntries
parameter_list|()
block|{
name|drainRecencyQueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|expirationQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// There's no point in calling nanoTime() if we have no entries to
comment|// expire.
return|return;
block|}
name|long
name|now
init|=
name|map
operator|.
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|expirationQueue
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|,
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|removeEntry
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getHash
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|EXPIRED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
comment|// eviction
DECL|method|enqueueNotification (ReferenceEntry<K, V> entry, RemovalCause cause)
name|void
name|enqueueNotification
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|enqueueNotification
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getHash
argument_list|()
argument_list|,
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
DECL|method|enqueueNotification (@ullable K key, int hash, @Nullable V value, RemovalCause cause)
name|void
name|enqueueNotification
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|removalNotificationQueue
operator|!=
name|DISCARDING_QUEUE
condition|)
block|{
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|notification
init|=
operator|new
name|RemovalNotification
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|cause
argument_list|)
decl_stmt|;
name|map
operator|.
name|removalNotificationQueue
operator|.
name|offer
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Performs eviction if the segment is full. This should only be called prior to adding a new      * entry and increasing {@code count}.      *      * @return {@code true} if eviction occurred      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|evictEntries ()
name|boolean
name|evictEntries
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|evictsBySize
argument_list|()
operator|&&
name|count
operator|>=
name|maxSegmentSize
condition|)
block|{
name|drainRecencyQueue
argument_list|()
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|evictionQueue
operator|.
name|remove
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|removeEntry
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getHash
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|SIZE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns first entry of bin for given hash.      */
DECL|method|getFirst (int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// read this volatile field only once
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|// Specialized implementations of map methods
DECL|method|getEntry (Object key, int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getLiveEntry (Object key, int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getLiveEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|map
operator|.
name|expires
argument_list|()
operator|&&
name|map
operator|.
name|isExpired
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|tryExpireEntries
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|e
return|;
block|}
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|recordRead
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method is a convenience for testing. Code should call {@link      * CustomConcurrentHashMap#containsValue} directly.      */
annotation|@
name|VisibleForTesting
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|entryValue
init|=
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valueReference
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
expr_stmt|;
comment|// count remains unchanged
block|}
elseif|else
if|if
condition|(
name|evictEntries
argument_list|()
condition|)
block|{
comment|// evictEntries after setting new value
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|onlyIfAbsent
condition|)
block|{
comment|// Mimic
comment|// "if (!map.containsKey(key)) ...
comment|// else return map.get(key);
name|recordLockedRead
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
else|else
block|{
comment|// clobber existing entry, count remains unchanged
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|evictEntries
argument_list|()
condition|)
block|{
comment|// evictEntries after setting new value
name|newCount
operator|=
name|this
operator|.
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Expands the table if possible.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*        * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the        * elements from each bin must either stay at same index, or move with a power of two offset.        * We eliminate unnecessary node creation by catching cases where old nodes can be reused        * because their next fields won't change. Statistically, at the default threshold, only        * about one-sixth of them need cloning when a table doubles. The nodes they replace will be        * garbage collectable as soon as they are no longer referenced by any reader thread that may        * be in the midst of traversing table right now.        */
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
operator|++
name|oldIndex
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|int
name|headIndex
init|=
name|head
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|next
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|removeCollectedEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|newCount
operator|--
expr_stmt|;
block|}
else|else
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|oldValue
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Mimic
comment|// "if (map.containsKey(key)&& map.get(key).equals(oldValue))..."
name|recordLockedRead
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
block|}
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|RemovalCause
name|cause
decl_stmt|;
if|if
condition|(
name|entryValue
operator|!=
literal|null
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|EXPLICIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|COLLECTED
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preWriteCleanup
argument_list|()
expr_stmt|;
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|V
name|entryValue
init|=
name|valueReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|RemovalCause
name|cause
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|entryValue
argument_list|)
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|EXPLICIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCollected
argument_list|(
name|valueReference
argument_list|)
condition|)
block|{
name|cause
operator|=
name|RemovalCause
operator|.
name|COLLECTED
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|entryKey
argument_list|,
name|hash
argument_list|,
name|entryValue
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
operator|(
name|cause
operator|==
name|RemovalCause
operator|.
name|EXPLICIT
operator|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|removalNotificationQueue
operator|!=
name|DISCARDING_QUEUE
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
comment|// Computing references aren't actually in the map yet.
if|if
condition|(
operator|!
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
name|enqueueNotification
argument_list|(
name|e
argument_list|,
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|clearReferenceQueues
argument_list|()
expr_stmt|;
name|evictionQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expirationQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes an entry from within a table. All entries following the removed node can stay, but      * all preceding ones need to be cloned.      *      *<p>This method does not decrement count for the removed entry, but does decrement count for      * all partially collected entries which are skipped. As such callers which are modifying count      * must re-read it after calling removeFromChain.      *      * @param first the first entry of the table      * @param entry the entry being removed from the table      * @return the new first entry for the table      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|removeFromChain (ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeFromChain
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|evictionQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|int
name|newCount
init|=
name|count
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|entry
operator|.
name|getNext
argument_list|()
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
name|entry
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|isCollected
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|removeCollectedEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|newCount
operator|--
expr_stmt|;
block|}
else|else
block|{
name|newFirst
operator|=
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
return|return
name|newFirst
return|;
block|}
DECL|method|removeCollectedEntry (ReferenceEntry<K, V> entry)
name|void
name|removeCollectedEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|enqueueNotification
argument_list|(
name|entry
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|evictionQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes an entry whose key has been garbage collected.      */
DECL|method|reclaimKey (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|reclaimKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Removes an entry whose value has been garbage collected.      */
DECL|method|reclaimValue (K key, int hash, ValueReference<K, V> valueReference)
name|boolean
name|reclaimValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueReference
operator|.
name|get
argument_list|()
argument_list|,
name|RemovalCause
operator|.
name|COLLECTED
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isHeldByCurrentThread
argument_list|()
condition|)
block|{
comment|// don't cleanup inside of put
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Clears a value that has not yet been set, and thus does not require count to be modified.      */
DECL|method|clearValue (K key, int hash, ValueReference<K, V> valueReference)
name|boolean
name|clearValue
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|map
operator|.
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
init|=
name|e
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|valueReference
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
name|postWriteCleanup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|removeEntry (ReferenceEntry<K, V> entry, int hash, RemovalCause cause)
name|boolean
name|removeEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|enqueueNotification
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hash
argument_list|,
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromChain
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|newCount
operator|=
name|this
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns {@code true} if the entry has been partially collected, meaning that either the key      * is null, or the value is null and it is not computing.      */
DECL|method|isCollected (ReferenceEntry<K, V> entry)
name|boolean
name|isCollected
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|isCollected
argument_list|(
name|entry
operator|.
name|getValueReference
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if the value has been partially collected, meaning that the value is      * null and it is not computing.      */
DECL|method|isCollected (ValueReference<K, V> valueReference)
name|boolean
name|isCollected
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
if|if
condition|(
name|valueReference
operator|.
name|isComputingReference
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|valueReference
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|)
return|;
block|}
comment|/**      * Gets the value from an entry. Returns {@code null} if the entry is invalid,      * partially-collected, computing, or expired.      */
DECL|method|getLiveValue (ReferenceEntry<K, V> entry)
name|V
name|getLiveValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|tryDrainReferenceQueues
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|map
operator|.
name|expires
argument_list|()
operator|&&
name|map
operator|.
name|isExpired
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|tryExpireEntries
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs routine cleanup following a read. Normally cleanup happens during writes, or from      * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try      * cleaning up from the read thread.      */
DECL|method|postReadCleanup ()
name|void
name|postReadCleanup
parameter_list|()
block|{
if|if
condition|(
operator|(
name|readCount
operator|.
name|incrementAndGet
argument_list|()
operator|&
name|DRAIN_THRESHOLD
operator|)
operator|==
literal|0
condition|)
block|{
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs routine cleanup prior to executing a write. This should be called every time a      * write thread acquires the segment lock, immediately after acquiring the lock.      *      *<p>Post-condition: expireEntries has been run.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|preWriteCleanup ()
name|void
name|preWriteCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs routine cleanup following a write.      */
DECL|method|postWriteCleanup ()
name|void
name|postWriteCleanup
parameter_list|()
block|{
name|runUnlockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runCleanup ()
name|void
name|runCleanup
parameter_list|()
block|{
name|runLockedCleanup
argument_list|()
expr_stmt|;
name|runUnlockedCleanup
argument_list|()
expr_stmt|;
block|}
DECL|method|runLockedCleanup ()
name|void
name|runLockedCleanup
parameter_list|()
block|{
if|if
condition|(
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainReferenceQueues
argument_list|()
expr_stmt|;
name|expireEntries
argument_list|()
expr_stmt|;
comment|// calls drainRecencyQueue
name|readCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|runUnlockedCleanup ()
name|void
name|runUnlockedCleanup
parameter_list|()
block|{
comment|// locked cleanup may generate notifications we can send unlocked
if|if
condition|(
operator|!
name|isHeldByCurrentThread
argument_list|()
condition|)
block|{
name|map
operator|.
name|processPendingNotifications
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Queues
comment|/**    * A custom queue for managing eviction order. Note that this is tightly integrated with {@code    * ReferenceEntry}, upon which it relies to perform its linking.    *    *<p>Note that this entire implementation makes the assumption that all elements which are in    * the map are also in this queue, and that all elements not in the queue are not in the map.    *    *<p>The benefits of creating our own queue are that (1) we can replace elements in the middle    * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized    * for the current model.    */
DECL|class|EvictionQueue
specifier|static
specifier|final
class|class
name|EvictionQueue
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|head
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
operator|new
name|AbstractReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEvictable
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextEvictable
parameter_list|()
block|{
return|return
name|nextEvictable
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextEvictable
operator|=
name|next
expr_stmt|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousEvictable
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousEvictable
parameter_list|()
block|{
return|return
name|previousEvictable
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPreviousEvictable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousEvictable
operator|=
name|previous
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// implements Queue
annotation|@
name|Override
DECL|method|offer (ReferenceEntry<K, V> entry)
specifier|public
name|boolean
name|offer
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
comment|// unlink
name|connectEvictables
argument_list|(
name|entry
operator|.
name|getPreviousEvictable
argument_list|()
argument_list|,
name|entry
operator|.
name|getNextEvictable
argument_list|()
argument_list|)
expr_stmt|;
comment|// add to tail
name|connectEvictables
argument_list|(
name|head
operator|.
name|getPreviousEvictable
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|connectEvictables
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|peek
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
annotation|@
name|Override
DECL|method|poll ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|poll
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|head
condition|)
block|{
return|return
literal|null
return|;
block|}
name|remove
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|e
operator|.
name|getPreviousEvictable
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
name|connectEvictables
argument_list|(
name|previous
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nullifyEvictable
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
return|return
name|e
operator|.
name|getNextEvictable
argument_list|()
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|head
operator|.
name|getNextEvictable
argument_list|()
operator|==
name|head
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextEvictable
argument_list|()
init|;
name|e
operator|!=
name|head
condition|;
name|e
operator|=
name|e
operator|.
name|getNextEvictable
argument_list|()
control|)
block|{
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|head
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
name|nullifyEvictable
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|.
name|setNextEvictable
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|.
name|setPreviousEvictable
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractLinkedIterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|peek
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|computeNext
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|previous
operator|.
name|getNextEvictable
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * A custom queue for managing expiration order. Note that this is tightly integrated with    * {@code ReferenceEntry}, upon which it reliese to perform its linking.    *    *<p>Note that this entire implementation makes the assumption that all elements which are in    * the map are also in this queue, and that all elements not in the queue are not in the map.    *    *<p>The benefits of creating our own queue are that (1) we can replace elements in the middle    * of the queue as part of copyEvictableEntry, and (2) the contains method is highly optimized    * for the current model.    */
DECL|class|ExpirationQueue
specifier|static
specifier|final
class|class
name|ExpirationQueue
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|head
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
operator|new
name|AbstractReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextExpirable
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNextExpirable
parameter_list|()
block|{
return|return
name|nextExpirable
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextExpirable
operator|=
name|next
expr_stmt|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previousExpirable
init|=
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previousExpirable
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previousExpirable
operator|=
name|previous
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// implements Queue
annotation|@
name|Override
DECL|method|offer (ReferenceEntry<K, V> entry)
specifier|public
name|boolean
name|offer
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
comment|// unlink
name|connectExpirables
argument_list|(
name|entry
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|entry
operator|.
name|getNextExpirable
argument_list|()
argument_list|)
expr_stmt|;
comment|// add to tail
name|connectExpirables
argument_list|(
name|head
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|connectExpirables
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|peek
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
annotation|@
name|Override
DECL|method|poll ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|poll
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|head
condition|)
block|{
return|return
literal|null
return|;
block|}
name|remove
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
init|=
name|e
operator|.
name|getPreviousExpirable
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
name|connectExpirables
argument_list|(
name|previous
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nullifyExpirable
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|ReferenceEntry
operator|)
name|o
decl_stmt|;
return|return
name|e
operator|.
name|getNextExpirable
argument_list|()
operator|!=
name|NullEntry
operator|.
name|INSTANCE
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|head
operator|.
name|getNextExpirable
argument_list|()
operator|==
name|head
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextExpirable
argument_list|()
init|;
name|e
operator|!=
name|head
condition|;
name|e
operator|=
name|e
operator|.
name|getNextExpirable
argument_list|()
control|)
block|{
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|head
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
name|nullifyExpirable
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|.
name|setNextExpirable
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|.
name|setPreviousExpirable
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractLinkedIterator
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|peek
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|computeNext
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|previous
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|previous
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
condition|?
literal|null
else|:
name|next
return|;
block|}
block|}
return|;
block|}
block|}
DECL|class|CleanupMapTask
specifier|static
specifier|final
class|class
name|CleanupMapTask
implements|implements
name|Runnable
block|{
DECL|field|mapReference
specifier|final
name|WeakReference
argument_list|<
name|CustomConcurrentHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|mapReference
decl_stmt|;
DECL|method|CleanupMapTask (CustomConcurrentHashMap<?, ?> map)
specifier|public
name|CleanupMapTask
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|mapReference
operator|=
operator|new
name|WeakReference
argument_list|<
name|CustomConcurrentHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|CustomConcurrentHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|mapReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
block|}
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|segment
operator|.
name|runCleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// ConcurrentMap methods
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
comment|/*      * Sum per-segment modCounts to avoid mis-reporting when elements are concurrently added and      * removed in one segment while checking another, in which case the table was never actually      * empty at any point. (The sum ensures accuracy up through at least 1<<31 per-segment      * modifications before recheck.)  Method containsValue() uses similar constructions for      * stability checks.      */
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
comment|// recheck unless no modifications
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|sum
operator|-=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0L
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|sum
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**    * Returns the internal entry for the specified key. The entry may be computing, expired, or    * partially collected. Does not impact recency ordering.    */
DECL|method|getEntry (@ullable Object key)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**    * Returns the live internal entry for the specified key. Does not impact recency ordering.    */
DECL|method|getLiveEntry (@ullable Object key)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getLiveEntry
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getLiveEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// This implementation is patterned after ConcurrentHashMap, but without the locking. The only
comment|// way for it to return a false negative would be for the target value to jump around in the map
comment|// such that none of the subsequent iterations observed it, despite the fact that at every point
comment|// in time it was present somewhere int the map. This becomes increasingly unlikely as
comment|// CONTAINS_VALUE_RETRIES increases, though without locking it is theoretically possible.
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|last
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONTAINS_VALUE_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
comment|// ensure visibility of most recent completed write
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"UnusedDeclaration"
block|,
literal|"unused"
block|}
argument_list|)
name|int
name|c
init|=
name|segment
operator|.
name|count
decl_stmt|;
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|j
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|segment
operator|.
name|getLiveValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|value
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
name|sum
operator|+=
name|segment
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
name|last
condition|)
block|{
break|break;
block|}
name|last
operator|=
name|sum
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key, @Nullable Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, @Nullable V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|// Iterator Support
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentSegment
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|currentSegment
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|currentSegment
operator|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|currentSegment
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|currentSegment
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Finds the next entry in the current chain. Returns {@code true} if an entry was found.      */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Finds the next entry in the current table. Returns {@code true} if an entry was found.      */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Advances to the given entry. Returns {@code true} if the entry was valid, {@code false} if it      * should be skipped.      */
DECL|method|advanceTo (ReferenceEntry<K, V> entry)
name|boolean
name|advanceTo
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
try|try
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getLiveValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip stale entry.
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|currentSegment
operator|.
name|postReadCleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|lastReturned
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the    * underlying map.    */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|value
name|V
name|value
decl_stmt|;
comment|// non-null
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Cannot use key and value equivalence
if|if
condition|(
name|object
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|key
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Cannot use key and value equivalence
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (V newValue)
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|V
name|oldValue
init|=
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
comment|// only if put succeeds
return|return
name|oldValue
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Serialization Support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5
decl_stmt|;
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|expireAfterWriteNanos
argument_list|,
name|expireAfterAccessNanos
argument_list|,
name|maximumSize
argument_list|,
name|concurrencyLevel
argument_list|,
name|removalListener
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|AbstractSerializationProxy
specifier|abstract
specifier|static
class|class
name|AbstractSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|expireAfterWriteNanos
specifier|final
name|long
name|expireAfterWriteNanos
decl_stmt|;
DECL|field|expireAfterAccessNanos
specifier|final
name|long
name|expireAfterAccessNanos
decl_stmt|;
DECL|field|maximumSize
specifier|final
name|int
name|maximumSize
decl_stmt|;
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
DECL|field|removalListener
specifier|final
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
decl_stmt|;
DECL|field|delegate
specifier|transient
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|AbstractSerializationProxy (Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, long expireAfterWriteNanos, long expireAfterAccessNanos, int maximumSize, int concurrencyLevel, RemovalListener<? super K, ? super V> removalListener, ConcurrentMap<K, V> delegate)
name|AbstractSerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|long
name|expireAfterWriteNanos
parameter_list|,
name|long
name|expireAfterAccessNanos
parameter_list|,
name|int
name|maximumSize
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|valueStrength
expr_stmt|;
name|this
operator|.
name|keyEquivalence
operator|=
name|keyEquivalence
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|valueEquivalence
expr_stmt|;
name|this
operator|.
name|expireAfterWriteNanos
operator|=
name|expireAfterWriteNanos
expr_stmt|;
name|this
operator|.
name|expireAfterAccessNanos
operator|=
name|expireAfterAccessNanos
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|maximumSize
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
name|this
operator|.
name|removalListener
operator|=
name|removalListener
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|writeMapTo (ObjectOutputStream out)
name|void
name|writeMapTo
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|delegate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|delegate
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// terminate entries
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// serialization of deprecated feature
DECL|method|readMapMaker (ObjectInputStream in)
name|MapMaker
name|readMapMaker
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|initialCapacity
argument_list|(
name|size
argument_list|)
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|setValueStrength
argument_list|(
name|valueStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|keyEquivalence
argument_list|)
operator|.
name|valueEquivalence
argument_list|(
name|valueEquivalence
argument_list|)
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
decl_stmt|;
name|mapMaker
operator|.
name|removalListener
argument_list|(
name|removalListener
argument_list|)
expr_stmt|;
if|if
condition|(
name|expireAfterWriteNanos
operator|>
literal|0
condition|)
block|{
name|mapMaker
operator|.
name|expireAfterWrite
argument_list|(
name|expireAfterWriteNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expireAfterAccessNanos
operator|>
literal|0
condition|)
block|{
name|mapMaker
operator|.
name|expireAfterAccess
argument_list|(
name|expireAfterAccessNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumSize
operator|!=
name|MapMaker
operator|.
name|UNSET_INT
condition|)
block|{
name|mapMaker
operator|.
name|maximumSize
argument_list|(
name|maximumSize
argument_list|)
expr_stmt|;
block|}
return|return
name|mapMaker
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readEntries (ObjectInputStream in)
name|void
name|readEntries
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
break|break;
comment|// terminator
block|}
name|V
name|value
init|=
operator|(
name|V
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|delegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a    * circular dependency is present, so the proxy must be able to behave as the map itself.    */
DECL|class|SerializationProxy
specifier|private
specifier|static
specifier|final
class|class
name|SerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3
decl_stmt|;
DECL|method|SerializationProxy (Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, long expireAfterWriteNanos, long expireAfterAccessNanos, int maximumSize, int concurrencyLevel, RemovalListener<? super K, ? super V> removalListener, ConcurrentMap<K, V> delegate)
name|SerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|long
name|expireAfterWriteNanos
parameter_list|,
name|long
name|expireAfterAccessNanos
parameter_list|,
name|int
name|maximumSize
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|RemovalListener
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|removalListener
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|expireAfterWriteNanos
argument_list|,
name|expireAfterAccessNanos
argument_list|,
name|maximumSize
argument_list|,
name|concurrencyLevel
argument_list|,
name|removalListener
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|writeObject (ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|writeMapTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|MapMaker
name|mapMaker
init|=
name|readMapMaker
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|delegate
operator|=
name|mapMaker
operator|.
name|makeMap
argument_list|()
expr_stmt|;
name|readEntries
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
block|}
end_class

end_unit

