begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Table
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BinaryOperator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Provides static methods that involve a {@code Table}.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#tables"> {@code Tables}</a>.  *  * @author Jared Levy  * @author Louis Wasserman  * @since 7.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Tables
specifier|public
specifier|final
class|class
name|Tables
block|{
DECL|method|Tables ()
specifier|private
name|Tables
parameter_list|()
block|{}
comment|/**    * Returns a {@link Collector} that accumulates elements into a {@code Table} created using the    * specified supplier, whose cells are generated by applying the provided mapping functions to the    * input elements. Cells are inserted into the generated {@code Table} in encounter order.    *    *<p>If multiple input elements map to the same row and column, an {@code IllegalStateException}    * is thrown when the collection operation is performed.    *    * @since 21.0    */
annotation|@
name|Beta
DECL|method|toTable ( java.util.function.Function<? super T, ? extends R> rowFunction, java.util.function.Function<? super T, ? extends C> columnFunction, java.util.function.Function<? super T, ? extends V> valueFunction, java.util.function.Supplier<I> tableSupplier)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|,
name|I
extends|extends
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
parameter_list|>
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|I
argument_list|>
name|toTable
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|R
argument_list|>
name|rowFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|C
argument_list|>
name|columnFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|valueFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
argument_list|<
name|I
argument_list|>
name|tableSupplier
parameter_list|)
block|{
return|return
name|toTable
argument_list|(
name|rowFunction
argument_list|,
name|columnFunction
argument_list|,
name|valueFunction
argument_list|,
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
lambda|->
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Conflicting values "
operator|+
name|v1
operator|+
literal|" and "
operator|+
name|v2
argument_list|)
throw|;
block|}
argument_list|,
name|tableSupplier
argument_list|)
return|;
block|}
comment|/**    * Returns a {@link Collector} that accumulates elements into a {@code Table} created using the    * specified supplier, whose cells are generated by applying the provided mapping functions to the    * input elements. Cells are inserted into the generated {@code Table} in encounter order.    *    *<p>If multiple input elements map to the same row and column, the specified merging function is    * used to combine the values. Like {@link    * java.util.stream.Collectors#toMap(java.util.function.Function, java.util.function.Function,    * BinaryOperator, java.util.function.Supplier)}, this Collector throws a {@code    * NullPointerException} on null values returned from {@code valueFunction}, and treats nulls    * returned from {@code mergeFunction} as removals of that row/column pair.    *    * @since 21.0    */
DECL|method|toTable ( java.util.function.Function<? super T, ? extends R> rowFunction, java.util.function.Function<? super T, ? extends C> columnFunction, java.util.function.Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction, java.util.function.Supplier<I> tableSupplier)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|,
name|I
extends|extends
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
parameter_list|>
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|I
argument_list|>
name|toTable
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|R
argument_list|>
name|rowFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|C
argument_list|>
name|columnFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|valueFunction
parameter_list|,
name|BinaryOperator
argument_list|<
name|V
argument_list|>
name|mergeFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
argument_list|<
name|I
argument_list|>
name|tableSupplier
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|rowFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|columnFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|valueFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|mergeFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|tableSupplier
argument_list|)
expr_stmt|;
return|return
name|Collector
operator|.
name|of
argument_list|(
name|tableSupplier
argument_list|,
parameter_list|(
name|table
parameter_list|,
name|input
parameter_list|)
lambda|->
name|merge
argument_list|(
name|table
argument_list|,
name|rowFunction
operator|.
name|apply
argument_list|(
name|input
argument_list|)
argument_list|,
name|columnFunction
operator|.
name|apply
argument_list|(
name|input
argument_list|)
argument_list|,
name|valueFunction
operator|.
name|apply
argument_list|(
name|input
argument_list|)
argument_list|,
name|mergeFunction
argument_list|)
argument_list|,
parameter_list|(
name|table1
parameter_list|,
name|table2
parameter_list|)
lambda|->
block|{
lambda|for (Table.Cell<R
argument_list|,
name|C
argument_list|,
name|V
operator|>
name|cell2
operator|:
name|table2
operator|.
name|cellSet
argument_list|()
argument_list|)
block|{
name|merge
argument_list|(
name|table1
argument_list|,
name|cell2
operator|.
name|getRowKey
argument_list|()
argument_list|,
name|cell2
operator|.
name|getColumnKey
argument_list|()
argument_list|,
name|cell2
operator|.
name|getValue
argument_list|()
argument_list|,
name|mergeFunction
argument_list|)
block|;           }
return|return
name|table1
return|;
block|}
block|)
class|;
end_class

begin_function
unit|}    private
DECL|method|merge ( Table<R, C, V> table, R row, C column, V value, BinaryOperator<V> mergeFunction)
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|void
name|merge
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|table
parameter_list|,
name|R
name|row
parameter_list|,
name|C
name|column
parameter_list|,
name|V
name|value
parameter_list|,
name|BinaryOperator
argument_list|<
name|V
argument_list|>
name|mergeFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|V
name|oldValue
init|=
name|table
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
name|table
operator|.
name|put
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|V
name|newValue
init|=
name|mergeFunction
operator|.
name|apply
argument_list|(
name|oldValue
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|newValue
operator|==
literal|null
condition|)
block|{
name|table
operator|.
name|remove
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|.
name|put
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Returns an immutable cell with the specified row key, column key, and value.    *    *<p>The returned cell is serializable.    *    * @param rowKey the row key to be associated with the returned cell    * @param columnKey the column key to be associated with the returned cell    * @param value the value to be associated with the returned cell    */
end_comment

begin_function
DECL|method|immutableCell ( @ullable R rowKey, @Nullable C columnKey, @Nullable V value)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|immutableCell
parameter_list|(
annotation|@
name|Nullable
name|R
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|C
name|columnKey
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|ImmutableCell
argument_list|<>
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|ImmutableCell
specifier|static
specifier|final
class|class
name|ImmutableCell
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|rowKey
specifier|private
specifier|final
name|R
name|rowKey
decl_stmt|;
DECL|field|columnKey
specifier|private
specifier|final
name|C
name|columnKey
decl_stmt|;
DECL|field|value
specifier|private
specifier|final
name|V
name|value
decl_stmt|;
DECL|method|ImmutableCell (@ullable R rowKey, @Nullable C columnKey, @Nullable V value)
name|ImmutableCell
parameter_list|(
annotation|@
name|Nullable
name|R
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|C
name|columnKey
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|rowKey
operator|=
name|rowKey
expr_stmt|;
name|this
operator|.
name|columnKey
operator|=
name|columnKey
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getRowKey ()
specifier|public
name|R
name|getRowKey
parameter_list|()
block|{
return|return
name|rowKey
return|;
block|}
annotation|@
name|Override
DECL|method|getColumnKey ()
specifier|public
name|C
name|getColumnKey
parameter_list|()
block|{
return|return
name|columnKey
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
end_class

begin_class
DECL|class|AbstractCell
specifier|abstract
specifier|static
class|class
name|AbstractCell
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
block|{
comment|// needed for serialization
DECL|method|AbstractCell ()
name|AbstractCell
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|Cell
condition|)
block|{
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|other
init|=
operator|(
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|getRowKey
argument_list|()
argument_list|,
name|other
operator|.
name|getRowKey
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|getColumnKey
argument_list|()
argument_list|,
name|other
operator|.
name|getColumnKey
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|getValue
argument_list|()
argument_list|,
name|other
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|getRowKey
argument_list|()
argument_list|,
name|getColumnKey
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"("
operator|+
name|getRowKey
argument_list|()
operator|+
literal|","
operator|+
name|getColumnKey
argument_list|()
operator|+
literal|")="
operator|+
name|getValue
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Creates a transposed view of a given table that flips its row and column keys. In other words,    * calling {@code get(columnKey, rowKey)} on the generated table always returns the same value as    * calling {@code get(rowKey, columnKey)} on the original table. Updating the original table    * changes the contents of the transposed table and vice versa.    *    *<p>The returned table supports update operations as long as the input table supports the    * analogous operation with swapped rows and columns. For example, in a {@link HashBasedTable}    * instance, {@code rowKeySet().iterator()} supports {@code remove()} but {@code    * columnKeySet().iterator()} doesn't. With a transposed {@link HashBasedTable}, it's the other    * way around.    */
end_comment

begin_function
DECL|method|transpose (Table<R, C, V> table)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Table
argument_list|<
name|C
argument_list|,
name|R
argument_list|,
name|V
argument_list|>
name|transpose
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|table
parameter_list|)
block|{
return|return
operator|(
name|table
operator|instanceof
name|TransposeTable
operator|)
condition|?
operator|(
operator|(
name|TransposeTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
operator|)
name|table
operator|)
operator|.
name|original
else|:
operator|new
name|TransposeTable
argument_list|<
name|C
argument_list|,
name|R
argument_list|,
name|V
argument_list|>
argument_list|(
name|table
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|TransposeTable
specifier|private
specifier|static
class|class
name|TransposeTable
parameter_list|<
name|C
parameter_list|,
name|R
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractTable
argument_list|<
name|C
argument_list|,
name|R
argument_list|,
name|V
argument_list|>
block|{
DECL|field|original
specifier|final
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|original
decl_stmt|;
DECL|method|TransposeTable (Table<R, C, V> original)
name|TransposeTable
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|original
parameter_list|)
block|{
name|this
operator|.
name|original
operator|=
name|checkNotNull
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|original
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|column (R columnKey)
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
name|column
parameter_list|(
name|R
name|columnKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|row
argument_list|(
name|columnKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|columnKeySet ()
specifier|public
name|Set
argument_list|<
name|R
argument_list|>
name|columnKeySet
parameter_list|()
block|{
return|return
name|original
operator|.
name|rowKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|columnMap ()
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|columnMap
parameter_list|()
block|{
return|return
name|original
operator|.
name|rowMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullable Object rowKey, @Nullable Object columnKey)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|contains
argument_list|(
name|columnKey
argument_list|,
name|rowKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsColumn (@ullable Object columnKey)
specifier|public
name|boolean
name|containsColumn
parameter_list|(
annotation|@
name|Nullable
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|containsRow
argument_list|(
name|columnKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsRow (@ullable Object rowKey)
specifier|public
name|boolean
name|containsRow
parameter_list|(
annotation|@
name|Nullable
name|Object
name|rowKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|containsColumn
argument_list|(
name|rowKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (@ullable Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
name|original
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object rowKey, @Nullable Object columnKey)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|get
argument_list|(
name|columnKey
argument_list|,
name|rowKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (C rowKey, R columnKey, V value)
specifier|public
name|V
name|put
parameter_list|(
name|C
name|rowKey
parameter_list|,
name|R
name|columnKey
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|original
operator|.
name|put
argument_list|(
name|columnKey
argument_list|,
name|rowKey
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Table<? extends C, ? extends R, ? extends V> table)
specifier|public
name|void
name|putAll
parameter_list|(
name|Table
argument_list|<
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|table
parameter_list|)
block|{
name|original
operator|.
name|putAll
argument_list|(
name|transpose
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object rowKey, @Nullable Object columnKey)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|remove
argument_list|(
name|columnKey
argument_list|,
name|rowKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|row (C rowKey)
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
name|row
parameter_list|(
name|C
name|rowKey
parameter_list|)
block|{
return|return
name|original
operator|.
name|column
argument_list|(
name|rowKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowKeySet ()
specifier|public
name|Set
argument_list|<
name|C
argument_list|>
name|rowKeySet
parameter_list|()
block|{
return|return
name|original
operator|.
name|columnKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|rowMap ()
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
argument_list|>
name|rowMap
parameter_list|()
block|{
return|return
name|original
operator|.
name|columnMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|original
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|original
operator|.
name|values
argument_list|()
return|;
block|}
comment|// Will cast TRANSPOSE_CELL to a type that always succeeds
DECL|field|TRANSPOSE_CELL
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|,
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|TRANSPOSE_CELL
init|=
operator|new
name|Function
argument_list|<
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|,
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|apply
parameter_list|(
name|Cell
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|cell
parameter_list|)
block|{
return|return
name|immutableCell
argument_list|(
name|cell
operator|.
name|getColumnKey
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowKey
argument_list|()
argument_list|,
name|cell
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|cellIterator ()
name|Iterator
argument_list|<
name|Cell
argument_list|<
name|C
argument_list|,
name|R
argument_list|,
name|V
argument_list|>
argument_list|>
name|cellIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|original
operator|.
name|cellSet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
operator|(
name|Function
operator|)
name|TRANSPOSE_CELL
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|cellSpliterator ()
name|Spliterator
argument_list|<
name|Cell
argument_list|<
name|C
argument_list|,
name|R
argument_list|,
name|V
argument_list|>
argument_list|>
name|cellSpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|original
operator|.
name|cellSet
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
operator|(
name|Function
operator|)
name|TRANSPOSE_CELL
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Creates a table that uses the specified backing map and factory. It can generate a table based    * on arbitrary {@link Map} classes.    *    *<p>The {@code factory}-generated and {@code backingMap} classes determine the table iteration    * order. However, the table's {@code row()} method returns instances of a different class than    * {@code factory.get()} does.    *    *<p>Call this method only when the simpler factory methods in classes like {@link    * HashBasedTable} and {@link TreeBasedTable} won't suffice.    *    *<p>The views returned by the {@code Table} methods {@link Table#column}, {@link    * Table#columnKeySet}, and {@link Table#columnMap} have iterators that don't support {@code    * remove()}. Otherwise, all optional operations are supported. Null row keys, columns keys, and    * values are not supported.    *    *<p>Lookups by row key are often faster than lookups by column key, because the data is stored    * in a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still    * runs quickly, since the row key is provided. However, {@code column(columnKey).size()} takes    * longer, since an iteration across all row keys occurs.    *    *<p>Note that this implementation is not synchronized. If multiple threads access this table    * concurrently and one of the threads modifies the table, it must be synchronized externally.    *    *<p>The table is serializable if {@code backingMap}, {@code factory}, the maps generated by    * {@code factory}, and the table contents are all serializable.    *    *<p>Note: the table assumes complete ownership over of {@code backingMap} and the maps returned    * by {@code factory}. Those objects should not be manually updated and they should not use soft,    * weak, or phantom references.    *    * @param backingMap place to store the mapping from each row key to its corresponding column key    *     / value map    * @param factory supplier of new, empty maps that will each hold all column key / value mappings    *     for a given row key    * @throws IllegalArgumentException if {@code backingMap} is not empty    * @since 10.0    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|newCustomTable ( Map<R, Map<C, V>> backingMap, Supplier<? extends Map<C, V>> factory)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|newCustomTable
parameter_list|(
name|Map
argument_list|<
name|R
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|backingMap
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|backingMap
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
comment|// TODO(jlevy): Wrap factory to validate that the supplied maps are empty?
return|return
operator|new
name|StandardTable
argument_list|<>
argument_list|(
name|backingMap
argument_list|,
name|factory
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a table where each value is transformed by a function. All other properties    * of the table, such as iteration order, are left intact.    *    *<p>Changes in the underlying table are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying table.    *    *<p>It's acceptable for the underlying table to contain null keys, and even null values provided    * that the function is capable of accepting null input. The transformed table might contain null    * values, if the function sometimes gives a null result.    *    *<p>The returned table is not thread-safe or serializable, even if the underlying table is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned    * table to be a view, but it means that the function will be applied many times for bulk    * operations like {@link Table#containsValue} and {@code Table.toString()}. For this to perform    * well, {@code function} should be fast. To avoid lazy evaluation when the returned table doesn't    * need to be a view, copy the returned table into a new table of your choosing.    *    * @since 10.0    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|transformValues ( Table<R, C, V1> fromTable, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
name|fromTable
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|TransformedTable
argument_list|<>
argument_list|(
name|fromTable
argument_list|,
name|function
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|TransformedTable
specifier|private
specifier|static
class|class
name|TransformedTable
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|AbstractTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromTable
specifier|final
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
name|fromTable
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformedTable (Table<R, C, V1> fromTable, Function<? super V1, V2> function)
name|TransformedTable
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
name|fromTable
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromTable
operator|=
name|checkNotNull
argument_list|(
name|fromTable
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|contains (Object rowKey, Object columnKey)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|rowKey
parameter_list|,
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|fromTable
operator|.
name|contains
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (Object rowKey, Object columnKey)
specifier|public
name|V2
name|get
parameter_list|(
name|Object
name|rowKey
parameter_list|,
name|Object
name|columnKey
parameter_list|)
block|{
comment|// The function is passed a null input only when the table contains a null
comment|// value.
return|return
name|contains
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|)
condition|?
name|function
operator|.
name|apply
argument_list|(
name|fromTable
operator|.
name|get
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromTable
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromTable
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|put (R rowKey, C columnKey, V2 value)
specifier|public
name|V2
name|put
parameter_list|(
name|R
name|rowKey
parameter_list|,
name|C
name|columnKey
parameter_list|,
name|V2
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Table<? extends R, ? extends C, ? extends V2> table)
specifier|public
name|void
name|putAll
parameter_list|(
name|Table
argument_list|<
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V2
argument_list|>
name|table
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|remove (Object rowKey, Object columnKey)
specifier|public
name|V2
name|remove
parameter_list|(
name|Object
name|rowKey
parameter_list|,
name|Object
name|columnKey
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|)
condition|?
name|function
operator|.
name|apply
argument_list|(
name|fromTable
operator|.
name|remove
argument_list|(
name|rowKey
argument_list|,
name|columnKey
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|row (R rowKey)
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|V2
argument_list|>
name|row
parameter_list|(
name|R
name|rowKey
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|fromTable
operator|.
name|row
argument_list|(
name|rowKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|column (C columnKey)
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|V2
argument_list|>
name|column
parameter_list|(
name|C
name|columnKey
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|fromTable
operator|.
name|column
argument_list|(
name|columnKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
DECL|method|cellFunction ()
name|Function
argument_list|<
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
name|cellFunction
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V1
argument_list|>
name|cell
parameter_list|)
block|{
return|return
name|immutableCell
argument_list|(
name|cell
operator|.
name|getRowKey
argument_list|()
argument_list|,
name|cell
operator|.
name|getColumnKey
argument_list|()
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|cell
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|cellIterator ()
name|Iterator
argument_list|<
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
name|cellIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromTable
operator|.
name|cellSet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|cellFunction
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cellSpliterator ()
name|Spliterator
argument_list|<
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
name|cellSpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|fromTable
operator|.
name|cellSet
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|cellFunction
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowKeySet ()
specifier|public
name|Set
argument_list|<
name|R
argument_list|>
name|rowKeySet
parameter_list|()
block|{
return|return
name|fromTable
operator|.
name|rowKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|columnKeySet ()
specifier|public
name|Set
argument_list|<
name|C
argument_list|>
name|columnKeySet
parameter_list|()
block|{
return|return
name|fromTable
operator|.
name|columnKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V2
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|fromTable
operator|.
name|values
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowMap ()
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
name|rowMap
parameter_list|()
block|{
name|Function
argument_list|<
name|Map
argument_list|<
name|C
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
name|rowFunction
init|=
operator|new
name|Function
argument_list|<
name|Map
argument_list|<
name|C
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
name|Map
argument_list|<
name|C
argument_list|,
name|V1
argument_list|>
name|row
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|row
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|fromTable
operator|.
name|rowMap
argument_list|()
argument_list|,
name|rowFunction
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|columnMap ()
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V2
argument_list|>
argument_list|>
name|columnMap
parameter_list|()
block|{
name|Function
argument_list|<
name|Map
argument_list|<
name|R
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V2
argument_list|>
argument_list|>
name|columnFunction
init|=
operator|new
name|Function
argument_list|<
name|Map
argument_list|<
name|R
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
name|Map
argument_list|<
name|R
argument_list|,
name|V1
argument_list|>
name|column
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|column
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|fromTable
operator|.
name|columnMap
argument_list|()
argument_list|,
name|columnFunction
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns an unmodifiable view of the specified table. This method allows modules to provide    * users with "read-only" access to internal tables. Query operations on the returned table "read    * through" to the specified table, and attempts to modify the returned table, whether direct or    * via its collection views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned table will be serializable if the specified table is serializable.    *    *<p>Consider using an {@link ImmutableTable}, which is guaranteed never to change.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|unmodifiableTable ( Table<? extends R, ? extends C, ? extends V> table)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|unmodifiableTable
parameter_list|(
name|Table
argument_list|<
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|table
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableTable
argument_list|<>
argument_list|(
name|table
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|UnmodifiableTable
specifier|private
specifier|static
class|class
name|UnmodifiableTable
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|delegate
specifier|final
name|Table
argument_list|<
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableTable (Table<? extends R, ? extends C, ? extends V> delegate)
name|UnmodifiableTable
parameter_list|(
name|Table
argument_list|<
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe, covariant cast
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
operator|)
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|cellSet ()
specifier|public
name|Set
argument_list|<
name|Cell
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|cellSet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|super
operator|.
name|cellSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|column (@ullable C columnKey)
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
name|column
parameter_list|(
annotation|@
name|Nullable
name|C
name|columnKey
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|super
operator|.
name|column
argument_list|(
name|columnKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|columnKeySet ()
specifier|public
name|Set
argument_list|<
name|C
argument_list|>
name|columnKeySet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|super
operator|.
name|columnKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|columnMap ()
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
argument_list|>
name|columnMap
parameter_list|()
block|{
name|Function
argument_list|<
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
argument_list|<
name|R
argument_list|,
name|V
argument_list|>
argument_list|>
name|wrapper
init|=
name|unmodifiableWrapper
argument_list|()
decl_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Maps
operator|.
name|transformValues
argument_list|(
name|super
operator|.
name|columnMap
argument_list|()
argument_list|,
name|wrapper
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (@ullable R rowKey, @Nullable C columnKey, @Nullable V value)
specifier|public
name|V
name|put
parameter_list|(
annotation|@
name|Nullable
name|R
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|C
name|columnKey
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Table<? extends R, ? extends C, ? extends V> table)
specifier|public
name|void
name|putAll
parameter_list|(
name|Table
argument_list|<
name|?
extends|extends
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|table
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object rowKey, @Nullable Object columnKey)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|rowKey
parameter_list|,
annotation|@
name|Nullable
name|Object
name|columnKey
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|row (@ullable R rowKey)
specifier|public
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
name|row
parameter_list|(
annotation|@
name|Nullable
name|R
name|rowKey
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|super
operator|.
name|row
argument_list|(
name|rowKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowKeySet ()
specifier|public
name|Set
argument_list|<
name|R
argument_list|>
name|rowKeySet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|super
operator|.
name|rowKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowMap ()
specifier|public
name|Map
argument_list|<
name|R
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|rowMap
parameter_list|()
block|{
name|Function
argument_list|<
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|wrapper
init|=
name|unmodifiableWrapper
argument_list|()
decl_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Maps
operator|.
name|transformValues
argument_list|(
name|super
operator|.
name|rowMap
argument_list|()
argument_list|,
name|wrapper
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|super
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
end_class

begin_comment
comment|/**    * Returns an unmodifiable view of the specified row-sorted table. This method allows modules to    * provide users with "read-only" access to internal tables. Query operations on the returned    * table "read through" to the specified table, and attempts to modify the returned table, whether    * direct or via its collection views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned table will be serializable if the specified table is serializable.    *    * @param table the row-sorted table for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified table    * @since 11.0    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|unmodifiableRowSortedTable ( RowSortedTable<R, ? extends C, ? extends V> table)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|unmodifiableRowSortedTable
parameter_list|(
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|table
parameter_list|)
block|{
comment|/*      * It's not ? extends R, because it's technically not covariant in R. Specifically,      * table.rowMap().comparator() could return a comparator that only works for the ? extends R.      * Collections.unmodifiableSortedMap makes the same distinction.      */
return|return
operator|new
name|UnmodifiableRowSortedMap
argument_list|<>
argument_list|(
name|table
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|UnmodifiableRowSortedMap
specifier|static
specifier|final
class|class
name|UnmodifiableRowSortedMap
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
implements|implements
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableRowSortedMap (RowSortedTable<R, ? extends C, ? extends V> delegate)
specifier|public
name|UnmodifiableRowSortedMap
parameter_list|(
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|?
extends|extends
name|C
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|RowSortedTable
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|rowMap ()
specifier|public
name|SortedMap
argument_list|<
name|R
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|rowMap
parameter_list|()
block|{
name|Function
argument_list|<
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
argument_list|<
name|C
argument_list|,
name|V
argument_list|>
argument_list|>
name|wrapper
init|=
name|unmodifiableWrapper
argument_list|()
decl_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|Maps
operator|.
name|transformValues
argument_list|(
name|delegate
argument_list|()
operator|.
name|rowMap
argument_list|()
argument_list|,
name|wrapper
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rowKeySet ()
specifier|public
name|SortedSet
argument_list|<
name|R
argument_list|>
name|rowKeySet
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|rowKeySet
argument_list|()
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
end_class

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|unmodifiableWrapper ()
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Function
argument_list|<
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableWrapper
parameter_list|()
block|{
return|return
operator|(
name|Function
operator|)
name|UNMODIFIABLE_WRAPPER
return|;
block|}
end_function

begin_decl_stmt
DECL|field|UNMODIFIABLE_WRAPPER
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|?
extends|extends
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|UNMODIFIABLE_WRAPPER
init|=
operator|new
name|Function
argument_list|<
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|,
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|apply
parameter_list|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Returns a synchronized (thread-safe) table backed by the specified table. In order to guarantee    * serial access, it is critical that<b>all</b> access to the backing table is accomplished    * through the returned table.    *    *<p>It is imperative that the user manually synchronize on the returned table when accessing any    * of its collection views:    *    *<pre>{@code    * Table<R, C, V> table = Tables.synchronizedTable(HashBasedTable.<R, C, V>create());    * ...    * Map<C, V> row = table.row(rowKey);  // Needn't be in synchronized block    * ...    * synchronized (table) {  // Synchronizing on table, not row!    *   Iterator<Entry<C, V>> i = row.entrySet().iterator(); // Must be in synchronized block    *   while (i.hasNext()) {    *     foo(i.next());    *   }    * }    * }</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned table will be serializable if the specified table is serializable.    *    * @param table the table to be wrapped in a synchronized view    * @return a synchronized view of the specified table    * @since 22.0    */
end_comment

begin_function
DECL|method|synchronizedTable (Table<R, C, V> table)
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|C
parameter_list|,
name|V
parameter_list|>
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|synchronizedTable
parameter_list|(
name|Table
argument_list|<
name|R
argument_list|,
name|C
argument_list|,
name|V
argument_list|>
name|table
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|table
argument_list|(
name|table
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|equalsImpl (Table<?, ?, ?> table, @Nullable Object obj)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Table
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|table
parameter_list|,
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|table
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Table
condition|)
block|{
name|Table
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Table
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|table
operator|.
name|cellSet
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|cellSet
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function

unit|}
end_unit

