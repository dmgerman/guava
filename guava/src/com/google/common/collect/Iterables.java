begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An assortment of mainly legacy static utility methods that operate on or return objects of type  * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method  * in the {@link Iterators} class.  *  *<p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for  * comparisons. This class is not being deprecated, but we gently encourage you to migrate to  * streams.  *  *<p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class  * are<i>lazy</i>, which means that their iterators only advance the backing iteration when  * absolutely necessary.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"> {@code  * Iterables}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
annotation|@
name|ElementTypesAreNonnullByDefault
DECL|class|Iterables
specifier|public
specifier|final
class|class
name|Iterables
block|{
DECL|method|Iterables ()
specifier|private
name|Iterables
parameter_list|()
block|{}
comment|/** Returns an unmodifiable view of {@code iterable}. */
DECL|method|unmodifiableIterable ( final Iterable<? extends T> iterable)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|unmodifiableIterable
argument_list|(
name|final
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
if|if
condition|(
name|iterable
operator|instanceof
name|UnmodifiableIterable
operator|||
name|iterable
operator|instanceof
name|ImmutableCollection
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Since it's unmodifiable, the covariant cast is safe
name|Iterable
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|(
name|Iterable
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|result
return|;
block|}
return|return
operator|new
name|UnmodifiableIterable
argument_list|<>
argument_list|(
name|iterable
argument_list|)
return|;
block|}
end_class

begin_comment
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
end_comment

begin_function
annotation|@
name|Deprecated
DECL|method|unmodifiableIterable (ImmutableCollection<E> iterable)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|unmodifiableIterable
parameter_list|(
name|ImmutableCollection
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
DECL|class|UnmodifiableIterable
specifier|private
specifier|static
name|final
name|class
name|UnmodifiableIterable
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|FluentIterable
argument_list|<
name|T
argument_list|>
block|{
DECL|field|iterable
specifier|private
name|final
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
block|;
DECL|method|UnmodifiableIterable (Iterable<? extends T> iterable)
specifier|private
name|UnmodifiableIterable
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
argument_list|)
block|{
name|this
operator|.
name|iterable
operator|=
name|iterable
block|;     }
expr|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
argument_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
expr|@
name|Override
DECL|method|forEach (Consumer<? super T> action)
specifier|public
name|void
name|forEach
argument_list|(
name|Consumer
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
argument_list|)
block|{
name|iterable
operator|.
name|forEach
argument_list|(
name|action
argument_list|)
block|;     }
expr|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe upcast, assuming no one has a crazy Spliterator subclass
expr|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
argument_list|()
block|{
return|return
operator|(
name|Spliterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
operator|.
name|spliterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|// no equals and hashCode; it would break the contract!
end_comment

begin_comment
unit|}
comment|/** Returns the number of elements in {@code iterable}. */
end_comment

begin_function
DECL|method|size (Iterable<?> iterable)
unit|public
specifier|static
name|int
name|size
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|size
argument_list|()
else|:
name|Iterators
operator|.
name|size
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code    * Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in    * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link    * ClassCastException}.    */
end_comment

begin_comment
comment|//<? extends @Nullable Object> instead of<?> because of Kotlin b/189937072, discussed in Joiner.
end_comment

begin_decl_stmt
DECL|method|contains ( Iterable<? extends @Nullable Object> iterable, @CheckForNull Object element)
specifier|public
specifier|static
name|boolean
name|contains
argument_list|(
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|Object
operator|>
name|iterable
argument_list|,
annotation|@
name|CheckForNull
name|Object
name|element
argument_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|Collections2
operator|.
name|safeContains
argument_list|(
name|collection
argument_list|,
name|element
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/**    * Removes, from an iterable, every element that belongs to the provided collection.    *    *<p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and    * {@link Iterators#removeAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRemove the elements to remove    * @return {@code true} if any element was removed from {@code iterable}    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|removeAll (Iterable<?> removeFrom, Collection<?> elementsToRemove)
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRemove
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRemove
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|removeAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRemove
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Removes, from an iterable, every element that does not belong to the provided collection.    *    *<p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and    * {@link Iterators#retainAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRetain the elements to retain    * @return {@code true} if any element was removed from {@code iterable}    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|retainAll (Iterable<?> removeFrom, Collection<?> elementsToRetain)
specifier|public
specifier|static
name|boolean
name|retainAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRetain
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRetain
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|retainAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRetain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Removes, from an iterable, every element that satisfies the provided predicate.    *    *<p>Removals may or may not happen immediately as each element is tested against the predicate.    * The behavior of this method is not specified if {@code predicate} is dependent on {@code    * removeFrom}.    *    *<p><b>Java 8 users:</b> if {@code removeFrom} is a {@link Collection}, use {@code    * removeFrom.removeIf(predicate)} instead.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param predicate a predicate that determines whether an element should be removed    * @return {@code true} if any elements were removed from the iterable    * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.    * @since 2.0    */
end_comment

begin_annotation
annotation|@
name|CanIgnoreReturnValue
end_annotation

begin_expr_stmt
DECL|method|removeIf ( Iterable<T> removeFrom, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|removeIf
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|removeFrom
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
if|if
condition|(
name|removeFrom
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|removeIf
argument_list|(
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Iterators
operator|.
name|removeIf
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/** Removes and returns the first matching element, or returns {@code null} if there is none. */
end_comment

begin_expr_stmt
unit|@
name|CheckForNull
DECL|method|removeFirstMatching ( Iterable<T> removeFrom, Predicate<? super T> predicate)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|removeFirstMatching
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|removeFrom
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
block|;
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
operator|=
name|removeFrom
operator|.
name|iterator
argument_list|()
block|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|next
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
literal|null
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Determines whether two iterables contain equal elements in the same order. More specifically,    * this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same    * number of elements and every element of {@code iterable1} is equal to the corresponding element    * of {@code iterable2}.    */
end_comment

begin_function
DECL|method|elementsEqual (Iterable<?> iterable1, Iterable<?> iterable2)
unit|public
specifier|static
name|boolean
name|elementsEqual
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable1
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable2
parameter_list|)
block|{
if|if
condition|(
name|iterable1
operator|instanceof
name|Collection
operator|&&
name|iterable2
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|collection1
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable1
decl_stmt|;
name|Collection
argument_list|<
name|?
argument_list|>
name|collection2
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable2
decl_stmt|;
if|if
condition|(
name|collection1
operator|.
name|size
argument_list|()
operator|!=
name|collection2
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|Iterators
operator|.
name|elementsEqual
argument_list|(
name|iterable1
operator|.
name|iterator
argument_list|()
argument_list|,
name|iterable2
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a string representation of {@code iterable}, with the format {@code [e1, e2, ..., en]}    * (that is, identical to {@link java.util.Arrays Arrays}{@code    * .toString(Iterables.toArray(iterable))}). Note that for<i>most</i> implementations of {@link    * Collection}, {@code collection.toString()} also gives the same result, but that behavior is not    * generally guaranteed.    */
end_comment

begin_function
DECL|method|toString (Iterable<?> iterable)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|toString
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the single element contained in {@code iterable}.    *    *<p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code    * stream.collect(MoreCollectors.onlyElement())}.    *    * @throws NoSuchElementException if the iterable is empty    * @throws IllegalArgumentException if the iterable contains multiple elements    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getOnlyElement (Iterable<T> iterable)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getOnlyElement
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the    * iterable is empty.    *    *<p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code    * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.    *    * @throws IllegalArgumentException if the iterator contains multiple elements    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getOnlyElement ( Iterable<? extends T> iterable, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getOnlyElement
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Copies an iterable's elements into an array.    *    * @param iterable the iterable to copy    * @param type the type of the elements    * @return a newly-allocated array into which all the elements of the iterable have been copied    */
end_comment

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// Array.newInstance(Class, int)
comment|/*    * If we could express Class<@Nonnull T>, we could generalize the type parameter to<T extends    * @Nullable Object>, and then we could accept an Iterable<? extends T> and return a plain T[]    * instead of a @Nullable T[].    */
DECL|method|toArray (Iterable<? extends @Nullable T> iterable, Class<T> type)
specifier|public
specifier|static
argument_list|<
name|T
argument_list|>
annotation|@
name|Nullable
name|T
index|[]
name|toArray
argument_list|(
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|T
operator|>
name|iterable
argument_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
argument_list|)
block|{
return|return
name|toArray
argument_list|(
name|iterable
argument_list|,
name|ObjectArrays
operator|.
name|newArray
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
DECL|method|toArray (Iterable<? extends T> iterable, T[] array)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
index|[]
name|toArray
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
name|T
index|[]
name|array
argument_list|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|collection
operator|=
name|castOrCopyToCollection
argument_list|(
name|iterable
argument_list|)
block|;
return|return
name|collection
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Copies an iterable's elements into an array.    *    * @param iterable the iterable to copy    * @return a newly-allocated array into which all the elements of the iterable have been copied    */
end_comment

begin_function
DECL|method|toArray (Iterable<?> iterable)
specifier|static
annotation|@
name|Nullable
name|Object
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|castOrCopyToCollection
argument_list|(
name|iterable
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Converts an iterable into a collection. If the iterable is already a collection, it is    * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the    * iterable in the same iteration order.    */
end_comment

begin_expr_stmt
DECL|method|castOrCopyToCollection ( Iterable<E> iterable)
specifier|private
specifier|static
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|Collection
argument_list|<
name|E
argument_list|>
name|castOrCopyToCollection
argument_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
argument_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
operator|?
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
operator|:
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Adds all elements in {@code iterable} to {@code collection}.    *    * @return {@code true} if {@code collection} was modified as a result of this operation.    */
end_comment

begin_annotation
annotation|@
name|CanIgnoreReturnValue
end_annotation

begin_expr_stmt
DECL|method|addAll ( Collection<T> addTo, Iterable<? extends T> elementsToAdd)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|addAll
argument_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|addTo
argument_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|elementsToAdd
argument_list|)
block|{
if|if
condition|(
name|elementsToAdd
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
init|=
operator|(
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
operator|)
name|elementsToAdd
decl_stmt|;
return|return
name|addTo
operator|.
name|addAll
argument_list|(
name|c
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Iterators
operator|.
name|addAll
argument_list|(
name|addTo
argument_list|,
name|checkNotNull
argument_list|(
name|elementsToAdd
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    * Returns the number of elements in the specified iterable that equal the specified object. This    * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.    *    *<p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code    * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code    * stream.filter(Predicate.isEqual(element)).count()} instead.    *    * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,    *     Object)    */
end_comment

begin_function
DECL|method|frequency (Iterable<?> iterable, @CheckForNull Object element)
unit|public
specifier|static
name|int
name|frequency
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Multiset
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Multiset
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|contains
argument_list|(
name|element
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
name|Iterators
operator|.
name|frequency
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.    *    *<p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code    * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code    * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}    * is empty.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    *    *<p>To cycle over the iterable {@code n} times, use the following: {@code    * Iterables.concat(Collections.nCopies(n, iterable))}    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Stream.generate(() -> iterable).flatMap(Streams::stream)}.    */
end_comment

begin_expr_stmt
DECL|method|cycle (final Iterable<T> iterable)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|cycle
argument_list|(
name|iterable
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
argument_list|()
block|{
return|return
name|Stream
operator|.
name|generate
argument_list|(
parameter_list|()
lambda|->
name|iterable
argument_list|)
operator|.
operator|<
name|T
operator|>
name|flatMap
argument_list|(
name|Streams
operator|::
name|stream
argument_list|)
operator|.
name|spliterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
operator|+
literal|" (cycled)"
return|;
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the provided elements.    *    *<p>After {@code remove} is invoked on a generated iterator, the removed element will no longer    * appear in either that iterator or any other iterator created from the same source iterable.    * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.    * The iterator's {@code hasNext} method returns {@code true} until all of the original elements    * have been removed.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You    * should use an explicit {@code break} or be certain that you will eventually remove all the    * elements.    *    *<p>To cycle over the elements {@code n} times, use the following: {@code    * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}    *    *<p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of    * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection    * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.    */
end_comment

begin_expr_stmt
unit|@
name|SafeVarargs
DECL|method|cycle (T... elements)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
argument_list|(
name|T
operator|...
name|elements
argument_list|)
block|{
return|return
name|cycle
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines two iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}. The source    * iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code Stream.concat(a,    * b)}.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
argument_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines three iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the    * elements in {@code c}. The source iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(a, b, c)}.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
argument_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines four iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the    * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not    * polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(a, b, c, d)}.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c, Iterable<? extends T> d)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
operator|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|d
argument_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled    * until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * Streams.concat(...)}.    *    * @throws NullPointerException if any of the provided iterables is null    */
end_comment

begin_annotation
annotation|@
name|SafeVarargs
end_annotation

begin_expr_stmt
DECL|method|concat (Iterable<? extends T>.... inputs)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
operator|...
name|inputs
argument_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|inputs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled    * until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the corresponding input    * iterator supports it. The methods of the returned iterable may throw {@code    * NullPointerException} if any of the input iterators is null.    *    *<p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code    * streamOfStreams.flatMap(s -> s)}.    */
end_comment

begin_expr_stmt
DECL|method|concat ( Iterable<? extends Iterable<? extends T>> inputs)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|inputs
argument_list|)
block|{
return|return
name|FluentIterable
operator|.
name|concat
argument_list|(
name|inputs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Divides an iterable into unmodifiable sublists of the given size (the final iterable may be    * smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a    * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two    * inner lists of three and two elements, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}    * method. The returned lists implement {@link RandomAccess}, whether or not the input list does.    *    *<p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}    * instead.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition (the last may be smaller)    * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided    *     into partitions    * @throws IllegalArgumentException if {@code size} is nonpositive    */
end_comment

begin_expr_stmt
DECL|method|partition ( final Iterable<T> iterable, final int size)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|final
name|int
name|size
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|partition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Divides an iterable into unmodifiable sublists of the given size, padding the final iterable    * with null values if necessary. For example, partitioning an iterable containing {@code [a, b,    * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer    * iterable containing two inner lists of three elements each, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}    * method.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition    * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided    *     into partitions (the final iterable may have trailing null elements)    * @throws IllegalArgumentException if {@code size} is nonpositive    */
end_comment

begin_expr_stmt
DECL|method|paddedPartition ( final Iterable<T> iterable, final int size)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|paddedPartition
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|final
name|int
name|size
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|paddedPartition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate    * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.    */
end_comment

begin_expr_stmt
DECL|method|filter ( final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|filter
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|unfiltered
argument_list|,
name|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|retainIfTrue
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|retainIfTrue
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|iterator
argument_list|()
argument_list|,
name|retainIfTrue
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|void
name|forEach
argument_list|(
name|Consumer
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
block|;
name|unfiltered
operator|.
name|forEach
argument_list|(
parameter_list|(
annotation|@
name|ParametricNullness
name|T
name|a
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|retainIfTrue
operator|.
name|test
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_function
unit|}        @
name|Override
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|spliterator
argument_list|()
argument_list|,
name|retainIfTrue
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Returns a view of {@code unfiltered} containing all elements that are of the type {@code    * desiredType}. The returned iterable's iterator does not support {@code remove()}.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.    * This does perform a little more work than necessary, so another option is to insert an    * unchecked cast at some later point:    *    *<pre>    * {@code @SuppressWarnings("unchecked") // safe because of ::isInstance check    * ImmutableList<NewType> result =    *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}    *</pre>    */
end_comment

begin_expr_stmt
unit|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
expr|@
name|GwtIncompatible
comment|// Class.isInstance
DECL|method|filter (final Iterable<?> unfiltered, final Class<T> desiredType)
specifier|public
specifier|static
operator|<
name|T
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|filter
argument_list|(
name|final
name|Iterable
argument_list|<
name|?
argument_list|>
name|unfiltered
operator|,
name|final
name|Class
argument_list|<
name|T
argument_list|>
name|desiredType
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|desiredType
argument_list|)
block|;
return|return
operator|(
name|Iterable
argument_list|<
name|T
argument_list|>
operator|)
name|filter
argument_list|(
name|unfiltered
argument_list|,
name|Predicates
operator|.
name|instanceOf
argument_list|(
name|desiredType
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@code true} if any element in {@code iterable} satisfies the predicate.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.    */
end_comment

begin_expr_stmt
DECL|method|any ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|any
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|any
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code    * iterable} is empty, {@code true} is returned.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.    */
end_comment

begin_expr_stmt
DECL|method|all ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|boolean
name|all
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|all
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the first element in {@code iterable} that satisfies the given predicate; use this    * method only when such an element is known to exist. If it is possible that<i>no</i> element    * will match, use {@link #tryFind} or {@link #find(Iterable, Predicate, Object)} instead.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}    *    * @throws NoSuchElementException if no element in {@code iterable} matches the given predicate    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|find ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|find
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the first element in {@code iterable} that satisfies the given predicate, or {@code    * defaultValue} if none found. Note that this can usually be handled more naturally using {@code    * tryFind(iterable, predicate).or(defaultValue)}.    *    *<p><b>{@code Stream} equivalent:</b> {@code    * stream.filter(predicate).findFirst().orElse(defaultValue)}    *    * @since 7.0    */
end_comment

begin_comment
comment|// The signature we really want here is...
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//<T extends @Nullable Object> @JointlyNullable T find(
end_comment

begin_comment
comment|//     Iterable<? extends T> iterable,
end_comment

begin_comment
comment|//     Predicate<? super T> predicate,
end_comment

begin_comment
comment|//     @JointlyNullable T defaultValue);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ...where "@JointlyNullable" is similar to @PolyNull but slightly different:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - @PolyNull means "@Nullable or @Nonnull"
end_comment

begin_comment
comment|//   (That would be unsound for an input Iterable<@Nullable Foo>. So, if we wanted to use
end_comment

begin_comment
comment|//   @PolyNull, we would have to restrict this method to non-null<T>. But it has users who pass
end_comment

begin_comment
comment|//   iterables with null elements.)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - @JointlyNullable means "@Nullable or no annotation"
end_comment

begin_annotation
annotation|@
name|CheckForNull
end_annotation

begin_expr_stmt
DECL|method|find ( Iterable<? extends T> iterable, Predicate<? super T> predicate, @CheckForNull T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|find
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
operator|,
condition|@
name|CheckForNull
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns an {@link Optional} containing the first element in {@code iterable} that satisfies the    * given predicate, if such an element exists.    *    *<p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}    * is matched in {@code iterable}, a NullPointerException will be thrown.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}    *    * @since 11.0    */
end_comment

begin_function
DECL|method|tryFind (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|tryFind
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|tryFind
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the index in {@code iterable} of the first element that satisfies the provided {@code    * predicate}, or {@code -1} if the Iterable has no such elements.    *    *<p>More formally, returns the lowest index {@code i} such that {@code    * predicate.apply(Iterables.get(iterable, i))} returns {@code true}, or {@code -1} if there is no    * such index.    *    * @since 2.0    */
end_comment

begin_expr_stmt
DECL|method|indexOf ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|int
name|indexOf
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|indexOf
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a view containing the result of applying {@code function} to each element of {@code    * fromIterable}.    *    *<p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s    * iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer    * contains the corresponding element.    *    *<p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},    * consider {@link Lists#transform} and {@link Collections2#transform}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#map}    */
end_comment

begin_expr_stmt
DECL|method|transform ( final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)
specifier|public
specifier|static
operator|<
name|F
expr|extends @
name|Nullable
name|Object
operator|,
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|transform
argument_list|(
name|final
name|Iterable
argument_list|<
name|F
argument_list|>
name|fromIterable
argument_list|,
name|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|fromIterable
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromIterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|void
name|forEach
argument_list|(
name|Consumer
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
block|;
name|fromIterable
operator|.
name|forEach
argument_list|(
parameter_list|(
name|F
name|f
parameter_list|)
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
block|;       }
expr|@
name|Override
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
argument_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|fromIterable
operator|.
name|spliterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Returns the element at the specified position in an iterable.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (throws    * {@code NoSuchElementException} if out of bounds)    *    * @param position position of the element to return    * @return the element at the specified position in {@code iterable}    * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to    *     the size of {@code iterable}    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|get (Iterable<T> iterable, int position)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|get
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|int
name|position
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
return|return
operator|(
name|iterable
operator|instanceof
name|List
operator|)
condition|?
operator|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|get
argument_list|(
name|position
argument_list|)
else|:
name|Iterators
operator|.
name|get
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|position
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the element at the specified position in an iterable or a default value otherwise.    *    *<p><b>{@code Stream} equivalent:</b> {@code    * stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index    * is out of bounds)    *    * @param position position of the element to return    * @param defaultValue the default value to return if {@code position} is greater than or equal to    *     the size of the iterable    * @return the element at the specified position in {@code iterable} or {@code defaultValue} if    *     {@code iterable} contains fewer than {@code position + 1} elements.    * @throws IndexOutOfBoundsException if {@code position} is negative    * @since 4.0    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|get ( Iterable<? extends T> iterable, int position, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|get
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
name|int
name|position
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
name|Iterators
operator|.
name|checkNonnegative
argument_list|(
name|position
argument_list|)
block|;
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list
init|=
name|Lists
operator|.
name|cast
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
return|return
operator|(
name|position
operator|<
name|list
operator|.
name|size
argument_list|()
operator|)
condition|?
name|list
operator|.
name|get
argument_list|(
name|position
argument_list|)
else|:
name|defaultValue
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
expr_stmt|;
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|iterator
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_else

begin_comment
unit|}
comment|/**    * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.    * The {@link Iterators} analog to this method is {@link Iterators#getNext}.    *    *<p>If no default value is desired (and the caller instead wants a {@link    * NoSuchElementException} to be thrown), it is recommended that {@code    * iterable.iterator().next()} is used instead.    *    *<p>To get the only element in a single-element {@code Iterable}, consider using {@link    * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.    *    *<p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}    *    * @param defaultValue the default value to return if the iterable is empty    * @return the first element of {@code iterable} or the default value    * @since 7.0    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|getFirst ( Iterable<? extends T> iterable, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getFirst
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with {@link    * RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}    *    * @return the last element of {@code iterable}    * @throws NoSuchElementException if the iterable is empty    */
end_comment

begin_annotation
annotation|@
name|ParametricNullness
end_annotation

begin_expr_stmt
DECL|method|getLast (Iterable<T> iterable)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getLast
argument_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|)
block|{
comment|// TODO(kevinb): Support a concurrently modified collection?
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
end_expr_stmt

begin_return
return|return
name|getLastInNonemptyList
argument_list|(
name|list
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}      return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.    * If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is    * guaranteed to be {@code O(1)}.    *    *<p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}    *    * @param defaultValue the value to return if {@code iterable} is empty    * @return the last element of {@code iterable} or the default value    * @since 3.0    */
end_comment

begin_expr_stmt
unit|@
name|ParametricNullness
DECL|method|getLast ( Iterable<? extends T> iterable, @ParametricNullness T defaultValue)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getLast
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
operator|,
condition|@
name|ParametricNullness
name|T
name|defaultValue
argument_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
init|=
operator|(
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
return|return
name|getLastInNonemptyList
argument_list|(
name|Lists
operator|.
name|cast
argument_list|(
name|iterable
argument_list|)
argument_list|)
return|;
block|}
end_elseif

begin_expr_stmt
unit|}      return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    @
name|ParametricNullness
DECL|method|getLastInNonemptyList (List<T> list)
specifier|private
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|T
name|getLastInNonemptyList
argument_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
argument_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If    * {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips    * all of its elements.    *    *<p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are    * reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}    * elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.    *    *<p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying    * iterable supports it. Note that it is<i>not</i> possible to delete the last skipped element by    * immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states    * that a call to {@code remove()} before a call to {@code next()} will throw an {@link    * IllegalStateException}.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#skip}    *    * @since 3.0    */
end_comment

begin_expr_stmt
DECL|method|skip ( final Iterable<T> iterable, final int numberToSkip)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|skip
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|final
name|int
name|numberToSkip
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
name|checkArgument
argument_list|(
name|numberToSkip
operator|>=
literal|0
argument_list|,
literal|"number to skip cannot be negative"
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
name|int
name|toSkip
init|=
name|Math
operator|.
name|min
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|numberToSkip
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|subList
argument_list|(
name|toSkip
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
name|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
operator|=
name|iterable
operator|.
name|iterator
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Iterators
operator|.
name|advance
argument_list|(
name|iterator
argument_list|,
name|numberToSkip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*          * We can't just return the iterator because an immediate call to its          * remove() method would remove one of the skipped elements instead of          * throwing an IllegalStateException.          */
end_comment

begin_return
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|atStart
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
specifier|public
name|T
name|next
parameter_list|()
block|{
name|T
name|result
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|atStart
operator|=
literal|false
expr_stmt|;
comment|// not called if next() fails
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
operator|!
name|atStart
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
end_return

begin_function
unit|}        @
name|Override
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
parameter_list|()
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
name|int
name|toSkip
init|=
name|Math
operator|.
name|min
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|numberToSkip
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|subList
argument_list|(
name|toSkip
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|spliterator
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Streams
operator|.
name|stream
argument_list|(
name|iterable
argument_list|)
operator|.
name|skip
argument_list|(
name|numberToSkip
argument_list|)
operator|.
name|spliterator
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
unit|};   }
comment|/**    * Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code    * iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its    * elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s    * iterator does.    *    *<p><b>{@code Stream} equivalent:</b> {@link Stream#limit}    *    * @param iterable the iterable to limit    * @param limitSize the maximum number of elements in the returned iterable    * @throws IllegalArgumentException if {@code limitSize} is negative    * @since 3.0    */
end_comment

begin_expr_stmt
DECL|method|limit ( final Iterable<T> iterable, final int limitSize)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|limit
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|,
name|final
name|int
name|limitSize
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
name|checkArgument
argument_list|(
name|limitSize
operator|>=
literal|0
argument_list|,
literal|"limit is negative"
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|limit
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|limitSize
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|Spliterator
argument_list|<
name|T
argument_list|>
name|spliterator
argument_list|()
block|{
return|return
name|Streams
operator|.
name|stream
argument_list|(
name|iterable
argument_list|)
operator|.
name|limit
argument_list|(
name|limitSize
argument_list|)
operator|.
name|spliterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|/**    * Returns a view of the supplied iterable that wraps each generated {@link Iterator} through    * {@link Iterators#consumingIterator(Iterator)}.    *    *<p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will get entries from    * {@link Queue#remove()} since {@link Queue}'s iteration order is undefined. Calling {@link    * Iterator#hasNext()} on a generated iterator from the returned iterable may cause an item to be    * immediately dequeued for return on a subsequent call to {@link Iterator#next()}.    *    * @param iterable the iterable to wrap    * @return a view of the supplied iterable that wraps each generated iterator through {@link    *     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators    *     that return and consume the queue's elements in queue order    * @see Iterators#consumingIterator(Iterator)    * @since 2.0    */
end_comment

begin_expr_stmt
DECL|method|consumingIterable ( final Iterable<T> iterable)
unit|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|consumingIterable
argument_list|(
name|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
block|;
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Queue
operator|)
condition|?
operator|new
name|ConsumingQueueIterator
argument_list|<>
argument_list|(
operator|(
name|Queue
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
argument_list|)
else|:
name|Iterators
operator|.
name|consumingIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
expr|@
name|Override
specifier|public
name|String
name|toString
argument_list|()
block|{
return|return
literal|"Iterables.consumingIterable(...)"
return|;
block|}
end_expr_stmt

begin_comment
unit|};   }
comment|// Methods only in Iterables, not in Iterators
end_comment

begin_comment
comment|/**    * Determines if the given iterable contains no elements.    *    *<p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an    * iterator whether it has any elements<i>remaining</i> (which one does using {@link    * Iterator#hasNext}).    *    *<p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}    *    * @return {@code true} if the iterable contains no elements    */
end_comment

begin_function
DECL|method|isEmpty (Iterable<?> iterable)
unit|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
return|return
operator|!
name|iterable
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries    * will not be de-duplicated.    *    *<p>Callers must ensure that the source {@code iterables} are in non-descending order as this    * method does not sort its input.    *    *<p>For any equivalent elements across all {@code iterables}, it is undefined which element is    * returned first.    *    * @since 11.0    */
end_comment

begin_annotation
annotation|@
name|Beta
end_annotation

begin_expr_stmt
DECL|method|mergeSorted ( final Iterable<? extends Iterable<? extends T>> iterables, final Comparator<? super T> comparator)
specifier|public
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|mergeSorted
argument_list|(
name|final
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterables
operator|,
name|final
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|comparator
argument_list|)
block|{
name|checkNotNull
argument_list|(
name|iterables
argument_list|,
literal|"iterables"
argument_list|)
block|;
name|checkNotNull
argument_list|(
name|comparator
argument_list|,
literal|"comparator"
argument_list|)
block|;
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
operator|=
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|mergeSorted
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|iterables
argument_list|,
name|Iterables
operator|.
expr|<
name|T
operator|>
name|toIterator
argument_list|()
argument_list|)
argument_list|,
name|comparator
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
unit|};
return|return
operator|new
name|UnmodifiableIterable
argument_list|<>
argument_list|(
name|iterable
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// TODO(user): Is this the best place for this? Move to fluent functions?
end_comment

begin_comment
comment|// Useful as a public method?
end_comment

begin_expr_stmt
unit|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
DECL|method|toIterator ()
name|Function
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|toIterator
argument_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|apply
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|iterable
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
empty_stmt|;
block|}
end_expr_stmt

unit|}
end_unit

