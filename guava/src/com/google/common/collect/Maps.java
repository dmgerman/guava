begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|compose
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|in
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
operator|.
name|MapJoiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapDifference
operator|.
name|ValueDifference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Map} instances (including instances of  * {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts  * {@link Lists}, {@link Sets} and {@link Queues}.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Maps">  * {@code Maps}</a>.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Isaac Shum  * @author Louis Wasserman  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Maps
specifier|public
specifier|final
class|class
name|Maps
block|{
DECL|method|Maps ()
specifier|private
name|Maps
parameter_list|()
block|{}
DECL|enum|EntryFunction
specifier|private
enum|enum
name|EntryFunction
implements|implements
name|Function
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|KEY
name|KEY
block|{
annotation|@
name|Override
annotation|@
name|Nullable
specifier|public
name|Object
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|VALUE
name|VALUE
block|{
annotation|@
name|Override
annotation|@
name|Nullable
specifier|public
name|Object
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
block|;   }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|keyFunction ()
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|()
block|{
return|return
operator|(
name|Function
operator|)
name|EntryFunction
operator|.
name|KEY
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|valueFunction ()
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|()
block|{
return|return
operator|(
name|Function
operator|)
name|EntryFunction
operator|.
name|VALUE
return|;
block|}
DECL|method|keyIterator (Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|K
argument_list|>
name|keyIterator
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|entryIterator
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyFunction
argument_list|()
argument_list|)
return|;
block|}
DECL|method|valueIterator (Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|V
argument_list|>
name|valueIterator
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|entryIterator
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valueFunction
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable map instance containing the given entries.    * Internally, the returned map will be backed by an {@link EnumMap}.    *    *<p>The iteration order of the returned map follows the enum's iteration    * order, not the order in which the elements appear in the given map.    *    * @param map the map to make an immutable copy of    * @return an immutable map containing those entries    * @since 14.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
annotation|@
name|Beta
DECL|method|immutableEnumMap ( Map<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|immutableEnumMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|ImmutableEnumMap
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe covariant cast
name|ImmutableEnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
operator|(
name|ImmutableEnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|map
decl_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|map
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableMap
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|checkNotNull
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableEnumMap
operator|.
name|asImmutable
argument_list|(
operator|new
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code HashMap} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#of()} instead.    *    *<p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link    * #newEnumMap} instead.    *    * @return a new, empty {@code HashMap}    */
DECL|method|newHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|()
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code HashMap} instance, with a high enough "initial capacity"    * that it<i>should</i> hold {@code expectedSize} elements without growth.    * This behavior cannot be broadly guaranteed, but it is observed to be true    * for OpenJDK 1.6. It also can't be guaranteed that the method isn't    * inadvertently<i>oversizing</i> the returned map.    *    * @param expectedSize the number of elements you expect to add to the    *        returned map    * @return a new, empty {@code HashMap} with enough capacity to hold {@code    *         expectedSize} elements without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|newHashMapWithExpectedSize ( int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMapWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a capacity that is sufficient to keep the map from being resized as    * long as it grows no larger than expectedSize and the load factor is>= its    * default (0.75).    */
DECL|method|capacity (int expectedSize)
specifier|static
name|int
name|capacity
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
if|if
condition|(
name|expectedSize
operator|<
literal|3
condition|)
block|{
name|checkNonnegative
argument_list|(
name|expectedSize
argument_list|,
literal|"expectedSize"
argument_list|)
expr_stmt|;
return|return
name|expectedSize
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|expectedSize
operator|<
name|Ints
operator|.
name|MAX_POWER_OF_TWO
condition|)
block|{
comment|// This is the calculation used in JDK8 to resize when a putAll
comment|// happens; it seems to be the most conservative calculation we
comment|// can make.  0,75 is the default load factor.
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|expectedSize
operator|/
literal|0.75F
operator|+
literal|1.0F
argument_list|)
return|;
block|}
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
comment|// any large value
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashMap} instance with the same mappings as    * the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#copyOf(Map)} instead.    *    *<p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link    * #newEnumMap} instead.    *    * @param map the mappings to be placed in the new map    * @return a new {@code HashMap} initialized with the mappings from {@code    *         map}    */
DECL|method|newHashMap ( Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}    * instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#of()} instead.    *    * @return a new, empty {@code LinkedHashMap}    */
DECL|method|newLinkedHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance    * with the same mappings as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#copyOf(Map)} instead.    *    * @param map the mappings to be placed in the new map    * @return a new, {@code LinkedHashMap} initialized with the mappings from    *         {@code map}    */
DECL|method|newLinkedHashMap ( Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Returns a general-purpose instance of {@code ConcurrentMap}, which supports    * all optional operations of the ConcurrentMap interface. It does not permit    * null keys or values. It is serializable.    *    *<p>This is currently accomplished by calling {@link MapMaker#makeMap()}.    *    *<p>It is preferable to use {@code MapMaker} directly (rather than through    * this method), as it presents numerous useful configuration options,    * such as the concurrency level, load factor, key/value reference types,    * and value computation.    *    * @return a new, empty {@code ConcurrentMap}    * @since 3.0    */
DECL|method|newConcurrentMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newConcurrentMap
parameter_list|()
block|{
return|return
operator|new
name|MapMaker
argument_list|()
operator|.
operator|<
name|K
operator|,
name|V
operator|>
name|makeMap
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the natural    * ordering of its elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedMap#of()} instead.    *    * @return a new, empty {@code TreeMap}    */
DECL|method|newTreeMap ()
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code TreeMap} instance with the same mappings as    * the specified map and using the same ordering as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.    *    * @param map the sorted map whose mappings are to be placed in the new map    *        and whose comparator is to be used to sort the new map    * @return a new {@code TreeMap} initialized with the mappings from {@code    *         map} and using the comparator of {@code map}    */
DECL|method|newTreeMap (SortedMap<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the given    * comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedMap.orderedBy(comparator).build()} instead.    *    * @param comparator the comparator to sort the keys with    * @return a new, empty {@code TreeMap}    */
DECL|method|newTreeMap ( @ullable Comparator<C> comparator)
specifier|public
specifier|static
parameter_list|<
name|C
parameter_list|,
name|K
extends|extends
name|C
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|C
argument_list|>
name|comparator
parameter_list|)
block|{
comment|// Ideally, the extra type parameter "C" shouldn't be necessary. It is a
comment|// work-around of a compiler type inference quirk that prevents the
comment|// following code from being compiled:
comment|// Comparator<Class<?>> comparator = null;
comment|// Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumMap} instance.    *    * @param type the key type for this map    * @return a new, empty {@code EnumMap}    */
DECL|method|newEnumMap (Class<K> type)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Class
argument_list|<
name|K
argument_list|>
name|type
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumMap} with the same mappings as the specified map.    *    * @param map the map from which to initialize this {@code EnumMap}    * @return a new {@code EnumMap} initialized with the mappings from {@code    *         map}    * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}    *         instance and contains no mappings    */
DECL|method|newEnumMap ( Map<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code IdentityHashMap} instance.    *    * @return a new, empty {@code IdentityHashMap}    */
DECL|method|newIdentityHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|IdentityHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newIdentityHashMap
parameter_list|()
block|{
return|return
operator|new
name|IdentityHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Computes the difference between two maps. This difference is an immutable    * snapshot of the state of the maps at the time this method is called. It    * will never change, even if the maps change at a later time.    *    *<p>Since this method uses {@code HashMap} instances internally, the keys of    * the supplied maps must be well-behaved with respect to    * {@link Object#equals} and {@link Object#hashCode}.    *    *<p><b>Note:</b>If you only need to know whether two maps have the same    * mappings, call {@code left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|difference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|SortedMap
condition|)
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|sortedLeft
init|=
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
operator|)
name|left
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|difference
argument_list|(
name|sortedLeft
argument_list|,
name|right
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
return|return
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|Equivalence
operator|.
name|equals
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Computes the difference between two maps. This difference is an immutable    * snapshot of the state of the maps at the time this method is called. It    * will never change, even if the maps change at a later time.    *    *<p>Values are compared using a provided equivalence, in the case of    * equality, the value on the 'left' is returned in the difference.    *    *<p>Since this method uses {@code HashMap} instances internally, the keys of    * the supplied maps must be well-behaved with respect to    * {@link Object#equals} and {@link Object#hashCode}.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @param valueEquivalence the equivalence relationship to use to compare    *    values    * @return the difference between the two maps    * @since 10.0    */
annotation|@
name|Beta
DECL|method|difference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|,
name|Equivalence
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueEquivalence
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|valueEquivalence
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|right
argument_list|)
decl_stmt|;
comment|// will whittle it down
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|doDifference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|valueEquivalence
argument_list|,
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
return|return
operator|new
name|MapDifferenceImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
return|;
block|}
DECL|method|doDifference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence, Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, MapDifference.ValueDifference<V>> differences)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|doDifference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|,
name|Equivalence
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueEquivalence
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|left
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|K
name|leftKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|leftValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|right
operator|.
name|containsKey
argument_list|(
name|leftKey
argument_list|)
condition|)
block|{
name|V
name|rightValue
init|=
name|onlyOnRight
operator|.
name|remove
argument_list|(
name|leftKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
condition|)
block|{
name|onBoth
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|differences
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|onlyOnLeft
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|unmodifiableMap (Map<K, V> map)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
DECL|class|MapDifferenceImpl
specifier|static
class|class
name|MapDifferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|onlyOnLeft
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
decl_stmt|;
DECL|field|onlyOnRight
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
decl_stmt|;
DECL|field|onBoth
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
decl_stmt|;
DECL|field|differences
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
decl_stmt|;
DECL|method|MapDifferenceImpl (Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, ValueDifference<V>> differences)
name|MapDifferenceImpl
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
name|this
operator|.
name|onlyOnLeft
operator|=
name|unmodifiableMap
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlyOnRight
operator|=
name|unmodifiableMap
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
name|this
operator|.
name|onBoth
operator|=
name|unmodifiableMap
argument_list|(
name|onBoth
argument_list|)
expr_stmt|;
name|this
operator|.
name|differences
operator|=
name|unmodifiableMap
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|areEqual ()
specifier|public
name|boolean
name|areEqual
parameter_list|()
block|{
return|return
name|onlyOnLeft
operator|.
name|isEmpty
argument_list|()
operator|&&
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
operator|&&
name|differences
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnLeft ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnLeft
parameter_list|()
block|{
return|return
name|onlyOnLeft
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnRight ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnRight
parameter_list|()
block|{
return|return
name|onlyOnRight
return|;
block|}
annotation|@
name|Override
DECL|method|entriesInCommon ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesInCommon
parameter_list|()
block|{
return|return
name|onBoth
return|;
block|}
annotation|@
name|Override
DECL|method|entriesDiffering ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|entriesDiffering
parameter_list|()
block|{
return|return
name|differences
return|;
block|}
DECL|method|equals (Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
condition|)
block|{
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|other
init|=
operator|(
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
operator|&&
name|entriesOnlyOnRight
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
operator|&&
name|entriesInCommon
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
operator|&&
name|entriesDiffering
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|entriesOnlyOnLeft
argument_list|()
argument_list|,
name|entriesOnlyOnRight
argument_list|()
argument_list|,
name|entriesInCommon
argument_list|()
argument_list|,
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|areEqual
argument_list|()
condition|)
block|{
return|return
literal|"equal"
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"not equal"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onlyOnLeft
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on left="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on right="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|differences
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": value differences="
argument_list|)
operator|.
name|append
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|ValueDifferenceImpl
specifier|static
class|class
name|ValueDifferenceImpl
parameter_list|<
name|V
parameter_list|>
implements|implements
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
block|{
DECL|field|left
specifier|private
specifier|final
name|V
name|left
decl_stmt|;
DECL|field|right
specifier|private
specifier|final
name|V
name|right
decl_stmt|;
DECL|method|create (@ullable V left, @Nullable V right)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ValueDifference
argument_list|<
name|V
argument_list|>
name|create
parameter_list|(
annotation|@
name|Nullable
name|V
name|left
parameter_list|,
annotation|@
name|Nullable
name|V
name|right
parameter_list|)
block|{
return|return
operator|new
name|ValueDifferenceImpl
argument_list|<
name|V
argument_list|>
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
DECL|method|ValueDifferenceImpl (@ullable V left, @Nullable V right)
specifier|private
name|ValueDifferenceImpl
parameter_list|(
annotation|@
name|Nullable
name|V
name|left
parameter_list|,
annotation|@
name|Nullable
name|V
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|leftValue ()
specifier|public
name|V
name|leftValue
parameter_list|()
block|{
return|return
name|left
return|;
block|}
annotation|@
name|Override
DECL|method|rightValue ()
specifier|public
name|V
name|rightValue
parameter_list|()
block|{
return|return
name|right
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
operator|.
name|ValueDifference
condition|)
block|{
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|left
argument_list|,
name|that
operator|.
name|leftValue
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|right
argument_list|,
name|that
operator|.
name|rightValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"("
operator|+
name|left
operator|+
literal|", "
operator|+
name|right
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Computes the difference between two sorted maps, using the comparator of    * the left map, or {@code Ordering.natural()} if the left map uses the    * natural ordering of its elements. This difference is an immutable snapshot    * of the state of the maps at the time this method is called. It will never    * change, even if the maps change at a later time.    *    *<p>Since this method uses {@code TreeMap} instances internally, the keys of    * the right map must all compare as distinct according to the comparator    * of the left map.    *    *<p><b>Note:</b>If you only need to know whether two sorted maps have the    * same mappings, call {@code left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    * @since 11.0    */
DECL|method|difference ( SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
init|=
name|orNaturalOrder
argument_list|(
name|left
operator|.
name|comparator
argument_list|()
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|onlyOnRight
operator|.
name|putAll
argument_list|(
name|right
argument_list|)
expr_stmt|;
comment|// will whittle it down
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|doDifference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|Equivalence
operator|.
name|equals
argument_list|()
argument_list|,
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
return|return
operator|new
name|SortedMapDifferenceImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
return|;
block|}
DECL|class|SortedMapDifferenceImpl
specifier|static
class|class
name|SortedMapDifferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapDifferenceImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SortedMapDifferenceImpl (SortedMap<K, V> onlyOnLeft, SortedMap<K, V> onlyOnRight, SortedMap<K, V> onBoth, SortedMap<K, ValueDifference<V>> differences)
name|SortedMapDifferenceImpl
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
name|super
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
block|}
DECL|method|entriesDiffering ()
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|entriesDiffering
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|entriesDiffering
argument_list|()
return|;
block|}
DECL|method|entriesInCommon ()
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesInCommon
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesInCommon
argument_list|()
return|;
block|}
DECL|method|entriesOnlyOnLeft ()
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnLeft
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesOnlyOnLeft
argument_list|()
return|;
block|}
DECL|method|entriesOnlyOnRight ()
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnRight
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesOnlyOnRight
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the specified comparator if not null; otherwise returns {@code    * Ordering.natural()}. This method is an abomination of generics; the only    * purpose of this method is to contain the ugly type-casting in one place.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|orNaturalOrder ( @ullable Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|orNaturalOrder
parameter_list|(
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|!=
literal|null
condition|)
block|{
comment|// can't use ? : because of javac bug 5080917
return|return
name|comparator
return|;
block|}
return|return
operator|(
name|Comparator
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
return|;
block|}
comment|/**    * Returns a live {@link Map} view whose keys are the contents of {@code set}    * and whose values are computed on demand using {@code function}. To get an    * immutable<i>copy</i> instead, use {@link #toMap(Iterable, Function)}.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code    * keySet}, {@code values}, and {@code entrySet} views of the returned map    * iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map.    * The returned map supports removal operations if the backing set does.    * Removal operations write through to the backing set.  The returned map    * does not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is    * required to make sure the set does not contain {@code null}, because the    * view cannot stop {@code null} from being added to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also    * of type {@code K}. Using a key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling    * methods on the resulting map view.    *    * @since 14.0    */
annotation|@
name|Beta
DECL|method|asMap ( Set<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|set
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|asMap
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|AsMapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a view of the sorted set as a map, mapping keys from the set    * according to the specified function.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code    * keySet}, {@code values}, and {@code entrySet} views of the returned map    * iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map.    * The returned map supports removal operations if the backing set does.    * Removal operations write through to the backing set.  The returned map does    * not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is    * required to make sure the set does not contain {@code null}, because the    * view cannot stop {@code null} from being added to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using a key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling    * methods on the resulting map view.    *    * @since 14.0    */
annotation|@
name|Beta
DECL|method|asMap ( SortedSet<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|SortedSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|Platform
operator|.
name|mapsAsMapSortedSet
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
DECL|method|asMapSortedIgnoreNavigable (SortedSet<K> set, Function<? super K, V> function)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMapSortedIgnoreNavigable
parameter_list|(
name|SortedSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**    * Returns a view of the navigable set as a map, mapping keys from the set    * according to the specified function.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code    * keySet}, {@code values}, and {@code entrySet} views of the returned map    * iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map.    * The returned map supports removal operations if the backing set does.    * Removal operations write through to the backing set.  The returned map    * does not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is    * required to make sure the set does not contain {@code null}, because the    * view cannot stop {@code null} from being added to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also    * of type {@code K}. Using a key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling    * methods on the resulting map view.    *    * @since 14.0    */
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|asMap ( NavigableSet<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
DECL|class|AsMapView
specifier|private
specifier|static
class|class
name|AsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|set
specifier|private
specifier|final
name|Set
argument_list|<
name|K
argument_list|>
name|set
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
decl_stmt|;
DECL|method|backingSet ()
name|Set
argument_list|<
name|K
argument_list|>
name|backingSet
parameter_list|()
block|{
return|return
name|set
return|;
block|}
DECL|method|AsMapView (Set<K> set, Function<? super K, V> function)
name|AsMapView
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|set
operator|=
name|checkNotNull
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|removeOnlySet
argument_list|(
name|backingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|contains
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|Collections2
operator|.
name|safeContains
argument_list|(
name|backingSet
argument_list|()
argument_list|,
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|backingSet
argument_list|()
operator|.
name|remove
argument_list|(
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|backingSet
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMapView
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asMapEntryIterator
argument_list|(
name|backingSet
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
DECL|method|asMapEntryIterator ( Set<K> set, final Function<? super K, V> function)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|asMapEntryIterator
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|K
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|set
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|transform
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|class|SortedAsMapView
specifier|private
specifier|static
class|class
name|SortedAsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AsMapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SortedAsMapView (SortedSet<K> set, Function<? super K, V> function)
name|SortedAsMapView
parameter_list|(
name|SortedSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|backingSet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|backingSet
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|backingSet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|backingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|headSet
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|first
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|last
argument_list|()
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|NavigableAsMapView
specifier|private
specifier|static
specifier|final
class|class
name|NavigableAsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/*      * Using AbstractNavigableMap is simpler than extending SortedAsMapView and rewriting all the      * NavigableMap methods.      */
DECL|field|set
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|set
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
decl_stmt|;
DECL|method|NavigableAsMapView (NavigableSet<K> ks, Function<? super K, V> vFunction)
name|NavigableAsMapView
parameter_list|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|ks
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|vFunction
parameter_list|)
block|{
name|this
operator|.
name|set
operator|=
name|checkNotNull
argument_list|(
name|ks
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|vFunction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|subSet
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|headSet
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|tailSet
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|set
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|Collections2
operator|.
name|safeContains
argument_list|(
name|set
argument_list|,
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|set
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|asMapEntryIterator
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
return|return
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|set
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|set
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|descendingSet
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
DECL|method|removeOnlySet (final Set<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|removeOnlySet
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
DECL|method|removeOnlySortedSet (final SortedSet<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
name|removeOnlySortedSet
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingSortedSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SortedSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|method|removeOnlyNavigableSet (final NavigableSet<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|removeOnlyNavigableSet
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|descendingSet
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an immutable map whose keys are the distinct elements of {@code    * keys} and whose value for each key was computed by {@code valueFunction}.    * The map's iteration order is the order of the first appearance of each key    * in {@code keys}.    *    *<p>If {@code keys} is a {@link Set}, a live view can be obtained instead of    * a copy using {@link Maps#asMap(Set, Function)}.    *    * @throws NullPointerException if any element of {@code keys} is    *     {@code null}, or if {@code valueFunction} produces {@code null}    *     for any key    * @since 14.0    */
annotation|@
name|Beta
DECL|method|toMap (Iterable<K> keys, Function<? super K, V> valueFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toMap
parameter_list|(
name|Iterable
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|)
block|{
return|return
name|toMap
argument_list|(
name|keys
operator|.
name|iterator
argument_list|()
argument_list|,
name|valueFunction
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable map whose keys are the distinct elements of {@code    * keys} and whose value for each key was computed by {@code valueFunction}.    * The map's iteration order is the order of the first appearance of each key    * in {@code keys}.    *    * @throws NullPointerException if any element of {@code keys} is    *     {@code null}, or if {@code valueFunction} produces {@code null}    *     for any key    * @since 14.0    */
annotation|@
name|Beta
DECL|method|toMap (Iterator<K> keys, Function<? super K, V> valueFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toMap
parameter_list|(
name|Iterator
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|valueFunction
argument_list|)
expr_stmt|;
comment|// Using LHM instead of a builder so as not to fail on duplicate keys
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
while|while
condition|(
name|keys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|K
name|key
init|=
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|valueFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|builder
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable map for which the {@link Map#values} are the given    * elements in the given order, and each key is the product of invoking a    * supplied function on its corresponding value.    *    * @param values the values to use when constructing the {@code Map}    * @param keyFunction the function used to produce the key for each value    * @return a map mapping the result of evaluating the function {@code    *         keyFunction} on each value in the input collection to that value    * @throws IllegalArgumentException if {@code keyFunction} produces the same    *         key for more than one value in the input collection    * @throws NullPointerException if any elements of {@code values} is null, or    *         if {@code keyFunction} produces {@code null} for any value    */
DECL|method|uniqueIndex ( Iterable<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|uniqueIndex
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
comment|// TODO(user): consider presizing the builder if values is a Collection
return|return
name|uniqueIndex
argument_list|(
name|values
operator|.
name|iterator
argument_list|()
argument_list|,
name|keyFunction
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable map for which the {@link Map#values} are the given    * elements in the given order, and each key is the product of invoking a    * supplied function on its corresponding value.    *    * @param values the values to use when constructing the {@code Map}    * @param keyFunction the function used to produce the key for each value    * @return a map mapping the result of evaluating the function {@code    *         keyFunction} on each value in the input collection to that value    * @throws IllegalArgumentException if {@code keyFunction} produces the same    *         key for more than one value in the input collection    * @throws NullPointerException if any elements of {@code values} is null, or    *         if {@code keyFunction} produces {@code null} for any value    * @since 10.0    */
DECL|method|uniqueIndex ( Iterator<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|uniqueIndex
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|V
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code ImmutableMap<String, String>} from a {@code Properties}    * instance. Properties normally derive from {@code Map<Object, Object>}, but    * they typically contain strings, which is awkward. This method lets you get    * a plain-old-{@code Map} out of a {@code Properties}.    *    * @param properties a {@code Properties} object to be converted    * @return an immutable map containing all the entries in {@code properties}    * @throws ClassCastException if any key in {@code Properties} is not a {@code    *         String}    * @throws NullPointerException if any key or value in {@code Properties} is    *         null    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.Properties"
argument_list|)
DECL|method|fromProperties ( Properties properties)
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fromProperties
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|?
argument_list|>
name|e
init|=
name|properties
operator|.
name|propertyNames
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|properties
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable map entry with the specified key and value. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.    *    *<p>The returned entry is serializable.    *    * @param key the key to be associated with the returned entry    * @param value the value to be associated with the returned entry    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEntry ( @ullable K key, @Nullable V value)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|immutableEntry
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|ImmutableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified set of entries. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException},    * as do any operations that would modify the returned set.    *    * @param entrySet the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
DECL|method|unmodifiableEntrySet ( Set<Entry<K, V>> entrySet)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableEntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|entrySet
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified map entry. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.    * This also has the side-effect of redefining {@code equals} to comply with    * the Entry contract, to avoid a possible nefarious implementation of equals.    *    * @param entry the entry for which to return an unmodifiable view    * @return an unmodifiable view of the entry    */
DECL|method|unmodifiableEntry (final Entry<? extends K, ? extends V> entry)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableEntry
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|unmodifiableEntryIterator ( final Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntryIterator
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableEntry
argument_list|(
name|entryIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** @see Multimaps#unmodifiableEntries */
DECL|class|UnmodifiableEntries
specifier|static
class|class
name|UnmodifiableEntries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|entries
specifier|private
specifier|final
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|method|UnmodifiableEntries (Collection<Entry<K, V>> entries)
name|UnmodifiableEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|this
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|unmodifiableEntryIterator
argument_list|(
name|entries
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|standardToArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|standardToArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
comment|/** @see Maps#unmodifiableEntrySet(Set) */
DECL|class|UnmodifiableEntrySet
specifier|static
class|class
name|UnmodifiableEntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|UnmodifiableEntrySet (Set<Entry<K, V>> entries)
name|UnmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|super
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|Sets
operator|.
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},    * and whose inverse view converts values using    * {@link BiMap#inverse bimap.inverse()}{@code .get()}.    *    *<p>To use a plain {@link Map} as a {@link Function}, see    * {@link com.google.common.base.Functions#forMap(Map)} or    * {@link com.google.common.base.Functions#forMap(Map, Object)}.    *    * @since 16.0    */
annotation|@
name|Beta
DECL|method|asConverter (final BiMap<A, B> bimap)
specifier|public
specifier|static
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
name|Converter
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|asConverter
parameter_list|(
specifier|final
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
operator|new
name|BiMapConverter
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
argument_list|(
name|bimap
argument_list|)
return|;
block|}
DECL|class|BiMapConverter
specifier|private
specifier|static
specifier|final
class|class
name|BiMapConverter
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
extends|extends
name|Converter
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|bimap
specifier|private
specifier|final
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
decl_stmt|;
DECL|method|BiMapConverter (BiMap<A, B> bimap)
name|BiMapConverter
parameter_list|(
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
parameter_list|)
block|{
name|this
operator|.
name|bimap
operator|=
name|checkNotNull
argument_list|(
name|bimap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doForward (A a)
specifier|protected
name|B
name|doForward
parameter_list|(
name|A
name|a
parameter_list|)
block|{
return|return
name|convert
argument_list|(
name|bimap
argument_list|,
name|a
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doBackward (B b)
specifier|protected
name|A
name|doBackward
parameter_list|(
name|B
name|b
parameter_list|)
block|{
return|return
name|convert
argument_list|(
name|bimap
operator|.
name|inverse
argument_list|()
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|convert (BiMap<X, Y> bimap, X input)
specifier|private
specifier|static
parameter_list|<
name|X
parameter_list|,
name|Y
parameter_list|>
name|Y
name|convert
parameter_list|(
name|BiMap
argument_list|<
name|X
argument_list|,
name|Y
argument_list|>
name|bimap
parameter_list|,
name|X
name|input
parameter_list|)
block|{
name|Y
name|output
init|=
name|bimap
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|output
operator|!=
literal|null
argument_list|,
literal|"No non-null mapping present for input: %s"
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullable Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|instanceof
name|BiMapConverter
condition|)
block|{
name|BiMapConverter
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|BiMapConverter
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|bimap
operator|.
name|equals
argument_list|(
name|that
operator|.
name|bimap
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|bimap
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// There's really no good way to implement toString() without printing the entire BiMap, right?
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Maps.asConverter("
operator|+
name|bimap
operator|+
literal|")"
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0L
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) bimap backed by the specified bimap.    * In order to guarantee serial access, it is critical that<b>all</b> access    * to the backing bimap is accomplished through the returned bimap.    *    *<p>It is imperative that the user manually synchronize on the returned map    * when accessing any of its collection views:<pre>   {@code    *    *   BiMap<Long, String> map = Maps.synchronizedBiMap(    *       HashBiMap.<Long, String>create());    *   ...    *   Set<Long> set = map.keySet();  // Needn't be in synchronized block    *   ...    *   synchronized (map) {  // Synchronizing on map, not set!    *     Iterator<Long> it = set.iterator(); // Must be in synchronized block    *     while (it.hasNext()) {    *       foo(it.next());    *     }    *   }}</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned bimap will be serializable if the specified bimap is    * serializable.    *    * @param bimap the bimap to be wrapped in a synchronized view    * @return a sychronized view of the specified bimap    */
DECL|method|synchronizedBiMap (BiMap<K, V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|biMap
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified bimap. This method allows    * modules to provide users with "read-only" access to internal bimaps. Query    * operations on the returned bimap "read through" to the specified bimap, and    * attempts to modify the returned map, whether direct or via its collection    * views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned bimap will be serializable if the specified bimap is    * serializable.    *    * @param bimap the bimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified bimap    */
DECL|method|unmodifiableBiMap ( BiMap<? extends K, ? extends V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** @see Maps#unmodifiableBiMap(BiMap) */
DECL|class|UnmodifiableBiMap
specifier|private
specifier|static
class|class
name|UnmodifiableBiMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|unmodifiableMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMap
decl_stmt|;
DECL|field|delegate
specifier|final
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|inverse
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
decl_stmt|;
DECL|field|values
specifier|transient
name|Set
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|UnmodifiableBiMap (BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse)
name|UnmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|)
block|{
name|unmodifiableMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|inverse
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableMap
return|;
block|}
annotation|@
name|Override
DECL|method|forcePut (K key, V value)
specifier|public
name|V
name|forcePut
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|inverse ()
specifier|public
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|()
block|{
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|result
init|=
name|inverse
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|inverse
operator|=
operator|new
name|UnmodifiableBiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|(
name|delegate
operator|.
name|inverse
argument_list|()
argument_list|,
name|this
argument_list|)
else|:
name|result
return|;
block|}
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a view of a map where each value is transformed by a function. All    * other properties of the map, such as iteration order, are left intact. For    * example, the code:<pre>   {@code    *    *   Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    */
DECL|method|transformValues ( Map<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a sorted map where each value is transformed by a    * function. All other properties of the map, such as iteration order, are    * left intact. For example, the code:<pre>   {@code    *    *   SortedMap<String, Integer> map = ImmutableSortedMap.of("a", 4, "b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   SortedMap<String, Double> transformed =    *        Maps.transformValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    *    * @since 11.0    */
DECL|method|transformValues ( SortedMap<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a navigable map where each value is transformed by a    * function. All other properties of the map, such as iteration order, are    * left intact.  For example, the code:<pre>   {@code    *    *   NavigableMap<String, Integer> map = Maps.newTreeMap();    *   map.put("a", 4);    *   map.put("b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   NavigableMap<String, Double> transformed =    *        Maps.transformNavigableValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    * Changes in the underlying map are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    *    * @since 13.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|transformValues ( NavigableMap<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a map whose values are derived from the original map's    * entries. In contrast to {@link #transformValues}, this method's    * entry-transformation logic may depend on the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   Map<String, Boolean> options =    *       ImmutableMap.of("verbose", true, "sort", false);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : "no" + key;    *         }    *       };    *   Map<String, String> transformed =    *       Maps.transformEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {verbose=verbose, sort=nosort}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *    * @since 7.0    */
DECL|method|transformEntries ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
if|if
condition|(
name|fromMap
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|transformEntries
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
return|return
operator|new
name|TransformedEntriesMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a sorted map whose values are derived from the original    * sorted map's entries. In contrast to {@link #transformValues}, this    * method's entry-transformation logic may depend on the key as well as the    * value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   Map<String, Boolean> options =    *       ImmutableSortedMap.of("verbose", true, "sort", false);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : "yes" + key;    *         }    *       };    *   SortedMap<String, String> transformed =    *       Maps.transformEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *    * @since 11.0    */
DECL|method|transformEntries ( SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
name|Platform
operator|.
name|mapsTransformEntriesSortedMap
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a navigable map whose values are derived from the    * original navigable map's entries. In contrast to {@link    * #transformValues}, this method's entry-transformation logic may    * depend on the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   NavigableMap<String, Boolean> options = Maps.newTreeMap();    *   options.put("verbose", false);    *   options.put("sort", true);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : ("yes" + key);    *         }    *       };    *   NavigableMap<String, String> transformed =    *       LabsMaps.transformNavigableEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *    * @since 13.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|transformEntries ( final NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesNavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|transformEntriesIgnoreNavigable ( SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntriesIgnoreNavigable
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesSortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * A transformation of the value of a key-value pair, using both key and value    * as inputs. To apply the transformation to a map, use    * {@link Maps#transformEntries(Map, EntryTransformer)}.    *    * @param<K> the key type of the input and output entries    * @param<V1> the value type of the input entry    * @param<V2> the value type of the output entry    * @since 7.0    */
DECL|interface|EntryTransformer
specifier|public
interface|interface
name|EntryTransformer
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
block|{
comment|/**      * Determines an output value based on a key-value pair. This method is      *<i>generally expected</i>, but not absolutely required, to have the      * following properties:      *      *<ul>      *<li>Its execution does not cause any observable side effects.      *<li>The computation is<i>consistent with equals</i>; that is,      *     {@link Objects#equal Objects.equal}{@code (k1, k2)&&}      *     {@link Objects#equal}{@code (v1, v2)} implies that {@code      *     Objects.equal(transformer.transform(k1, v1),      *     transformer.transform(k2, v2))}.      *</ul>      *      * @throws NullPointerException if the key or value is null and this      *     transformer does not accept null arguments      */
DECL|method|transformEntry (@ullable K key, @Nullable V1 value)
name|V2
name|transformEntry
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V1
name|value
parameter_list|)
function_decl|;
block|}
comment|/**    * Views a function as an entry transformer that ignores the entry key.    */
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
DECL|method|asEntryTransformer (final Function<? super V1, V2> function)
name|asEntryTransformer
parameter_list|(
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|asValueToValueFunction ( final EntryTransformer<? super K, V1, V2> transformer, final K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
name|asValueToValueFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|,
specifier|final
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
annotation|@
name|Nullable
name|V1
name|v1
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|key
argument_list|,
name|v1
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Views an entry transformer as a function from {@code Entry} to values.    */
DECL|method|asEntryToValueFunction ( final EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|V2
argument_list|>
name|asEntryToValueFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of an entry transformed by the specified transformer.    */
DECL|method|transformEntry ( final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry)
specifier|static
parameter_list|<
name|V2
parameter_list|,
name|K
parameter_list|,
name|V1
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntry
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|,
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V2
name|getValue
parameter_list|()
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Views an entry transformer as a function from entries to entries.    */
DECL|method|asEntryToEntryFunction ( final EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|asEntryToEntryFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|transformer
argument_list|,
name|entry
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|class|TransformedEntriesMap
specifier|static
class|class
name|TransformedEntriesMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|IteratorBasedAbstractMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
decl_stmt|;
DECL|field|transformer
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
decl_stmt|;
DECL|method|TransformedEntriesMap ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|fromMap
operator|=
name|checkNotNull
argument_list|(
name|fromMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V2
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|V1
name|value
init|=
name|fromMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|||
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|value
argument_list|)
else|:
literal|null
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V2
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|fromMap
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|entryIterator ()
annotation|@
name|Override
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Maps
operator|.
expr|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
operator|>
name|asEntryToEntryFunction
argument_list|(
name|transformer
argument_list|)
argument_list|)
return|;
block|}
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
DECL|class|TransformedEntriesSortedMap
specifier|static
class|class
name|TransformedEntriesSortedMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|fromMap ()
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|fromMap
return|;
block|}
DECL|method|TransformedEntriesSortedMap (SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesSortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|comparator ()
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
DECL|method|firstKey ()
annotation|@
name|Override
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|lastKey ()
annotation|@
name|Override
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|TransformedEntriesNavigableMap
specifier|private
specifier|static
class|class
name|TransformedEntriesNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesSortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|TransformedEntriesNavigableMap (NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|ceilingEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ceilingKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|descendingKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
return|;
block|}
DECL|method|descendingMap ()
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|firstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|floorEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|floorKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|headMap (K toKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|higherEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|higherKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|lastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|lowerEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|lowerKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|navigableKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|method|pollFirstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|pollLastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Nullable
DECL|method|transformEntry (@ullable Entry<K, V1> entry)
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntry
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Maps
operator|.
name|transformEntry
argument_list|(
name|transformer
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|fromMap ()
annotation|@
name|Override
specifier|protected
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|super
operator|.
name|fromMap
argument_list|()
return|;
block|}
block|}
DECL|method|keyPredicateOnEntries (Predicate<? super K> keyPredicate)
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|>
name|keyPredicateOnEntries
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|keyPredicate
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyFunction
argument_list|()
argument_list|)
return|;
block|}
DECL|method|valuePredicateOnEntries (Predicate<? super V> valuePredicate)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
argument_list|>
name|valuePredicateOnEntries
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|valuePredicate
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valueFunction
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose keys    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a key that    * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}    * methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose keys satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    */
DECL|method|filterKeys ( Map<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|filterKeys
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|BiMap
condition|)
block|{
return|return
name|filterKeys
argument_list|(
operator|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|>
name|entryPredicate
init|=
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
decl_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredKeyMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|keyPredicate
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose    * keys satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a key that    * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}    * methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose keys satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    *    * @since 11.0    */
DECL|method|filterKeys ( SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
comment|// TODO(user): Return a subclass of Maps.FilteredKeyMap for slightly better
comment|// performance.
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a navigable map containing the mappings in {@code unfiltered} whose    * keys satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a key that    * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}    * methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose keys satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    *    * @since 14.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|filterKeys ( NavigableMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
comment|// TODO(user): Return a subclass of Maps.FilteredKeyMap for slightly better
comment|// performance.
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.    * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the    * bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code    * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in    * the underlying bimap and determine which satisfy the filter. When a live view is<i>not</i>    * needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as    * documented at {@link Predicate#apply}.    *    * @since 14.0    */
DECL|method|filterKeys ( BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose values    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a value    * that doesn't satisfy the predicate, the map's {@code put()}, {@code    * putAll()}, and {@link Entry#setValue} methods throw an {@link    * IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose values satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    */
DECL|method|filterValues ( Map<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|filterValues
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|valuePredicate
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|BiMap
condition|)
block|{
return|return
name|filterValues
argument_list|(
operator|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|valuePredicate
argument_list|)
return|;
block|}
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose    * values satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a value    * that doesn't satisfy the predicate, the map's {@code put()}, {@code    * putAll()}, and {@link Entry#setValue} methods throw an {@link    * IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose values satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    *    * @since 11.0    */
DECL|method|filterValues ( SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a navigable map containing the mappings in {@code unfiltered} whose    * values satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a value    * that doesn't satisfy the predicate, the map's {@code put()}, {@code    * putAll()}, and {@link Entry#setValue} methods throw an {@link    * IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose values satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    *    * @since 14.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|filterValues ( NavigableMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a    * predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the    * other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the    * bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's    * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method    * that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the    * predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in    * the underlying bimap and determine which satisfy the filter. When a live view is<i>not</i>    * needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as    * documented at {@link Predicate#apply}.    *    * @since 14.0    */
DECL|method|filterValues ( BiMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} that satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes    * to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a    * key/value pair that doesn't satisfy the predicate, the map's {@code put()}    * and {@code putAll()} methods throw an {@link IllegalArgumentException}.    * Similarly, the map's entries have a {@link Entry#setValue} method that    * throws an {@link IllegalArgumentException} when the existing key and the    * provided value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings that satisfy the filter    * will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}.    */
DECL|method|filterEntries ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|filterEntries
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|unfiltered
operator|instanceof
name|BiMap
condition|)
block|{
return|return
name|filterEntries
argument_list|(
operator|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} that    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a    * key/value pair that doesn't satisfy the predicate, the map's {@code put()}    * and {@code putAll()} methods throw an {@link IllegalArgumentException}.    * Similarly, the map's entries have a {@link Entry#setValue} method that    * throws an {@link IllegalArgumentException} when the existing key and the    * provided value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings that satisfy the filter    * will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}.    *    * @since 11.0    */
DECL|method|filterEntries ( SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
return|return
name|Platform
operator|.
name|mapsFilterSortedMap
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
DECL|method|filterSortedIgnoreNavigable ( SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterSortedIgnoreNavigable
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntrySortedMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} that    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a    * key/value pair that doesn't satisfy the predicate, the map's {@code put()}    * and {@code putAll()} methods throw an {@link IllegalArgumentException}.    * Similarly, the map's entries have a {@link Entry#setValue} method that    * throws an {@link IllegalArgumentException} when the existing key and the    * provided value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings that satisfy the filter    * will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}.    *    * @since 14.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|filterEntries ( NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntryNavigableMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The    * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the bimap    * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's    * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an    * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}    * method that throws an {@link IllegalArgumentException} when the existing key and the provided    * value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every    * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live    * view is<i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as    * documented at {@link Predicate#apply}.    *    * @since 14.0    */
DECL|method|filterEntries ( BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntryBiMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered map.    */
DECL|method|filterFiltered (AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|AbstractFilteredMap
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractFilteredMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|unfiltered
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
decl_stmt|;
DECL|method|AbstractFilteredMap ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate)
name|AbstractFilteredMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|apply (@ullable Object key, @Nullable V value)
name|boolean
name|apply
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
comment|// This method is called only when the key is in the map, implying that
comment|// key is a K.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|k
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|putAll (Map<? extends K, ? extends V> map)
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unfiltered
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|V
name|value
init|=
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|!=
literal|null
operator|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|)
condition|?
name|value
else|:
literal|null
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|unfiltered
operator|.
name|remove
argument_list|(
name|key
argument_list|)
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
operator|new
name|FilteredMapValues
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
DECL|class|FilteredMapValues
specifier|private
specifier|static
specifier|final
class|class
name|FilteredMapValues
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Maps
operator|.
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|unfiltered
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
decl_stmt|;
DECL|method|FilteredMapValues (Map<K, V> filteredMap, Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate)
name|FilteredMapValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filteredMap
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|filteredMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|predicate
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|equalTo
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|removeIf (Predicate<? super V> valuePredicate)
specifier|private
name|boolean
name|removeIf
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|removeIf
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|predicate
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|in
argument_list|(
name|collection
argument_list|)
argument_list|)
return|;
block|}
DECL|method|retainAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|not
argument_list|(
name|in
argument_list|(
name|collection
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
DECL|class|FilteredKeyMap
specifier|private
specifier|static
class|class
name|FilteredKeyMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|keyPredicate
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
decl_stmt|;
DECL|method|FilteredKeyMap (Map<K, V> unfiltered, Predicate<? super K> keyPredicate, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredKeyMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|keyPredicate
operator|=
name|keyPredicate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|keySet
argument_list|()
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
comment|// The cast is called only when the key is in the unfiltered map, implying
comment|// that key is a K.
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|keyPredicate
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
return|;
block|}
block|}
DECL|class|FilteredEntryMap
specifier|static
class|class
name|FilteredEntryMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Entries in this set satisfy the predicate, but they don't validate the      * input to {@code Entry.setValue()}.      */
DECL|field|filteredEntrySet
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|filteredEntrySet
decl_stmt|;
DECL|method|FilteredEntryMap ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntryMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|filteredEntrySet
operator|=
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|()
return|;
block|}
DECL|class|EntrySet
specifier|private
class|class
name|EntrySet
extends|extends
name|ForwardingSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|filteredEntrySet
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|filteredEntrySet
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|ForwardingMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|setValue
argument_list|(
name|newValue
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySet
argument_list|()
return|;
block|}
DECL|class|KeySet
class|class
name|KeySet
extends|extends
name|Maps
operator|.
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|KeySet ()
name|KeySet
parameter_list|()
block|{
name|super
argument_list|(
name|FilteredEntryMap
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|unfiltered
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|removeIf (Predicate<? super K> keyPredicate)
specifier|private
name|boolean
name|removeIf
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|removeIf
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|predicate
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|in
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|not
argument_list|(
name|in
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered sorted map.    */
DECL|method|filterFiltered ( FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|sortedMap
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|class|FilteredEntrySortedMap
specifier|private
specifier|static
class|class
name|FilteredEntrySortedMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|FilteredEntrySortedMap (SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntrySortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|SortedKeySet
argument_list|()
return|;
block|}
DECL|class|SortedKeySet
class|class
name|SortedKeySet
extends|extends
name|KeySet
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|headMap
argument_list|(
name|toElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|tailMap
argument_list|(
name|fromElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|lastKey
argument_list|()
return|;
block|}
block|}
DECL|method|comparator ()
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
DECL|method|firstKey ()
annotation|@
name|Override
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
return|return
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|lastKey ()
annotation|@
name|Override
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
init|=
name|sortedMap
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
name|K
name|key
init|=
name|headMap
operator|.
name|lastKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|key
return|;
block|}
name|headMap
operator|=
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered navigable map.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|filterFiltered ( FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|map
operator|.
name|entryPredicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|FilteredEntryNavigableMap
specifier|private
specifier|static
class|class
name|FilteredEntryNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/*      * It's less code to extend AbstractNavigableMap and forward the filtering logic to      * FilteredEntryMap than to extend FilteredEntrySortedMap and reimplement all the NavigableMap      * methods.      */
DECL|field|unfiltered
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|entryPredicate
specifier|private
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
decl_stmt|;
DECL|field|filteredDelegate
specifier|private
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filteredDelegate
decl_stmt|;
DECL|method|FilteredEntryNavigableMap ( NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntryNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|this
operator|.
name|entryPredicate
operator|=
name|entryPredicate
expr_stmt|;
name|this
operator|.
name|filteredDelegate
operator|=
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|unfiltered
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
operator|new
name|Maps
operator|.
name|NavigableKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|removeIf
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|entryPredicate
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|in
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|removeIf
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|entryPredicate
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|not
argument_list|(
name|in
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|FilteredMapValues
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|filteredDelegate
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|Iterables
operator|.
name|any
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nullable
DECL|method|get (@ullable Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|filteredDelegate
operator|.
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|filteredDelegate
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|filteredDelegate
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered map.    */
DECL|method|filterFiltered ( FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|class|FilteredEntryBiMap
specifier|static
specifier|final
class|class
name|FilteredEntryBiMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|inverse
specifier|private
specifier|final
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
decl_stmt|;
DECL|method|inversePredicate ( final Predicate<? super Entry<K, V>> forwardPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|>
name|inversePredicate
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|forwardPredicate
parameter_list|)
block|{
return|return
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|forwardPredicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|input
operator|.
name|getValue
argument_list|()
argument_list|,
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|FilteredEntryBiMap (BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate)
name|FilteredEntryBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
operator|new
name|FilteredEntryBiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|(
name|delegate
operator|.
name|inverse
argument_list|()
argument_list|,
name|inversePredicate
argument_list|(
name|predicate
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|FilteredEntryBiMap ( BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate, BiMap<V, K> inverse)
specifier|private
name|FilteredEntryBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|,
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|inverse
expr_stmt|;
block|}
DECL|method|unfiltered ()
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|()
block|{
return|return
operator|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
return|;
block|}
annotation|@
name|Override
DECL|method|forcePut (@ullable K key, @Nullable V value)
specifier|public
name|V
name|forcePut
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
argument_list|()
operator|.
name|forcePut
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|inverse ()
specifier|public
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|()
block|{
return|return
name|inverse
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|inverse
operator|.
name|keySet
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns an unmodifiable view of the specified navigable map. Query operations on the returned    * map read through to the specified map, and attempts to modify the returned map, whether direct    * or via its views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned navigable map will be serializable if the specified navigable map is    * serializable.    *    * @param map the navigable map for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified navigable map    * @since 12.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|unmodifiableNavigableMap (NavigableMap<K, V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|instanceof
name|UnmodifiableNavigableMap
condition|)
block|{
return|return
name|map
return|;
block|}
else|else
block|{
return|return
operator|new
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
DECL|method|unmodifiableOrNull (@ullable Entry<K, V> entry)
annotation|@
name|Nullable
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableOrNull
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Maps
operator|.
name|unmodifiableEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|UnmodifiableNavigableMap
specifier|static
class|class
name|UnmodifiableNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|delegate
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableNavigableMap (NavigableMap<K, V> delegate)
name|UnmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|UnmodifiableNavigableMap ( NavigableMap<K, V> delegate, UnmodifiableNavigableMap<K, V> descendingMap)
name|UnmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|descendingMap
operator|=
name|descendingMap
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|delegate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|descendingMap
specifier|private
specifier|transient
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
decl_stmt|;
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|descendingMap
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|descendingMap
operator|=
operator|new
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|this
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|navigableKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|descendingKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|subMap (K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a synchronized (thread-safe) navigable map backed by the specified    * navigable map.  In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing navigable map is accomplished    * through the returned navigable map (or its views).    *    *<p>It is imperative that the user manually synchronize on the returned    * navigable map when iterating over any of its collection views, or the    * collections views of any of its {@code descendingMap}, {@code subMap},    * {@code headMap} or {@code tailMap} views.<pre>   {@code    *    *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    *    *   // Needn't be in synchronized block    *   NavigableSet<K> set = map.navigableKeySet();    *    *   synchronized (map) { // Synchronizing on map, not set!    *     Iterator<K> it = set.iterator(); // Must be in synchronized block    *     while (it.hasNext()) {    *       foo(it.next());    *     }    *   }}</pre>    *    *<p>or:<pre>   {@code    *    *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    *   NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);    *    *   // Needn't be in synchronized block    *   NavigableSet<K> set2 = map2.descendingKeySet();    *    *   synchronized (map) { // Synchronizing on map, not map2 or set2!    *     Iterator<K> it = set2.iterator(); // Must be in synchronized block    *     while (it.hasNext()) {    *       foo(it.next());    *     }    *   }}</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned navigable map will be serializable if the specified    * navigable map is serializable.    *    * @param navigableMap the navigable map to be "wrapped" in a synchronized    *    navigable map.    * @return a synchronized view of the specified navigable map.    * @since 13.0    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|method|synchronizedNavigableMap ( NavigableMap<K, V> navigableMap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|navigableMap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|navigableMap
argument_list|(
name|navigableMap
argument_list|)
return|;
block|}
comment|/**    * {@code AbstractMap} extension that makes it easy to cache customized keySet, values,    * and entrySet views.    */
annotation|@
name|GwtCompatible
DECL|class|ViewCachingAbstractMap
specifier|abstract
specifier|static
class|class
name|ViewCachingAbstractMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Creates the entry set to be returned by {@link #entrySet()}. This method      * is invoked at most once on a given map, at the time when {@code entrySet}      * is first called.      */
DECL|method|createEntrySet ()
specifier|abstract
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
function_decl|;
DECL|field|entrySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|createEntrySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|field|keySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|keySet
operator|=
name|createKeySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|field|values
specifier|private
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
name|createValues
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
DECL|class|IteratorBasedAbstractMap
specifier|abstract
specifier|static
class|class
name|IteratorBasedAbstractMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|size ()
annotation|@
name|Override
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
DECL|method|entryIterator ()
specifier|abstract
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
function_decl|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|IteratorBasedAbstractMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Iterators
operator|.
name|clear
argument_list|(
name|entryIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delegates to {@link Map#get}. Returns {@code null} on {@code    * ClassCastException} and {@code NullPointerException}.    */
DECL|method|safeGet (Map<?, V> map, @Nullable Object key)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|safeGet
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code    * ClassCastException} and {@code NullPointerException}.    */
DECL|method|safeContainsKey (Map<?, ?> map, Object key)
specifier|static
name|boolean
name|safeContainsKey
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Delegates to {@link Map#remove}. Returns {@code null} on {@code    * ClassCastException} and {@code NullPointerException}.    */
DECL|method|safeRemove (Map<?, V> map, Object key)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|safeRemove
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * An admittedly inefficient implementation of {@link Map#containsKey}.    */
DECL|method|containsKeyImpl (Map<?, ?> map, @Nullable Object key)
specifier|static
name|boolean
name|containsKeyImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|keyIterator
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|/**    * An implementation of {@link Map#containsValue}.    */
DECL|method|containsValueImpl (Map<?, ?> map, @Nullable Object value)
specifier|static
name|boolean
name|containsValueImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|valueIterator
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Implements {@code Collection.contains} safely for forwarding collections of    * map entries. If {@code o} is an instance of {@code Map.Entry}, it is    * wrapped using {@link #unmodifiableEntry} to protect against a possible    * nefarious equals method.    *    *<p>Note that {@code c} is the backing (delegate) collection, rather than    * the forwarding collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object that might be contained in {@code c}    * @return {@code true} if {@code c} contains {@code o}    */
DECL|method|containsEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|containsEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|contains
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Implements {@code Collection.remove} safely for forwarding collections of    * map entries. If {@code o} is an instance of {@code Map.Entry}, it is    * wrapped using {@link #unmodifiableEntry} to protect against a possible    * nefarious equals method.    *    *<p>Note that {@code c} is backing (delegate) collection, rather than the    * forwarding collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object to remove from {@code c}    * @return {@code true} if {@code c} was changed    */
DECL|method|removeEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|removeEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|remove
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * An implementation of {@link Map#equals}.    */
DECL|method|equalsImpl (Map<?, ?> map, Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|map
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|Map
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|o
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|field|STANDARD_JOINER
specifier|static
specifier|final
name|MapJoiner
name|STANDARD_JOINER
init|=
name|Collections2
operator|.
name|STANDARD_JOINER
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
comment|/**    * An implementation of {@link Map#toString}.    */
DECL|method|toStringImpl (Map<?, ?> map)
specifier|static
name|String
name|toStringImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
name|Collections2
operator|.
name|newStringBuilderForCollection
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
decl_stmt|;
name|STANDARD_JOINER
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * An implementation of {@link Map#putAll}.    */
DECL|method|putAllImpl ( Map<K, V> self, Map<? extends K, ? extends V> map)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|putAllImpl
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|self
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|KeySet
specifier|static
class|class
name|KeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|K
argument_list|>
block|{
DECL|field|map
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|KeySet (Map<K, V> map)
name|KeySet
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|map ()
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|map
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|keyIterator
argument_list|(
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Nullable
DECL|method|keyOrNull (@ullable Entry<K, ?> entry)
specifier|static
parameter_list|<
name|K
parameter_list|>
name|K
name|keyOrNull
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Nullable
DECL|method|valueOrNull (@ullable Entry<?, V> entry)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|valueOrNull
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
DECL|class|SortedKeySet
specifier|static
class|class
name|SortedKeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|SortedKeySet (SortedMap<K, V> map)
name|SortedKeySet
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|map ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|map
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|NavigableKeySet
specifier|static
class|class
name|NavigableKeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SortedKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|NavigableKeySet (NavigableMap<K, V> map)
name|NavigableKeySet
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|map ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|map
return|;
block|}
annotation|@
name|Override
DECL|method|lower (K e)
specifier|public
name|K
name|lower
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (K e)
specifier|public
name|K
name|floor
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|floorKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (K e)
specifier|public
name|K
name|ceiling
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (K e)
specifier|public
name|K
name|higher
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|higherKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|K
name|pollFirst
parameter_list|()
block|{
return|return
name|keyOrNull
argument_list|(
name|map
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|K
name|pollLast
parameter_list|()
block|{
return|return
name|keyOrNull
argument_list|(
name|map
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|descendingSet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( K fromElement, boolean fromInclusive, K toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
DECL|class|Values
specifier|static
class|class
name|Values
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|map
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|Values (Map<K, V> map)
name|Values
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|map ()
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|map
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|valueIterator
argument_list|(
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|remove
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|o
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|method|removeAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|toRemove
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|toRemove
argument_list|)
return|;
block|}
block|}
DECL|method|retainAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|toRetain
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|toRetain
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|toRetain
argument_list|)
return|;
block|}
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EntrySet
specifier|abstract
specifier|static
class|class
name|EntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|map ()
specifier|abstract
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
function_decl|;
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|map
argument_list|()
argument_list|,
name|key
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|value
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|&&
operator|(
name|value
operator|!=
literal|null
operator|||
name|map
argument_list|()
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|removeAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// if the iterators don't support remove
return|return
name|Sets
operator|.
name|removeAllImpl
argument_list|(
name|this
argument_list|,
name|c
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|retainAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// if the iterators don't support remove
name|Set
argument_list|<
name|Object
argument_list|>
name|keys
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|c
control|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|keys
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableMap"
argument_list|)
DECL|class|DescendingMap
specifier|abstract
specifier|static
class|class
name|DescendingMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|forward ()
specifier|abstract
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|forward
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|forward
argument_list|()
return|;
block|}
DECL|field|comparator
specifier|private
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|result
init|=
name|comparator
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|forwardCmp
init|=
name|forward
argument_list|()
operator|.
name|comparator
argument_list|()
decl_stmt|;
if|if
condition|(
name|forwardCmp
operator|==
literal|null
condition|)
block|{
name|forwardCmp
operator|=
operator|(
name|Comparator
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|comparator
operator|=
name|reverse
argument_list|(
name|forwardCmp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// If we inline this, we get a javac error.
DECL|method|reverse (Comparator<T> forward)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|forward
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|from
argument_list|(
name|forward
argument_list|)
operator|.
name|reverse
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|lastEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|firstEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|forward
argument_list|()
return|;
block|}
DECL|field|entrySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|createEntrySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|entryIterator ()
specifier|abstract
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
function_decl|;
DECL|method|createEntrySet ()
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|DescendingMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|field|navigableKeySet
specifier|private
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
decl_stmt|;
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|result
init|=
name|navigableKeySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|navigableKeySet
operator|=
operator|new
name|NavigableKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|subMap (K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|subMap
argument_list|(
name|toKey
argument_list|,
name|toInclusive
argument_list|,
name|fromKey
argument_list|,
name|fromInclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|tailMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|headMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|standardToString
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns a map from the ith element of list to i.    */
DECL|method|indexMap (Collection<E> list)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|indexMap
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|builder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
end_class

end_unit

