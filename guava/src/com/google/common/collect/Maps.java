begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
operator|.
name|compose
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkEntryNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapDifference
operator|.
name|ValueDifference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|RetainedWith
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|Weak
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterators
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BinaryOperator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|compatqual
operator|.
name|NullableDecl
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Map} instances (including instances of {@link  * SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts {@link Lists}, {@link Sets}  * and {@link Queues}.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps"> {@code Maps}</a>.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Isaac Shum  * @author Louis Wasserman  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Maps
specifier|public
specifier|final
class|class
name|Maps
block|{
DECL|method|Maps ()
specifier|private
name|Maps
parameter_list|()
block|{}
DECL|enum|EntryFunction
specifier|private
enum|enum
name|EntryFunction
implements|implements
name|Function
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|,
name|Object
argument_list|>
block|{
DECL|enumConstant|KEY
name|KEY
block|{
annotation|@
name|Override
annotation|@
name|NullableDecl
specifier|public
name|Object
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|VALUE
name|VALUE
block|{
annotation|@
name|Override
annotation|@
name|NullableDecl
specifier|public
name|Object
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
block|;   }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|keyFunction ()
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|()
block|{
return|return
operator|(
name|Function
operator|)
name|EntryFunction
operator|.
name|KEY
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|valueFunction ()
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|()
block|{
return|return
operator|(
name|Function
operator|)
name|EntryFunction
operator|.
name|VALUE
return|;
block|}
DECL|method|keyIterator (Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|K
argument_list|>
name|keyIterator
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|entryIterator
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyFunction
argument_list|()
argument_list|)
return|;
block|}
DECL|method|valueIterator (Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|V
argument_list|>
name|valueIterator
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|entryIterator
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valueFunction
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable map instance containing the given entries. Internally, the returned map    * will be backed by an {@link EnumMap}.    *    *<p>The iteration order of the returned map follows the enum's iteration order, not the order in    * which the elements appear in the given map.    *    * @param map the map to make an immutable copy of    * @return an immutable map containing those entries    * @since 14.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
annotation|@
name|Beta
DECL|method|immutableEnumMap ( Map<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|immutableEnumMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|ImmutableEnumMap
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe covariant cast
name|ImmutableEnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
operator|(
name|ImmutableEnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|map
decl_stmt|;
return|return
name|result
return|;
block|}
name|Iterator
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|ImmutableMap
operator|.
name|of
argument_list|()
return|;
block|}
name|Entry
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry1
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|K
name|key1
init|=
name|entry1
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value1
init|=
name|entry1
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|checkEntryNotNull
argument_list|(
name|key1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|K
argument_list|>
name|clazz
init|=
name|key1
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|enumMap
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|enumMap
operator|.
name|put
argument_list|(
name|key1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|checkEntryNotNull
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|enumMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableEnumMap
operator|.
name|asImmutable
argument_list|(
name|enumMap
argument_list|)
return|;
block|}
DECL|class|Accumulator
specifier|private
specifier|static
class|class
name|Accumulator
parameter_list|<
name|K
extends|extends
name|Enum
parameter_list|<
name|K
parameter_list|>
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|mergeFunction
specifier|private
specifier|final
name|BinaryOperator
argument_list|<
name|V
argument_list|>
name|mergeFunction
decl_stmt|;
DECL|field|map
specifier|private
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
literal|null
decl_stmt|;
DECL|method|Accumulator (BinaryOperator<V> mergeFunction)
name|Accumulator
parameter_list|(
name|BinaryOperator
argument_list|<
name|V
argument_list|>
name|mergeFunction
parameter_list|)
block|{
name|this
operator|.
name|mergeFunction
operator|=
name|mergeFunction
expr_stmt|;
block|}
DECL|method|put (K key, V value)
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|key
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|merge
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|mergeFunction
argument_list|)
expr_stmt|;
block|}
DECL|method|combine (Accumulator<K, V> other)
name|Accumulator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|combine
parameter_list|(
name|Accumulator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|map
operator|==
literal|null
condition|)
block|{
return|return
name|other
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|map
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
name|other
operator|.
name|map
operator|.
name|forEach
argument_list|(
name|this
operator|::
name|put
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
DECL|method|toImmutableMap ()
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toImmutableMap
parameter_list|()
block|{
return|return
operator|(
name|map
operator|==
literal|null
operator|)
condition|?
name|ImmutableMap
operator|.
expr|<
name|K
operator|,
name|V
operator|>
name|of
argument_list|()
operator|:
name|ImmutableEnumMap
operator|.
name|asImmutable
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys    * and values are the result of applying the provided mapping functions to the input elements. The    * resulting implementation is specialized for enum key types. The returned map and its views will    * iterate over keys in their enum definition order, not encounter order.    *    *<p>If the mapped keys contain duplicates, an {@code IllegalArgumentException} is thrown when    * the collection operation is performed. (This differs from the {@code Collector} returned by    * {@link java.util.stream.Collectors#toMap(java.util.function.Function,    * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code    * IllegalStateException}.)    *    * @since 21.0    */
annotation|@
name|Beta
DECL|method|toImmutableEnumMap ( java.util.function.Function<? super T, ? extends K> keyFunction, java.util.function.Function<? super T, ? extends V> valueFunction)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|toImmutableEnumMap
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|keyFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|valueFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|valueFunction
argument_list|)
expr_stmt|;
return|return
name|Collector
operator|.
name|of
argument_list|(
parameter_list|()
lambda|->
operator|new
name|Accumulator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
lambda|->
block|{
throw|throw
argument_list|new
name|IllegalArgumentException
argument_list|(
literal|"Multiple values for key: "
operator|+
name|v1
operator|+
literal|", "
operator|+
name|v2
argument_list|)
argument_list|;
block|}
block|)
operator|,
parameter_list|(
name|accum
parameter_list|,
name|t
parameter_list|)
lambda|->
block|{
name|K
name|key
init|=
name|checkNotNull
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"Null key for input %s"
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|V
name|newValue
init|=
name|checkNotNull
argument_list|(
name|valueFunction
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"Null value for input %s"
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|accum
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
operator|,
name|Accumulator
operator|::
name|combine
operator|,
name|Accumulator
operator|::
name|toImmutableMap
operator|,
name|Collector
operator|.
name|Characteristics
operator|.
name|UNORDERED
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys    * and values are the result of applying the provided mapping functions to the input elements. The    * resulting implementation is specialized for enum key types. The returned map and its views will    * iterate over keys in their enum definition order, not encounter order.    *    *<p>If the mapped keys contain duplicates, the values are merged using the specified merging    * function.    *    * @since 21.0    */
end_comment

begin_function
unit|@
name|Beta
DECL|method|toImmutableEnumMap ( java.util.function.Function<? super T, ? extends K> keyFunction, java.util.function.Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction)
specifier|public
specifier|static
argument_list|<
name|T
argument_list|,
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
name|Collector
argument_list|<
name|T
argument_list|,
name|?
argument_list|,
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|toImmutableEnumMap
parameter_list|(
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|keyFunction
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|valueFunction
parameter_list|,
name|BinaryOperator
argument_list|<
name|V
argument_list|>
name|mergeFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|valueFunction
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|mergeFunction
argument_list|)
expr_stmt|;
comment|// not UNORDERED because we don't know if mergeFunction is commutative
return|return
name|Collector
operator|.
name|of
argument_list|(
parameter_list|()
lambda|->
operator|new
name|Accumulator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|mergeFunction
argument_list|)
argument_list|,
parameter_list|(
name|accum
parameter_list|,
name|t
parameter_list|)
lambda|->
block|{
name|K
name|key
operator|=
name|checkNotNull
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"Null key for input %s"
argument_list|,
name|t
argument_list|)
argument_list|;
name|V
name|newValue
operator|=
name|checkNotNull
argument_list|(
name|valueFunction
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"Null value for input %s"
argument_list|,
name|t
argument_list|)
argument_list|;
name|accum
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
argument_list|;
block|}
end_function

begin_operator
operator|,
end_operator

begin_expr_stmt
name|Accumulator
operator|::
name|combine
operator|,
name|Accumulator
operator|::
name|toImmutableMap
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Creates a<i>mutable</i>, empty {@code HashMap} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.    *    *<p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link #newEnumMap} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code HashMap}    */
end_comment

begin_function
DECL|method|newHashMap ()
unit|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|()
block|{
return|return
operator|new
name|HashMap
argument_list|<>
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code HashMap} instance, with a high enough "initial capacity" that it<i>should</i>    * hold {@code expectedSize} elements without growth. This behavior cannot be broadly guaranteed,    * but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method    * isn't inadvertently<i>oversizing</i> the returned map.    *    * @param expectedSize the number of entries you expect to add to the returned map    * @return a new, empty {@code HashMap} with enough capacity to hold {@code expectedSize} entries    *     without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
end_comment

begin_function
DECL|method|newHashMapWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMapWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no    * larger than expectedSize and the load factor is â¥ its default (0.75).    */
end_comment

begin_function
DECL|method|capacity (int expectedSize)
specifier|static
name|int
name|capacity
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
if|if
condition|(
name|expectedSize
operator|<
literal|3
condition|)
block|{
name|checkNonnegative
argument_list|(
name|expectedSize
argument_list|,
literal|"expectedSize"
argument_list|)
expr_stmt|;
return|return
name|expectedSize
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|expectedSize
operator|<
name|Ints
operator|.
name|MAX_POWER_OF_TWO
condition|)
block|{
comment|// This is the calculation used in JDK8 to resize when a putAll
comment|// happens; it seems to be the most conservative calculation we
comment|// can make.  0.75 is the default load factor.
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|expectedSize
operator|/
literal|0.75F
operator|+
literal|1.0F
argument_list|)
return|;
block|}
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
comment|// any large value
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i> {@code HashMap} instance with the same mappings as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.    *    *<p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link #newEnumMap} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code HashMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @param map the mappings to be placed in the new map    * @return a new {@code HashMap} initialized with the mappings from {@code map}    */
end_comment

begin_function
DECL|method|newHashMap (Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of    * the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code LinkedHashMap}    */
end_comment

begin_function
DECL|method|newLinkedHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code LinkedHashMap} instance, with a high enough "initial capacity" that it    *<i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be    * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed    * that the method isn't inadvertently<i>oversizing</i> the returned map.    *    * @param expectedSize the number of entries you expect to add to the returned map    * @return a new, empty {@code LinkedHashMap} with enough capacity to hold {@code expectedSize}    *     entries without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    * @since 19.0    */
end_comment

begin_function
DECL|method|newLinkedHashMapWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMapWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance with the same    * mappings as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code LinkedHashMap} constructor directly, taking advantage of    * the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @param map the mappings to be placed in the new map    * @return a new, {@code LinkedHashMap} initialized with the mappings from {@code map}    */
end_comment

begin_function
DECL|method|newLinkedHashMap (Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a new empty {@link ConcurrentHashMap} instance.    *    * @since 3.0    */
end_comment

begin_function
DECL|method|newConcurrentMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newConcurrentMap
parameter_list|()
block|{
return|return
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the natural ordering of its    * elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedMap#of()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code TreeMap}    */
end_comment

begin_function
DECL|method|newTreeMap ()
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<>
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i> {@code TreeMap} instance with the same mappings as the specified map    * and using the same ordering as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @param map the sorted map whose mappings are to be placed in the new map and whose comparator    *     is to be used to sort the new map    * @return a new {@code TreeMap} initialized with the mappings from {@code map} and using the    *     comparator of {@code map}    */
end_comment

begin_function
DECL|method|newTreeMap (SortedMap<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the given comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedMap.orderedBy(comparator).build()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code TreeMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @param comparator the comparator to sort the keys with    * @return a new, empty {@code TreeMap}    */
end_comment

begin_function
DECL|method|newTreeMap ( @ullableDecl Comparator<C> comparator)
specifier|public
specifier|static
parameter_list|<
name|C
parameter_list|,
name|K
extends|extends
name|C
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
annotation|@
name|NullableDecl
name|Comparator
argument_list|<
name|C
argument_list|>
name|comparator
parameter_list|)
block|{
comment|// Ideally, the extra type parameter "C" shouldn't be necessary. It is a
comment|// work-around of a compiler type inference quirk that prevents the
comment|// following code from being compiled:
comment|// Comparator<Class<?>> comparator = null;
comment|// Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);
return|return
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an {@code EnumMap} instance.    *    * @param type the key type for this map    * @return a new, empty {@code EnumMap}    */
end_comment

begin_function
DECL|method|newEnumMap (Class<K> type)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Class
argument_list|<
name|K
argument_list|>
name|type
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|checkNotNull
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an {@code EnumMap} with the same mappings as the specified map.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code EnumMap} constructor directly, taking advantage of the new    *<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @param map the map from which to initialize this {@code EnumMap}    * @return a new {@code EnumMap} initialized with the mappings from {@code map}    * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap} instance and contains    *     no mappings    */
end_comment

begin_function
DECL|method|newEnumMap (Map<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an {@code IdentityHashMap} instance.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as    * deprecated. Instead, use the {@code IdentityHashMap} constructor directly, taking advantage of    * the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    *    * @return a new, empty {@code IdentityHashMap}    */
end_comment

begin_function
DECL|method|newIdentityHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|IdentityHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newIdentityHashMap
parameter_list|()
block|{
return|return
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the difference between two maps. This difference is an immutable snapshot of the state    * of the maps at the time this method is called. It will never change, even if the maps change at    * a later time.    *    *<p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps    * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.    *    *<p><b>Note:</b>If you only need to know whether two maps have the same mappings, call {@code    * left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|difference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|SortedMap
condition|)
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|sortedLeft
init|=
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
operator|)
name|left
decl_stmt|;
return|return
name|difference
argument_list|(
name|sortedLeft
argument_list|,
name|right
argument_list|)
return|;
block|}
return|return
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|Equivalence
operator|.
name|equals
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the difference between two maps. This difference is an immutable snapshot of the state    * of the maps at the time this method is called. It will never change, even if the maps change at    * a later time.    *    *<p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps    * must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @param valueEquivalence the equivalence relationship to use to compare values    * @return the difference between the two maps    * @since 10.0    */
end_comment

begin_function
DECL|method|difference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|,
name|Equivalence
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueEquivalence
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|valueEquivalence
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|right
argument_list|)
decl_stmt|;
comment|// will whittle it down
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|doDifference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|valueEquivalence
argument_list|,
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
return|return
operator|new
name|MapDifferenceImpl
argument_list|<>
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|doDifference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence, Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, MapDifference.ValueDifference<V>> differences)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|doDifference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|,
name|Equivalence
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueEquivalence
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|left
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|K
name|leftKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|leftValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|right
operator|.
name|containsKey
argument_list|(
name|leftKey
argument_list|)
condition|)
block|{
name|V
name|rightValue
init|=
name|onlyOnRight
operator|.
name|remove
argument_list|(
name|leftKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
condition|)
block|{
name|onBoth
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|differences
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|onlyOnLeft
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|unmodifiableMap (Map<K, ? extends V> map)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
end_function

begin_class
DECL|class|MapDifferenceImpl
specifier|static
class|class
name|MapDifferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|onlyOnLeft
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
decl_stmt|;
DECL|field|onlyOnRight
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
decl_stmt|;
DECL|field|onBoth
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
decl_stmt|;
DECL|field|differences
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
decl_stmt|;
DECL|method|MapDifferenceImpl ( Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, ValueDifference<V>> differences)
name|MapDifferenceImpl
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
name|this
operator|.
name|onlyOnLeft
operator|=
name|unmodifiableMap
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlyOnRight
operator|=
name|unmodifiableMap
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
name|this
operator|.
name|onBoth
operator|=
name|unmodifiableMap
argument_list|(
name|onBoth
argument_list|)
expr_stmt|;
name|this
operator|.
name|differences
operator|=
name|unmodifiableMap
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|areEqual ()
specifier|public
name|boolean
name|areEqual
parameter_list|()
block|{
return|return
name|onlyOnLeft
operator|.
name|isEmpty
argument_list|()
operator|&&
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
operator|&&
name|differences
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnLeft ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnLeft
parameter_list|()
block|{
return|return
name|onlyOnLeft
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnRight ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnRight
parameter_list|()
block|{
return|return
name|onlyOnRight
return|;
block|}
annotation|@
name|Override
DECL|method|entriesInCommon ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesInCommon
parameter_list|()
block|{
return|return
name|onBoth
return|;
block|}
annotation|@
name|Override
DECL|method|entriesDiffering ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|entriesDiffering
parameter_list|()
block|{
return|return
name|differences
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
condition|)
block|{
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|other
init|=
operator|(
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
operator|&&
name|entriesOnlyOnRight
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
operator|&&
name|entriesInCommon
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
operator|&&
name|entriesDiffering
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|entriesOnlyOnLeft
argument_list|()
argument_list|,
name|entriesOnlyOnRight
argument_list|()
argument_list|,
name|entriesInCommon
argument_list|()
argument_list|,
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|areEqual
argument_list|()
condition|)
block|{
return|return
literal|"equal"
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"not equal"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onlyOnLeft
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on left="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on right="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|differences
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": value differences="
argument_list|)
operator|.
name|append
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

begin_class
DECL|class|ValueDifferenceImpl
specifier|static
class|class
name|ValueDifferenceImpl
parameter_list|<
name|V
parameter_list|>
implements|implements
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
block|{
DECL|field|left
specifier|private
specifier|final
name|V
name|left
decl_stmt|;
DECL|field|right
specifier|private
specifier|final
name|V
name|right
decl_stmt|;
DECL|method|create (@ullableDecl V left, @NullableDecl V right)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ValueDifference
argument_list|<
name|V
argument_list|>
name|create
parameter_list|(
annotation|@
name|NullableDecl
name|V
name|left
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|right
parameter_list|)
block|{
return|return
operator|new
name|ValueDifferenceImpl
argument_list|<
name|V
argument_list|>
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
DECL|method|ValueDifferenceImpl (@ullableDecl V left, @NullableDecl V right)
specifier|private
name|ValueDifferenceImpl
parameter_list|(
annotation|@
name|NullableDecl
name|V
name|left
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|leftValue ()
specifier|public
name|V
name|leftValue
parameter_list|()
block|{
return|return
name|left
return|;
block|}
annotation|@
name|Override
DECL|method|rightValue ()
specifier|public
name|V
name|rightValue
parameter_list|()
block|{
return|return
name|right
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullableDecl Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
operator|.
name|ValueDifference
condition|)
block|{
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|left
argument_list|,
name|that
operator|.
name|leftValue
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|right
argument_list|,
name|that
operator|.
name|rightValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"("
operator|+
name|left
operator|+
literal|", "
operator|+
name|right
operator|+
literal|")"
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Computes the difference between two sorted maps, using the comparator of the left map, or    * {@code Ordering.natural()} if the left map uses the natural ordering of its elements. This    * difference is an immutable snapshot of the state of the maps at the time this method is called.    * It will never change, even if the maps change at a later time.    *    *<p>Since this method uses {@code TreeMap} instances internally, the keys of the right map must    * all compare as distinct according to the comparator of the left map.    *    *<p><b>Note:</b>If you only need to know whether two sorted maps have the same mappings, call    * {@code left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    * @since 11.0    */
end_comment

begin_function
DECL|method|difference ( SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
init|=
name|orNaturalOrder
argument_list|(
name|left
operator|.
name|comparator
argument_list|()
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|onlyOnRight
operator|.
name|putAll
argument_list|(
name|right
argument_list|)
expr_stmt|;
comment|// will whittle it down
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|doDifference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|Equivalence
operator|.
name|equals
argument_list|()
argument_list|,
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
return|return
operator|new
name|SortedMapDifferenceImpl
argument_list|<>
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|SortedMapDifferenceImpl
specifier|static
class|class
name|SortedMapDifferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapDifferenceImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SortedMapDifferenceImpl ( SortedMap<K, V> onlyOnLeft, SortedMap<K, V> onlyOnRight, SortedMap<K, V> onBoth, SortedMap<K, ValueDifference<V>> differences)
name|SortedMapDifferenceImpl
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
name|super
argument_list|(
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|entriesDiffering ()
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|entriesDiffering
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|entriesDiffering
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entriesInCommon ()
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesInCommon
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesInCommon
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnLeft ()
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnLeft
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesOnlyOnLeft
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entriesOnlyOnRight ()
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnRight
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|entriesOnlyOnRight
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns the specified comparator if not null; otherwise returns {@code Ordering.natural()}.    * This method is an abomination of generics; the only purpose of this method is to contain the    * ugly type-casting in one place.    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|orNaturalOrder (@ullableDecl Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|orNaturalOrder
parameter_list|(
annotation|@
name|NullableDecl
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|!=
literal|null
condition|)
block|{
comment|// can't use ? : because of javac bug 5080917
return|return
name|comparator
return|;
block|}
return|return
operator|(
name|Comparator
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a live {@link Map} view whose keys are the contents of {@code set} and whose values are    * computed on demand using {@code function}. To get an immutable<i>copy</i> instead, use {@link    * #toMap(Iterable, Function)}.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping    * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code    * entrySet} views of the returned map iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map. The returned map    * supports removal operations if the backing set does. Removal operations write through to the    * backing set. The returned map does not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the    * set does not contain {@code null}, because the view cannot stop {@code null} from being added    * to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},    * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for    * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when    * calling methods on the resulting map view.    *    * @since 14.0    */
end_comment

begin_function
DECL|method|asMap (Set<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|AsMapView
argument_list|<>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of the sorted set as a map, mapping keys from the set according to the specified    * function.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping    * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code    * entrySet} views of the returned map iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map. The returned map    * supports removal operations if the backing set does. Removal operations write through to the    * backing set. The returned map does not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the    * set does not contain {@code null}, because the view cannot stop {@code null} from being added    * to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},    * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for    * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when    * calling methods on the resulting map view.    *    * @since 14.0    */
end_comment

begin_function
DECL|method|asMap (SortedSet<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|SortedSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMapView
argument_list|<>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of the navigable set as a map, mapping keys from the set according to the    * specified function.    *    *<p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping    * {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code    * entrySet} views of the returned map iterate in the same order as the backing set.    *    *<p>Modifications to the backing set are read through to the returned map. The returned map    * supports removal operations if the backing set does. Removal operations write through to the    * backing set. The returned map does not support put operations.    *    *<p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the    * set does not contain {@code null}, because the view cannot stop {@code null} from being added    * to the set.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},    * {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for    * which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when    * calling methods on the resulting map view.    *    * @since 14.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|asMap ( NavigableSet<K> set, Function<? super K, V> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMapView
argument_list|<>
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|AsMapView
specifier|private
specifier|static
class|class
name|AsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|set
specifier|private
specifier|final
name|Set
argument_list|<
name|K
argument_list|>
name|set
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
decl_stmt|;
DECL|method|backingSet ()
name|Set
argument_list|<
name|K
argument_list|>
name|backingSet
parameter_list|()
block|{
return|return
name|set
return|;
block|}
DECL|method|AsMapView (Set<K> set, Function<? super K, V> function)
name|AsMapView
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|set
operator|=
name|checkNotNull
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|removeOnlySet
argument_list|(
name|backingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullableDecl Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|contains
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (@ullableDecl Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|getOrDefault
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getOrDefault (@ullableDecl Object key, @NullableDecl V defaultValue)
specifier|public
name|V
name|getOrDefault
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|defaultValue
parameter_list|)
block|{
if|if
condition|(
name|Collections2
operator|.
name|safeContains
argument_list|(
name|backingSet
argument_list|()
argument_list|,
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|defaultValue
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove (@ullableDecl Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|backingSet
argument_list|()
operator|.
name|remove
argument_list|(
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|backingSet
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
annotation|@
name|WeakOuter
class|class
name|EntrySetImpl
extends|extends
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMapView
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asMapEntryIterator
argument_list|(
name|backingSet
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|EntrySetImpl
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (BiConsumer<? super K, ? super V> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|BiConsumer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
comment|// avoids allocation of entries
name|backingSet
argument_list|()
operator|.
name|forEach
argument_list|(
name|k
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|k
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_function
DECL|method|asMapEntryIterator ( Set<K> set, final Function<? super K, V> function)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|asMapEntryIterator
parameter_list|(
name|Set
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|K
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|set
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|transform
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_class
DECL|class|SortedAsMapView
specifier|private
specifier|static
class|class
name|SortedAsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AsMapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SortedAsMapView (SortedSet<K> set, Function<? super K, V> function)
name|SortedAsMapView
parameter_list|(
name|SortedSet
argument_list|<
name|K
argument_list|>
name|set
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|backingSet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|backingSet
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|backingSet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|backingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|headSet
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|backingSet
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|first
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|backingSet
argument_list|()
operator|.
name|last
argument_list|()
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|NavigableAsMapView
specifier|private
specifier|static
specifier|final
class|class
name|NavigableAsMapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/*      * Using AbstractNavigableMap is simpler than extending SortedAsMapView and rewriting all the      * NavigableMap methods.      */
DECL|field|set
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|set
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|function
decl_stmt|;
DECL|method|NavigableAsMapView (NavigableSet<K> ks, Function<? super K, V> vFunction)
name|NavigableAsMapView
parameter_list|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|ks
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|vFunction
parameter_list|)
block|{
name|this
operator|.
name|set
operator|=
name|checkNotNull
argument_list|(
name|ks
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|vFunction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|subSet
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|headSet
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|tailSet
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|set
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|get (@ullableDecl Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|getOrDefault
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|getOrDefault (@ullableDecl Object key, @NullableDecl V defaultValue)
specifier|public
name|V
name|getOrDefault
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|defaultValue
parameter_list|)
block|{
if|if
condition|(
name|Collections2
operator|.
name|safeContains
argument_list|(
name|set
argument_list|,
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, but Javadoc warns about it
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|defaultValue
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|set
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|asMapEntryIterator
argument_list|(
name|set
argument_list|,
name|function
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entrySpliterator ()
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|set
operator|.
name|spliterator
argument_list|()
argument_list|,
name|e
lambda|->
name|immutableEntry
argument_list|(
name|e
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (BiConsumer<? super K, ? super V> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|BiConsumer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|set
operator|.
name|forEach
argument_list|(
name|k
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|k
argument_list|,
name|function
operator|.
name|apply
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
return|return
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|set
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|set
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|asMap
argument_list|(
name|set
operator|.
name|descendingSet
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
end_class

begin_function
DECL|method|removeOnlySet (final Set<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|removeOnlySet
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
end_function

begin_function
DECL|method|removeOnlySortedSet (final SortedSet<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
name|removeOnlySortedSet
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingSortedSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SortedSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableSet
DECL|method|removeOnlyNavigableSet (final NavigableSet<E> set)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|removeOnlyNavigableSet
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
return|return
operator|new
name|ForwardingNavigableSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|es
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
name|removeOnlySortedSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|E
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|E
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|removeOnlyNavigableSet
argument_list|(
name|super
operator|.
name|descendingSet
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value    * for each key was computed by {@code valueFunction}. The map's iteration order is the order of    * the first appearance of each key in {@code keys}.    *    *<p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code    * valueFunction} will be applied to more than one instance of that key and, if it is, which    * result will be mapped to that key in the returned map.    *    *<p>If {@code keys} is a {@link Set}, a live view can be obtained instead of a copy using {@link    * Maps#asMap(Set, Function)}.    *    * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code    *     valueFunction} produces {@code null} for any key    * @since 14.0    */
end_comment

begin_function
DECL|method|toMap ( Iterable<K> keys, Function<? super K, V> valueFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toMap
parameter_list|(
name|Iterable
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|)
block|{
return|return
name|toMap
argument_list|(
name|keys
operator|.
name|iterator
argument_list|()
argument_list|,
name|valueFunction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value    * for each key was computed by {@code valueFunction}. The map's iteration order is the order of    * the first appearance of each key in {@code keys}.    *    *<p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code    * valueFunction} will be applied to more than one instance of that key and, if it is, which    * result will be mapped to that key in the returned map.    *    * @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code    *     valueFunction} produces {@code null} for any key    * @since 14.0    */
end_comment

begin_function
DECL|method|toMap ( Iterator<K> keys, Function<? super K, V> valueFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toMap
parameter_list|(
name|Iterator
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|valueFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|valueFunction
argument_list|)
expr_stmt|;
comment|// Using LHM instead of a builder so as not to fail on duplicate keys
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|newLinkedHashMap
argument_list|()
decl_stmt|;
while|while
condition|(
name|keys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|K
name|key
init|=
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|valueFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|builder
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a map with the given {@code values}, indexed by keys derived from those values. In    * other words, each input value produces an entry in the map whose key is the result of applying    * {@code keyFunction} to that value. These entries appear in the same order as the input values.    * Example usage:    *    *<pre>{@code    * Color red = new Color("red", 255, 0, 0);    * ...    * ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);    *    * Map<String, Color> colorForName =    *     uniqueIndex(allColors, toStringFunction());    * assertThat(colorForName).containsEntry("red", red);    * }</pre>    *    *<p>If your index may associate multiple values with each key, use {@link    * Multimaps#index(Iterable, Function) Multimaps.index}.    *    * @param values the values to use when constructing the {@code Map}    * @param keyFunction the function used to produce the key for each value    * @return a map mapping the result of evaluating the function {@code keyFunction} on each value    *     in the input collection to that value    * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one    *     value in the input collection    * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code    *     keyFunction} produces {@code null} for any value    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|uniqueIndex ( Iterable<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|uniqueIndex
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
comment|// TODO(lowasser): consider presizing the builder if values is a Collection
return|return
name|uniqueIndex
argument_list|(
name|values
operator|.
name|iterator
argument_list|()
argument_list|,
name|keyFunction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a map with the given {@code values}, indexed by keys derived from those values. In    * other words, each input value produces an entry in the map whose key is the result of applying    * {@code keyFunction} to that value. These entries appear in the same order as the input values.    * Example usage:    *    *<pre>{@code    * Color red = new Color("red", 255, 0, 0);    * ...    * Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();    *    * Map<String, Color> colorForName =    *     uniqueIndex(allColors, toStringFunction());    * assertThat(colorForName).containsEntry("red", red);    * }</pre>    *    *<p>If your index may associate multiple values with each key, use {@link    * Multimaps#index(Iterator, Function) Multimaps.index}.    *    * @param values the values to use when constructing the {@code Map}    * @param keyFunction the function used to produce the key for each value    * @return a map mapping the result of evaluating the function {@code keyFunction} on each value    *     in the input collection to that value    * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one    *     value in the input collection    * @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code    *     keyFunction} produces {@code null} for any value    * @since 10.0    */
end_comment

begin_function
annotation|@
name|CanIgnoreReturnValue
DECL|method|uniqueIndex ( Iterator<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|uniqueIndex
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|V
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|duplicateKeys
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|duplicateKeys
operator|.
name|getMessage
argument_list|()
operator|+
literal|". To index multiple values under a key, use Multimaps.index."
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties    * normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is    * awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}.    *    * @param properties a {@code Properties} object to be converted    * @return an immutable map containing all the entries in {@code properties}    * @throws ClassCastException if any key in {@code Properties} is not a {@code String}    * @throws NullPointerException if any key or value in {@code Properties} is null    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// java.util.Properties
DECL|method|fromProperties (Properties properties)
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fromProperties
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|?
argument_list|>
name|e
init|=
name|properties
operator|.
name|propertyNames
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|properties
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an immutable map entry with the specified key and value. The {@link Entry#setValue}    * operation throws an {@link UnsupportedOperationException}.    *    *<p>The returned entry is serializable.    *    * @param key the key to be associated with the returned entry    * @param value the value to be associated with the returned entry    */
end_comment

begin_function
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEntry (@ullableDecl K key, @NullableDecl V value)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|immutableEntry
parameter_list|(
annotation|@
name|NullableDecl
name|K
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|ImmutableEntry
argument_list|<>
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an unmodifiable view of the specified set of entries. The {@link Entry#setValue}    * operation throws an {@link UnsupportedOperationException}, as do any operations that would    * modify the returned set.    *    * @param entrySet the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
end_comment

begin_function
DECL|method|unmodifiableEntrySet (Set<Entry<K, V>> entrySet)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableEntrySet
argument_list|<>
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|entrySet
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an unmodifiable view of the specified map entry. The {@link Entry#setValue} operation    * throws an {@link UnsupportedOperationException}. This also has the side-effect of redefining    * {@code equals} to comply with the Entry contract, to avoid a possible nefarious implementation    * of equals.    *    * @param entry the entry for which to return an unmodifiable view    * @return an unmodifiable view of the entry    */
end_comment

begin_function
DECL|method|unmodifiableEntry (final Entry<? extends K, ? extends V> entry)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableEntry
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
DECL|method|unmodifiableEntryIterator ( final Iterator<Entry<K, V>> entryIterator)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntryIterator
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableEntry
argument_list|(
name|entryIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** @see Multimaps#unmodifiableEntries */
end_comment

begin_class
DECL|class|UnmodifiableEntries
specifier|static
class|class
name|UnmodifiableEntries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|entries
specifier|private
specifier|final
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|method|UnmodifiableEntries (Collection<Entry<K, V>> entries)
name|UnmodifiableEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|this
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|unmodifiableEntryIterator
argument_list|(
name|entries
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|standardToArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (T[] array)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|standardToArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** @see Maps#unmodifiableEntrySet(Set) */
end_comment

begin_class
DECL|class|UnmodifiableEntrySet
specifier|static
class|class
name|UnmodifiableEntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|UnmodifiableEntrySet (Set<Entry<K, V>> entries)
name|UnmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|super
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
annotation|@
name|Override
DECL|method|equals (@ullableDecl Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|object
parameter_list|)
block|{
return|return
name|Sets
operator|.
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()}, and whose    * inverse view converts values using {@link BiMap#inverse bimap.inverse()}{@code .get()}.    *    *<p>To use a plain {@link Map} as a {@link Function}, see {@link    * com.google.common.base.Functions#forMap(Map)} or {@link    * com.google.common.base.Functions#forMap(Map, Object)}.    *    * @since 16.0    */
end_comment

begin_function
annotation|@
name|Beta
DECL|method|asConverter (final BiMap<A, B> bimap)
specifier|public
specifier|static
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
name|Converter
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|asConverter
parameter_list|(
specifier|final
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
operator|new
name|BiMapConverter
argument_list|<>
argument_list|(
name|bimap
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|BiMapConverter
specifier|private
specifier|static
specifier|final
class|class
name|BiMapConverter
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
extends|extends
name|Converter
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|bimap
specifier|private
specifier|final
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
decl_stmt|;
DECL|method|BiMapConverter (BiMap<A, B> bimap)
name|BiMapConverter
parameter_list|(
name|BiMap
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bimap
parameter_list|)
block|{
name|this
operator|.
name|bimap
operator|=
name|checkNotNull
argument_list|(
name|bimap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doForward (A a)
specifier|protected
name|B
name|doForward
parameter_list|(
name|A
name|a
parameter_list|)
block|{
return|return
name|convert
argument_list|(
name|bimap
argument_list|,
name|a
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doBackward (B b)
specifier|protected
name|A
name|doBackward
parameter_list|(
name|B
name|b
parameter_list|)
block|{
return|return
name|convert
argument_list|(
name|bimap
operator|.
name|inverse
argument_list|()
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|convert (BiMap<X, Y> bimap, X input)
specifier|private
specifier|static
parameter_list|<
name|X
parameter_list|,
name|Y
parameter_list|>
name|Y
name|convert
parameter_list|(
name|BiMap
argument_list|<
name|X
argument_list|,
name|Y
argument_list|>
name|bimap
parameter_list|,
name|X
name|input
parameter_list|)
block|{
name|Y
name|output
init|=
name|bimap
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|output
operator|!=
literal|null
argument_list|,
literal|"No non-null mapping present for input: %s"
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@ullableDecl Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|instanceof
name|BiMapConverter
condition|)
block|{
name|BiMapConverter
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|BiMapConverter
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|bimap
operator|.
name|equals
argument_list|(
name|that
operator|.
name|bimap
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|bimap
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// There's really no good way to implement toString() without printing the entire BiMap, right?
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Maps.asConverter("
operator|+
name|bimap
operator|+
literal|")"
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0L
decl_stmt|;
block|}
end_class

begin_comment
comment|/**    * Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee    * serial access, it is critical that<b>all</b> access to the backing bimap is accomplished    * through the returned bimap.    *    *<p>It is imperative that the user manually synchronize on the returned map when accessing any    * of its collection views:    *    *<pre>{@code    * BiMap<Long, String> map = Maps.synchronizedBiMap(    *     HashBiMap.<Long, String>create());    * ...    * Set<Long> set = map.keySet();  // Needn't be in synchronized block    * ...    * synchronized (map) {  // Synchronizing on map, not set!    *   Iterator<Long> it = set.iterator(); // Must be in synchronized block    *   while (it.hasNext()) {    *     foo(it.next());    *   }    * }    * }</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned bimap will be serializable if the specified bimap is serializable.    *    * @param bimap the bimap to be wrapped in a synchronized view    * @return a synchronized view of the specified bimap    */
end_comment

begin_function
DECL|method|synchronizedBiMap (BiMap<K, V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|biMap
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an unmodifiable view of the specified bimap. This method allows modules to provide    * users with "read-only" access to internal bimaps. Query operations on the returned bimap "read    * through" to the specified bimap, and attempts to modify the returned map, whether direct or via    * its collection views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned bimap will be serializable if the specified bimap is serializable.    *    * @param bimap the bimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified bimap    */
end_comment

begin_function
DECL|method|unmodifiableBiMap (BiMap<? extends K, ? extends V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableBiMap
argument_list|<>
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** @see Maps#unmodifiableBiMap(BiMap) */
end_comment

begin_class
DECL|class|UnmodifiableBiMap
specifier|private
specifier|static
class|class
name|UnmodifiableBiMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|unmodifiableMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMap
decl_stmt|;
DECL|field|delegate
specifier|final
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|inverse
annotation|@
name|RetainedWith
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
decl_stmt|;
DECL|field|values
specifier|transient
name|Set
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|UnmodifiableBiMap (BiMap<? extends K, ? extends V> delegate, @NullableDecl BiMap<V, K> inverse)
name|UnmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|NullableDecl
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|)
block|{
name|unmodifiableMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|inverse
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableMap
return|;
block|}
annotation|@
name|Override
DECL|method|forcePut (K key, V value)
specifier|public
name|V
name|forcePut
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|inverse ()
specifier|public
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|()
block|{
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|result
init|=
name|inverse
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|inverse
operator|=
operator|new
name|UnmodifiableBiMap
argument_list|<>
argument_list|(
name|delegate
operator|.
name|inverse
argument_list|()
argument_list|,
name|this
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
end_class

begin_comment
comment|/**    * Returns a view of a map where each value is transformed by a function. All other properties of    * the map, such as iteration order, are left intact. For example, the code:    *    *<pre>{@code    * Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);    * Function<Integer, Double> sqrt =    *     new Function<Integer, Double>() {    *       public Double apply(Integer in) {    *         return Math.sqrt((int) in);    *       }    *     };    * Map<String, Double> transformed = Maps.transformValues(map, sqrt);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even null values provided    * that the function is capable of accepting null input. The transformed map might contain null    * values, if the function sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned map    * to be a view, but it means that the function will be applied many times for bulk operations    * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code    * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a    * view, copy the returned map into a new map of your choosing.    */
end_comment

begin_function
DECL|method|transformValues ( Map<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a sorted map where each value is transformed by a function. All other    * properties of the map, such as iteration order, are left intact. For example, the code:    *    *<pre>{@code    * SortedMap<String, Integer> map = ImmutableSortedMap.of("a", 4, "b", 9);    * Function<Integer, Double> sqrt =    *     new Function<Integer, Double>() {    *       public Double apply(Integer in) {    *         return Math.sqrt((int) in);    *       }    *     };    * SortedMap<String, Double> transformed =    *      Maps.transformValues(map, sqrt);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even null values provided    * that the function is capable of accepting null input. The transformed map might contain null    * values, if the function sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned map    * to be a view, but it means that the function will be applied many times for bulk operations    * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code    * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a    * view, copy the returned map into a new map of your choosing.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|transformValues ( SortedMap<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a navigable map where each value is transformed by a function. All other    * properties of the map, such as iteration order, are left intact. For example, the code:    *    *<pre>{@code    * NavigableMap<String, Integer> map = Maps.newTreeMap();    * map.put("a", 4);    * map.put("b", 9);    * Function<Integer, Double> sqrt =    *     new Function<Integer, Double>() {    *       public Double apply(Integer in) {    *         return Math.sqrt((int) in);    *       }    *     };    * NavigableMap<String, Double> transformed =    *      Maps.transformNavigableValues(map, sqrt);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even null values provided    * that the function is capable of accepting null input. The transformed map might contain null    * values, if the function sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary for the returned map    * to be a view, but it means that the function will be applied many times for bulk operations    * like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code    * function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a    * view, copy the returned map into a new map of your choosing.    *    * @since 13.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|transformValues ( NavigableMap<K, V1> fromMap, Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|asEntryTransformer
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a map whose values are derived from the original map's entries. In contrast    * to {@link #transformValues}, this method's entry-transformation logic may depend on the key as    * well as the value.    *    *<p>All other properties of the transformed map, such as iteration order, are left intact. For    * example, the code:    *    *<pre>{@code    * Map<String, Boolean> options =    *     ImmutableMap.of("verbose", true, "sort", false);    * EntryTransformer<String, Boolean, String> flagPrefixer =    *     new EntryTransformer<String, Boolean, String>() {    *       public String transformEntry(String key, Boolean value) {    *         return value ? key : "no" + key;    *       }    *     };    * Map<String, String> transformed =    *     Maps.transformEntries(options, flagPrefixer);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {verbose=verbose, sort=nosort}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null values provided that    * the transformer is capable of accepting null inputs. The transformed map might contain null    * values if the transformer sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is necessary for the returned    * map to be a view, but it means that the transformer will be applied many times for bulk    * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map    * doesn't need to be a view, copy the returned map into a new map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code    * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the    * transformed map.    *    * @since 7.0    */
end_comment

begin_function
DECL|method|transformEntries ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesMap
argument_list|<>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a sorted map whose values are derived from the original sorted map's entries.    * In contrast to {@link #transformValues}, this method's entry-transformation logic may depend on    * the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order, are left intact. For    * example, the code:    *    *<pre>{@code    * Map<String, Boolean> options =    *     ImmutableSortedMap.of("verbose", true, "sort", false);    * EntryTransformer<String, Boolean, String> flagPrefixer =    *     new EntryTransformer<String, Boolean, String>() {    *       public String transformEntry(String key, Boolean value) {    *         return value ? key : "yes" + key;    *       }    *     };    * SortedMap<String, String> transformed =    *     Maps.transformEntries(options, flagPrefixer);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null values provided that    * the transformer is capable of accepting null inputs. The transformed map might contain null    * values if the transformer sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is necessary for the returned    * map to be a view, but it means that the transformer will be applied many times for bulk    * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map    * doesn't need to be a view, copy the returned map into a new map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code    * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the    * transformed map.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|transformEntries ( SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesSortedMap
argument_list|<>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of a navigable map whose values are derived from the original navigable map's    * entries. In contrast to {@link #transformValues}, this method's entry-transformation logic may    * depend on the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order, are left intact. For    * example, the code:    *    *<pre>{@code    * NavigableMap<String, Boolean> options = Maps.newTreeMap();    * options.put("verbose", false);    * options.put("sort", true);    * EntryTransformer<String, Boolean, String> flagPrefixer =    *     new EntryTransformer<String, Boolean, String>() {    *       public String transformEntry(String key, Boolean value) {    *         return value ? key : ("yes" + key);    *       }    *     };    * NavigableMap<String, String> transformed =    *     LabsMaps.transformNavigableEntries(options, flagPrefixer);    * System.out.println(transformed);    * }</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely, this view supports    * removal operations, and these are reflected in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null values provided that    * the transformer is capable of accepting null inputs. The transformed map might contain null    * values if the transformer sometimes gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is necessary for the returned    * map to be a view, but it means that the transformer will be applied many times for bulk    * operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map    * doesn't need to be a view, copy the returned map into a new map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code    * EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of    * type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as    * {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the    * transformed map.    *    * @since 13.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|transformEntries ( final NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesNavigableMap
argument_list|<>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * A transformation of the value of a key-value pair, using both key and value as inputs. To apply    * the transformation to a map, use {@link Maps#transformEntries(Map, EntryTransformer)}.    *    * @param<K> the key type of the input and output entries    * @param<V1> the value type of the input entry    * @param<V2> the value type of the output entry    * @since 7.0    */
end_comment

begin_interface
annotation|@
name|FunctionalInterface
DECL|interface|EntryTransformer
specifier|public
interface|interface
name|EntryTransformer
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
block|{
comment|/**      * Determines an output value based on a key-value pair. This method is<i>generally      * expected</i>, but not absolutely required, to have the following properties:      *      *<ul>      *<li>Its execution does not cause any observable side effects.      *<li>The computation is<i>consistent with equals</i>; that is, {@link Objects#equal      *       Objects.equal}{@code (k1, k2)&&} {@link Objects#equal}{@code (v1, v2)} implies that      *       {@code Objects.equal(transformer.transform(k1, v1), transformer.transform(k2, v2))}.      *</ul>      *      * @throws NullPointerException if the key or value is null and this transformer does not accept      *     null arguments      */
DECL|method|transformEntry (@ullableDecl K key, @NullableDecl V1 value)
name|V2
name|transformEntry
parameter_list|(
annotation|@
name|NullableDecl
name|K
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V1
name|value
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/** Views a function as an entry transformer that ignores the entry key. */
end_comment

begin_function
DECL|method|asEntryTransformer ( final Function<? super V1, V2> function)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|asEntryTransformer
parameter_list|(
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
DECL|method|asValueToValueFunction ( final EntryTransformer<? super K, V1, V2> transformer, final K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
name|asValueToValueFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|,
specifier|final
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
annotation|@
name|NullableDecl
name|V1
name|v1
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|key
argument_list|,
name|v1
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** Views an entry transformer as a function from {@code Entry} to values. */
end_comment

begin_function
DECL|method|asEntryToValueFunction ( final EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|V2
argument_list|>
name|asEntryToValueFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** Returns a view of an entry transformed by the specified transformer. */
end_comment

begin_function
DECL|method|transformEntry ( final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry)
specifier|static
parameter_list|<
name|V2
parameter_list|,
name|K
parameter_list|,
name|V1
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntry
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|,
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V2
name|getValue
parameter_list|()
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** Views an entry transformer as a function from entries to entries. */
end_comment

begin_function
DECL|method|asEntryToEntryFunction ( final EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|asEntryToEntryFunction
parameter_list|(
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
return|return
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|transformer
argument_list|,
name|entry
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_class
DECL|class|TransformedEntriesMap
specifier|static
class|class
name|TransformedEntriesMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|IteratorBasedAbstractMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
decl_stmt|;
DECL|field|transformer
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
decl_stmt|;
DECL|method|TransformedEntriesMap ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|fromMap
operator|=
name|checkNotNull
argument_list|(
name|fromMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromMap
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|get (@ullableDecl Object key)
specifier|public
name|V2
name|get
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|getOrDefault
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|getOrDefault (@ullableDecl Object key, @NullableDecl V2 defaultValue)
specifier|public
name|V2
name|getOrDefault
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V2
name|defaultValue
parameter_list|)
block|{
name|V1
name|value
init|=
name|fromMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|||
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|value
argument_list|)
else|:
name|defaultValue
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|remove (Object key)
specifier|public
name|V2
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|fromMap
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Maps
operator|.
expr|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
operator|>
name|asEntryToEntryFunction
argument_list|(
name|transformer
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entrySpliterator ()
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entrySpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|fromMap
operator|.
name|entrySet
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|Maps
operator|.
expr|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
operator|>
name|asEntryToEntryFunction
argument_list|(
name|transformer
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (BiConsumer<? super K, ? super V2> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|BiConsumer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V2
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
comment|// avoids creating new Entry<K, V2> objects
name|fromMap
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v1
parameter_list|)
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|k
argument_list|,
name|transformer
operator|.
name|transformEntry
argument_list|(
name|k
argument_list|,
name|v1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|TransformedEntriesSortedMap
specifier|static
class|class
name|TransformedEntriesSortedMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|fromMap ()
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|fromMap
return|;
block|}
DECL|method|TransformedEntriesSortedMap ( SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesSortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|TransformedEntriesNavigableMap
specifier|private
specifier|static
class|class
name|TransformedEntriesNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesSortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|TransformedEntriesNavigableMap ( NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
annotation|@
name|NullableDecl
DECL|method|transformEntry (@ullableDecl Entry<K, V1> entry)
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntry
parameter_list|(
annotation|@
name|NullableDecl
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Maps
operator|.
name|transformEntry
argument_list|(
name|transformer
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|fromMap ()
specifier|protected
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|super
operator|.
name|fromMap
argument_list|()
return|;
block|}
block|}
end_class

begin_function
DECL|method|keyPredicateOnEntries (Predicate<? super K> keyPredicate)
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|>
name|keyPredicateOnEntries
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|keyPredicate
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyFunction
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|valuePredicateOnEntries (Predicate<? super V> valuePredicate)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
argument_list|>
name|valuePredicateOnEntries
parameter_list|(
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|valuePredicate
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valueFunction
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The    * returned map is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and    * {@code putAll()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose keys satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    */
end_comment

begin_function
DECL|method|filterKeys ( Map<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
argument_list|>
name|entryPredicate
init|=
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
decl_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredKeyMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|keyPredicate
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose keys satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the    * other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and    * {@code putAll()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose keys satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|filterKeys ( SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
comment|// TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better
comment|// performance.
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a navigable map containing the mappings in {@code unfiltered} whose keys satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the    * other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and    * {@code putAll()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose keys satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with equals</i>, as documented at    * {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 14.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|filterKeys ( NavigableMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
comment|// TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better
comment|// performance.
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.    * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the bimap    * and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()},    * {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in    * the underlying bimap and determine which satisfy the filter. When a live view is<i>not</i>    * needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 14.0    */
end_comment

begin_function
DECL|method|filterKeys ( BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|K
operator|>
name|keyPredicateOnEntries
argument_list|(
name|keyPredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose values satisfy a predicate.    * The returned map is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},    * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose values satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    */
end_comment

begin_function
DECL|method|filterValues ( Map<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose values satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the    * other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},    * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose values satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|filterValues ( SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the    * other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},    * {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings whose values satisfy the filter will be removed from the underlying    * map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}. Do not provide a predicate such as {@code    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.    *    * @since 14.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|filterValues ( NavigableMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a predicate.    * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the bimap    * and its views. When given a value that doesn't satisfy the predicate, the bimap's {@code    * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method    * that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the    * predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in    * the underlying bimap and determine which satisfy the filter. When a live view is<i>not</i>    * needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 14.0    */
end_comment

begin_function
DECL|method|filterValues ( BiMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|Maps
operator|.
expr|<
name|V
operator|>
name|valuePredicateOnEntries
argument_list|(
name|valuePredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a map containing the mappings in {@code unfiltered} that satisfy a predicate. The    * returned map is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code    * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the    * map's entries have a {@link Entry#setValue} method that throws an {@link    * IllegalArgumentException} when the existing key and the provided value don't satisfy the    * predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings that satisfy the filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    */
end_comment

begin_function
DECL|method|filterEntries ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.    * The returned map is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code    * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the    * map's entries have a {@link Entry#setValue} method that throws an {@link    * IllegalArgumentException} when the existing key and the provided value don't satisfy the    * predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings that satisfy the filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 11.0    */
end_comment

begin_function
DECL|method|filterEntries ( SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntrySortedMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.    * The returned map is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the map    * and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code    * put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the    * map's entries have a {@link Entry#setValue} method that throws an {@link    * IllegalArgumentException} when the existing key and the provided value don't satisfy the    * predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map    * or its views, only mappings that satisfy the filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying map and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 14.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|filterEntries ( NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntryNavigableMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The    * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.    *    *<p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have    * iterators that don't support {@code remove()}, but all other methods are supported by the bimap    * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's    * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method    * that throws an {@link IllegalArgumentException} when the existing key and the provided value    * don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying    * bimap.    *    *<p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.    *    *<p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value    * mapping in the underlying bimap and determine which satisfy the filter. When a live view is    *<i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with equals</i>, as documented    * at {@link Predicate#apply}.    *    * @since 14.0    */
end_comment

begin_function
DECL|method|filterEntries ( BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredEntryBiMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered    * map.    */
end_comment

begin_function
DECL|method|filterFiltered ( AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntryMap
argument_list|<>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|,
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|AbstractFilteredMap
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractFilteredMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|unfiltered
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
decl_stmt|;
DECL|method|AbstractFilteredMap (Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate)
name|AbstractFilteredMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|apply (@ullableDecl Object key, @NullableDecl V value)
name|boolean
name|apply
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|value
parameter_list|)
block|{
comment|// This method is called only when the key is in the map, implying that
comment|// key is a K.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|k
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> map)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unfiltered
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (Object key)
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|V
name|value
init|=
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|!=
literal|null
operator|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|)
condition|?
name|value
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object key)
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|unfiltered
operator|.
name|remove
argument_list|(
name|key
argument_list|)
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
operator|new
name|FilteredMapValues
argument_list|<>
argument_list|(
name|this
argument_list|,
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|FilteredMapValues
specifier|private
specifier|static
specifier|final
class|class
name|FilteredMapValues
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Maps
operator|.
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|unfiltered
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
decl_stmt|;
DECL|method|FilteredMapValues ( Map<K, V> filteredMap, Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate)
name|FilteredMapValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filteredMap
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|filteredMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|o
argument_list|)
condition|)
block|{
name|entryItr
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> collection)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
operator|&&
name|collection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|entryItr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> collection)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
operator|&&
operator|!
name|collection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|entryItr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (T[] array)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|FilteredKeyMap
specifier|private
specifier|static
class|class
name|FilteredKeyMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|keyPredicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
decl_stmt|;
DECL|method|FilteredKeyMap ( Map<K, V> unfiltered, Predicate<? super K> keyPredicate, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredKeyMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|keyPredicate
operator|=
name|keyPredicate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|keySet
argument_list|()
argument_list|,
name|keyPredicate
argument_list|)
return|;
block|}
comment|// The cast is called only when the key is in the unfiltered map, implying
comment|// that key is a K.
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|keyPredicate
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|FilteredEntryMap
specifier|static
class|class
name|FilteredEntryMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Entries in this set satisfy the predicate, but they don't validate the input to {@code      * Entry.setValue()}.      */
DECL|field|filteredEntrySet
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|filteredEntrySet
decl_stmt|;
DECL|method|FilteredEntryMap (Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntryMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|filteredEntrySet
operator|=
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|()
return|;
block|}
annotation|@
name|WeakOuter
DECL|class|EntrySet
specifier|private
class|class
name|EntrySet
extends|extends
name|ForwardingSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|filteredEntrySet
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|filteredEntrySet
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|ForwardingMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|setValue
argument_list|(
name|newValue
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySet
argument_list|()
return|;
block|}
DECL|method|removeAllKeys ( Map<K, V> map, Predicate<? super Entry<K, V>> entryPredicate, Collection<?> keyCollection)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|removeAllKeys
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|keyCollection
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryPredicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
operator|&&
name|keyCollection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|entryItr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|retainAllKeys ( Map<K, V> map, Predicate<? super Entry<K, V>> entryPredicate, Collection<?> keyCollection)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|retainAllKeys
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|keyCollection
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryItr
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|result
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|entryItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entryItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryPredicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
operator|&&
operator|!
name|keyCollection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|entryItr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|WeakOuter
DECL|class|KeySet
class|class
name|KeySet
extends|extends
name|Maps
operator|.
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|KeySet ()
name|KeySet
parameter_list|()
block|{
name|super
argument_list|(
name|FilteredEntryMap
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|unfiltered
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> collection)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|removeAllKeys
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|,
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> collection)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|retainAllKeys
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|,
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toArray (T[] array)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered    * sorted map.    */
end_comment

begin_function
DECL|method|filterFiltered ( FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntrySortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<>
argument_list|(
name|map
operator|.
name|sortedMap
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|FilteredEntrySortedMap
specifier|private
specifier|static
class|class
name|FilteredEntrySortedMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|FilteredEntrySortedMap ( SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntrySortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|SortedKeySet
argument_list|()
return|;
block|}
annotation|@
name|WeakOuter
DECL|class|SortedKeySet
class|class
name|SortedKeySet
extends|extends
name|KeySet
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|headMap
argument_list|(
name|toElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|K
argument_list|>
operator|)
name|tailMap
argument_list|(
name|fromElement
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|lastKey
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
return|return
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
init|=
name|sortedMap
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
name|K
name|key
init|=
name|headMap
operator|.
name|lastKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|key
return|;
block|}
name|headMap
operator|=
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredEntrySortedMap
argument_list|<>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered    * navigable map.    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|filterFiltered ( FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntryNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|map
operator|.
name|entryPredicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryNavigableMap
argument_list|<>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_function

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|FilteredEntryNavigableMap
specifier|private
specifier|static
class|class
name|FilteredEntryNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/*      * It's less code to extend AbstractNavigableMap and forward the filtering logic to      * FilteredEntryMap than to extend FilteredEntrySortedMap and reimplement all the NavigableMap      * methods.      */
DECL|field|unfiltered
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|entryPredicate
specifier|private
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
decl_stmt|;
DECL|field|filteredDelegate
specifier|private
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filteredDelegate
decl_stmt|;
DECL|method|FilteredEntryNavigableMap ( NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntryNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|this
operator|.
name|entryPredicate
operator|=
name|entryPredicate
expr_stmt|;
name|this
operator|.
name|filteredDelegate
operator|=
operator|new
name|FilteredEntryMap
argument_list|<>
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|unfiltered
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
operator|new
name|Maps
operator|.
name|NavigableKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|FilteredEntryMap
operator|.
name|removeAllKeys
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|,
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|FilteredEntryMap
operator|.
name|retainAllKeys
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|,
name|collection
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|FilteredMapValues
argument_list|<>
argument_list|(
name|this
argument_list|,
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|filteredDelegate
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|Iterables
operator|.
name|any
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|NullableDecl
DECL|method|get (@ullableDecl Object key)
specifier|public
name|V
name|get
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullableDecl Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullableDecl Object key)
specifier|public
name|V
name|remove
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|filteredDelegate
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|putAll (Map<? extends K, ? extends V> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|filteredDelegate
operator|.
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|filteredDelegate
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|filteredDelegate
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|removeFirstMatching
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|filterEntries
argument_list|(
name|unfiltered
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered    * map.    */
end_comment

begin_function
DECL|method|filterFiltered ( FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredEntryBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
expr|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|>
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryBiMap
argument_list|<>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|FilteredEntryBiMap
specifier|static
specifier|final
class|class
name|FilteredEntryBiMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|inverse
annotation|@
name|RetainedWith
specifier|private
specifier|final
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
decl_stmt|;
DECL|method|inversePredicate ( final Predicate<? super Entry<K, V>> forwardPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|>
name|inversePredicate
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|forwardPredicate
parameter_list|)
block|{
return|return
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|forwardPredicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|input
operator|.
name|getValue
argument_list|()
argument_list|,
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|FilteredEntryBiMap (BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate)
name|FilteredEntryBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
operator|new
name|FilteredEntryBiMap
argument_list|<>
argument_list|(
name|delegate
operator|.
name|inverse
argument_list|()
argument_list|,
name|inversePredicate
argument_list|(
name|predicate
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|FilteredEntryBiMap ( BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate, BiMap<V, K> inverse)
specifier|private
name|FilteredEntryBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|,
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|inverse
expr_stmt|;
block|}
DECL|method|unfiltered ()
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|()
block|{
return|return
operator|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
return|;
block|}
annotation|@
name|Override
DECL|method|forcePut (@ullableDecl K key, @NullableDecl V value)
specifier|public
name|V
name|forcePut
parameter_list|(
annotation|@
name|NullableDecl
name|K
name|key
parameter_list|,
annotation|@
name|NullableDecl
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
argument_list|()
operator|.
name|forcePut
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|replaceAll (BiFunction<? super K, ? super V, ? extends V> function)
specifier|public
name|void
name|replaceAll
parameter_list|(
name|BiFunction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|function
parameter_list|)
block|{
name|unfiltered
argument_list|()
operator|.
name|replaceAll
argument_list|(
operator|(
name|key
operator|,
name|value
operator|)
operator|->
name|predicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
condition|?
name|function
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
else|:
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|inverse ()
specifier|public
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|()
block|{
return|return
name|inverse
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|inverse
operator|.
name|keySet
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns an unmodifiable view of the specified navigable map. Query operations on the returned    * map read through to the specified map, and attempts to modify the returned map, whether direct    * or via its views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned navigable map will be serializable if the specified navigable map is    * serializable.    *    *<p>This method's signature will not permit you to convert a {@code NavigableMap<? extends K,    * V>} to a {@code NavigableMap<K, V>}. If it permitted this, the returned map's {@code    * comparator()} method might return a {@code Comparator<? extends K>}, which works only on a    * particular subtype of {@code K}, but promise that it's a {@code Comparator<? super K>}, which    * must work on any type of {@code K}.    *    * @param map the navigable map for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified navigable map    * @since 12.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|unmodifiableNavigableMap ( NavigableMap<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|instanceof
name|UnmodifiableNavigableMap
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// covariant
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
operator|(
name|NavigableMap
operator|)
name|map
decl_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
return|return
operator|new
name|UnmodifiableNavigableMap
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|NullableDecl
DECL|method|unmodifiableOrNull (@ullableDecl Entry<K, ? extends V> entry)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableOrNull
parameter_list|(
annotation|@
name|NullableDecl
name|Entry
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Maps
operator|.
name|unmodifiableEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|UnmodifiableNavigableMap
specifier|static
class|class
name|UnmodifiableNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|delegate
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableNavigableMap (NavigableMap<K, ? extends V> delegate)
name|UnmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|UnmodifiableNavigableMap ( NavigableMap<K, ? extends V> delegate, UnmodifiableNavigableMap<K, V> descendingMap)
name|UnmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|,
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|descendingMap
operator|=
name|descendingMap
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|delegate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|unmodifiableOrNull
argument_list|(
name|delegate
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|descendingMap
specifier|private
specifier|transient
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
decl_stmt|;
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|descendingMap
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|descendingMap
operator|=
operator|new
name|UnmodifiableNavigableMap
argument_list|<>
argument_list|(
name|delegate
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|this
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|navigableKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|descendingKeySet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In    * order to guarantee serial access, it is critical that<b>all</b> access to the backing    * navigable map is accomplished through the returned navigable map (or its views).    *    *<p>It is imperative that the user manually synchronize on the returned navigable map when    * iterating over any of its collection views, or the collections views of any of its {@code    * descendingMap}, {@code subMap}, {@code headMap} or {@code tailMap} views.    *    *<pre>{@code    * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    *    * // Needn't be in synchronized block    * NavigableSet<K> set = map.navigableKeySet();    *    * synchronized (map) { // Synchronizing on map, not set!    *   Iterator<K> it = set.iterator(); // Must be in synchronized block    *   while (it.hasNext()) {    *     foo(it.next());    *   }    * }    * }</pre>    *    *<p>or:    *    *<pre>{@code    * NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    * NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);    *    * // Needn't be in synchronized block    * NavigableSet<K> set2 = map2.descendingKeySet();    *    * synchronized (map) { // Synchronizing on map, not map2 or set2!    *   Iterator<K> it = set2.iterator(); // Must be in synchronized block    *   while (it.hasNext()) {    *     foo(it.next());    *   }    * }    * }</pre>    *    *<p>Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned navigable map will be serializable if the specified navigable map is    * serializable.    *    * @param navigableMap the navigable map to be "wrapped" in a synchronized navigable map.    * @return a synchronized view of the specified navigable map.    * @since 13.0    */
end_comment

begin_function
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|synchronizedNavigableMap ( NavigableMap<K, V> navigableMap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|navigableMap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|navigableMap
argument_list|(
name|navigableMap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * {@code AbstractMap} extension that makes it easy to cache customized keySet, values, and    * entrySet views.    */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|ViewCachingAbstractMap
specifier|abstract
specifier|static
class|class
name|ViewCachingAbstractMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Creates the entry set to be returned by {@link #entrySet()}. This method is invoked at most      * once on a given map, at the time when {@code entrySet} is first called.      */
DECL|method|createEntrySet ()
specifier|abstract
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
function_decl|;
DECL|field|entrySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|createEntrySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|field|keySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|keySet
operator|=
name|createKeySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySet
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|field|values
specifier|private
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
name|createValues
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|IteratorBasedAbstractMap
specifier|abstract
specifier|static
class|class
name|IteratorBasedAbstractMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|size ()
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
DECL|method|entryIterator ()
specifier|abstract
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
function_decl|;
DECL|method|entrySpliterator ()
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySpliterator
parameter_list|()
block|{
return|return
name|Spliterators
operator|.
name|spliterator
argument_list|(
name|entryIterator
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|Spliterator
operator|.
name|SIZED
operator||
name|Spliterator
operator|.
name|DISTINCT
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|IteratorBasedAbstractMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|entrySpliterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
name|forEachEntry
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|forEachEntry (Consumer<? super Entry<K, V>> action)
name|void
name|forEachEntry
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
name|entryIterator
argument_list|()
operator|.
name|forEachRemaining
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Iterators
operator|.
name|clear
argument_list|(
name|entryIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**    * Delegates to {@link Map#get}. Returns {@code null} on {@code ClassCastException} and {@code    * NullPointerException}.    */
end_comment

begin_function
DECL|method|safeGet (Map<?, V> map, @NullableDecl Object key)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|safeGet
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code ClassCastException} and    * {@code NullPointerException}.    */
end_comment

begin_function
DECL|method|safeContainsKey (Map<?, ?> map, Object key)
specifier|static
name|boolean
name|safeContainsKey
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Delegates to {@link Map#remove}. Returns {@code null} on {@code ClassCastException} and {@code    * NullPointerException}.    */
end_comment

begin_function
DECL|method|safeRemove (Map<?, V> map, Object key)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|safeRemove
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
end_function

begin_comment
comment|/** An admittedly inefficient implementation of {@link Map#containsKey}. */
end_comment

begin_function
DECL|method|containsKeyImpl (Map<?, ?> map, @NullableDecl Object key)
specifier|static
name|boolean
name|containsKeyImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|key
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|keyIterator
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** An implementation of {@link Map#containsValue}. */
end_comment

begin_function
DECL|method|containsValueImpl (Map<?, ?> map, @NullableDecl Object value)
specifier|static
name|boolean
name|containsValueImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
annotation|@
name|NullableDecl
name|Object
name|value
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|valueIterator
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Implements {@code Collection.contains} safely for forwarding collections of map entries. If    * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to    * protect against a possible nefarious equals method.    *    *<p>Note that {@code c} is the backing (delegate) collection, rather than the forwarding    * collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object that might be contained in {@code c}    * @return {@code true} if {@code c} contains {@code o}    */
end_comment

begin_function
DECL|method|containsEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|containsEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|contains
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Implements {@code Collection.remove} safely for forwarding collections of map entries. If    * {@code o} is an instance of {@code Entry}, it is wrapped using {@link #unmodifiableEntry} to    * protect against a possible nefarious equals method.    *    *<p>Note that {@code c} is backing (delegate) collection, rather than the forwarding collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object to remove from {@code c}    * @return {@code true} if {@code c} was changed    */
end_comment

begin_function
DECL|method|removeEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|removeEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|remove
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** An implementation of {@link Map#equals}. */
end_comment

begin_function
DECL|method|equalsImpl (Map<?, ?> map, Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|map
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|Map
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|o
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|/** An implementation of {@link Map#toString}. */
end_comment

begin_function
DECL|method|toStringImpl (Map<?, ?> map)
specifier|static
name|String
name|toStringImpl
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
name|Collections2
operator|.
name|newStringBuilderForCollection
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** An implementation of {@link Map#putAll}. */
end_comment

begin_function
DECL|method|putAllImpl (Map<K, V> self, Map<? extends K, ? extends V> map)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|putAllImpl
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|self
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|self
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_class
DECL|class|KeySet
specifier|static
class|class
name|KeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|K
argument_list|>
block|{
DECL|field|map
annotation|@
name|Weak
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|KeySet (Map<K, V> map)
name|KeySet
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|map ()
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|map
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|keyIterator
argument_list|(
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (Consumer<? super K> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
comment|// avoids entry allocation for those maps that allocate entries on iteration
name|map
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_function
annotation|@
name|NullableDecl
DECL|method|keyOrNull (@ullableDecl Entry<K, ?> entry)
specifier|static
parameter_list|<
name|K
parameter_list|>
name|K
name|keyOrNull
parameter_list|(
annotation|@
name|NullableDecl
name|Entry
argument_list|<
name|K
argument_list|,
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|NullableDecl
DECL|method|valueOrNull (@ullableDecl Entry<?, V> entry)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|valueOrNull
parameter_list|(
annotation|@
name|NullableDecl
name|Entry
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
end_function

begin_class
DECL|class|SortedKeySet
specifier|static
class|class
name|SortedKeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|SortedKeySet (SortedMap<K, V> map)
name|SortedKeySet
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|map ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|map
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<>
argument_list|(
name|map
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<>
argument_list|(
name|map
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|<>
argument_list|(
name|map
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|NavigableKeySet
specifier|static
class|class
name|NavigableKeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SortedKeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|NavigableKeySet (NavigableMap<K, V> map)
name|NavigableKeySet
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|map ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|map
return|;
block|}
annotation|@
name|Override
DECL|method|lower (K e)
specifier|public
name|K
name|lower
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (K e)
specifier|public
name|K
name|floor
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|floorKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (K e)
specifier|public
name|K
name|ceiling
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (K e)
specifier|public
name|K
name|higher
parameter_list|(
name|K
name|e
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|higherKey
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|K
name|pollFirst
parameter_list|()
block|{
return|return
name|keyOrNull
argument_list|(
name|map
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|K
name|pollLast
parameter_list|()
block|{
return|return
name|keyOrNull
argument_list|(
name|map
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|descendingSet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( K fromElement, boolean fromInclusive, K toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|Values
specifier|static
class|class
name|Values
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|map
annotation|@
name|Weak
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|Values (Map<K, V> map)
name|Values
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|map ()
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|map
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|valueIterator
argument_list|(
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forEach (Consumer<? super V> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|Consumer
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
comment|// avoids allocation of entries for those maps that generate fresh entries on iteration
name|map
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|remove
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|o
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|toRemove
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|toRemove
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|toRetain
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|toRetain
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|toRetain
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullableDecl Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|NullableDecl
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_class
DECL|class|EntrySet
specifier|abstract
specifier|static
class|class
name|EntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|map ()
specifier|abstract
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|contains (Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|map
argument_list|()
argument_list|,
name|key
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|value
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|&&
operator|(
name|value
operator|!=
literal|null
operator|||
name|map
argument_list|()
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// if the iterators don't support remove
return|return
name|Sets
operator|.
name|removeAllImpl
argument_list|(
name|this
argument_list|,
name|c
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// if the iterators don't support remove
name|Set
argument_list|<
name|Object
argument_list|>
name|keys
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|c
control|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|keys
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_class
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|class|DescendingMap
specifier|abstract
specifier|static
class|class
name|DescendingMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|forward ()
specifier|abstract
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|forward
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|forward
argument_list|()
return|;
block|}
DECL|field|comparator
specifier|private
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|result
init|=
name|comparator
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|forwardCmp
init|=
name|forward
argument_list|()
operator|.
name|comparator
argument_list|()
decl_stmt|;
if|if
condition|(
name|forwardCmp
operator|==
literal|null
condition|)
block|{
name|forwardCmp
operator|=
operator|(
name|Comparator
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|comparator
operator|=
name|reverse
argument_list|(
name|forwardCmp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// If we inline this, we get a javac error.
DECL|method|reverse (Comparator<T> forward)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|forward
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|from
argument_list|(
name|forward
argument_list|)
operator|.
name|reverse
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|lastEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|firstEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|forward
argument_list|()
return|;
block|}
DECL|field|entrySet
specifier|private
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|createEntrySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|entryIterator ()
specifier|abstract
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
function_decl|;
DECL|method|createEntrySet ()
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
annotation|@
name|WeakOuter
class|class
name|EntrySetImpl
extends|extends
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|DescendingMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
block|}
return|return
operator|new
name|EntrySetImpl
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|field|navigableKeySet
specifier|private
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
decl_stmt|;
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|result
init|=
name|navigableKeySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|navigableKeySet
operator|=
operator|new
name|NavigableKeySet
argument_list|<>
argument_list|(
name|this
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|forward
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|subMap
argument_list|(
name|toKey
argument_list|,
name|toInclusive
argument_list|,
name|fromKey
argument_list|,
name|fromInclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|tailMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|forward
argument_list|()
operator|.
name|headMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
operator|.
name|descendingMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|standardToString
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/** Returns a map from the ith element of list to i. */
end_comment

begin_function
DECL|method|indexMap (Collection<E> list)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableMap
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|indexMap
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|E
argument_list|,
name|Integer
argument_list|>
name|builder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a view of the portion of {@code map} whose keys are contained by {@code range}.    *    *<p>This method delegates to the appropriate methods of {@link NavigableMap} (namely {@link    * NavigableMap#subMap(Object, boolean, Object, boolean) subMap()}, {@link    * NavigableMap#tailMap(Object, boolean) tailMap()}, and {@link NavigableMap#headMap(Object,    * boolean) headMap()}) to actually construct the view. Consult these methods for a full    * description of the returned view's behavior.    *    *<p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural    * ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a {@link    * Comparator}, which can violate the natural ordering. Using this method (or in general using    * {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined behavior.    *    * @since 20.0    */
end_comment

begin_function
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
comment|// NavigableMap
DECL|method|subMap ( NavigableMap<K, V> map, Range<K> range)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Range
argument_list|<
name|K
argument_list|>
name|range
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|comparator
argument_list|()
operator|!=
literal|null
operator|&&
name|map
operator|.
name|comparator
argument_list|()
operator|!=
name|Ordering
operator|.
name|natural
argument_list|()
operator|&&
name|range
operator|.
name|hasLowerBound
argument_list|()
operator|&&
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
name|checkArgument
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|)
operator|<=
literal|0
argument_list|,
literal|"map is using a custom comparator which is inconsistent with the natural ordering."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
operator|&&
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
return|return
name|map
operator|.
name|subMap
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|lowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|,
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
return|return
name|map
operator|.
name|tailMap
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|lowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
return|return
name|map
operator|.
name|headMap
argument_list|(
name|range
operator|.
name|upperEndpoint
argument_list|()
argument_list|,
name|range
operator|.
name|upperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
argument_list|)
return|;
block|}
return|return
name|checkNotNull
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

unit|}
end_unit

