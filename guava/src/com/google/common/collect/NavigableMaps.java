begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NavigableSets
operator|.
name|synchronizedNavigableSet
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NavigableSets
operator|.
name|unmodifiableNavigableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|TransformedEntriesSortedMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Synchronized
operator|.
name|SynchronizedObject
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Synchronized
operator|.
name|SynchronizedSortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link NavigableMap} instances.  *  * @author Louis Wasserman  */
end_comment

begin_class
annotation|@
name|GwtIncompatible
argument_list|(
name|value
operator|=
literal|"JDK 5 incompatibility"
argument_list|)
DECL|class|NavigableMaps
specifier|final
class|class
name|NavigableMaps
block|{
DECL|method|NavigableMaps ()
specifier|private
name|NavigableMaps
parameter_list|()
block|{}
comment|/**    * Returns a view of a navigable map where each value is transformed by a    * function. All other properties of the map, such as iteration order, are    * left intact.  For example, the code:<pre>   {@code    *    *   NavigableMap<String, Integer> map = Maps.newTreeMap();    *   map.put("a", 4);    *   map.put("b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   NavigableMap<String, Double> transformed =    *        Maps.transformNavigableValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    * Changes in the underlying map are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    *    * @deprecated Use {@link Maps#transformValues(NavigableMap, Function}.    */
annotation|@
name|Deprecated
DECL|method|transformValues ( NavigableMap<K, V1> fromMap, final Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a navigable map whose values are derived from the    * original navigable map's entries. In contrast to {@link    * #transformValues}, this method's entry-transformation logic may    * depend on the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   NavigableMap<String, Boolean> options = Maps.newTreeMap();    *   options.put("verbose", false);    *   options.put("sort", true);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : ("yes" + key);    *         }    *       };    *   NavigableMap<String, String> transformed =    *       LabsMaps.transformNavigableEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *    * @deprecated Use {@link Maps#transformEntries(NavigableMap,    * EntryTransformer}.    */
annotation|@
name|Deprecated
DECL|method|transformEntries ( final NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesNavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|class|TransformedEntriesNavigableMap
specifier|private
specifier|static
class|class
name|TransformedEntriesNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesSortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|TransformedEntriesNavigableMap (NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|ceilingEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ceilingKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|descendingKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
return|;
block|}
DECL|method|descendingMap ()
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|firstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|floorEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|floorKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|headMap (K toKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|higherEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|higherKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|lastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|lowerEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|lowerKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|navigableKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|fromMap
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|method|pollFirstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|pollLastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|transformEntry
argument_list|(
name|fromMap
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|method|transformEntry (Entry<K, V1> entry)
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntry
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V2
name|v2
init|=
name|transformer
operator|.
name|transformEntry
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|v2
argument_list|)
return|;
block|}
DECL|method|fromMap ()
annotation|@
name|Override
specifier|protected
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
operator|)
name|super
operator|.
name|fromMap
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns an unmodifiable view of the specified navigable map. This method    * allows modules to provide users with "read-only" access to internal    * navigable maps. Query operations on the returned navigable map "read    * through" to the specified navigable map. Attempts to modify the returned    * navigable map, whether direct, via its collection views, or via its    * {@code descendingMap}, {@code subMap}, {@code headMap}, or    * {@code tailMap} views, result in an    * {@code UnsupportedOperationException}.    *    *<p>The returned navigable map will be serializable if the specified    * navigable map is serializable.    *    * @param navigableMap the navigable map for which an unmodifiable view is to    *        be returned.    * @return an unmodifiable view of the specified navigable map.    * @deprecated Use {@link Maps#unmodifiableNavigableMap}.    */
annotation|@
name|Deprecated
DECL|method|unmodifiableNavigableMap ( NavigableMap<K, V> navigableMap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|navigableMap
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|navigableMap
argument_list|)
return|;
block|}
DECL|method|nullableUnmodifiableEntry ( @ullable Entry<K, V> entry)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullableUnmodifiableEntry
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Maps
operator|.
name|unmodifiableEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
DECL|class|UnmodifiableNavigableMap
specifier|private
specifier|static
class|class
name|UnmodifiableNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|delegate
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|unmodifiableSortedMap
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSortedMap
decl_stmt|;
DECL|field|descendingMap
specifier|transient
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
decl_stmt|;
DECL|field|navigableKeySet
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
decl_stmt|;
DECL|field|descendingKeySet
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
decl_stmt|;
DECL|method|UnmodifiableNavigableMap (NavigableMap<K, V> delegate)
specifier|protected
name|UnmodifiableNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|unmodifiableSortedMap
operator|=
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableSortedMap
return|;
block|}
DECL|method|ceilingEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ceilingKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|descendingKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
if|if
condition|(
name|descendingKeySet
operator|==
literal|null
condition|)
block|{
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|dKS
init|=
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|descendingKeySet
argument_list|()
argument_list|)
decl_stmt|;
name|descendingKeySet
operator|=
name|dKS
expr_stmt|;
return|return
name|dKS
return|;
block|}
return|return
name|descendingKeySet
return|;
block|}
DECL|method|descendingMap ()
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
if|if
condition|(
name|descendingMap
operator|==
literal|null
condition|)
block|{
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|dM
init|=
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|descendingMap
argument_list|()
argument_list|)
decl_stmt|;
name|descendingMap
operator|=
name|dM
expr_stmt|;
return|return
name|dM
return|;
block|}
return|return
name|descendingMap
return|;
block|}
DECL|method|firstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|firstEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|floorEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|floorKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|headMap (K toKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|method|higherEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|higherKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|lastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|lastEntry
argument_list|()
argument_list|)
return|;
block|}
DECL|method|lowerEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|nullableUnmodifiableEntry
argument_list|(
name|delegate
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|lowerKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|method|navigableKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
if|if
condition|(
name|navigableKeySet
operator|==
literal|null
condition|)
block|{
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|nKS
init|=
name|unmodifiableNavigableSet
argument_list|(
name|delegate
operator|.
name|navigableKeySet
argument_list|()
argument_list|)
decl_stmt|;
name|navigableKeySet
operator|=
name|nKS
expr_stmt|;
return|return
name|nKS
return|;
block|}
return|return
name|navigableKeySet
return|;
block|}
DECL|method|pollFirstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|pollLastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|unmodifiableNavigableMap
argument_list|(
name|delegate
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|nullableSynchronizedEntry ( @ullable Entry<K, V> entry, @Nullable Object mutex)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nullableSynchronizedEntry
parameter_list|(
annotation|@
name|Nullable
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|SynchronizedEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|entry
argument_list|,
name|mutex
argument_list|)
return|;
block|}
DECL|class|SynchronizedEntry
specifier|private
specifier|static
class|class
name|SynchronizedEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SynchronizedObject
implements|implements
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SynchronizedEntry (Entry<K, V> delegate, @Nullable Object mutex)
name|SynchronizedEntry
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// guaranteed by the constructor
DECL|method|delegate ()
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
DECL|method|getKey ()
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|method|getValue ()
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
DECL|method|setValue (V value)
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) navigable map backed by the specified    * navigable map.  In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing navigable map is accomplished    * through the returned navigable map (or its views).    *    *<p>It is imperative that the user manually synchronize on the returned    * navigable map when iterating over any of its collection views, or the    * collections views of any of its {@code descendingMap}, {@code subMap},    * {@code headMap} or {@code tailMap} views.<pre>   {@code    *    *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    *    *   // Needn't be in synchronized block    *   NavigableSet<K> set = map.navigableKeySet();    *    *   synchronized (map) { // Synchronizing on map, not set!    *     Iterator<K> it = set.iterator(); // Must be in synchronized block    *     while (it.hasNext()){    *       foo(it.next());    *     }    *   }}</pre>    *    * or:<pre>   {@code    *    *   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());    *   NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);    *    *   // Needn't be in synchronized block    *   NavigableSet<K> set2 = map2.descendingKeySet();    *    *   synchronized (map) { // Synchronizing on map, not map2 or set2!    *     Iterator<K> it = set2.iterator(); // Must be in synchronized block    *     while (it.hasNext()){    *       foo(it.next());    *     }    *   }}</pre>    *    * Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned navigable map will be serializable if the specified    * navigable map is serializable.    *    * @param navigableMap the navigable map to be "wrapped" in a synchronized    *    navigable map.    * @return a synchronized view of the specified navigable map.    * @deprecated Use {@link Maps#synchronizedNavigableMap}.    */
annotation|@
name|Deprecated
DECL|method|synchronizedNavigableMap ( NavigableMap<K, V> navigableMap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|navigableMap
parameter_list|)
block|{
return|return
name|synchronizedNavigableMap
argument_list|(
name|navigableMap
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|synchronizedNavigableMap ( NavigableMap<K, V> navigableMap, @Nullable Object mutex)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|navigableMap
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
return|return
operator|new
name|SynchronizedNavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|navigableMap
argument_list|,
name|mutex
argument_list|)
return|;
block|}
DECL|class|SynchronizedNavigableMap
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|SynchronizedNavigableMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SynchronizedSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SynchronizedNavigableMap ( NavigableMap<K, V> delegate, @Nullable Object mutex)
name|SynchronizedNavigableMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|Object
name|mutex
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|ceilingEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|ceilingKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
DECL|field|descendingKeySet
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
decl_stmt|;
DECL|method|descendingKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|descendingKeySet
operator|==
literal|null
condition|)
block|{
return|return
name|descendingKeySet
operator|=
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|descendingKeySet
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
return|return
name|descendingKeySet
return|;
block|}
block|}
DECL|field|descendingMap
specifier|transient
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
decl_stmt|;
DECL|method|descendingMap ()
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|descendingMap
operator|==
literal|null
condition|)
block|{
return|return
name|descendingMap
operator|=
name|synchronizedNavigableMap
argument_list|(
name|delegate
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
return|return
name|descendingMap
return|;
block|}
block|}
DECL|method|firstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|firstEntry
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|firstEntry
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|floorEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|floorKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
DECL|method|headMap (K toKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableMap
argument_list|(
name|delegate
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|higherEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|higherKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
DECL|method|lastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastEntry
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|lastEntry
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|lowerEntry (K key)
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|lowerKey (K key)
annotation|@
name|Override
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|delegate
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|field|navigableKeySet
specifier|transient
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
decl_stmt|;
DECL|method|navigableKeySet ()
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|navigableKeySet
operator|==
literal|null
condition|)
block|{
return|return
name|navigableKeySet
operator|=
name|synchronizedNavigableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
return|return
name|navigableKeySet
return|;
block|}
block|}
DECL|method|pollFirstEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|pollFirstEntry
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|pollLastEntry ()
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|nullableSynchronizedEntry
argument_list|(
name|delegate
argument_list|()
operator|.
name|pollLastEntry
argument_list|()
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableMap
argument_list|(
name|delegate
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|tailMap (K fromKey, boolean inclusive)
annotation|@
name|Override
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
return|return
name|synchronizedNavigableMap
argument_list|(
name|delegate
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|,
name|mutex
argument_list|)
return|;
block|}
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
block|}
end_class

end_unit

