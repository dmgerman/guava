begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkElementIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedLists
operator|.
name|KeyAbsentBehavior
operator|.
name|NEXT_HIGHER
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedLists
operator|.
name|KeyAbsentBehavior
operator|.
name|NEXT_LOWER
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedLists
operator|.
name|KeyPresentBehavior
operator|.
name|ANY_PRESENT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedLists
operator|.
name|KeyAbsentBehavior
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SortedLists
operator|.
name|KeyPresentBehavior
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|concurrent
operator|.
name|LazyInit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A {@link RangeSet} whose contents will never change, with many other important properties  * detailed at {@link ImmutableCollection}.  *  * @author Louis Wasserman  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|ImmutableRangeSet
specifier|public
specifier|final
class|class
name|ImmutableRangeSet
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
extends|extends
name|AbstractRangeSet
argument_list|<
name|C
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|ImmutableRangeSet
argument_list|<
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
name|EMPTY
init|=
operator|new
name|ImmutableRangeSet
argument_list|<>
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Range
argument_list|<
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|ALL
specifier|private
specifier|static
specifier|final
name|ImmutableRangeSet
argument_list|<
name|Comparable
argument_list|<
name|?
argument_list|>
argument_list|>
name|ALL
init|=
operator|new
name|ImmutableRangeSet
argument_list|<>
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Range
operator|.
expr|<
name|Comparable
argument_list|<
name|?
argument_list|>
operator|>
name|all
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Returns a {@code Collector} that accumulates the input elements into a new {@code    * ImmutableRangeSet}. As in {@link Builder}, overlapping ranges are not permitted and adjacent    * ranges will be merged.    *    * @since 23.1    */
annotation|@
name|Beta
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|E
argument_list|>
parameter_list|>
DECL|method|toImmutableRangeSet ()
name|Collector
argument_list|<
name|Range
argument_list|<
name|E
argument_list|>
argument_list|,
name|?
argument_list|,
name|ImmutableRangeSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|toImmutableRangeSet
parameter_list|()
block|{
return|return
name|CollectCollectors
operator|.
name|toImmutableRangeSet
argument_list|()
return|;
block|}
comment|/** Returns an empty immutable range set. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|of ()
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|of
parameter_list|()
block|{
return|return
operator|(
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
operator|)
name|EMPTY
return|;
block|}
comment|/** Returns an immutable range set containing the single range {@link Range#all()}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|all ()
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|all
parameter_list|()
block|{
return|return
operator|(
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
operator|)
name|ALL
return|;
block|}
comment|/**    * Returns an immutable range set containing the specified single range. If {@link Range#isEmpty()    * range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.    */
DECL|method|of (Range<C> range)
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|of
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|of
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|equals
argument_list|(
name|Range
operator|.
name|all
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|all
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|range
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Returns an immutable copy of the specified {@code RangeSet}. */
DECL|method|copyOf (RangeSet<C> rangeSet)
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|copyOf
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|rangeSet
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|rangeSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangeSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|of
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|rangeSet
operator|.
name|encloses
argument_list|(
name|Range
operator|.
expr|<
name|C
operator|>
name|all
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|all
argument_list|()
return|;
block|}
if|if
condition|(
name|rangeSet
operator|instanceof
name|ImmutableRangeSet
condition|)
block|{
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|immutableRangeSet
init|=
operator|(
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
operator|)
name|rangeSet
decl_stmt|;
if|if
condition|(
operator|!
name|immutableRangeSet
operator|.
name|isPartialView
argument_list|()
condition|)
block|{
return|return
name|immutableRangeSet
return|;
block|}
block|}
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|rangeSet
operator|.
name|asRanges
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an {@code ImmutableRangeSet} representing the union of the specified ranges.    *    *<p>This is the smallest {@code RangeSet} which encloses each of the specified ranges. Duplicate    * or connected ranges are permitted, and will be coalesced in the result.    *    * @since 21.0    */
DECL|method|unionOf (Iterable<Range<C>> ranges)
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|unionOf
parameter_list|(
name|Iterable
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|)
block|{
return|return
name|copyOf
argument_list|(
name|TreeRangeSet
operator|.
name|create
argument_list|(
name|ranges
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an {@code ImmutableRangeSet} containing each of the specified disjoint ranges.    * Overlapping ranges and empty ranges are forbidden, though adjacent ranges are permitted and    * will be merged.    *    * @throws IllegalArgumentException if any ranges overlap or are empty    * @since 21.0    */
DECL|method|copyOf (Iterable<Range<C>> ranges)
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|copyOf
parameter_list|(
name|Iterable
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|)
block|{
return|return
operator|new
name|ImmutableRangeSet
operator|.
name|Builder
argument_list|<
name|C
argument_list|>
argument_list|()
operator|.
name|addAll
argument_list|(
name|ranges
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|ImmutableRangeSet (ImmutableList<Range<C>> ranges)
name|ImmutableRangeSet
parameter_list|(
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|)
block|{
name|this
operator|.
name|ranges
operator|=
name|ranges
expr_stmt|;
block|}
DECL|method|ImmutableRangeSet (ImmutableList<Range<C>> ranges, ImmutableRangeSet<C> complement)
specifier|private
name|ImmutableRangeSet
parameter_list|(
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|,
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|complement
parameter_list|)
block|{
name|this
operator|.
name|ranges
operator|=
name|ranges
expr_stmt|;
name|this
operator|.
name|complement
operator|=
name|complement
expr_stmt|;
block|}
DECL|field|ranges
specifier|private
specifier|final
specifier|transient
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
decl_stmt|;
annotation|@
name|Override
DECL|method|intersects (Range<C> otherRange)
specifier|public
name|boolean
name|intersects
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|otherRange
parameter_list|)
block|{
name|int
name|ceilingIndex
init|=
name|SortedLists
operator|.
name|binarySearch
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|lowerBoundFn
argument_list|()
argument_list|,
name|otherRange
operator|.
name|lowerBound
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|ANY_PRESENT
argument_list|,
name|NEXT_HIGHER
argument_list|)
decl_stmt|;
if|if
condition|(
name|ceilingIndex
operator|<
name|ranges
operator|.
name|size
argument_list|()
operator|&&
name|ranges
operator|.
name|get
argument_list|(
name|ceilingIndex
argument_list|)
operator|.
name|isConnected
argument_list|(
name|otherRange
argument_list|)
operator|&&
operator|!
name|ranges
operator|.
name|get
argument_list|(
name|ceilingIndex
argument_list|)
operator|.
name|intersection
argument_list|(
name|otherRange
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|ceilingIndex
operator|>
literal|0
operator|&&
name|ranges
operator|.
name|get
argument_list|(
name|ceilingIndex
operator|-
literal|1
argument_list|)
operator|.
name|isConnected
argument_list|(
name|otherRange
argument_list|)
operator|&&
operator|!
name|ranges
operator|.
name|get
argument_list|(
name|ceilingIndex
operator|-
literal|1
argument_list|)
operator|.
name|intersection
argument_list|(
name|otherRange
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|encloses (Range<C> otherRange)
specifier|public
name|boolean
name|encloses
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|otherRange
parameter_list|)
block|{
name|int
name|index
init|=
name|SortedLists
operator|.
name|binarySearch
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|lowerBoundFn
argument_list|()
argument_list|,
name|otherRange
operator|.
name|lowerBound
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|ANY_PRESENT
argument_list|,
name|NEXT_LOWER
argument_list|)
decl_stmt|;
return|return
name|index
operator|!=
operator|-
literal|1
operator|&&
name|ranges
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|encloses
argument_list|(
name|otherRange
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rangeContaining (C value)
specifier|public
name|Range
argument_list|<
name|C
argument_list|>
name|rangeContaining
parameter_list|(
name|C
name|value
parameter_list|)
block|{
name|int
name|index
init|=
name|SortedLists
operator|.
name|binarySearch
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|lowerBoundFn
argument_list|()
argument_list|,
name|Cut
operator|.
name|belowValue
argument_list|(
name|value
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|,
name|ANY_PRESENT
argument_list|,
name|NEXT_LOWER
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|Range
argument_list|<
name|C
argument_list|>
name|range
init|=
name|ranges
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|range
operator|.
name|contains
argument_list|(
name|value
argument_list|)
condition|?
name|range
else|:
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|span ()
specifier|public
name|Range
argument_list|<
name|C
argument_list|>
name|span
parameter_list|()
block|{
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|Range
operator|.
name|create
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|lowerBound
argument_list|,
name|ranges
operator|.
name|get
argument_list|(
name|ranges
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|upperBound
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ranges
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|add (Range<C> range)
specifier|public
name|void
name|add
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|addAll (RangeSet<C> other)
specifier|public
name|void
name|addAll
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|other
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|addAll (Iterable<Range<C>> other)
specifier|public
name|void
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|other
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|remove (Range<C> range)
specifier|public
name|void
name|remove
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|removeAll (RangeSet<C> other)
specifier|public
name|void
name|removeAll
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|other
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.    *    * @throws UnsupportedOperationException always    * @deprecated Unsupported operation.    */
annotation|@
name|Deprecated
annotation|@
name|Override
DECL|method|removeAll (Iterable<Range<C>> other)
specifier|public
name|void
name|removeAll
parameter_list|(
name|Iterable
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|other
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|asRanges ()
specifier|public
name|ImmutableSet
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|asRanges
parameter_list|()
block|{
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<>
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|rangeLexOrdering
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|asDescendingSetOfRanges ()
specifier|public
name|ImmutableSet
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|asDescendingSetOfRanges
parameter_list|()
block|{
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
return|return
operator|new
name|RegularImmutableSortedSet
argument_list|<>
argument_list|(
name|ranges
operator|.
name|reverse
argument_list|()
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|rangeLexOrdering
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
return|;
block|}
DECL|field|complement
annotation|@
name|LazyInit
specifier|private
specifier|transient
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|complement
decl_stmt|;
DECL|class|ComplementRanges
specifier|private
specifier|final
class|class
name|ComplementRanges
extends|extends
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
block|{
comment|// True if the "positive" range set is empty or bounded below.
DECL|field|positiveBoundedBelow
specifier|private
specifier|final
name|boolean
name|positiveBoundedBelow
decl_stmt|;
comment|// True if the "positive" range set is empty or bounded above.
DECL|field|positiveBoundedAbove
specifier|private
specifier|final
name|boolean
name|positiveBoundedAbove
decl_stmt|;
DECL|field|size
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|ComplementRanges ()
name|ComplementRanges
parameter_list|()
block|{
name|this
operator|.
name|positiveBoundedBelow
operator|=
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hasLowerBound
argument_list|()
expr_stmt|;
name|this
operator|.
name|positiveBoundedAbove
operator|=
name|Iterables
operator|.
name|getLast
argument_list|(
name|ranges
argument_list|)
operator|.
name|hasUpperBound
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|ranges
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|positiveBoundedBelow
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|positiveBoundedAbove
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|get (int index)
specifier|public
name|Range
argument_list|<
name|C
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Cut
argument_list|<
name|C
argument_list|>
name|lowerBound
decl_stmt|;
if|if
condition|(
name|positiveBoundedBelow
condition|)
block|{
name|lowerBound
operator|=
operator|(
name|index
operator|==
literal|0
operator|)
condition|?
name|Cut
operator|.
expr|<
name|C
operator|>
name|belowAll
argument_list|()
else|:
name|ranges
operator|.
name|get
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|.
name|upperBound
expr_stmt|;
block|}
else|else
block|{
name|lowerBound
operator|=
name|ranges
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|upperBound
expr_stmt|;
block|}
name|Cut
argument_list|<
name|C
argument_list|>
name|upperBound
decl_stmt|;
if|if
condition|(
name|positiveBoundedAbove
operator|&&
name|index
operator|==
name|size
operator|-
literal|1
condition|)
block|{
name|upperBound
operator|=
name|Cut
operator|.
expr|<
name|C
operator|>
name|aboveAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|upperBound
operator|=
name|ranges
operator|.
name|get
argument_list|(
name|index
operator|+
operator|(
name|positiveBoundedBelow
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
operator|.
name|lowerBound
expr_stmt|;
block|}
return|return
name|Range
operator|.
name|create
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isPartialView ()
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|complement ()
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|complement
parameter_list|()
block|{
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|result
init|=
name|complement
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|complement
operator|=
name|all
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|Range
operator|.
name|all
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|complement
operator|=
name|of
argument_list|()
return|;
block|}
else|else
block|{
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|complementRanges
init|=
operator|new
name|ComplementRanges
argument_list|()
decl_stmt|;
name|result
operator|=
name|complement
operator|=
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|complementRanges
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns a new range set consisting of the union of this range set and {@code other}.    *    *<p>This is essentially the same as {@code TreeRangeSet.create(this).addAll(other)} except it    * returns an {@code ImmutableRangeSet}.    *    * @since 21.0    */
DECL|method|union (RangeSet<C> other)
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|union
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|other
parameter_list|)
block|{
return|return
name|unionOf
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|asRanges
argument_list|()
argument_list|,
name|other
operator|.
name|asRanges
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new range set consisting of the intersection of this range set and {@code other}.    *    *<p>This is essentially the same as {@code    * TreeRangeSet.create(this).removeAll(other.complement())} except it returns an {@code    * ImmutableRangeSet}.    *    * @since 21.0    */
DECL|method|intersection (RangeSet<C> other)
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|intersection
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|other
parameter_list|)
block|{
name|RangeSet
argument_list|<
name|C
argument_list|>
name|copy
init|=
name|TreeRangeSet
operator|.
name|create
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|removeAll
argument_list|(
name|other
operator|.
name|complement
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|copyOf
argument_list|(
name|copy
argument_list|)
return|;
block|}
comment|/**    * Returns a new range set consisting of the difference of this range set and {@code other}.    *    *<p>This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other)} except it    * returns an {@code ImmutableRangeSet}.    *    * @since 21.0    */
DECL|method|difference (RangeSet<C> other)
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|difference
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|other
parameter_list|)
block|{
name|RangeSet
argument_list|<
name|C
argument_list|>
name|copy
init|=
name|TreeRangeSet
operator|.
name|create
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|removeAll
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|copyOf
argument_list|(
name|copy
argument_list|)
return|;
block|}
comment|/**    * Returns a list containing the nonempty intersections of {@code range} with the ranges in this    * range set.    */
DECL|method|intersectRanges (final Range<C> range)
specifier|private
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|intersectRanges
parameter_list|(
specifier|final
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
operator|||
name|range
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|encloses
argument_list|(
name|span
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ranges
return|;
block|}
specifier|final
name|int
name|fromIndex
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
name|fromIndex
operator|=
name|SortedLists
operator|.
name|binarySearch
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|upperBoundFn
argument_list|()
argument_list|,
name|range
operator|.
name|lowerBound
argument_list|,
name|KeyPresentBehavior
operator|.
name|FIRST_AFTER
argument_list|,
name|KeyAbsentBehavior
operator|.
name|NEXT_HIGHER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fromIndex
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|toIndex
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
name|toIndex
operator|=
name|SortedLists
operator|.
name|binarySearch
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|lowerBoundFn
argument_list|()
argument_list|,
name|range
operator|.
name|upperBound
argument_list|,
name|KeyPresentBehavior
operator|.
name|FIRST_PRESENT
argument_list|,
name|KeyAbsentBehavior
operator|.
name|NEXT_HIGHER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toIndex
operator|=
name|ranges
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|length
init|=
name|toIndex
operator|-
name|fromIndex
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Range
argument_list|<
name|C
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
operator|||
name|index
operator|==
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|ranges
operator|.
name|get
argument_list|(
name|index
operator|+
name|fromIndex
argument_list|)
operator|.
name|intersection
argument_list|(
name|range
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ranges
operator|.
name|get
argument_list|(
name|index
operator|+
name|fromIndex
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
return|;
block|}
block|}
comment|/** Returns a view of the intersection of this range set with the given range. */
annotation|@
name|Override
DECL|method|subRangeSet (Range<C> range)
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|subRangeSet
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|Range
argument_list|<
name|C
argument_list|>
name|span
init|=
name|span
argument_list|()
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|encloses
argument_list|(
name|span
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|isConnected
argument_list|(
name|span
argument_list|)
condition|)
block|{
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|intersectRanges
argument_list|(
name|range
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|of
argument_list|()
return|;
block|}
comment|/**    * Returns an {@link ImmutableSortedSet} containing the same values in the given domain    * {@linkplain RangeSet#contains contained} by this range set.    *    *<p><b>Note:</b> {@code a.asSet(d).equals(b.asSet(d))} does not imply {@code a.equals(b)}! For    * example, {@code a} and {@code b} could be {@code [2..4]} and {@code (1..5)}, or the empty    * ranges {@code [3..3)} and {@code [4..4)}.    *    *<p><b>Warning:</b> Be extremely careful what you do with the {@code asSet} view of a large    * range set (such as {@code ImmutableRangeSet.of(Range.greaterThan(0))}). Certain operations on    * such a set can be performed efficiently, but others (such as {@link Set#hashCode} or {@link    * Collections#frequency}) can cause major performance problems.    *    *<p>The returned set's {@link Object#toString} method returns a short-hand form of the set's    * contents, such as {@code "[1..100]}"}.    *    * @throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if    *     neither has an upper bound    */
DECL|method|asSet (DiscreteDomain<C> domain)
specifier|public
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|asSet
parameter_list|(
name|DiscreteDomain
argument_list|<
name|C
argument_list|>
name|domain
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSortedSet
operator|.
name|of
argument_list|()
return|;
block|}
name|Range
argument_list|<
name|C
argument_list|>
name|span
init|=
name|span
argument_list|()
operator|.
name|canonical
argument_list|(
name|domain
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|span
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
comment|// according to the spec of canonical, neither this ImmutableRangeSet nor
comment|// the range have a lower bound
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Neither the DiscreteDomain nor this range set are bounded below"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|span
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
try|try
block|{
name|domain
operator|.
name|maxValue
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Neither the DiscreteDomain nor this range set are bounded above"
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|AsSet
argument_list|(
name|domain
argument_list|)
return|;
block|}
DECL|class|AsSet
specifier|private
specifier|final
class|class
name|AsSet
extends|extends
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
block|{
DECL|field|domain
specifier|private
specifier|final
name|DiscreteDomain
argument_list|<
name|C
argument_list|>
name|domain
decl_stmt|;
DECL|method|AsSet (DiscreteDomain<C> domain)
name|AsSet
parameter_list|(
name|DiscreteDomain
argument_list|<
name|C
argument_list|>
name|domain
parameter_list|)
block|{
name|super
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
block|}
DECL|field|size
specifier|private
specifier|transient
name|Integer
name|size
decl_stmt|;
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
comment|// racy single-check idiom
name|Integer
name|result
init|=
name|size
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|long
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
range|:
name|ranges
control|)
block|{
name|total
operator|+=
name|ContiguousSet
operator|.
name|create
argument_list|(
name|range
argument_list|,
name|domain
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|total
operator|>=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
break|break;
block|}
block|}
name|result
operator|=
name|size
operator|=
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|total
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|intValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|UnmodifiableIterator
argument_list|<
name|C
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|C
argument_list|>
argument_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|rangeItr
init|=
name|ranges
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|C
argument_list|>
name|elemItr
init|=
name|Iterators
operator|.
name|emptyIterator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|C
name|computeNext
parameter_list|()
block|{
while|while
condition|(
operator|!
name|elemItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|rangeItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|elemItr
operator|=
name|ContiguousSet
operator|.
name|create
argument_list|(
name|rangeItr
operator|.
name|next
argument_list|()
argument_list|,
name|domain
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
return|return
name|elemItr
operator|.
name|next
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|method|descendingIterator ()
specifier|public
name|UnmodifiableIterator
argument_list|<
name|C
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|C
argument_list|>
argument_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|rangeItr
init|=
name|ranges
operator|.
name|reverse
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|C
argument_list|>
name|elemItr
init|=
name|Iterators
operator|.
name|emptyIterator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|C
name|computeNext
parameter_list|()
block|{
while|while
condition|(
operator|!
name|elemItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|rangeItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|elemItr
operator|=
name|ContiguousSet
operator|.
name|create
argument_list|(
name|rangeItr
operator|.
name|next
argument_list|()
argument_list|,
name|domain
argument_list|)
operator|.
name|descendingIterator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
return|return
name|elemItr
operator|.
name|next
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|subSet (Range<C> range)
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|subSet
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
return|return
name|subRangeSet
argument_list|(
name|range
argument_list|)
operator|.
name|asSet
argument_list|(
name|domain
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSetImpl (C toElement, boolean inclusive)
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|headSetImpl
parameter_list|(
name|C
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|Range
operator|.
name|upTo
argument_list|(
name|toElement
argument_list|,
name|BoundType
operator|.
name|forBoolean
argument_list|(
name|inclusive
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSetImpl ( C fromElement, boolean fromInclusive, C toElement, boolean toInclusive)
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|subSetImpl
parameter_list|(
name|C
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|C
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fromInclusive
operator|&&
operator|!
name|toInclusive
operator|&&
name|Range
operator|.
name|compareOrThrow
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableSortedSet
operator|.
name|of
argument_list|()
return|;
block|}
return|return
name|subSet
argument_list|(
name|Range
operator|.
name|range
argument_list|(
name|fromElement
argument_list|,
name|BoundType
operator|.
name|forBoolean
argument_list|(
name|fromInclusive
argument_list|)
argument_list|,
name|toElement
argument_list|,
name|BoundType
operator|.
name|forBoolean
argument_list|(
name|toInclusive
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSetImpl (C fromElement, boolean inclusive)
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|tailSetImpl
parameter_list|(
name|C
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|Range
operator|.
name|downTo
argument_list|(
name|fromElement
argument_list|,
name|BoundType
operator|.
name|forBoolean
argument_list|(
name|inclusive
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@ullable Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// we catch CCE's
name|C
name|c
init|=
operator|(
name|C
operator|)
name|o
decl_stmt|;
return|return
name|ImmutableRangeSet
operator|.
name|this
operator|.
name|contains
argument_list|(
name|c
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|indexOf (Object target)
name|int
name|indexOf
parameter_list|(
name|Object
name|target
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// if it's contained, it's definitely a C
name|C
name|c
init|=
operator|(
name|C
operator|)
name|target
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|range
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|total
operator|+
name|ContiguousSet
operator|.
name|create
argument_list|(
name|range
argument_list|,
name|domain
argument_list|)
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|total
operator|+=
name|ContiguousSet
operator|.
name|create
argument_list|(
name|range
argument_list|,
name|domain
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"impossible"
argument_list|)
throw|;
block|}
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|createDescendingSet ()
name|ImmutableSortedSet
argument_list|<
name|C
argument_list|>
name|createDescendingSet
parameter_list|()
block|{
return|return
operator|new
name|DescendingImmutableSortedSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isPartialView ()
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
name|ranges
operator|.
name|isPartialView
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|ranges
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|AsSetSerializedForm
argument_list|<
name|C
argument_list|>
argument_list|(
name|ranges
argument_list|,
name|domain
argument_list|)
return|;
block|}
block|}
DECL|class|AsSetSerializedForm
specifier|private
specifier|static
class|class
name|AsSetSerializedForm
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|ranges
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
decl_stmt|;
DECL|field|domain
specifier|private
specifier|final
name|DiscreteDomain
argument_list|<
name|C
argument_list|>
name|domain
decl_stmt|;
DECL|method|AsSetSerializedForm (ImmutableList<Range<C>> ranges, DiscreteDomain<C> domain)
name|AsSetSerializedForm
parameter_list|(
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|,
name|DiscreteDomain
argument_list|<
name|C
argument_list|>
name|domain
parameter_list|)
block|{
name|this
operator|.
name|ranges
operator|=
name|ranges
expr_stmt|;
name|this
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
block|}
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|ranges
argument_list|)
operator|.
name|asSet
argument_list|(
name|domain
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns {@code true} if this immutable range set's implementation contains references to    * user-created objects that aren't accessible via this range set's methods. This is generally    * used to determine whether {@code copyOf} implementations should make an explicit copy to avoid    * memory leaks.    */
DECL|method|isPartialView ()
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
name|ranges
operator|.
name|isPartialView
argument_list|()
return|;
block|}
comment|/** Returns a new builder for an immutable range set. */
DECL|method|builder ()
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Builder
argument_list|<
name|C
argument_list|>
name|builder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|C
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * A builder for immutable range sets.    *    * @since 14.0    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|<
name|?
parameter_list|>
parameter_list|>
block|{
DECL|field|ranges
specifier|private
specifier|final
name|List
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
decl_stmt|;
DECL|method|Builder ()
specifier|public
name|Builder
parameter_list|()
block|{
name|this
operator|.
name|ranges
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
block|}
comment|// TODO(lowasser): consider adding union, in addition to add, that does allow overlap
comment|/**      * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,      * but overlapping ranges will cause an exception when {@link #build()} is called.      *      * @throws IllegalArgumentException if {@code range} is empty      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|add (Range<C> range)
specifier|public
name|Builder
argument_list|<
name|C
argument_list|>
name|add
parameter_list|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
parameter_list|)
block|{
name|checkArgument
argument_list|(
operator|!
name|range
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"range must not be empty, but was %s"
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|ranges
operator|.
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted      * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is      * called.      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|addAll (RangeSet<C> ranges)
specifier|public
name|Builder
argument_list|<
name|C
argument_list|>
name|addAll
parameter_list|(
name|RangeSet
argument_list|<
name|C
argument_list|>
name|ranges
parameter_list|)
block|{
return|return
name|addAll
argument_list|(
name|ranges
operator|.
name|asRanges
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be      * merged, but overlapping ranges will cause an exception when {@link #build()} is called.      *      * @throws IllegalArgumentException if any inserted ranges are empty      * @since 21.0      */
annotation|@
name|CanIgnoreReturnValue
DECL|method|addAll (Iterable<Range<C>> ranges)
specifier|public
name|Builder
argument_list|<
name|C
argument_list|>
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|)
block|{
for|for
control|(
name|Range
argument_list|<
name|C
argument_list|>
name|range
range|:
name|ranges
control|)
block|{
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|CanIgnoreReturnValue
DECL|method|combine (Builder<C> builder)
name|Builder
argument_list|<
name|C
argument_list|>
name|combine
parameter_list|(
name|Builder
argument_list|<
name|C
argument_list|>
name|builder
parameter_list|)
block|{
name|addAll
argument_list|(
name|builder
operator|.
name|ranges
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.      *      * @throws IllegalArgumentException if any input ranges have nonempty overlap      */
DECL|method|build ()
specifier|public
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
name|build
parameter_list|()
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|mergedRangesBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|(
name|ranges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|ranges
argument_list|,
name|Range
operator|.
expr|<
name|C
operator|>
name|rangeLexOrdering
argument_list|()
argument_list|)
expr_stmt|;
name|PeekingIterator
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|peekingItr
init|=
name|Iterators
operator|.
name|peekingIterator
argument_list|(
name|ranges
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|peekingItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Range
argument_list|<
name|C
argument_list|>
name|range
init|=
name|peekingItr
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|peekingItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Range
argument_list|<
name|C
argument_list|>
name|nextRange
init|=
name|peekingItr
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|isConnected
argument_list|(
name|nextRange
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
name|range
operator|.
name|intersection
argument_list|(
name|nextRange
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Overlapping ranges not permitted but found %s overlapping %s"
argument_list|,
name|range
argument_list|,
name|nextRange
argument_list|)
expr_stmt|;
name|range
operator|=
name|range
operator|.
name|span
argument_list|(
name|peekingItr
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|mergedRangesBuilder
operator|.
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|mergedRanges
init|=
name|mergedRangesBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|mergedRanges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|of
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|mergedRanges
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|mergedRanges
argument_list|)
operator|.
name|equals
argument_list|(
name|Range
operator|.
name|all
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|all
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|mergedRanges
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|SerializedForm
specifier|private
specifier|static
specifier|final
class|class
name|SerializedForm
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|ranges
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
decl_stmt|;
DECL|method|SerializedForm (ImmutableList<Range<C>> ranges)
name|SerializedForm
parameter_list|(
name|ImmutableList
argument_list|<
name|Range
argument_list|<
name|C
argument_list|>
argument_list|>
name|ranges
parameter_list|)
block|{
name|this
operator|.
name|ranges
operator|=
name|ranges
expr_stmt|;
block|}
DECL|method|readResolve ()
name|Object
name|readResolve
parameter_list|()
block|{
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|of
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|equals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Range
operator|.
name|all
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|all
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|ImmutableRangeSet
argument_list|<
name|C
argument_list|>
argument_list|(
name|ranges
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializedForm
argument_list|<
name|C
argument_list|>
argument_list|(
name|ranges
argument_list|)
return|;
block|}
block|}
end_class

end_unit

