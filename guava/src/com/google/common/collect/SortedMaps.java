begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link SortedMap} instances.  *  * @author Louis Wasserman  * @since 8.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
DECL|class|SortedMaps
specifier|public
specifier|final
class|class
name|SortedMaps
block|{
DECL|method|SortedMaps ()
specifier|private
name|SortedMaps
parameter_list|()
block|{}
comment|/**    * Returns a view of a sorted map where each value is transformed by a    * function. All other properties of the map, such as iteration order, are    * left intact. For example, the code:<pre>   {@code    *    *   SortedMap<String, Integer> map = ImmutableSortedMap.of("a", 4, "b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   SortedMap<String, Double> transformed =    *        Maps.transformSortedValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    *     * @deprecated Use {@link Maps#transformValues(SortedMap, Function)}    */
DECL|method|transformValues ( SortedMap<K, V1> fromMap, final Function<? super V1, V2> function)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformValues
argument_list|(
name|fromMap
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a sorted map whose values are derived from the original    * sorted map's entries. In contrast to {@link #transformValues}, this    * method's entry-transformation logic may depend on the key as well as the    * value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   Map<String, Boolean> options =    *       ImmutableSortedMap.of("verbose", true, "sort", false);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : "yes" + key;    *         }    *       };    *   SortedMap<String, String> transformed =    *       LabsMaps.transformSortedEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {sort=yessort, verbose=verbose}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *     * @deprecated Use {@link Maps#transformEntries(SortedMap, EntryTransformer)}    */
DECL|method|transformEntries ( final SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
specifier|final
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Computes the difference between two sorted maps, using the comparator of    * the left map, or {@code Ordering.natural()} if the left map uses the    * natural ordering of its elements. This difference is an immutable snapshot    * of the state of the maps at the time this method is called. It will never    * change, even if the maps change at a later time.    *    *<p>Since this method uses {@code TreeMap} instances internally, the keys of    * the right map must all compare as distinct according to the comparator    * of the left map.    *    *<p><b>Note:</b>If you only need to know whether two sorted maps have the    * same mappings, call {@code left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    * @deprecated Use {@link Maps#difference(SortedMap, Map)}    */
DECL|method|difference ( SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Returns the specified comparator if not null; otherwise returns {@code    * Ordering.natural()}. This method is an abomination of generics; the only    * purpose of this method is to contain the ugly type-casting in one place.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|orNaturalOrder ( @ullable Comparator<? super E> comparator)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|orNaturalOrder
parameter_list|(
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|!=
literal|null
condition|)
block|{
comment|// can't use ? : because of javac bug 5080917
return|return
name|comparator
return|;
block|}
return|return
operator|(
name|Comparator
argument_list|<
name|E
argument_list|>
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose    * keys satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a key that    * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}    * methods throw an {@link IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose keys satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code keyPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"untested"
argument_list|)
DECL|method|filterKeys ( SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
comment|// TODO: Return a subclass of Maps.FilteredKeyMap for slightly better
comment|// performance.
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|keyPredicate
operator|.
name|apply
argument_list|(
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} whose    * values satisfy a predicate. The returned map is a live view of {@code    * unfiltered}; changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a value    * that doesn't satisfy the predicate, the map's {@code put()}, {@code    * putAll()}, and {@link Entry#setValue} methods throw an {@link     * IllegalArgumentException}.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose values satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code valuePredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}. Do not provide a    * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is    * inconsistent with equals.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"untested"
argument_list|)
DECL|method|filterValues ( SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|valuePredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|valuePredicate
operator|.
name|apply
argument_list|(
name|input
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a sorted map containing the mappings in {@code unfiltered} that    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. When given a    * key/value pair that doesn't satisfy the predicate, the map's {@code put()}    * and {@code putAll()} methods throw an {@link IllegalArgumentException}.    * Similarly, the map's entries have a {@link Entry#setValue} method that    * throws an {@link IllegalArgumentException} when the existing key and the    * provided value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings that satisfy the filter    * will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    *    *<p><b>Warning:</b> {@code entryPredicate} must be<i>consistent with    * equals</i>, as documented at {@link Predicate#apply}.    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"untested"
argument_list|)
DECL|method|filterEntries ( SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|FilteredSortedMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered sorted map.    */
DECL|method|filterFiltered ( FilteredSortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|sortedMap
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|class|FilteredSortedMap
specifier|private
specifier|static
class|class
name|FilteredSortedMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Maps
operator|.
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|FilteredSortedMap (SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredSortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
return|;
block|}
DECL|method|comparator ()
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
DECL|method|firstKey ()
annotation|@
name|Override
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
return|return
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|lastKey ()
annotation|@
name|Override
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
init|=
name|sortedMap
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// correctly throws NoSuchElementException when filtered map is empty.
name|K
name|key
init|=
name|headMap
operator|.
name|lastKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|key
return|;
block|}
name|headMap
operator|=
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|headMap (K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|subMap (K fromKey, K toKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|tailMap (K fromKey)
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

