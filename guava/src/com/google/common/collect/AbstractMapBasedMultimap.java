begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Basic implementation of the {@link Multimap} interface. This class represents  * a multimap as a map that associates each key with a collection of values. All  * methods of {@link Multimap} are supported, including those specified as  * optional in the interface.  *  *<p>To implement a multimap, a subclass must define the method {@link  * #createCollection()}, which creates an empty collection of values for a key.  *  *<p>The multimap constructor takes a map that has a single entry for each  * distinct key. When you insert a key-value pair with a key that isn't already  * in the multimap, {@code AbstractMapBasedMultimap} calls {@link #createCollection()}  * to create the collection of values for that key. The subclass should not call  * {@link #createCollection()} directly, and a new instance should be created  * every time the method is called.  *  *<p>For example, the subclass could pass a {@link java.util.TreeMap} during  * construction, and {@link #createCollection()} could return a {@link  * java.util.TreeSet}, in which case the multimap's iterators would propagate  * through the keys and values in sorted order.  *  *<p>Keys and values may be null, as long as the underlying collection classes  * support null elements.  *  *<p>The collections created by {@link #createCollection()} may or may not  * allow duplicates. If the collection, such as a {@link Set}, does not support  * duplicates, an added key-value pair will replace an existing pair with the  * same key and value, if such a pair is present. With collections like {@link  * List} that allow duplicates, the collection will keep the existing key-value  * pairs while adding a new pair.  *  *<p>This class is not threadsafe when any concurrent operations update the  * multimap, even if the underlying map and {@link #createCollection()} method  * return threadsafe classes. Concurrent read operations will work correctly. To  * allow concurrent update operations, wrap your multimap with a call to {@link  * Multimaps#synchronizedMultimap}.  *  *<p>For serialization to work, the subclass must specify explicit  * {@code readObject} and {@code writeObject} methods.  *  * @author Jared Levy  * @author Louis Wasserman  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|AbstractMapBasedMultimap
specifier|abstract
class|class
name|AbstractMapBasedMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
comment|/*    * Here's an outline of the overall design.    *    * The map variable contains the collection of values associated with each    * key. When a key-value pair is added to a multimap that didn't previously    * contain any values for that key, a new collection generated by    * createCollection is added to the map. That same collection instance    * remains in the map as long as the multimap has any values for the key. If    * all values for the key are removed, the key and collection are removed    * from the map.    *    * The get method returns a WrappedCollection, which decorates the collection    * in the map (if the key is present) or an empty collection (if the key is    * not present). When the collection delegate in the WrappedCollection is    * empty, the multimap may contain subsequently added values for that key. To    * handle that situation, the WrappedCollection checks whether map contains    * an entry for the provided key, and if so replaces the delegate.    */
DECL|field|map
specifier|private
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
decl_stmt|;
DECL|field|totalSize
specifier|private
specifier|transient
name|int
name|totalSize
decl_stmt|;
comment|/**    * Creates a new multimap that uses the provided map.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|AbstractMapBasedMultimap (Map<K, Collection<V>> map)
specifier|protected
name|AbstractMapBasedMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/** Used during deserialization only. */
DECL|method|setMap (Map<K, Collection<V>> map)
specifier|final
name|void
name|setMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Collection
argument_list|<
name|V
argument_list|>
name|values
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|checkArgument
argument_list|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|values
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates an unmodifiable, empty collection of values.    *    *<p>This is used in {@link #removeAll} on an empty key.    */
DECL|method|createUnmodifiableEmptyCollection ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createUnmodifiableEmptyCollection
parameter_list|()
block|{
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|createCollection
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates the collection of values for a single key.    *    *<p>Collections with weak, soft, or phantom references are not supported.    * Each call to {@code createCollection} should create a new instance.    *    *<p>The returned collection class determines whether duplicate key-value    * pairs are allowed.    *    * @return an empty collection of values    */
DECL|method|createCollection ()
specifier|abstract
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
function_decl|;
comment|/**    * Creates the collection of values for an explicitly provided key. By    * default, it simply calls {@link #createCollection()}, which is the correct    * behavior for most implementations. The {@link LinkedHashMultimap} class    * overrides it.    *    * @param key key to associate with values in the collection    * @return an empty collection of values    */
DECL|method|createCollection (@ullable K key)
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|)
block|{
return|return
name|createCollection
argument_list|()
return|;
block|}
DECL|method|backingMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|backingMap
parameter_list|()
block|{
return|return
name|map
return|;
block|}
comment|// Query Operations
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|totalSize
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (@ullable Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// Modification Operations
annotation|@
name|Override
DECL|method|put (@ullable K key, @Nullable V value)
specifier|public
name|boolean
name|put
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"New Collection violated the Collection spec"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|getOrCreateCollection (@ullable K key)
specifier|private
name|Collection
argument_list|<
name|V
argument_list|>
name|getOrCreateCollection
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
return|return
name|collection
return|;
block|}
comment|// Bulk Operations
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is immutable.    */
annotation|@
name|Override
DECL|method|replaceValues (@ullable K key, Iterable<? extends V> values)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|iterator
init|=
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|removeAll
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// TODO(user): investigate atomic failure?
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|getOrCreateCollection
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|oldValues
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|oldValues
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
block|}
block|}
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|oldValues
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is immutable.    */
annotation|@
name|Override
DECL|method|removeAll (@ullable Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|Nullable
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
name|createUnmodifiableEmptyCollection
argument_list|()
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|output
argument_list|)
return|;
block|}
DECL|method|unmodifiableCollectionSubclass (Collection<V> collection)
name|Collection
argument_list|<
name|V
argument_list|>
name|unmodifiableCollectionSubclass
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
comment|// We don't deal with NavigableSet here yet for GWT reasons -- instead,
comment|// non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// Clear each collection, to make previously returned collections empty.
for|for
control|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
block|}
comment|// Views
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is not serializable.    */
annotation|@
name|Override
DECL|method|get (@ullable K key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapCollection
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
return|;
block|}
comment|/**    * Generates a decorated collection that remains consistent with the values in    * the multimap for the provided key. Changes to the multimap may alter the    * returned collection, and vice versa.    */
DECL|method|wrapCollection (@ullable K key, Collection<V> collection)
name|Collection
argument_list|<
name|V
argument_list|>
name|wrapCollection
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
comment|// We don't deal with NavigableSet here yet for GWT reasons -- instead,
comment|// non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|key
argument_list|,
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
operator|new
name|WrappedSet
argument_list|(
name|key
argument_list|,
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|wrapList
argument_list|(
name|key
argument_list|,
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|WrappedCollection
argument_list|(
name|key
argument_list|,
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
DECL|method|wrapList ( @ullable K key, List<V> list, @Nullable WrappedCollection ancestor)
specifier|private
name|List
argument_list|<
name|V
argument_list|>
name|wrapList
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
return|return
operator|(
name|list
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|RandomAccessWrappedList
argument_list|(
name|key
argument_list|,
name|list
argument_list|,
name|ancestor
argument_list|)
else|:
operator|new
name|WrappedList
argument_list|(
name|key
argument_list|,
name|list
argument_list|,
name|ancestor
argument_list|)
return|;
block|}
comment|/**    * Collection decorator that stays in sync with the multimap values for a key.    * There are two kinds of wrapped collections: full and subcollections. Both    * have a delegate pointing to the underlying collection class.    *    *<p>Full collections, identified by a null ancestor field, contain all    * multimap values for a given key. Its delegate is a value in {@link    * AbstractMapBasedMultimap#map} whenever the delegate is non-empty. The {@code    * refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure    * that the {@code WrappedCollection} and map remain consistent.    *    *<p>A subcollection, such as a sublist, contains some of the values for a    * given key. Its ancestor field points to the full wrapped collection with    * all values for the key. The subcollection {@code refreshIfEmpty}, {@code    * removeIfEmpty}, and {@code addToMap} methods call the corresponding methods    * of the full wrapped collection.    */
DECL|class|WrappedCollection
specifier|private
class|class
name|WrappedCollection
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|delegate
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|ancestor
specifier|final
name|WrappedCollection
name|ancestor
decl_stmt|;
DECL|field|ancestorDelegate
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|ancestorDelegate
decl_stmt|;
DECL|method|WrappedCollection (@ullable K key, Collection<V> delegate, @Nullable WrappedCollection ancestor)
name|WrappedCollection
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|ancestor
operator|=
name|ancestor
expr_stmt|;
name|this
operator|.
name|ancestorDelegate
operator|=
operator|(
name|ancestor
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ancestor
operator|.
name|getDelegate
argument_list|()
expr_stmt|;
block|}
comment|/**      * If the delegate collection is empty, but the multimap has values for the      * key, replace the delegate with the new collection for the key.      *      *<p>For a subcollection, refresh its ancestor and validate that the      * ancestor delegate hasn't changed.      */
DECL|method|refreshIfEmpty ()
name|void
name|refreshIfEmpty
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|refreshIfEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|ancestor
operator|.
name|getDelegate
argument_list|()
operator|!=
name|ancestorDelegate
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|delegate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|newDelegate
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDelegate
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|=
name|newDelegate
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}.      * For subcollections, check whether the ancestor collection is empty.      */
DECL|method|removeIfEmpty ()
name|void
name|removeIfEmpty
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delegate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
comment|/**      * Add the delegate to the map. Other {@code WrappedCollection} methods      * should call this method after adding elements to a previously empty      * collection.      *      *<p>Subcollection add the ancestor's delegate instead.      */
DECL|method|addToMap ()
name|void
name|addToMap
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|addToMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getDelegate ()
name|Collection
argument_list|<
name|V
argument_list|>
name|getDelegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedIterator
argument_list|()
return|;
block|}
comment|/** Collection iterator for {@code WrappedCollection}. */
DECL|class|WrappedIterator
class|class
name|WrappedIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
DECL|field|delegateIterator
specifier|final
name|Iterator
argument_list|<
name|V
argument_list|>
name|delegateIterator
decl_stmt|;
DECL|field|originalDelegate
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|originalDelegate
init|=
name|delegate
decl_stmt|;
DECL|method|WrappedIterator ()
name|WrappedIterator
parameter_list|()
block|{
name|delegateIterator
operator|=
name|iteratorOrListIterator
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|WrappedIterator (Iterator<V> delegateIterator)
name|WrappedIterator
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|delegateIterator
parameter_list|)
block|{
name|this
operator|.
name|delegateIterator
operator|=
name|delegateIterator
expr_stmt|;
block|}
comment|/**        * If the delegate changed since the iterator was created, the iterator is        * no longer valid.        */
DECL|method|validateIterator ()
name|void
name|validateIterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|delegate
operator|!=
name|originalDelegate
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegateIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
DECL|method|getDelegateIterator ()
name|Iterator
argument_list|<
name|V
argument_list|>
name|getDelegateIterator
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
return|;
block|}
block|}
DECL|method|add (V value)
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|wasEmpty
init|=
name|delegate
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
name|delegate
operator|.
name|add
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|getAncestor ()
name|WrappedCollection
name|getAncestor
parameter_list|()
block|{
return|return
name|ancestor
return|;
block|}
comment|// The following methods are provided for better performance.
DECL|method|addAll (Collection<? extends V> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|delegate
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|oldSize
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
comment|// maybe shouldn't be removed if this is a sublist
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|changed
init|=
name|delegate
operator|.
name|remove
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
DECL|method|removeAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|removeAll
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
DECL|method|retainAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|retainAll
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
block|}
DECL|method|iteratorOrListIterator (Collection<V> collection)
specifier|private
name|Iterator
argument_list|<
name|V
argument_list|>
name|iteratorOrListIterator
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
return|return
operator|(
name|collection
operator|instanceof
name|List
operator|)
condition|?
operator|(
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
operator|)
operator|.
name|listIterator
argument_list|()
else|:
name|collection
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** Set decorator that stays in sync with the multimap values for a key. */
DECL|class|WrappedSet
specifier|private
class|class
name|WrappedSet
extends|extends
name|WrappedCollection
implements|implements
name|Set
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedSet (@ullable K key, Set<V> delegate)
name|WrappedSet
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|Set
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
comment|// Guava issue 1013: AbstractSet and most JDK set implementations are
comment|// susceptible to quadratic removeAll performance on lists;
comment|// use a slightly smarter implementation here
name|boolean
name|changed
init|=
name|Sets
operator|.
name|removeAllImpl
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|delegate
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
block|}
comment|/**    * SortedSet decorator that stays in sync with the multimap values for a key.    */
DECL|class|WrappedSortedSet
specifier|private
class|class
name|WrappedSortedSet
extends|extends
name|WrappedCollection
implements|implements
name|SortedSet
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedSortedSet (@ullable K key, SortedSet<V> delegate, @Nullable WrappedCollection ancestor)
name|WrappedSortedSet
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|SortedSet
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
DECL|method|getSortedSetDelegate ()
name|SortedSet
argument_list|<
name|V
argument_list|>
name|getSortedSetDelegate
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|V
name|first
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|first
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|V
name|last
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|last
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (V toElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|headSet
parameter_list|(
name|V
name|toElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (V fromElement, V toElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|subSet
parameter_list|(
name|V
name|fromElement
parameter_list|,
name|V
name|toElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (V fromElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|tailSet
parameter_list|(
name|V
name|fromElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|class|WrappedNavigableSet
class|class
name|WrappedNavigableSet
extends|extends
name|WrappedSortedSet
implements|implements
name|NavigableSet
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedNavigableSet ( @ullable K key, NavigableSet<V> delegate, @Nullable WrappedCollection ancestor)
name|WrappedNavigableSet
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getSortedSetDelegate ()
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|getSortedSetDelegate
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
operator|)
name|super
operator|.
name|getSortedSetDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lower (V v)
specifier|public
name|V
name|lower
parameter_list|(
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|lower
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (V v)
specifier|public
name|V
name|floor
parameter_list|(
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|floor
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (V v)
specifier|public
name|V
name|ceiling
parameter_list|(
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|ceiling
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (V v)
specifier|public
name|V
name|higher
parameter_list|(
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|higher
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|V
name|pollFirst
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|V
name|pollLast
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|wrap (NavigableSet<V> wrapped)
specifier|private
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|wrap
parameter_list|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|wrapped
parameter_list|)
block|{
return|return
operator|new
name|WrappedNavigableSet
argument_list|(
name|key
argument_list|,
name|wrapped
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|descendingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
operator|new
name|WrappedIterator
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|subSet
parameter_list|(
name|V
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|V
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (V toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|headSet
parameter_list|(
name|V
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (V fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|tailSet
parameter_list|(
name|V
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** List decorator that stays in sync with the multimap values for a key. */
DECL|class|WrappedList
specifier|private
class|class
name|WrappedList
extends|extends
name|WrappedCollection
implements|implements
name|List
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedList (@ullable K key, List<V> delegate, @Nullable WrappedCollection ancestor)
name|WrappedList
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
DECL|method|getListDelegate ()
name|List
argument_list|<
name|V
argument_list|>
name|getListDelegate
parameter_list|()
block|{
return|return
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addAll (int index, Collection<? extends V> c)
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|getListDelegate
argument_list|()
operator|.
name|addAll
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|getDelegate
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|Override
DECL|method|get (int index)
specifier|public
name|V
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|set (int index, V element)
specifier|public
name|V
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|V
name|element
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|add (int index, V element)
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|V
name|element
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|wasEmpty
init|=
name|getDelegate
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|getListDelegate
argument_list|()
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove (int index)
specifier|public
name|V
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|V
name|value
init|=
name|getListDelegate
argument_list|()
operator|.
name|remove
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|indexOf (Object o)
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|indexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastIndexOf (Object o)
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|listIterator ()
specifier|public
name|ListIterator
argument_list|<
name|V
argument_list|>
name|listIterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedListIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|listIterator (int index)
specifier|public
name|ListIterator
argument_list|<
name|V
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedListIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subList (int fromIndex, int toIndex)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|wrapList
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getListDelegate
argument_list|()
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
comment|/** ListIterator decorator. */
DECL|class|WrappedListIterator
specifier|private
class|class
name|WrappedListIterator
extends|extends
name|WrappedIterator
implements|implements
name|ListIterator
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedListIterator ()
name|WrappedListIterator
parameter_list|()
block|{}
DECL|method|WrappedListIterator (int index)
specifier|public
name|WrappedListIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|getListDelegate
argument_list|()
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getDelegateListIterator ()
specifier|private
name|ListIterator
argument_list|<
name|V
argument_list|>
name|getDelegateListIterator
parameter_list|()
block|{
return|return
operator|(
name|ListIterator
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegateIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasPrevious ()
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|hasPrevious
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|previous ()
specifier|public
name|V
name|previous
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|previous
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextIndex ()
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|nextIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|previousIndex ()
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|previousIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|set (V value)
specifier|public
name|void
name|set
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|getDelegateListIterator
argument_list|()
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|add (V value)
specifier|public
name|void
name|add
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|boolean
name|wasEmpty
init|=
name|isEmpty
argument_list|()
decl_stmt|;
name|getDelegateListIterator
argument_list|()
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * List decorator that stays in sync with the multimap values for a key and    * supports rapid random access.    */
DECL|class|RandomAccessWrappedList
specifier|private
class|class
name|RandomAccessWrappedList
extends|extends
name|WrappedList
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessWrappedList (@ullable K key, List<V> delegate, @Nullable WrappedCollection ancestor)
name|RandomAccessWrappedList
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
comment|// TreeMultimap uses NavigableKeySet explicitly, but we don't handle that here for GWT
comment|// compatibility reasons
return|return
operator|(
name|map
operator|instanceof
name|SortedMap
operator|)
condition|?
operator|new
name|SortedKeySet
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
else|:
operator|new
name|KeySet
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|class|KeySet
specifier|private
class|class
name|KeySet
extends|extends
name|Maps
operator|.
name|KeySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|KeySet (final Map<K, Collection<V>> subMap)
name|KeySet
parameter_list|(
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entryIterator
init|=
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|K
name|next
parameter_list|()
block|{
name|entry
operator|=
name|entryIterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|Iterators
operator|.
name|checkRemove
argument_list|(
name|entry
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|entryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|// The following methods are included for better performance.
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
name|count
operator|=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|count
operator|>
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Iterators
operator|.
name|clear
argument_list|(
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|this
operator|==
name|object
operator|||
name|this
operator|.
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
DECL|class|SortedKeySet
specifier|private
class|class
name|SortedKeySet
extends|extends
name|KeySet
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|SortedKeySet (SortedMap<K, Collection<V>> subMap)
name|SortedKeySet
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|map
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableSet"
argument_list|)
DECL|class|NavigableKeySet
class|class
name|NavigableKeySet
extends|extends
name|SortedKeySet
implements|implements
name|NavigableSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|NavigableKeySet (NavigableMap<K, Collection<V>> subMap)
name|NavigableKeySet
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|sortedMap ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|sortedMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lower (K k)
specifier|public
name|K
name|lower
parameter_list|(
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floor (K k)
specifier|public
name|K
name|floor
parameter_list|(
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceiling (K k)
specifier|public
name|K
name|ceiling
parameter_list|(
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higher (K k)
specifier|public
name|K
name|higher
parameter_list|(
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirst ()
specifier|public
name|K
name|pollFirst
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLast ()
specifier|public
name|K
name|pollLast
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|descendingSet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (K toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
name|K
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (K fromElement, K toElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|K
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( K fromElement, boolean fromInclusive, K toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (K fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
name|K
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Removes all values for the provided key. Unlike {@link #removeAll}, it    * returns the number of removed mappings.    */
DECL|method|removeValuesForKey (Object key)
specifier|private
name|int
name|removeValuesForKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|Maps
operator|.
name|safeRemove
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
name|count
operator|=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * {@inheritDoc}    *    *<p>The iterator generated by the returned collection traverses the values    * for one key, followed by the values of a second key, and so on.    */
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|super
operator|.
name|values
argument_list|()
return|;
block|}
comment|/*    * TODO(kevinb): should we copy this javadoc to each concrete class, so that    * classes like LinkedHashMultimap that need to say something different are    * still able to {@inheritDoc} all the way from Multimap?    */
comment|/**    * {@inheritDoc}    *    *<p>The iterator generated by the returned collection traverses the values    * for one key, followed by the values of a second key, and so on.    *    *<p>Each entry is an immutable snapshot of a key-value mapping in the    * multimap, taken at the time the entry is returned by a method call to the    * collection or its iterator.    */
annotation|@
name|Override
DECL|method|entries ()
specifier|public
name|Collection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|super
operator|.
name|entries
argument_list|()
return|;
block|}
comment|/**    * Returns an iterator across all key-value map entries, used by {@code    * entries().iterator()} and {@code values().iterator()}. The default    * behavior, which traverses the values for one key, the values for a second    * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.    *    * @return an iterator across map entries    */
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
comment|/** Iterator across all key-value pairs. */
DECL|class|EntryIterator
specifier|private
class|class
name|EntryIterator
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|keyIterator
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|keyIterator
decl_stmt|;
DECL|field|key
name|K
name|key
decl_stmt|;
DECL|field|collection
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
decl_stmt|;
DECL|field|valueIterator
name|Iterator
argument_list|<
name|V
argument_list|>
name|valueIterator
decl_stmt|;
DECL|method|EntryIterator ()
name|EntryIterator
parameter_list|()
block|{
name|keyIterator
operator|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|keyIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|findValueIteratorAndKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|valueIterator
operator|=
name|Iterators
operator|.
name|emptyModifiableIterator
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|findValueIteratorAndKey ()
name|void
name|findValueIteratorAndKey
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|keyIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|key
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|collection
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|valueIterator
operator|=
name|collection
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|keyIterator
operator|.
name|hasNext
argument_list|()
operator|||
name|valueIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|valueIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|findValueIteratorAndKey
argument_list|()
expr_stmt|;
block|}
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|valueIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|valueIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|totalSize
operator|--
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
parameter_list|()
block|{
comment|// TreeMultimap uses NavigableAsMap explicitly, but we don't handle that here for GWT
comment|// compatibility reasons
return|return
operator|(
name|map
operator|instanceof
name|SortedMap
operator|)
condition|?
operator|new
name|SortedAsMap
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
else|:
operator|new
name|AsMap
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|class|AsMap
specifier|private
class|class
name|AsMap
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
comment|/**      * Usually the same as map, but smaller for the headMap(), tailMap(), or      * subMap() of a SortedAsMap.      */
DECL|field|submap
specifier|final
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
decl_stmt|;
DECL|method|AsMap (Map<K, Collection<V>> submap)
name|AsMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|this
operator|.
name|submap
operator|=
name|submap
expr_stmt|;
block|}
DECL|field|entrySet
specifier|transient
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
operator|new
name|AsMapEntries
argument_list|()
else|:
name|result
return|;
block|}
comment|// The following methods are included for performance.
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|safeContainsKey
argument_list|(
name|submap
argument_list|,
name|key
argument_list|)
return|;
block|}
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|submap
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|wrapCollection
argument_list|(
name|k
argument_list|,
name|collection
argument_list|)
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|AbstractMapBasedMultimap
operator|.
name|this
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|submap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|submap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|output
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|this
operator|==
name|object
operator|||
name|submap
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|submap
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|submap
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|submap
operator|==
name|map
condition|)
block|{
name|AbstractMapBasedMultimap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Iterators
operator|.
name|clear
argument_list|(
operator|new
name|AsMapIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|wrapEntry (Entry<K, Collection<V>> entry)
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|wrapEntry
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
parameter_list|)
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|wrapCollection
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|class|AsMapEntries
class|class
name|AsMapEntries
extends|extends
name|Maps
operator|.
name|EntrySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|map ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMap
operator|.
name|this
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AsMapIterator
argument_list|()
return|;
block|}
comment|// The following methods are included for performance.
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|safeContains
argument_list|(
name|submap
operator|.
name|entrySet
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|removeValuesForKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/** Iterator across all keys and value collections. */
DECL|class|AsMapIterator
class|class
name|AsMapIterator
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|field|delegateIterator
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegateIterator
init|=
name|submap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
DECL|field|collection
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
decl_stmt|;
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegateIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|next
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|delegateIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|collection
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
return|return
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegateIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|SortedAsMap
specifier|private
class|class
name|SortedAsMap
extends|extends
name|AsMap
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|SortedAsMap (SortedMap<K, Collection<V>> submap)
name|SortedAsMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|super
argument_list|(
name|submap
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|submap
return|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|)
return|;
block|}
DECL|field|sortedKeySet
name|SortedSet
argument_list|<
name|K
argument_list|>
name|sortedKeySet
decl_stmt|;
comment|// returns a SortedSet, even though returning a Set would be sufficient to
comment|// satisfy the SortedMap.keySet() interface
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|K
argument_list|>
name|result
init|=
name|sortedKeySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|sortedKeySet
operator|=
name|createKeySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|method|createKeySet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NavigableAsMap"
argument_list|)
DECL|class|NavigableAsMap
class|class
name|NavigableAsMap
extends|extends
name|SortedAsMap
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|NavigableAsMap (NavigableMap<K, Collection<V>> submap)
name|NavigableAsMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|super
argument_list|(
name|submap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|sortedMap ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|sortedMap
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lowerEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|lowerEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lowerKey (K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|floorEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floorKey (K key)
specifier|public
name|K
name|floorKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|ceilingEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ceilingKey (K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherEntry (K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|higherEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|higherKey (K key)
specifier|public
name|K
name|higherKey
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|firstEntry
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|firstEntry
argument_list|()
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|lastEntry
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|lastEntry
argument_list|()
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|pollAsMapEntry
argument_list|(
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|pollAsMapEntry
argument_list|(
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|pollAsMapEntry (Iterator<Entry<K, Collection<V>>> entryIterator)
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollAsMapEntry
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
if|if
condition|(
operator|!
name|entryIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|entryIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|entryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|unmodifiableCollectionSubclass
argument_list|(
name|output
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|descendingMap
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap (K fromKey, K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2447537837011683357L
decl_stmt|;
block|}
end_class

end_unit

