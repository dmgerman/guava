begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NullnessCasts
operator|.
name|uncheckedCastNullableTToT
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|ViewCachingAbstractMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|WeakOuter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map  * that associates each key with a collection of values. All methods of {@link Multimap} are  * supported, including those specified as optional in the interface.  *  *<p>To implement a multimap, a subclass must define the method {@link #createCollection()}, which  * creates an empty collection of values for a key.  *  *<p>The multimap constructor takes a map that has a single entry for each distinct key. When you  * insert a key-value pair with a key that isn't already in the multimap, {@code  * AbstractMapBasedMultimap} calls {@link #createCollection()} to create the collection of values  * for that key. The subclass should not call {@link #createCollection()} directly, and a new  * instance should be created every time the method is called.  *  *<p>For example, the subclass could pass a {@link java.util.TreeMap} during construction, and  * {@link #createCollection()} could return a {@link java.util.TreeSet}, in which case the  * multimap's iterators would propagate through the keys and values in sorted order.  *  *<p>Keys and values may be null, as long as the underlying collection classes support null  * elements.  *  *<p>The collections created by {@link #createCollection()} may or may not allow duplicates. If the  * collection, such as a {@link Set}, does not support duplicates, an added key-value pair will  * replace an existing pair with the same key and value, if such a pair is present. With collections  * like {@link List} that allow duplicates, the collection will keep the existing key-value pairs  * while adding a new pair.  *  *<p>This class is not threadsafe when any concurrent operations update the multimap, even if the  * underlying map and {@link #createCollection()} method return threadsafe classes. Concurrent read  * operations will work correctly. To allow concurrent update operations, wrap your multimap with a  * call to {@link Multimaps#synchronizedMultimap}.  *  *<p>For serialization to work, the subclass must specify explicit {@code readObject} and {@code  * writeObject} methods.  *  * @author Jared Levy  * @author Louis Wasserman  */
end_comment

begin_annotation
annotation|@
name|GwtCompatible
end_annotation

begin_annotation
annotation|@
name|ElementTypesAreNonnullByDefault
end_annotation

begin_expr_stmt
DECL|class|AbstractMapBasedMultimap
specifier|abstract
name|class
name|AbstractMapBasedMultimap
operator|<
name|K
expr|extends @
name|Nullable
name|Object
operator|,
name|V
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
expr|implements
name|Serializable
block|{
comment|/*    * Here's an outline of the overall design.    *    * The map variable contains the collection of values associated with each    * key. When a key-value pair is added to a multimap that didn't previously    * contain any values for that key, a new collection generated by    * createCollection is added to the map. That same collection instance    * remains in the map as long as the multimap has any values for the key. If    * all values for the key are removed, the key and collection are removed    * from the map.    *    * The get method returns a WrappedCollection, which decorates the collection    * in the map (if the key is present) or an empty collection (if the key is    * not present). When the collection delegate in the WrappedCollection is    * empty, the multimap may contain subsequently added values for that key. To    * handle that situation, the WrappedCollection checks whether map contains    * an entry for the provided key, and if so replaces the delegate.    */
DECL|field|map
specifier|private
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
block|;
DECL|field|totalSize
specifier|private
specifier|transient
name|int
name|totalSize
block|;
comment|/**    * Creates a new multimap that uses the provided map.    *    * @param map place to store the mapping from each key to its corresponding values    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|AbstractMapBasedMultimap (Map<K, Collection<V>> map)
specifier|protected
name|AbstractMapBasedMultimap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|)
block|{
name|checkArgument
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
block|;
name|this
operator|.
name|map
operator|=
name|map
block|;   }
comment|/** Used during deserialization only. */
DECL|method|setMap (Map<K, Collection<V>> map)
name|final
name|void
name|setMap
argument_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
argument_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
block|;
name|totalSize
operator|=
literal|0
block|;
for|for
control|(
name|Collection
argument_list|<
name|V
argument_list|>
name|values
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|checkArgument
argument_list|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|values
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates an unmodifiable, empty collection of values.    *    *<p>This is used in {@link #removeAll} on an empty key.    */
DECL|method|createUnmodifiableEmptyCollection ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createUnmodifiableEmptyCollection
argument_list|()
block|{
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|createCollection
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Creates the collection of values for a single key.    *    *<p>Collections with weak, soft, or phantom references are not supported. Each call to {@code    * createCollection} should create a new instance.    *    *<p>The returned collection class determines whether duplicate key-value pairs are allowed.    *    * @return an empty collection of values    */
end_comment

begin_function_decl
DECL|method|createCollection ()
specifier|abstract
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/**    * Creates the collection of values for an explicitly provided key. By default, it simply calls    * {@link #createCollection()}, which is the correct behavior for most implementations. The {@link    * LinkedHashMultimap} class overrides it.    *    * @param key key to associate with values in the collection    * @return an empty collection of values    */
end_comment

begin_function
DECL|method|createCollection (@arametricNullness K key)
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|createCollection
argument_list|()
return|;
block|}
end_function

begin_function
DECL|method|backingMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|backingMap
parameter_list|()
block|{
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|// Query Operations
end_comment

begin_function
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|totalSize
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|containsKey (@heckForNull Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Modification Operations
end_comment

begin_function
annotation|@
name|Override
DECL|method|put (@arametricNullness K key, @ParametricNullness V value)
specifier|public
name|boolean
name|put
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"New Collection violated the Collection spec"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function

begin_function
DECL|method|getOrCreateCollection (@arametricNullness K key)
specifier|private
name|Collection
argument_list|<
name|V
argument_list|>
name|getOrCreateCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
expr_stmt|;
block|}
return|return
name|collection
return|;
block|}
end_function

begin_comment
comment|// Bulk Operations
end_comment

begin_comment
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is immutable.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|replaceValues (@arametricNullness K key, Iterable<? extends V> values)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|iterator
init|=
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|removeAll
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// TODO(lowasser): investigate atomic failure?
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|getOrCreateCollection
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|oldValues
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|oldValues
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|collection
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
block|}
block|}
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|oldValues
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is immutable.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|removeAll (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
name|createUnmodifiableEmptyCollection
argument_list|()
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|unmodifiableCollectionSubclass
argument_list|(
name|output
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
DECL|method|unmodifiableCollectionSubclass ( Collection<E> collection)
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|Collection
argument_list|<
name|E
argument_list|>
name|unmodifiableCollectionSubclass
argument_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
argument_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// Clear each collection, to make previously returned collections empty.
for|for
control|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|// Views
end_comment

begin_comment
comment|/**    * {@inheritDoc}    *    *<p>The returned collection is not serializable.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|get (@arametricNullness K key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
name|collection
operator|=
name|createCollection
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapCollection
argument_list|(
name|key
argument_list|,
name|collection
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Generates a decorated collection that remains consistent with the values in the multimap for    * the provided key. Changes to the multimap may alter the returned collection, and vice versa.    */
end_comment

begin_function
DECL|method|wrapCollection (@arametricNullness K key, Collection<V> collection)
name|Collection
argument_list|<
name|V
argument_list|>
name|wrapCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
return|return
operator|new
name|WrappedCollection
argument_list|(
name|key
argument_list|,
name|collection
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|wrapList ( @arametricNullness K key, List<V> list, @CheckForNull WrappedCollection ancestor)
specifier|final
name|List
argument_list|<
name|V
argument_list|>
name|wrapList
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|list
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
return|return
operator|(
name|list
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|RandomAccessWrappedList
argument_list|(
name|key
argument_list|,
name|list
argument_list|,
name|ancestor
argument_list|)
else|:
operator|new
name|WrappedList
argument_list|(
name|key
argument_list|,
name|list
argument_list|,
name|ancestor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Collection decorator that stays in sync with the multimap values for a key. There are two kinds    * of wrapped collections: full and subcollections. Both have a delegate pointing to the    * underlying collection class.    *    *<p>Full collections, identified by a null ancestor field, contain all multimap values for a    * given key. Its delegate is a value in {@link AbstractMapBasedMultimap#map} whenever the    * delegate is non-empty. The {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap}    * methods ensure that the {@code WrappedCollection} and map remain consistent.    *    *<p>A subcollection, such as a sublist, contains some of the values for a given key. Its    * ancestor field points to the full wrapped collection with all values for the key. The    * subcollection {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods call    * the corresponding methods of the full wrapped collection.    */
end_comment

begin_class
annotation|@
name|WeakOuter
DECL|class|WrappedCollection
class|class
name|WrappedCollection
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|key
annotation|@
name|ParametricNullness
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|delegate
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|ancestor
annotation|@
name|CheckForNull
specifier|final
name|WrappedCollection
name|ancestor
decl_stmt|;
DECL|field|ancestorDelegate
annotation|@
name|CheckForNull
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|ancestorDelegate
decl_stmt|;
DECL|method|WrappedCollection ( @arametricNullness K key, Collection<V> delegate, @CheckForNull WrappedCollection ancestor)
name|WrappedCollection
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|ancestor
operator|=
name|ancestor
expr_stmt|;
name|this
operator|.
name|ancestorDelegate
operator|=
operator|(
name|ancestor
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ancestor
operator|.
name|getDelegate
argument_list|()
expr_stmt|;
block|}
comment|/**      * If the delegate collection is empty, but the multimap has values for the key, replace the      * delegate with the new collection for the key.      *      *<p>For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't      * changed.      */
DECL|method|refreshIfEmpty ()
name|void
name|refreshIfEmpty
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|refreshIfEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|ancestor
operator|.
name|getDelegate
argument_list|()
operator|!=
name|ancestorDelegate
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|delegate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|newDelegate
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDelegate
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|=
name|newDelegate
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}. For      * subcollections, check whether the ancestor collection is empty.      */
DECL|method|removeIfEmpty ()
name|void
name|removeIfEmpty
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delegate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|ParametricNullness
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
comment|/**      * Add the delegate to the map. Other {@code WrappedCollection} methods should call this method      * after adding elements to a previously empty collection.      *      *<p>Subcollection add the ancestor's delegate instead.      */
DECL|method|addToMap ()
name|void
name|addToMap
parameter_list|()
block|{
if|if
condition|(
name|ancestor
operator|!=
literal|null
condition|)
block|{
name|ancestor
operator|.
name|addToMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@heckForNull Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getDelegate ()
name|Collection
argument_list|<
name|V
argument_list|>
name|getDelegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|V
argument_list|>
name|spliterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|spliterator
argument_list|()
return|;
block|}
comment|/** Collection iterator for {@code WrappedCollection}. */
DECL|class|WrappedIterator
class|class
name|WrappedIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
DECL|field|delegateIterator
specifier|final
name|Iterator
argument_list|<
name|V
argument_list|>
name|delegateIterator
decl_stmt|;
DECL|field|originalDelegate
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|originalDelegate
init|=
name|delegate
decl_stmt|;
DECL|method|WrappedIterator ()
name|WrappedIterator
parameter_list|()
block|{
name|delegateIterator
operator|=
name|iteratorOrListIterator
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|WrappedIterator (Iterator<V> delegateIterator)
name|WrappedIterator
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|delegateIterator
parameter_list|)
block|{
name|this
operator|.
name|delegateIterator
operator|=
name|delegateIterator
expr_stmt|;
block|}
comment|/**        * If the delegate changed since the iterator was created, the iterator is no longer valid.        */
DECL|method|validateIterator ()
name|void
name|validateIterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|delegate
operator|!=
name|originalDelegate
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegateIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
DECL|method|getDelegateIterator ()
name|Iterator
argument_list|<
name|V
argument_list|>
name|getDelegateIterator
parameter_list|()
block|{
name|validateIterator
argument_list|()
expr_stmt|;
return|return
name|delegateIterator
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|add (@arametricNullness V value)
specifier|public
name|boolean
name|add
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|wasEmpty
init|=
name|delegate
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
name|delegate
operator|.
name|add
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|CheckForNull
DECL|method|getAncestor ()
name|WrappedCollection
name|getAncestor
parameter_list|()
block|{
return|return
name|ancestor
return|;
block|}
comment|// The following methods are provided for better performance.
annotation|@
name|Override
DECL|method|addAll (Collection<? extends V> collection)
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|Override
DECL|method|contains (@heckForNull Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsAll (Collection<?> c)
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|delegate
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|delegate
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|oldSize
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
comment|// maybe shouldn't be removed if this is a sublist
block|}
annotation|@
name|Override
DECL|method|remove (@heckForNull Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|changed
init|=
name|delegate
operator|.
name|remove
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|removeAll
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|delegate
operator|.
name|retainAll
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
block|}
end_class

begin_expr_stmt
DECL|method|iteratorOrListIterator ( Collection<E> collection)
specifier|private
specifier|static
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|Iterator
argument_list|<
name|E
argument_list|>
name|iteratorOrListIterator
argument_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
argument_list|)
block|{
return|return
operator|(
name|collection
operator|instanceof
name|List
operator|)
operator|?
operator|(
operator|(
name|List
argument_list|<
name|E
argument_list|>
operator|)
name|collection
operator|)
operator|.
name|listIterator
argument_list|()
operator|:
name|collection
operator|.
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/** Set decorator that stays in sync with the multimap values for a key. */
end_comment

begin_class
annotation|@
name|WeakOuter
DECL|class|WrappedSet
class|class
name|WrappedSet
extends|extends
name|WrappedCollection
implements|implements
name|Set
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedSet (@arametricNullness K key, Set<V> delegate)
name|WrappedSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|Set
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
comment|// Guava issue 1013: AbstractSet and most JDK set implementations are
comment|// susceptible to quadratic removeAll performance on lists;
comment|// use a slightly smarter implementation here
name|boolean
name|changed
init|=
name|Sets
operator|.
name|removeAllImpl
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|delegate
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|delegate
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
block|}
end_class

begin_comment
comment|/** SortedSet decorator that stays in sync with the multimap values for a key. */
end_comment

begin_class
annotation|@
name|WeakOuter
DECL|class|WrappedSortedSet
class|class
name|WrappedSortedSet
extends|extends
name|WrappedCollection
implements|implements
name|SortedSet
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedSortedSet ( @arametricNullness K key, SortedSet<V> delegate, @CheckForNull WrappedCollection ancestor)
name|WrappedSortedSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|SortedSet
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
DECL|method|getSortedSetDelegate ()
name|SortedSet
argument_list|<
name|V
argument_list|>
name|getSortedSetDelegate
parameter_list|()
block|{
return|return
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|first ()
specifier|public
name|V
name|first
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|first
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|last ()
specifier|public
name|V
name|last
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|last
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (@arametricNullness V toElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|headSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|toElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (@arametricNullness V fromElement, @ParametricNullness V toElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|subSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|fromElement
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|toElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (@arametricNullness V fromElement)
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|tailSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|fromElement
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedSortedSet
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getSortedSetDelegate
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|WeakOuter
DECL|class|WrappedNavigableSet
class|class
name|WrappedNavigableSet
extends|extends
name|WrappedSortedSet
implements|implements
name|NavigableSet
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedNavigableSet ( @arametricNullness K key, NavigableSet<V> delegate, @CheckForNull WrappedCollection ancestor)
name|WrappedNavigableSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getSortedSetDelegate ()
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|getSortedSetDelegate
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
operator|)
name|super
operator|.
name|getSortedSetDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|lower (@arametricNullness V v)
specifier|public
name|V
name|lower
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|lower
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|floor (@arametricNullness V v)
specifier|public
name|V
name|floor
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|floor
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|ceiling (@arametricNullness V v)
specifier|public
name|V
name|ceiling
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|ceiling
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|higher (@arametricNullness V v)
specifier|public
name|V
name|higher
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|v
parameter_list|)
block|{
return|return
name|getSortedSetDelegate
argument_list|()
operator|.
name|higher
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollFirst ()
specifier|public
name|V
name|pollFirst
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollLast ()
specifier|public
name|V
name|pollLast
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|wrap (NavigableSet<V> wrapped)
specifier|private
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|wrap
parameter_list|(
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|wrapped
parameter_list|)
block|{
return|return
operator|new
name|WrappedNavigableSet
argument_list|(
name|key
argument_list|,
name|wrapped
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|descendingSet
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
operator|new
name|WrappedIterator
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( @arametricNullness V fromElement, boolean fromInclusive, @ParametricNullness V toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|subSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (@arametricNullness V toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|headSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (@arametricNullness V fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|V
argument_list|>
name|tailSet
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
name|wrap
argument_list|(
name|getSortedSetDelegate
argument_list|()
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** List decorator that stays in sync with the multimap values for a key. */
end_comment

begin_class
annotation|@
name|WeakOuter
DECL|class|WrappedList
class|class
name|WrappedList
extends|extends
name|WrappedCollection
implements|implements
name|List
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedList ( @arametricNullness K key, List<V> delegate, @CheckForNull WrappedCollection ancestor)
name|WrappedList
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
DECL|method|getListDelegate ()
name|List
argument_list|<
name|V
argument_list|>
name|getListDelegate
parameter_list|()
block|{
return|return
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegate
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addAll (int index, Collection<? extends V> c)
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
comment|// calls refreshIfEmpty
name|boolean
name|changed
init|=
name|getListDelegate
argument_list|()
operator|.
name|addAll
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|newSize
init|=
name|getDelegate
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|totalSize
operator|+=
operator|(
name|newSize
operator|-
name|oldSize
operator|)
expr_stmt|;
if|if
condition|(
name|oldSize
operator|==
literal|0
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|get (int index)
specifier|public
name|V
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|set (int index, @ParametricNullness V element)
specifier|public
name|V
name|set
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|element
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|add (int index, @ParametricNullness V element)
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|element
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|boolean
name|wasEmpty
init|=
name|getDelegate
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|getListDelegate
argument_list|()
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|remove (int index)
specifier|public
name|V
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
name|V
name|value
init|=
name|getListDelegate
argument_list|()
operator|.
name|remove
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|totalSize
operator|--
expr_stmt|;
name|removeIfEmpty
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|indexOf (@heckForNull Object o)
specifier|public
name|int
name|indexOf
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|indexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lastIndexOf (@heckForNull Object o)
specifier|public
name|int
name|lastIndexOf
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|getListDelegate
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|listIterator ()
specifier|public
name|ListIterator
argument_list|<
name|V
argument_list|>
name|listIterator
parameter_list|()
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedListIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|listIterator (int index)
specifier|public
name|ListIterator
argument_list|<
name|V
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
operator|new
name|WrappedListIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subList (int fromIndex, int toIndex)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|refreshIfEmpty
argument_list|()
expr_stmt|;
return|return
name|wrapList
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|getListDelegate
argument_list|()
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
argument_list|,
operator|(
name|getAncestor
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|getAncestor
argument_list|()
argument_list|)
return|;
block|}
comment|/** ListIterator decorator. */
DECL|class|WrappedListIterator
specifier|private
class|class
name|WrappedListIterator
extends|extends
name|WrappedIterator
implements|implements
name|ListIterator
argument_list|<
name|V
argument_list|>
block|{
DECL|method|WrappedListIterator ()
name|WrappedListIterator
parameter_list|()
block|{}
DECL|method|WrappedListIterator (int index)
specifier|public
name|WrappedListIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|getListDelegate
argument_list|()
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getDelegateListIterator ()
specifier|private
name|ListIterator
argument_list|<
name|V
argument_list|>
name|getDelegateListIterator
parameter_list|()
block|{
return|return
operator|(
name|ListIterator
argument_list|<
name|V
argument_list|>
operator|)
name|getDelegateIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasPrevious ()
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|hasPrevious
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|previous ()
specifier|public
name|V
name|previous
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|previous
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextIndex ()
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|nextIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|previousIndex ()
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|getDelegateListIterator
argument_list|()
operator|.
name|previousIndex
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|set (@arametricNullness V value)
specifier|public
name|void
name|set
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
name|getDelegateListIterator
argument_list|()
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|add (@arametricNullness V value)
specifier|public
name|void
name|add
parameter_list|(
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
name|boolean
name|wasEmpty
init|=
name|isEmpty
argument_list|()
decl_stmt|;
name|getDelegateListIterator
argument_list|()
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|totalSize
operator|++
expr_stmt|;
if|if
condition|(
name|wasEmpty
condition|)
block|{
name|addToMap
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * List decorator that stays in sync with the multimap values for a key and supports rapid random    * access.    */
end_comment

begin_class
DECL|class|RandomAccessWrappedList
specifier|private
class|class
name|RandomAccessWrappedList
extends|extends
name|WrappedList
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessWrappedList ( @arametricNullness K key, List<V> delegate, @CheckForNull WrappedCollection ancestor)
name|RandomAccessWrappedList
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
name|List
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|CheckForNull
name|WrappedCollection
name|ancestor
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|delegate
argument_list|,
name|ancestor
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|createKeySet ()
name|Set
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySet
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|createMaybeNavigableKeySet ()
specifier|final
name|Set
argument_list|<
name|K
argument_list|>
name|createMaybeNavigableKeySet
parameter_list|()
block|{
if|if
condition|(
name|map
operator|instanceof
name|NavigableMap
condition|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|map
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|KeySet
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
end_function

begin_class
annotation|@
name|WeakOuter
DECL|class|KeySet
specifier|private
class|class
name|KeySet
extends|extends
name|Maps
operator|.
name|KeySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|KeySet (final Map<K, Collection<V>> subMap)
name|KeySet
parameter_list|(
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entryIterator
init|=
name|map
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
annotation|@
name|CheckForNull
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
specifier|public
name|K
name|next
parameter_list|()
block|{
name|entry
operator|=
name|entryIterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|entry
operator|!=
literal|null
argument_list|,
literal|"no calls to next() since the last call to remove()"
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|entryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|entry
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
comment|// The following methods are included for better performance.
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|K
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|spliterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@heckForNull Object key)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|map
argument_list|()
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
name|count
operator|=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|count
operator|>
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Iterators
operator|.
name|clear
argument_list|(
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|containsAll (Collection<?> c)
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@heckForNull Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|object
parameter_list|)
block|{
return|return
name|this
operator|==
name|object
operator|||
name|this
operator|.
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|map
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|WeakOuter
DECL|class|SortedKeySet
specifier|private
class|class
name|SortedKeySet
extends|extends
name|KeySet
implements|implements
name|SortedSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|SortedKeySet (SortedMap<K, Collection<V>> subMap)
name|SortedKeySet
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|map
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|first ()
specifier|public
name|K
name|first
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (@arametricNullness K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|last ()
specifier|public
name|K
name|last
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (@arametricNullness K fromElement, @ParametricNullness K toElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (@arametricNullness K fromElement)
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_class
annotation|@
name|WeakOuter
DECL|class|NavigableKeySet
class|class
name|NavigableKeySet
extends|extends
name|SortedKeySet
implements|implements
name|NavigableSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|NavigableKeySet (NavigableMap<K, Collection<V>> subMap)
name|NavigableKeySet
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|)
block|{
name|super
argument_list|(
name|subMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|sortedMap ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|sortedMap
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|lower (@arametricNullness K k)
specifier|public
name|K
name|lower
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|floor (@arametricNullness K k)
specifier|public
name|K
name|floor
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|ceiling (@arametricNullness K k)
specifier|public
name|K
name|ceiling
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|higher (@arametricNullness K k)
specifier|public
name|K
name|higher
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|k
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollFirst ()
specifier|public
name|K
name|pollFirst
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollLast ()
specifier|public
name|K
name|pollLast
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|pollNext
argument_list|(
name|descendingIterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingSet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingSet
parameter_list|()
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingIterator ()
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
name|descendingSet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (@arametricNullness K toElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|)
block|{
return|return
name|headSet
argument_list|(
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (@arametricNullness K toElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|headSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( @arametricNullness K fromElement, @ParametricNullness K toElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|)
block|{
return|return
name|subSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|,
name|toElement
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subSet ( @arametricNullness K fromElement, boolean fromInclusive, @ParametricNullness K toElement, boolean toInclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|subSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toElement
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromElement
argument_list|,
name|fromInclusive
argument_list|,
name|toElement
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (@arametricNullness K fromElement)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|)
block|{
return|return
name|tailSet
argument_list|(
name|fromElement
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (@arametricNullness K fromElement, boolean inclusive)
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|tailSet
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromElement
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromElement
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** Removes all values for the provided key. */
end_comment

begin_function
DECL|method|removeValuesForKey (@heckForNull Object key)
specifier|private
name|void
name|removeValuesForKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|Maps
operator|.
name|safeRemove
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
name|collection
operator|.
name|size
argument_list|()
decl_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
DECL|class|Itr
specifier|private
specifier|abstract
name|class
name|Itr
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
expr|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|keyIterator
name|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|keyIterator
block|;     @
DECL|field|key
name|CheckForNull
name|K
name|key
block|;     @
DECL|field|collection
name|CheckForNull
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
block|;
DECL|field|valueIterator
name|Iterator
argument_list|<
name|V
argument_list|>
name|valueIterator
block|;
DECL|method|Itr ()
name|Itr
argument_list|()
block|{
name|keyIterator
operator|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
block|;
name|key
operator|=
literal|null
block|;
name|collection
operator|=
literal|null
block|;
name|valueIterator
operator|=
name|Iterators
operator|.
name|emptyModifiableIterator
argument_list|()
block|;     }
DECL|method|output (@arametricNullness K key, @ParametricNullness V value)
specifier|abstract
name|T
name|output
argument_list|(
annotation|@
name|ParametricNullness
name|K
name|key
argument_list|,
annotation|@
name|ParametricNullness
name|V
name|value
argument_list|)
block|;      @
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
argument_list|()
block|{
return|return
name|keyIterator
operator|.
name|hasNext
argument_list|()
operator|||
name|valueIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
expr|@
name|Override
DECL|method|next ()
specifier|public
name|T
name|next
argument_list|()
block|{
if|if
condition|(
operator|!
name|valueIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|mapEntry
init|=
name|keyIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|key
operator|=
name|mapEntry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|collection
operator|=
name|mapEntry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|valueIterator
operator|=
name|collection
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/*        * uncheckedCastNullableTToT is safe: The first call to this method always enters the !hasNext() case and        * populates key, after which it's never cleared.        */
end_comment

begin_return
return|return
name|output
argument_list|(
name|uncheckedCastNullableTToT
argument_list|(
name|key
argument_list|)
argument_list|,
name|valueIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
end_return

begin_function
unit|}      @
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|valueIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|/*        * requireNonNull is safe because we've already initialized `collection`. If we hadn't, then        * valueIterator.remove() would have failed.        */
if|if
condition|(
name|requireNonNull
argument_list|(
name|collection
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|totalSize
operator|--
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|/**    * {@inheritDoc}    *    *<p>The iterator generated by the returned collection traverses the values for one key, followed    * by the values of a second key, and so on.    */
end_comment

begin_function
unit|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|super
operator|.
name|values
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
operator|new
name|Values
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|valueIterator ()
name|Iterator
argument_list|<
name|V
argument_list|>
name|valueIterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
annotation|@
name|ParametricNullness
name|V
name|output
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
return|return
name|value
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|valueSpliterator ()
name|Spliterator
argument_list|<
name|V
argument_list|>
name|valueSpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|flatMap
argument_list|(
name|map
operator|.
name|values
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|Collection
operator|::
name|spliterator
argument_list|,
name|Spliterator
operator|.
name|SIZED
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * TODO(kevinb): should we copy this javadoc to each concrete class, so that    * classes like LinkedHashMultimap that need to say something different are    * still able to {@inheritDoc} all the way from Multimap?    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|createKeys ()
name|Multiset
argument_list|<
name|K
argument_list|>
name|createKeys
parameter_list|()
block|{
return|return
operator|new
name|Multimaps
operator|.
name|Keys
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * {@inheritDoc}    *    *<p>The iterator generated by the returned collection traverses the values for one key, followed    * by the values of a second key, and so on.    *    *<p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the    * time the entry is returned by a method call to the collection or its iterator.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|entries ()
specifier|public
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|super
operator|.
name|entries
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createEntries ()
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntries
parameter_list|()
block|{
if|if
condition|(
name|this
operator|instanceof
name|SetMultimap
condition|)
block|{
return|return
operator|new
name|EntrySet
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|Entries
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and    * {@code values().iterator()}. The default behavior, which traverses the values for one key, the    * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}    * implementations.    *    * @return an iterator across map entries    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|output
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|,
annotation|@
name|ParametricNullness
name|V
name|value
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|entrySpliterator ()
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySpliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|flatMap
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|keyToValueCollectionEntry
lambda|->
block|{
name|K
name|key
init|=
name|keyToValueCollectionEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|keyToValueCollectionEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|valueCollection
operator|.
name|spliterator
argument_list|()
argument_list|,
parameter_list|(
name|V
name|value
parameter_list|)
lambda|->
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
argument_list|,
name|Spliterator
operator|.
name|SIZED
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|forEach (BiConsumer<? super K, ? super V> action)
specifier|public
name|void
name|forEach
parameter_list|(
name|BiConsumer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|map
operator|.
name|forEach
argument_list|(
parameter_list|(
name|key
parameter_list|,
name|valueCollection
parameter_list|)
lambda|->
name|valueCollection
operator|.
name|forEach
argument_list|(
name|value
lambda|->
name|action
operator|.
name|accept
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createAsMap
parameter_list|()
block|{
return|return
operator|new
name|AsMap
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|createMaybeNavigableAsMap ()
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|createMaybeNavigableAsMap
parameter_list|()
block|{
if|if
condition|(
name|map
operator|instanceof
name|NavigableMap
condition|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|map
operator|instanceof
name|SortedMap
condition|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|map
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|AsMap
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
end_function

begin_class
annotation|@
name|WeakOuter
DECL|class|AsMap
specifier|private
class|class
name|AsMap
extends|extends
name|ViewCachingAbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
comment|/**      * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a      * SortedAsMap.      */
DECL|field|submap
specifier|final
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
decl_stmt|;
DECL|method|AsMap (Map<K, Collection<V>> submap)
name|AsMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|this
operator|.
name|submap
operator|=
name|submap
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEntrySet ()
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|AsMapEntries
argument_list|()
return|;
block|}
comment|// The following methods are included for performance.
annotation|@
name|Override
DECL|method|containsKey (@heckForNull Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|safeContainsKey
argument_list|(
name|submap
argument_list|,
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|get (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|submap
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|wrapCollection
argument_list|(
name|k
argument_list|,
name|collection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|AbstractMapBasedMultimap
operator|.
name|this
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|submap
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|remove (@heckForNull Object key)
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|submap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|Override
DECL|method|equals (@heckForNull Object object)
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|object
parameter_list|)
block|{
return|return
name|this
operator|==
name|object
operator|||
name|submap
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|submap
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|submap
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|submap
operator|==
name|map
condition|)
block|{
name|AbstractMapBasedMultimap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Iterators
operator|.
name|clear
argument_list|(
operator|new
name|AsMapIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|wrapEntry (Entry<K, Collection<V>> entry)
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|wrapEntry
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
parameter_list|)
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|wrapCollection
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|WeakOuter
DECL|class|AsMapEntries
class|class
name|AsMapEntries
extends|extends
name|Maps
operator|.
name|EntrySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|map ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMap
operator|.
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AsMapIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|spliterator ()
specifier|public
name|Spliterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|spliterator
parameter_list|()
block|{
return|return
name|CollectSpliterators
operator|.
name|map
argument_list|(
name|submap
operator|.
name|entrySet
argument_list|()
operator|.
name|spliterator
argument_list|()
argument_list|,
name|AsMap
operator|.
name|this
operator|::
name|wrapEntry
argument_list|)
return|;
block|}
comment|// The following methods are included for performance.
annotation|@
name|Override
DECL|method|contains (@heckForNull Object o)
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|safeContains
argument_list|(
name|submap
operator|.
name|entrySet
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@heckForNull Object o)
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// requireNonNull is safe because of the contains check.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
name|requireNonNull
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
decl_stmt|;
name|removeValuesForKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/** Iterator across all keys and value collections. */
DECL|class|AsMapIterator
class|class
name|AsMapIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|field|delegateIterator
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegateIterator
init|=
name|submap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
DECL|field|collection
annotation|@
name|CheckForNull
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
decl_stmt|;
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegateIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|next
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|delegateIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|collection
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
return|return
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|collection
operator|!=
literal|null
argument_list|,
literal|"no calls to next() since the last call to remove()"
argument_list|)
expr_stmt|;
name|delegateIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|totalSize
operator|-=
name|collection
operator|.
name|size
argument_list|()
expr_stmt|;
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|collection
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
end_class

begin_class
annotation|@
name|WeakOuter
DECL|class|SortedAsMap
specifier|private
class|class
name|SortedAsMap
extends|extends
name|AsMap
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|SortedAsMap (SortedMap<K, Collection<V>> submap)
name|SortedAsMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|super
argument_list|(
name|submap
argument_list|)
expr_stmt|;
block|}
DECL|method|sortedMap ()
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|submap
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|firstKey ()
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|firstKey
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|ParametricNullness
DECL|method|lastKey ()
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lastKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (@arametricNullness K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( @arametricNullness K fromKey, @ParametricNullness K toKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (@arametricNullness K fromKey)
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|)
block|{
return|return
operator|new
name|SortedAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
argument_list|)
return|;
block|}
DECL|field|sortedKeySet
annotation|@
name|CheckForNull
name|SortedSet
argument_list|<
name|K
argument_list|>
name|sortedKeySet
decl_stmt|;
comment|// returns a SortedSet, even though returning a Set would be sufficient to
comment|// satisfy the SortedMap.keySet() interface
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|SortedSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|K
argument_list|>
name|result
init|=
name|sortedKeySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|sortedKeySet
operator|=
name|createKeySet
argument_list|()
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|SortedSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|SortedKeySet
argument_list|(
name|sortedMap
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|NavigableAsMap
class|class
name|NavigableAsMap
extends|extends
name|SortedAsMap
implements|implements
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|NavigableAsMap (NavigableMap<K, Collection<V>> submap)
name|NavigableAsMap
parameter_list|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|submap
parameter_list|)
block|{
name|super
argument_list|(
name|submap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|sortedMap ()
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|sortedMap
parameter_list|()
block|{
return|return
operator|(
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
operator|)
name|super
operator|.
name|sortedMap
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|lowerEntry (@arametricNullness K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|lowerEntry
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|lowerEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|lowerKey (@arametricNullness K key)
specifier|public
name|K
name|lowerKey
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|lowerKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|floorEntry (@arametricNullness K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|floorEntry
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|floorEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|floorKey (@arametricNullness K key)
specifier|public
name|K
name|floorKey
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|floorKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|ceilingEntry (@arametricNullness K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|ceilingEntry
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|ceilingEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|ceilingKey (@arametricNullness K key)
specifier|public
name|K
name|ceilingKey
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|ceilingKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|higherEntry (@arametricNullness K key)
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|higherEntry
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|higherEntry
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|higherKey (@arametricNullness K key)
specifier|public
name|K
name|higherKey
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|key
parameter_list|)
block|{
return|return
name|sortedMap
argument_list|()
operator|.
name|higherKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|firstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|firstEntry
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|firstEntry
argument_list|()
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|lastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|lastEntry
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|sortedMap
argument_list|()
operator|.
name|lastEntry
argument_list|()
decl_stmt|;
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|wrapEntry
argument_list|(
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollFirstEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollFirstEntry
parameter_list|()
block|{
return|return
name|pollAsMapEntry
argument_list|(
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|CheckForNull
DECL|method|pollLastEntry ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollLastEntry
parameter_list|()
block|{
return|return
name|pollAsMapEntry
argument_list|(
name|descendingMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|CheckForNull
DECL|method|pollAsMapEntry (Iterator<Entry<K, Collection<V>>> entryIterator)
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|pollAsMapEntry
parameter_list|(
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entryIterator
parameter_list|)
block|{
if|if
condition|(
operator|!
name|entryIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
init|=
name|entryIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|output
init|=
name|createCollection
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|entryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|unmodifiableCollectionSubclass
argument_list|(
name|output
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingMap ()
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|descendingMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|(
name|NavigableSet
argument_list|<
name|K
argument_list|>
operator|)
name|super
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createKeySet ()
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|createKeySet
parameter_list|()
block|{
return|return
operator|new
name|NavigableKeySet
argument_list|(
name|sortedMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|descendingKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|descendingMap
argument_list|()
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( @arametricNullness K fromKey, @ParametricNullness K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|)
block|{
return|return
name|subMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|,
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|subMap ( @arametricNullness K fromKey, boolean fromInclusive, @ParametricNullness K toKey, boolean toInclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|subMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|,
name|boolean
name|fromInclusive
parameter_list|,
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|,
name|boolean
name|toInclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|fromInclusive
argument_list|,
name|toKey
argument_list|,
name|toInclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (@arametricNullness K toKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|)
block|{
return|return
name|headMap
argument_list|(
name|toKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headMap (@arametricNullness K toKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|headMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|toKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap (@arametricNullness K fromKey)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|tailMap
argument_list|(
name|fromKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMap ( @arametricNullness K fromKey, boolean inclusive)
specifier|public
name|NavigableMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|tailMap
parameter_list|(
annotation|@
name|ParametricNullness
name|K
name|fromKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
return|return
operator|new
name|NavigableAsMap
argument_list|(
name|sortedMap
argument_list|()
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|,
name|inclusive
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_decl_stmt
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2447537837011683357L
decl_stmt|;
end_decl_stmt

unit|}
end_unit

