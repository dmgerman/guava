begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BstSide
operator|.
name|LEFT
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BstSide
operator|.
name|RIGHT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A multiset which maintains the ordering of its elements, according to either  * their natural order or an explicit {@link Comparator}. In all cases, this  * implementation uses {@link Comparable#compareTo} or {@link  * Comparator#compare} instead of {@link Object#equals} to determine  * equivalence of instances.  *  *<p><b>Warning:</b> The comparison must be<i>consistent with equals</i> as  * explained by the {@link Comparable} class specification. Otherwise, the  * resulting multiset will violate the {@link java.util.Collection} contract,  * which is specified in terms of {@link Object#equals}.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">  * {@code Multiset}</a>.  *  * @author Louis Wasserman  * @author Jared Levy  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|TreeMultiset
specifier|public
specifier|final
class|class
name|TreeMultiset
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSortedMultiset
argument_list|<
name|E
argument_list|>
implements|implements
name|Serializable
block|{
comment|/**    * Creates a new, empty multiset, sorted according to the elements' natural    * order. All elements inserted into the multiset must implement the    * {@code Comparable} interface. Furthermore, all such elements must be    *<i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a    * {@code ClassCastException} for any elements {@code e1} and {@code e2} in    * the multiset. If the user attempts to add an element to the multiset that    * violates this constraint (for example, the user attempts to add a string    * element to a set whose elements are integers), the {@code add(Object)}    * call will throw a {@code ClassCastException}.    *    *<p>The type specification is {@code<E extends Comparable>}, instead of the    * more specific {@code<E extends Comparable<? super E>>}, to support    * classes defined without generics.    */
DECL|method|create ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|()
block|{
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new, empty multiset, sorted according to the specified    * comparator. All elements inserted into the multiset must be<i>mutually    * comparable</i> by the specified comparator: {@code comparator.compare(e1,    * e2)} must not throw a {@code ClassCastException} for any elements {@code    * e1} and {@code e2} in the multiset. If the user attempts to add an element    * to the multiset that violates this constraint, the {@code add(Object)} call    * will throw a {@code ClassCastException}.    *    * @param comparator the comparator that will be used to sort this multiset. A    *     null value indicates that the elements'<i>natural ordering</i> should    *     be used.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|create ( @ullable Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|(
name|comparator
operator|==
literal|null
operator|)
condition|?
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|Comparator
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
else|:
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Creates an empty multiset containing the given initial elements, sorted    * according to the elements' natural order.    *    *<p>This implementation is highly efficient when {@code elements} is itself    * a {@link Multiset}.    *    *<p>The type specification is {@code<E extends Comparable>}, instead of the    * more specific {@code<E extends Comparable<? super E>>}, to support    * classes defined without generics.    */
DECL|method|create ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|create
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|multiset
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
comment|/**    * Returns an iterator over the elements contained in this collection.    */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// Needed to avoid Javadoc bug.
return|return
name|super
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|TreeMultiset (Comparator<? super E> comparator)
specifier|private
name|TreeMultiset
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|super
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
name|GeneralRange
operator|.
name|all
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootReference
operator|=
operator|new
name|Reference
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|TreeMultiset (GeneralRange<E> range, Reference<Node<E>> root)
specifier|private
name|TreeMultiset
parameter_list|(
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
parameter_list|,
name|Reference
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|root
parameter_list|)
block|{
name|super
argument_list|(
name|range
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
name|range
expr_stmt|;
name|this
operator|.
name|rootReference
operator|=
name|root
expr_stmt|;
block|}
DECL|method|checkElement (Object o)
name|E
name|checkElement
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|cast
init|=
operator|(
name|E
operator|)
name|o
decl_stmt|;
comment|// Make sure the object is accepted by the comparator (e.g., the right type, possibly non-null).
name|comparator
operator|.
name|compare
argument_list|(
name|cast
argument_list|,
name|cast
argument_list|)
expr_stmt|;
return|return
name|cast
return|;
block|}
DECL|field|range
specifier|private
specifier|transient
specifier|final
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
decl_stmt|;
DECL|field|rootReference
specifier|private
specifier|transient
specifier|final
name|Reference
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|rootReference
decl_stmt|;
DECL|class|Reference
specifier|static
specifier|final
class|class
name|Reference
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|value
name|T
name|value
decl_stmt|;
DECL|method|Reference ()
specifier|public
name|Reference
parameter_list|()
block|{}
DECL|method|get ()
specifier|public
name|T
name|get
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|compareAndSet (T expected, T newValue)
specifier|public
name|boolean
name|compareAndSet
parameter_list|(
name|T
name|expected
parameter_list|,
name|T
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
name|expected
condition|)
block|{
name|value
operator|=
name|newValue
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|distinctElements ()
name|int
name|distinctElements
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|Ints
operator|.
name|checkedCast
argument_list|(
name|BstRangeOps
operator|.
name|totalInRange
argument_list|(
name|distinctAggregate
argument_list|()
argument_list|,
name|range
argument_list|,
name|root
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|BstRangeOps
operator|.
name|totalInRange
argument_list|(
name|sizeAggregate
argument_list|()
argument_list|,
name|range
argument_list|,
name|root
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|count (@ullable Object element)
specifier|public
name|int
name|count
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
try|try
block|{
name|E
name|e
init|=
name|checkElement
argument_list|(
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|BstOperations
operator|.
name|seek
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|rootReference
operator|.
name|get
argument_list|()
argument_list|,
name|e
argument_list|)
decl_stmt|;
return|return
name|countOrZero
argument_list|(
name|node
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|mutate (@ullable E e, MultisetModifier modifier)
specifier|private
name|int
name|mutate
parameter_list|(
annotation|@
name|Nullable
name|E
name|e
parameter_list|,
name|MultisetModifier
name|modifier
parameter_list|)
block|{
name|BstMutationRule
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|mutationRule
init|=
name|BstMutationRule
operator|.
name|createRule
argument_list|(
name|modifier
argument_list|,
name|BstCountBasedBalancePolicies
operator|.
expr|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
operator|>
name|singleRebalancePolicy
argument_list|(
name|distinctAggregate
argument_list|()
argument_list|)
argument_list|,
name|nodeFactory
argument_list|()
argument_list|)
decl_stmt|;
name|BstMutationResult
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|mutationResult
init|=
name|BstOperations
operator|.
name|mutate
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|mutationRule
argument_list|,
name|rootReference
operator|.
name|get
argument_list|()
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rootReference
operator|.
name|compareAndSet
argument_list|(
name|mutationResult
operator|.
name|getOriginalRoot
argument_list|()
argument_list|,
name|mutationResult
operator|.
name|getChangedRoot
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
name|Node
argument_list|<
name|E
argument_list|>
name|original
init|=
name|mutationResult
operator|.
name|getOriginalTarget
argument_list|()
decl_stmt|;
return|return
name|countOrZero
argument_list|(
name|original
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|add (E element, int occurrences)
specifier|public
name|int
name|add
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkElement
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|AddModifier
argument_list|(
name|occurrences
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove (@ullable Object element, int occurrences)
specifier|public
name|int
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
try|try
block|{
name|E
name|e
init|=
name|checkElement
argument_list|(
name|element
argument_list|)
decl_stmt|;
return|return
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|?
name|mutate
argument_list|(
name|e
argument_list|,
operator|new
name|RemoveModifier
argument_list|(
name|occurrences
argument_list|)
argument_list|)
else|:
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setCount (E element, int oldCount, int newCount)
specifier|public
name|boolean
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|oldCount
parameter_list|,
name|int
name|newCount
parameter_list|)
block|{
name|checkElement
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|ConditionalSetCountModifier
argument_list|(
name|oldCount
argument_list|,
name|newCount
argument_list|)
argument_list|)
operator|==
name|oldCount
return|;
block|}
annotation|@
name|Override
DECL|method|setCount (E element, int count)
specifier|public
name|int
name|setCount
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|checkElement
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mutate
argument_list|(
name|element
argument_list|,
operator|new
name|SetCountModifier
argument_list|(
name|count
argument_list|)
argument_list|)
return|;
block|}
DECL|method|pathFactory ()
specifier|private
name|BstPathFactory
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|,
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|>
name|pathFactory
parameter_list|()
block|{
return|return
name|BstInOrderPath
operator|.
name|inOrderFactory
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|startingPath
init|=
name|BstRangeOps
operator|.
name|furthestPath
argument_list|(
name|range
argument_list|,
name|LEFT
argument_list|,
name|pathFactory
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
return|return
name|iteratorInDirection
argument_list|(
name|startingPath
argument_list|,
name|RIGHT
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|startingPath
init|=
name|BstRangeOps
operator|.
name|furthestPath
argument_list|(
name|range
argument_list|,
name|RIGHT
argument_list|,
name|pathFactory
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
return|return
name|iteratorInDirection
argument_list|(
name|startingPath
argument_list|,
name|LEFT
argument_list|)
return|;
block|}
DECL|method|iteratorInDirection ( @ullable BstInOrderPath<Node<E>> start, final BstSide direction)
specifier|private
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|iteratorInDirection
parameter_list|(
annotation|@
name|Nullable
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|start
parameter_list|,
specifier|final
name|BstSide
name|direction
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|>
name|pathIterator
init|=
operator|new
name|AbstractSequentialIterator
argument_list|<
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|start
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|computeNext
parameter_list|(
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|previous
parameter_list|)
block|{
if|if
condition|(
operator|!
name|previous
operator|.
name|hasNext
argument_list|(
name|direction
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|next
init|=
name|previous
operator|.
name|next
argument_list|(
name|direction
argument_list|)
decl_stmt|;
comment|// TODO(user): only check against one side
return|return
name|range
operator|.
name|contains
argument_list|(
name|next
operator|.
name|getTip
argument_list|()
operator|.
name|getKey
argument_list|()
argument_list|)
condition|?
name|next
else|:
literal|null
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
name|ToRemove
argument_list|<
name|E
argument_list|>
name|toRemove
init|=
operator|new
name|ToRemove
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|pathIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|E
argument_list|>
name|next
parameter_list|()
block|{
name|BstInOrderPath
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|path
init|=
name|pathIterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|LiveEntry
argument_list|(
name|toRemove
operator|.
name|setAndGet
argument_list|(
name|path
operator|.
name|getTip
argument_list|()
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|path
operator|.
name|getTip
argument_list|()
operator|.
name|elemCount
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|setCount
argument_list|(
name|toRemove
operator|.
name|getAndClear
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|// If we were ever to resurrect AbstractRemovableIterator, we could use it instead.
DECL|class|ToRemove
specifier|private
specifier|static
specifier|final
class|class
name|ToRemove
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|element
annotation|@
name|Nullable
name|Optional
argument_list|<
name|E
argument_list|>
name|element
decl_stmt|;
DECL|method|setAndGet (@ullable E element)
name|E
name|setAndGet
parameter_list|(
annotation|@
name|Nullable
name|E
name|element
parameter_list|)
block|{
name|this
operator|.
name|element
operator|=
name|Optional
operator|.
name|fromNullable
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|element
return|;
block|}
DECL|method|getAndClear ()
name|E
name|getAndClear
parameter_list|()
block|{
name|checkState
argument_list|(
name|element
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|E
name|returnValue
init|=
name|element
operator|.
name|orNull
argument_list|()
decl_stmt|;
name|element
operator|=
literal|null
expr_stmt|;
return|return
name|returnValue
return|;
block|}
block|}
DECL|class|LiveEntry
class|class
name|LiveEntry
extends|extends
name|Multisets
operator|.
name|AbstractEntry
argument_list|<
name|E
argument_list|>
block|{
DECL|field|expectedRoot
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|expectedRoot
decl_stmt|;
DECL|field|element
specifier|private
specifier|final
name|E
name|element
decl_stmt|;
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
DECL|method|LiveEntry (E element, int count)
specifier|private
name|LiveEntry
parameter_list|(
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|expectedRoot
operator|=
name|rootReference
operator|.
name|get
argument_list|()
expr_stmt|;
name|this
operator|.
name|element
operator|=
name|element
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getElement ()
specifier|public
name|E
name|getElement
parameter_list|()
block|{
return|return
name|element
return|;
block|}
annotation|@
name|Override
DECL|method|getCount ()
specifier|public
name|int
name|getCount
parameter_list|()
block|{
if|if
condition|(
name|rootReference
operator|.
name|get
argument_list|()
operator|==
name|expectedRoot
condition|)
block|{
return|return
name|count
return|;
block|}
else|else
block|{
comment|// check for updates
name|expectedRoot
operator|=
name|rootReference
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|count
operator|=
name|TreeMultiset
operator|.
name|this
operator|.
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|cleared
init|=
name|BstRangeOps
operator|.
name|minusRange
argument_list|(
name|range
argument_list|,
name|BstCountBasedBalancePolicies
operator|.
expr|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
operator|>
name|fullRebalancePolicy
argument_list|(
name|distinctAggregate
argument_list|()
argument_list|)
argument_list|,
name|nodeFactory
argument_list|()
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rootReference
operator|.
name|compareAndSet
argument_list|(
name|root
argument_list|,
name|cleared
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|headMultiset (E upperBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|headMultiset
parameter_list|(
name|E
name|upperBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|upperBound
argument_list|)
expr_stmt|;
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|upTo
argument_list|(
name|comparator
argument_list|,
name|upperBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|rootReference
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailMultiset (E lowerBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|tailMultiset
parameter_list|(
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|lowerBound
argument_list|)
expr_stmt|;
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|downTo
argument_list|(
name|comparator
argument_list|,
name|lowerBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|rootReference
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @since 11.0    */
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|super
operator|.
name|comparator
argument_list|()
return|;
block|}
DECL|class|Node
specifier|private
specifier|static
specifier|final
class|class
name|Node
parameter_list|<
name|E
parameter_list|>
extends|extends
name|BstNode
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|size
specifier|private
specifier|final
name|long
name|size
decl_stmt|;
DECL|field|distinct
specifier|private
specifier|final
name|int
name|distinct
decl_stmt|;
DECL|method|Node (E key, int elemCount, @Nullable Node<E> left, @Nullable Node<E> right)
specifier|private
name|Node
parameter_list|(
name|E
name|key
parameter_list|,
name|int
name|elemCount
parameter_list|,
annotation|@
name|Nullable
name|Node
argument_list|<
name|E
argument_list|>
name|left
parameter_list|,
annotation|@
name|Nullable
name|Node
argument_list|<
name|E
argument_list|>
name|right
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|elemCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|(
name|long
operator|)
name|elemCount
operator|+
name|sizeOrZero
argument_list|(
name|left
argument_list|)
operator|+
name|sizeOrZero
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
literal|1
operator|+
name|distinctOrZero
argument_list|(
name|left
argument_list|)
operator|+
name|distinctOrZero
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
DECL|method|elemCount ()
name|int
name|elemCount
parameter_list|()
block|{
name|long
name|result
init|=
name|size
operator|-
name|sizeOrZero
argument_list|(
name|childOrNull
argument_list|(
name|LEFT
argument_list|)
argument_list|)
operator|-
name|sizeOrZero
argument_list|(
name|childOrNull
argument_list|(
name|RIGHT
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Ints
operator|.
name|checkedCast
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|method|Node (E key, int elemCount)
specifier|private
name|Node
parameter_list|(
name|E
name|key
parameter_list|,
name|int
name|elemCount
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
name|elemCount
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|sizeOrZero (@ullable Node<?> node)
specifier|private
specifier|static
name|long
name|sizeOrZero
parameter_list|(
annotation|@
name|Nullable
name|Node
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|size
return|;
block|}
DECL|method|distinctOrZero (@ullable Node<?> node)
specifier|private
specifier|static
name|int
name|distinctOrZero
parameter_list|(
annotation|@
name|Nullable
name|Node
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|distinct
return|;
block|}
DECL|method|countOrZero (@ullable Node<?> entry)
specifier|private
specifier|static
name|int
name|countOrZero
parameter_list|(
annotation|@
name|Nullable
name|Node
argument_list|<
name|?
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|entry
operator|.
name|elemCount
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|distinctAggregate ()
specifier|private
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|distinctAggregate
parameter_list|()
block|{
return|return
operator|(
name|BstAggregate
operator|)
name|DISTINCT_AGGREGATE
return|;
block|}
DECL|field|DISTINCT_AGGREGATE
specifier|private
specifier|static
specifier|final
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
name|DISTINCT_AGGREGATE
init|=
operator|new
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|entryValue
parameter_list|(
name|Node
argument_list|<
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|treeValue
parameter_list|(
annotation|@
name|Nullable
name|Node
argument_list|<
name|Object
argument_list|>
name|tree
parameter_list|)
block|{
return|return
name|distinctOrZero
argument_list|(
name|tree
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|sizeAggregate ()
specifier|private
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|sizeAggregate
parameter_list|()
block|{
return|return
operator|(
name|BstAggregate
operator|)
name|SIZE_AGGREGATE
return|;
block|}
DECL|field|SIZE_AGGREGATE
specifier|private
specifier|static
specifier|final
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
name|SIZE_AGGREGATE
init|=
operator|new
name|BstAggregate
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|entryValue
parameter_list|(
name|Node
argument_list|<
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|elemCount
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|treeValue
parameter_list|(
annotation|@
name|Nullable
name|Node
argument_list|<
name|Object
argument_list|>
name|tree
parameter_list|)
block|{
return|return
name|sizeOrZero
argument_list|(
name|tree
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|nodeFactory ()
specifier|private
name|BstNodeFactory
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|nodeFactory
parameter_list|()
block|{
return|return
operator|(
name|BstNodeFactory
operator|)
name|NODE_FACTORY
return|;
block|}
DECL|field|NODE_FACTORY
specifier|private
specifier|static
specifier|final
name|BstNodeFactory
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
name|NODE_FACTORY
init|=
operator|new
name|BstNodeFactory
argument_list|<
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Node
argument_list|<
name|Object
argument_list|>
name|createNode
parameter_list|(
name|Node
argument_list|<
name|Object
argument_list|>
name|source
parameter_list|,
annotation|@
name|Nullable
name|Node
argument_list|<
name|Object
argument_list|>
name|left
parameter_list|,
annotation|@
name|Nullable
name|Node
argument_list|<
name|Object
argument_list|>
name|right
parameter_list|)
block|{
return|return
operator|new
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|(
name|source
operator|.
name|getKey
argument_list|()
argument_list|,
name|source
operator|.
name|elemCount
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|class|MultisetModifier
specifier|private
specifier|abstract
class|class
name|MultisetModifier
implements|implements
name|BstModifier
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|method|newCount (int oldCount)
specifier|abstract
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
function_decl|;
annotation|@
name|Nullable
annotation|@
name|Override
DECL|method|modify (E key, @Nullable Node<E> originalEntry)
specifier|public
name|BstModificationResult
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|modify
parameter_list|(
name|E
name|key
parameter_list|,
annotation|@
name|Nullable
name|Node
argument_list|<
name|E
argument_list|>
name|originalEntry
parameter_list|)
block|{
name|int
name|oldCount
init|=
name|countOrZero
argument_list|(
name|originalEntry
argument_list|)
decl_stmt|;
name|int
name|newCount
init|=
name|newCount
argument_list|(
name|oldCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldCount
operator|==
name|newCount
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|identity
argument_list|(
name|originalEntry
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|newCount
operator|==
literal|0
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|rebalancingChange
argument_list|(
name|originalEntry
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|oldCount
operator|==
literal|0
condition|)
block|{
return|return
name|BstModificationResult
operator|.
name|rebalancingChange
argument_list|(
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|key
argument_list|,
name|newCount
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|BstModificationResult
operator|.
name|rebuildingChange
argument_list|(
name|originalEntry
argument_list|,
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|originalEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|newCount
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|AddModifier
specifier|private
specifier|final
class|class
name|AddModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToAdd
specifier|private
specifier|final
name|int
name|countToAdd
decl_stmt|;
DECL|method|AddModifier (int countToAdd)
specifier|private
name|AddModifier
parameter_list|(
name|int
name|countToAdd
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToAdd
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToAdd
operator|=
name|countToAdd
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToAdd
operator|<=
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|oldCount
argument_list|,
literal|"Cannot add this many elements"
argument_list|)
expr_stmt|;
return|return
name|oldCount
operator|+
name|countToAdd
return|;
block|}
block|}
DECL|class|RemoveModifier
specifier|private
specifier|final
class|class
name|RemoveModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToRemove
specifier|private
specifier|final
name|int
name|countToRemove
decl_stmt|;
DECL|method|RemoveModifier (int countToRemove)
specifier|private
name|RemoveModifier
parameter_list|(
name|int
name|countToRemove
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToRemove
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToRemove
operator|=
name|countToRemove
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|oldCount
operator|-
name|countToRemove
argument_list|)
return|;
block|}
block|}
DECL|class|SetCountModifier
specifier|private
specifier|final
class|class
name|SetCountModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|countToSet
specifier|private
specifier|final
name|int
name|countToSet
decl_stmt|;
DECL|method|SetCountModifier (int countToSet)
specifier|private
name|SetCountModifier
parameter_list|(
name|int
name|countToSet
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|countToSet
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|countToSet
operator|=
name|countToSet
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
name|countToSet
return|;
block|}
block|}
DECL|class|ConditionalSetCountModifier
specifier|private
specifier|final
class|class
name|ConditionalSetCountModifier
extends|extends
name|MultisetModifier
block|{
DECL|field|expectedCount
specifier|private
specifier|final
name|int
name|expectedCount
decl_stmt|;
DECL|field|setCount
specifier|private
specifier|final
name|int
name|setCount
decl_stmt|;
DECL|method|ConditionalSetCountModifier (int expectedCount, int setCount)
specifier|private
name|ConditionalSetCountModifier
parameter_list|(
name|int
name|expectedCount
parameter_list|,
name|int
name|setCount
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|setCount
operator|>=
literal|0
operator|&
name|expectedCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|expectedCount
operator|=
name|expectedCount
expr_stmt|;
name|this
operator|.
name|setCount
operator|=
name|setCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCount (int oldCount)
name|int
name|newCount
parameter_list|(
name|int
name|oldCount
parameter_list|)
block|{
return|return
operator|(
name|oldCount
operator|==
name|expectedCount
operator|)
condition|?
name|setCount
else|:
name|oldCount
return|;
block|}
block|}
comment|/*    * TODO(jlevy): Decide whether entrySet() should return entries with an    * equals() method that calls the comparator to compare the two keys. If that    * change is made, AbstractMultiset.equals() can simply check whether two    * multisets have equal entry sets.    */
comment|/**    * @serialData the comparator, the number of distinct elements, the first    *     element, its count, the second element, its count, and so on    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.io.ObjectOutputStream"
argument_list|)
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|stream
operator|.
name|writeObject
argument_list|(
name|elementSet
argument_list|()
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|writeMultiset
argument_list|(
name|this
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.io.ObjectInputStream"
argument_list|)
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
init|=
operator|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|AbstractSortedMultiset
operator|.
name|class
argument_list|,
literal|"comparator"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|TreeMultiset
operator|.
name|class
argument_list|,
literal|"range"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|GeneralRange
operator|.
name|all
argument_list|(
name|comparator
argument_list|)
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|TreeMultiset
operator|.
name|class
argument_list|,
literal|"rootReference"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
operator|new
name|Reference
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|populateMultiset
argument_list|(
name|this
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"not needed in emulated source"
argument_list|)
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
block|}
end_class

end_unit

