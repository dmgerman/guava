begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|NullnessCasts
operator|.
name|uncheckedCastNullableTToT
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|ObjIntConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A multiset which maintains the ordering of its elements, according to either their natural order  * or an explicit {@link Comparator}. In all cases, this implementation uses {@link  * Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to determine  * equivalence of instances.  *  *<p><b>Warning:</b> The comparison must be<i>consistent with equals</i> as explained by the  * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link  * java.util.Collection} contract, which is specified in terms of {@link Object#equals}.  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset"> {@code  * Multiset}</a>.  *  * @author Louis Wasserman  * @author Jared Levy  * @since 2.0  */
end_comment

begin_annotation
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
end_annotation

begin_annotation
annotation|@
name|ElementTypesAreNonnullByDefault
end_annotation

begin_expr_stmt
DECL|class|TreeMultiset
specifier|public
name|final
name|class
name|TreeMultiset
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
expr|extends
name|AbstractSortedMultiset
argument_list|<
name|E
argument_list|>
expr|implements
name|Serializable
block|{
comment|/**    * Creates a new, empty multiset, sorted according to the elements' natural order. All elements    * inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all    * such elements must be<i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a    * {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the    * user attempts to add an element to the multiset that violates this constraint (for example, the    * user attempts to add a string element to a set whose elements are integers), the {@code    * add(Object)} call will throw a {@code ClassCastException}.    *    *<p>The type specification is {@code<E extends Comparable>}, instead of the more specific    * {@code<E extends Comparable<? super E>>}, to support classes defined without generics.    */
DECL|method|create ()
specifier|public
specifier|static
operator|<
name|E
expr|extends
name|Comparable
operator|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
argument_list|()
block|{
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new, empty multiset, sorted according to the specified comparator. All elements    * inserted into the multiset must be<i>mutually comparable</i> by the specified comparator:    * {@code comparator.compare(e1, e2)} must not throw a {@code ClassCastException} for any elements    * {@code e1} and {@code e2} in the multiset. If the user attempts to add an element to the    * multiset that violates this constraint, the {@code add(Object)} call will throw a {@code    * ClassCastException}.    *    * @param comparator the comparator that will be used to sort this multiset. A null value    *     indicates that the elements'<i>natural ordering</i> should be used.    */
expr|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|create ( @heckForNull Comparator<? super E> comparator)
specifier|public
specifier|static
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
argument_list|(
annotation|@
name|CheckForNull
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
argument_list|)
block|{
return|return
operator|(
name|comparator
operator|==
literal|null
operator|)
condition|?
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|Comparator
operator|)
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
else|:
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    * Creates an empty multiset containing the given initial elements, sorted according to the    * elements' natural order.    *    *<p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.    *    *<p>The type specification is {@code<E extends Comparable>}, instead of the more specific    * {@code<E extends Comparable<? super E>>}, to support classes defined without generics.    */
end_comment

begin_function
DECL|method|create (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|TreeMultiset
argument_list|<
name|E
argument_list|>
name|multiset
init|=
name|create
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|multiset
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
end_function

begin_decl_stmt
DECL|field|rootReference
specifier|private
specifier|final
specifier|transient
name|Reference
argument_list|<
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|>
name|rootReference
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|range
specifier|private
specifier|final
specifier|transient
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|header
specifier|private
specifier|final
specifier|transient
name|AvlNode
argument_list|<
name|E
argument_list|>
name|header
decl_stmt|;
end_decl_stmt

begin_expr_stmt
DECL|method|TreeMultiset (Reference<AvlNode<E>> rootReference, GeneralRange<E> range, AvlNode<E> endLink)
name|TreeMultiset
argument_list|(
name|Reference
argument_list|<
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|>
name|rootReference
argument_list|,
name|GeneralRange
argument_list|<
name|E
argument_list|>
name|range
argument_list|,
name|AvlNode
argument_list|<
name|E
argument_list|>
name|endLink
argument_list|)
block|{
name|super
argument_list|(
name|range
operator|.
name|comparator
argument_list|()
argument_list|)
block|;
name|this
operator|.
name|rootReference
operator|=
name|rootReference
block|;
name|this
operator|.
name|range
operator|=
name|range
block|;
name|this
operator|.
name|header
operator|=
name|endLink
block|;   }
DECL|method|TreeMultiset (Comparator<? super E> comparator)
name|TreeMultiset
argument_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
argument_list|)
block|{
name|super
argument_list|(
name|comparator
argument_list|)
block|;
name|this
operator|.
name|range
operator|=
name|GeneralRange
operator|.
name|all
argument_list|(
name|comparator
argument_list|)
block|;
name|this
operator|.
name|header
operator|=
operator|new
name|AvlNode
argument_list|<>
argument_list|()
block|;
name|successor
argument_list|(
name|header
argument_list|,
name|header
argument_list|)
block|;
name|this
operator|.
name|rootReference
operator|=
operator|new
name|Reference
argument_list|<>
argument_list|()
block|;   }
comment|/** A function which can be summed across a subtree. */
DECL|enum|Aggregate
specifier|private
expr|enum
name|Aggregate
block|{
DECL|enumConstant|SIZE
name|SIZE
block|{       @
name|Override
name|int
name|nodeAggregate
argument_list|(
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
argument_list|)
block|{
return|return
name|node
operator|.
name|elemCount
return|;
block|}
expr|@
name|Override
name|long
name|treeAggregate
argument_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|root
argument_list|)
block|{
return|return
operator|(
name|root
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|root
operator|.
name|totalCount
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|},
DECL|enumConstant|DISTINCT
name|DISTINCT
block|{       @
name|Override
name|int
name|nodeAggregate
argument_list|(
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
argument_list|)
block|{
return|return
literal|1
return|;
block|}
expr|@
name|Override
name|long
name|treeAggregate
argument_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|root
argument_list|)
block|{
return|return
operator|(
name|root
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|root
operator|.
name|distinctElements
return|;
block|}
end_expr_stmt

begin_function_decl
unit|};
DECL|method|nodeAggregate (AvlNode<?> node)
specifier|abstract
name|int
name|nodeAggregate
parameter_list|(
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
DECL|method|treeAggregate (@heckForNull AvlNode<?> root)
specifier|abstract
name|long
name|treeAggregate
parameter_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|root
parameter_list|)
function_decl|;
end_function_decl

begin_function
unit|}    private
DECL|method|aggregateForEntries (Aggregate aggr)
name|long
name|aggregateForEntries
parameter_list|(
name|Aggregate
name|aggr
parameter_list|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|total
init|=
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
name|total
operator|-=
name|aggregateBelowRange
argument_list|(
name|aggr
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
name|total
operator|-=
name|aggregateAboveRange
argument_list|(
name|aggr
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
DECL|method|aggregateBelowRange (Aggregate aggr, @CheckForNull AvlNode<E> node)
specifier|private
name|long
name|aggregateBelowRange
parameter_list|(
name|Aggregate
name|aggr
parameter_list|,
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// The cast is safe because we call this method only if hasLowerBound().
name|int
name|cmp
init|=
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|uncheckedCastNullableTToT
argument_list|(
name|range
operator|.
name|getLowerEndpoint
argument_list|()
argument_list|)
argument_list|,
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
return|return
name|aggregateBelowRange
argument_list|(
name|aggr
argument_list|,
name|node
operator|.
name|left
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|range
operator|.
name|getLowerBoundType
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
return|return
name|aggr
operator|.
name|nodeAggregate
argument_list|(
name|node
argument_list|)
operator|+
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|left
argument_list|)
return|;
case|case
name|CLOSED
case|:
return|return
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|left
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
else|else
block|{
return|return
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|left
argument_list|)
operator|+
name|aggr
operator|.
name|nodeAggregate
argument_list|(
name|node
argument_list|)
operator|+
name|aggregateBelowRange
argument_list|(
name|aggr
argument_list|,
name|node
operator|.
name|right
argument_list|)
return|;
block|}
block|}
end_function

begin_function
DECL|method|aggregateAboveRange (Aggregate aggr, @CheckForNull AvlNode<E> node)
specifier|private
name|long
name|aggregateAboveRange
parameter_list|(
name|Aggregate
name|aggr
parameter_list|,
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// The cast is safe because we call this method only if hasUpperBound().
name|int
name|cmp
init|=
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|uncheckedCastNullableTToT
argument_list|(
name|range
operator|.
name|getUpperEndpoint
argument_list|()
argument_list|)
argument_list|,
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
return|return
name|aggregateAboveRange
argument_list|(
name|aggr
argument_list|,
name|node
operator|.
name|right
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|range
operator|.
name|getUpperBoundType
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
return|return
name|aggr
operator|.
name|nodeAggregate
argument_list|(
name|node
argument_list|)
operator|+
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|right
argument_list|)
return|;
case|case
name|CLOSED
case|:
return|return
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|right
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
else|else
block|{
return|return
name|aggr
operator|.
name|treeAggregate
argument_list|(
name|node
operator|.
name|right
argument_list|)
operator|+
name|aggr
operator|.
name|nodeAggregate
argument_list|(
name|node
argument_list|)
operator|+
name|aggregateAboveRange
argument_list|(
name|aggr
argument_list|,
name|node
operator|.
name|left
argument_list|)
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|aggregateForEntries
argument_list|(
name|Aggregate
operator|.
name|SIZE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|distinctElements ()
name|int
name|distinctElements
parameter_list|()
block|{
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|aggregateForEntries
argument_list|(
name|Aggregate
operator|.
name|DISTINCT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|distinctElements (@heckForNull AvlNode<?> node)
specifier|static
name|int
name|distinctElements
parameter_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|distinctElements
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|count (@heckForNull Object element)
specifier|public
name|int
name|count
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|)
block|{
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|element
decl_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
operator|||
name|root
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|root
operator|.
name|count
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|add (@arametricNullness E element, int occurrences)
specifier|public
name|int
name|add
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|occurrences
argument_list|,
literal|"occurrences"
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|element
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newRoot
init|=
operator|new
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|(
name|element
argument_list|,
name|occurrences
argument_list|)
decl_stmt|;
name|successor
argument_list|(
name|header
argument_list|,
name|newRoot
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|rootReference
operator|.
name|checkAndSet
argument_list|(
name|root
argument_list|,
name|newRoot
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
comment|// used as a mutable int reference to hold result
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newRoot
init|=
name|root
operator|.
name|add
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|element
argument_list|,
name|occurrences
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|rootReference
operator|.
name|checkAndSet
argument_list|(
name|root
argument_list|,
name|newRoot
argument_list|)
expr_stmt|;
return|return
name|result
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|remove (@heckForNull Object element, int occurrences)
specifier|public
name|int
name|remove
parameter_list|(
annotation|@
name|CheckForNull
name|Object
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|occurrences
argument_list|,
literal|"occurrences"
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
comment|// used as a mutable int reference to hold result
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newRoot
decl_stmt|;
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|element
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|contains
argument_list|(
name|e
argument_list|)
operator|||
name|root
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|newRoot
operator|=
name|root
operator|.
name|remove
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|e
argument_list|,
name|occurrences
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
decl||
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|rootReference
operator|.
name|checkAndSet
argument_list|(
name|root
argument_list|,
name|newRoot
argument_list|)
expr_stmt|;
return|return
name|result
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|setCount (@arametricNullness E element, int count)
specifier|public
name|int
name|setCount
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|element
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|count
argument_list|,
literal|"count"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|add
argument_list|(
name|element
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
comment|// used as a mutable int reference to hold result
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newRoot
init|=
name|root
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|element
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|rootReference
operator|.
name|checkAndSet
argument_list|(
name|root
argument_list|,
name|newRoot
argument_list|)
expr_stmt|;
return|return
name|result
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|Override
DECL|method|setCount (@arametricNullness E element, int oldCount, int newCount)
specifier|public
name|boolean
name|setCount
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|element
parameter_list|,
name|int
name|oldCount
parameter_list|,
name|int
name|newCount
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|newCount
argument_list|,
literal|"newCount"
argument_list|)
expr_stmt|;
name|checkNonnegative
argument_list|(
name|oldCount
argument_list|,
literal|"oldCount"
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|range
operator|.
name|contains
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|oldCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|newCount
operator|>
literal|0
condition|)
block|{
name|add
argument_list|(
name|element
argument_list|,
name|newCount
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
comment|// used as a mutable int reference to hold result
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newRoot
init|=
name|root
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|element
argument_list|,
name|oldCount
argument_list|,
name|newCount
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|rootReference
operator|.
name|checkAndSet
argument_list|(
name|root
argument_list|,
name|newRoot
argument_list|)
expr_stmt|;
return|return
name|result
index|[
literal|0
index|]
operator|==
name|oldCount
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
operator|!
name|range
operator|.
name|hasLowerBound
argument_list|()
operator|&&
operator|!
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
comment|// We can do this in O(n) rather than removing one by one, which could force rebalancing.
for|for
control|(
name|AvlNode
argument_list|<
name|E
argument_list|>
name|current
init|=
name|header
operator|.
name|succ
argument_list|()
init|;
name|current
operator|!=
name|header
condition|;
control|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|next
init|=
name|current
operator|.
name|succ
argument_list|()
decl_stmt|;
name|current
operator|.
name|elemCount
operator|=
literal|0
expr_stmt|;
comment|// Also clear these fields so that one deleted Entry doesn't retain all elements.
name|current
operator|.
name|left
operator|=
literal|null
expr_stmt|;
name|current
operator|.
name|right
operator|=
literal|null
expr_stmt|;
name|current
operator|.
name|pred
operator|=
literal|null
expr_stmt|;
name|current
operator|.
name|succ
operator|=
literal|null
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
block|}
name|successor
argument_list|(
name|header
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|rootReference
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// TODO(cpovirk): Perhaps we can optimize in this case, too?
name|Iterators
operator|.
name|clear
argument_list|(
name|entryIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|wrapEntry (final AvlNode<E> baseEntry)
specifier|private
name|Entry
argument_list|<
name|E
argument_list|>
name|wrapEntry
parameter_list|(
specifier|final
name|AvlNode
argument_list|<
name|E
argument_list|>
name|baseEntry
parameter_list|)
block|{
return|return
operator|new
name|Multisets
operator|.
name|AbstractEntry
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
annotation|@
name|ParametricNullness
specifier|public
name|E
name|getElement
parameter_list|()
block|{
return|return
name|baseEntry
operator|.
name|getElement
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCount
parameter_list|()
block|{
name|int
name|result
init|=
name|baseEntry
operator|.
name|getCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|getElement
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** Returns the first node in the tree that is in range. */
end_comment

begin_function
annotation|@
name|CheckForNull
DECL|method|firstNode ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|firstNode
parameter_list|()
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
comment|// The cast is safe because of the hasLowerBound check.
name|E
name|endpoint
init|=
name|uncheckedCastNullableTToT
argument_list|(
name|range
operator|.
name|getLowerEndpoint
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|=
name|root
operator|.
name|ceiling
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|range
operator|.
name|getLowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|OPEN
operator|&&
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|endpoint
argument_list|,
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|succ
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|header
operator|.
name|succ
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|==
name|header
operator|||
operator|!
name|range
operator|.
name|contains
argument_list|(
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
operator|)
condition|?
literal|null
else|:
name|node
return|;
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|lastNode ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|lastNode
parameter_list|()
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|root
init|=
name|rootReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
comment|// The cast is safe because of the hasUpperBound check.
name|E
name|endpoint
init|=
name|uncheckedCastNullableTToT
argument_list|(
name|range
operator|.
name|getUpperEndpoint
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|=
name|root
operator|.
name|floor
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|range
operator|.
name|getUpperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|OPEN
operator|&&
name|comparator
argument_list|()
operator|.
name|compare
argument_list|(
name|endpoint
argument_list|,
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|pred
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|header
operator|.
name|pred
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|==
name|header
operator|||
operator|!
name|range
operator|.
name|contains
argument_list|(
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
operator|)
condition|?
literal|null
else|:
name|node
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|elementIterator ()
name|Iterator
argument_list|<
name|E
argument_list|>
name|elementIterator
parameter_list|()
block|{
return|return
name|Multisets
operator|.
name|elementIterator
argument_list|(
name|entryIterator
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|E
argument_list|>
name|current
init|=
name|firstNode
argument_list|()
decl_stmt|;
annotation|@
name|CheckForNull
name|Entry
argument_list|<
name|E
argument_list|>
name|prevEntry
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|tooHigh
argument_list|(
name|current
operator|.
name|getElement
argument_list|()
argument_list|)
condition|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|E
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
comment|// requireNonNull is safe because current is only nulled out after iteration is complete.
name|Entry
argument_list|<
name|E
argument_list|>
name|result
init|=
name|wrapEntry
argument_list|(
name|requireNonNull
argument_list|(
name|current
argument_list|)
argument_list|)
decl_stmt|;
name|prevEntry
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|succ
argument_list|()
operator|==
name|header
condition|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|current
operator|.
name|succ
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|prevEntry
operator|!=
literal|null
argument_list|,
literal|"no calls to next() since the last call to remove()"
argument_list|)
expr_stmt|;
name|setCount
argument_list|(
name|prevEntry
operator|.
name|getElement
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prevEntry
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|descendingEntryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
name|descendingEntryIterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|E
argument_list|>
name|current
init|=
name|lastNode
argument_list|()
decl_stmt|;
annotation|@
name|CheckForNull
name|Entry
argument_list|<
name|E
argument_list|>
name|prevEntry
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|range
operator|.
name|tooLow
argument_list|(
name|current
operator|.
name|getElement
argument_list|()
argument_list|)
condition|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|E
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
comment|// requireNonNull is safe because current is only nulled out after iteration is complete.
name|requireNonNull
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|E
argument_list|>
name|result
init|=
name|wrapEntry
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|prevEntry
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|pred
argument_list|()
operator|==
name|header
condition|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|current
operator|.
name|pred
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|prevEntry
operator|!=
literal|null
argument_list|,
literal|"no calls to next() since the last call to remove()"
argument_list|)
expr_stmt|;
name|setCount
argument_list|(
name|prevEntry
operator|.
name|getElement
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prevEntry
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|forEachEntry (ObjIntConsumer<? super E> action)
specifier|public
name|void
name|forEachEntry
parameter_list|(
name|ObjIntConsumer
argument_list|<
name|?
super|super
name|E
argument_list|>
name|action
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|action
argument_list|)
expr_stmt|;
for|for
control|(
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
init|=
name|firstNode
argument_list|()
init|;
name|node
operator|!=
name|header
operator|&&
name|node
operator|!=
literal|null
operator|&&
operator|!
name|range
operator|.
name|tooHigh
argument_list|(
name|node
operator|.
name|getElement
argument_list|()
argument_list|)
condition|;
name|node
operator|=
name|node
operator|.
name|succ
argument_list|()
control|)
block|{
name|action
operator|.
name|accept
argument_list|(
name|node
operator|.
name|getElement
argument_list|()
argument_list|,
name|node
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Multisets
operator|.
name|iteratorImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|headMultiset (@arametricNullness E upperBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|headMultiset
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|upperBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|rootReference
argument_list|,
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|upTo
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|upperBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|header
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|tailMultiset (@arametricNullness E lowerBound, BoundType boundType)
specifier|public
name|SortedMultiset
argument_list|<
name|E
argument_list|>
name|tailMultiset
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|lowerBound
parameter_list|,
name|BoundType
name|boundType
parameter_list|)
block|{
return|return
operator|new
name|TreeMultiset
argument_list|<
name|E
argument_list|>
argument_list|(
name|rootReference
argument_list|,
name|range
operator|.
name|intersect
argument_list|(
name|GeneralRange
operator|.
name|downTo
argument_list|(
name|comparator
argument_list|()
argument_list|,
name|lowerBound
argument_list|,
name|boundType
argument_list|)
argument_list|)
argument_list|,
name|header
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|Reference
specifier|private
specifier|static
specifier|final
class|class
name|Reference
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|value
annotation|@
name|CheckForNull
specifier|private
name|T
name|value
decl_stmt|;
annotation|@
name|CheckForNull
DECL|method|get ()
specifier|public
name|T
name|get
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|checkAndSet (@heckForNull T expected, @CheckForNull T newValue)
specifier|public
name|void
name|checkAndSet
parameter_list|(
annotation|@
name|CheckForNull
name|T
name|expected
parameter_list|,
annotation|@
name|CheckForNull
name|T
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
name|value
operator|=
name|newValue
expr_stmt|;
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
block|}
end_class

begin_expr_stmt
DECL|class|AvlNode
specifier|private
specifier|static
name|final
name|class
name|AvlNode
operator|<
name|E
expr|extends @
name|Nullable
name|Object
operator|>
block|{
comment|/*      * For "normal" nodes, the type of this field is `E`, not `@Nullable E` (though note that E is a      * type that can include null, as in a TreeMultiset<@Nullable String>).      *      * For the header node, though, this field contains `null`, regardless of the type of the      * multiset.      *      * Most code that operates on an AvlNode never operates on the header node. Such code can access      * the elem field without a null check by calling getElement().      */
DECL|field|elem
block|@
name|CheckForNull
specifier|private
name|final
name|E
name|elem
block|;
comment|// elemCount is 0 iff this node has been deleted.
DECL|field|elemCount
specifier|private
name|int
name|elemCount
block|;
DECL|field|distinctElements
specifier|private
name|int
name|distinctElements
block|;
DECL|field|totalCount
specifier|private
name|long
name|totalCount
block|;
DECL|field|height
specifier|private
name|int
name|height
block|;     @
DECL|field|left
name|CheckForNull
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|left
block|;     @
DECL|field|right
name|CheckForNull
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|right
block|;
comment|/*      * pred and succ are nullable after construction, but we always call successor() to initialize      * them immediately thereafter.      *      * They may be subsequently nulled out by TreeMultiset.clear(). I think that the only place that      * we can reference a node whose fields have been cleared is inside the iterator (and presumably      * only under concurrent modification).      *      * To access these fields when you know that they are not null, call the pred() and succ()      * methods, which perform null checks before returning the fields.      */
DECL|field|pred
block|@
name|CheckForNull
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|pred
block|;     @
DECL|field|succ
name|CheckForNull
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|succ
block|;
DECL|method|AvlNode (@arametricNullness E elem, int elemCount)
name|AvlNode
argument_list|(
annotation|@
name|ParametricNullness
name|E
name|elem
argument_list|,
name|int
name|elemCount
argument_list|)
block|{
name|checkArgument
argument_list|(
name|elemCount
operator|>
literal|0
argument_list|)
block|;
name|this
operator|.
name|elem
operator|=
name|elem
block|;
name|this
operator|.
name|elemCount
operator|=
name|elemCount
block|;
name|this
operator|.
name|totalCount
operator|=
name|elemCount
block|;
name|this
operator|.
name|distinctElements
operator|=
literal|1
block|;
name|this
operator|.
name|height
operator|=
literal|1
block|;
name|this
operator|.
name|left
operator|=
literal|null
block|;
name|this
operator|.
name|right
operator|=
literal|null
block|;     }
comment|/** Constructor for the header node. */
DECL|method|AvlNode ()
name|AvlNode
argument_list|()
block|{
name|this
operator|.
name|elem
operator|=
literal|null
block|;
name|this
operator|.
name|elemCount
operator|=
literal|1
block|;     }
comment|// For discussion of pred() and succ(), see the comment on the pred and succ fields.
DECL|method|pred ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|pred
argument_list|()
block|{
return|return
name|requireNonNull
argument_list|(
name|pred
argument_list|)
return|;
block|}
DECL|method|succ ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|succ
argument_list|()
block|{
return|return
name|requireNonNull
argument_list|(
name|succ
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
DECL|method|count (Comparator<? super E> comparator, @ParametricNullness E e)
name|int
name|count
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|left
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|left
operator|.
name|count
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|right
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|right
operator|.
name|count
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|elemCount
return|;
block|}
block|}
end_function

begin_function
DECL|method|addRightChild (@arametricNullness E e, int count)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|addRightChild
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|right
operator|=
operator|new
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|successor
argument_list|(
name|this
argument_list|,
name|right
argument_list|,
name|succ
argument_list|()
argument_list|)
expr_stmt|;
name|height
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|2
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|distinctElements
operator|++
expr_stmt|;
name|totalCount
operator|+=
name|count
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
DECL|method|addLeftChild (@arametricNullness E e, int count)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|addLeftChild
parameter_list|(
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|left
operator|=
operator|new
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|successor
argument_list|(
name|pred
argument_list|()
argument_list|,
name|left
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|height
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|2
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|distinctElements
operator|++
expr_stmt|;
name|totalCount
operator|+=
name|count
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
DECL|method|add ( Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result)
name|AvlNode
argument_list|<
name|E
argument_list|>
name|add
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|count
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
comment|/*        * It speeds things up considerably to unconditionally add count to totalCount here,        * but that destroys failure atomicity in the case of count overflow. =(        */
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initLeft
init|=
name|left
decl_stmt|;
if|if
condition|(
name|initLeft
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|addLeftChild
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
return|;
block|}
name|int
name|initHeight
init|=
name|initLeft
operator|.
name|height
decl_stmt|;
name|left
operator|=
name|initLeft
operator|.
name|add
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|left
operator|.
name|height
operator|==
name|initHeight
operator|)
condition|?
name|this
else|:
name|rebalance
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initRight
init|=
name|right
decl_stmt|;
if|if
condition|(
name|initRight
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|addRightChild
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
return|;
block|}
name|int
name|initHeight
init|=
name|initRight
operator|.
name|height
decl_stmt|;
name|right
operator|=
name|initRight
operator|.
name|add
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|right
operator|.
name|height
operator|==
name|initHeight
operator|)
condition|?
name|this
else|:
name|rebalance
argument_list|()
return|;
block|}
comment|// adding count to me!  No rebalance possible.
name|result
index|[
literal|0
index|]
operator|=
name|elemCount
expr_stmt|;
name|long
name|resultCount
init|=
operator|(
name|long
operator|)
name|elemCount
operator|+
name|count
decl_stmt|;
name|checkArgument
argument_list|(
name|resultCount
operator|<=
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|this
operator|.
name|elemCount
operator|+=
name|count
expr_stmt|;
name|this
operator|.
name|totalCount
operator|+=
name|count
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|remove ( Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result)
name|AvlNode
argument_list|<
name|E
argument_list|>
name|remove
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|count
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initLeft
init|=
name|left
decl_stmt|;
if|if
condition|(
name|initLeft
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|this
return|;
block|}
name|left
operator|=
name|initLeft
operator|.
name|remove
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|result
index|[
literal|0
index|]
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
name|this
operator|.
name|totalCount
operator|-=
name|result
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|totalCount
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
name|this
else|:
name|rebalance
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initRight
init|=
name|right
decl_stmt|;
if|if
condition|(
name|initRight
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|this
return|;
block|}
name|right
operator|=
name|initRight
operator|.
name|remove
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|result
index|[
literal|0
index|]
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
name|this
operator|.
name|totalCount
operator|-=
name|result
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|totalCount
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|rebalance
argument_list|()
return|;
block|}
comment|// removing count from me!
name|result
index|[
literal|0
index|]
operator|=
name|elemCount
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|elemCount
condition|)
block|{
return|return
name|deleteMe
argument_list|()
return|;
block|}
else|else
block|{
name|this
operator|.
name|elemCount
operator|-=
name|count
expr_stmt|;
name|this
operator|.
name|totalCount
operator|-=
name|count
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|setCount ( Comparator<? super E> comparator, @ParametricNullness E e, int count, int[] result)
name|AvlNode
argument_list|<
name|E
argument_list|>
name|setCount
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|count
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initLeft
init|=
name|left
decl_stmt|;
if|if
condition|(
name|initLeft
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|count
operator|>
literal|0
operator|)
condition|?
name|addLeftChild
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
else|:
name|this
return|;
block|}
name|left
operator|=
name|initLeft
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|count
operator|-
name|result
index|[
literal|0
index|]
expr_stmt|;
return|return
name|rebalance
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initRight
init|=
name|right
decl_stmt|;
if|if
condition|(
name|initRight
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|count
operator|>
literal|0
operator|)
condition|?
name|addRightChild
argument_list|(
name|e
argument_list|,
name|count
argument_list|)
else|:
name|this
return|;
block|}
name|right
operator|=
name|initRight
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|count
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|count
operator|-
name|result
index|[
literal|0
index|]
expr_stmt|;
return|return
name|rebalance
argument_list|()
return|;
block|}
comment|// setting my count
name|result
index|[
literal|0
index|]
operator|=
name|elemCount
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
name|deleteMe
argument_list|()
return|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|count
operator|-
name|elemCount
expr_stmt|;
name|this
operator|.
name|elemCount
operator|=
name|count
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|setCount ( Comparator<? super E> comparator, @ParametricNullness E e, int expectedCount, int newCount, int[] result)
name|AvlNode
argument_list|<
name|E
argument_list|>
name|setCount
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|,
name|int
name|expectedCount
parameter_list|,
name|int
name|newCount
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initLeft
init|=
name|left
decl_stmt|;
if|if
condition|(
name|initLeft
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expectedCount
operator|==
literal|0
operator|&&
name|newCount
operator|>
literal|0
condition|)
block|{
return|return
name|addLeftChild
argument_list|(
name|e
argument_list|,
name|newCount
argument_list|)
return|;
block|}
return|return
name|this
return|;
block|}
name|left
operator|=
name|initLeft
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|expectedCount
argument_list|,
name|newCount
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
name|expectedCount
condition|)
block|{
if|if
condition|(
name|newCount
operator|==
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newCount
operator|>
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|newCount
operator|-
name|result
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|rebalance
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|initRight
init|=
name|right
decl_stmt|;
if|if
condition|(
name|initRight
operator|==
literal|null
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expectedCount
operator|==
literal|0
operator|&&
name|newCount
operator|>
literal|0
condition|)
block|{
return|return
name|addRightChild
argument_list|(
name|e
argument_list|,
name|newCount
argument_list|)
return|;
block|}
return|return
name|this
return|;
block|}
name|right
operator|=
name|initRight
operator|.
name|setCount
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|,
name|expectedCount
argument_list|,
name|newCount
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
name|expectedCount
condition|)
block|{
if|if
condition|(
name|newCount
operator|==
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newCount
operator|>
literal|0
operator|&&
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|distinctElements
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|newCount
operator|-
name|result
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|rebalance
argument_list|()
return|;
block|}
comment|// setting my count
name|result
index|[
literal|0
index|]
operator|=
name|elemCount
expr_stmt|;
if|if
condition|(
name|expectedCount
operator|==
name|elemCount
condition|)
block|{
if|if
condition|(
name|newCount
operator|==
literal|0
condition|)
block|{
return|return
name|deleteMe
argument_list|()
return|;
block|}
name|this
operator|.
name|totalCount
operator|+=
name|newCount
operator|-
name|elemCount
expr_stmt|;
name|this
operator|.
name|elemCount
operator|=
name|newCount
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|deleteMe ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|deleteMe
parameter_list|()
block|{
name|int
name|oldElemCount
init|=
name|this
operator|.
name|elemCount
decl_stmt|;
name|this
operator|.
name|elemCount
operator|=
literal|0
expr_stmt|;
name|successor
argument_list|(
name|pred
argument_list|()
argument_list|,
name|succ
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
return|return
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
return|return
name|left
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|.
name|height
operator|>=
name|right
operator|.
name|height
condition|)
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newTop
init|=
name|pred
argument_list|()
decl_stmt|;
comment|// newTop is the maximum node in my left subtree
name|newTop
operator|.
name|left
operator|=
name|left
operator|.
name|removeMax
argument_list|(
name|newTop
argument_list|)
expr_stmt|;
name|newTop
operator|.
name|right
operator|=
name|right
expr_stmt|;
name|newTop
operator|.
name|distinctElements
operator|=
name|distinctElements
operator|-
literal|1
expr_stmt|;
name|newTop
operator|.
name|totalCount
operator|=
name|totalCount
operator|-
name|oldElemCount
expr_stmt|;
return|return
name|newTop
operator|.
name|rebalance
argument_list|()
return|;
block|}
else|else
block|{
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newTop
init|=
name|succ
argument_list|()
decl_stmt|;
name|newTop
operator|.
name|right
operator|=
name|right
operator|.
name|removeMin
argument_list|(
name|newTop
argument_list|)
expr_stmt|;
name|newTop
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|newTop
operator|.
name|distinctElements
operator|=
name|distinctElements
operator|-
literal|1
expr_stmt|;
name|newTop
operator|.
name|totalCount
operator|=
name|totalCount
operator|-
name|oldElemCount
expr_stmt|;
return|return
name|newTop
operator|.
name|rebalance
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|// Removes the minimum node from this subtree to be reused elsewhere
end_comment

begin_function
annotation|@
name|CheckForNull
DECL|method|removeMin (AvlNode<E> node)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|removeMin
parameter_list|(
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
return|return
name|right
return|;
block|}
else|else
block|{
name|left
operator|=
name|left
operator|.
name|removeMin
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|distinctElements
operator|--
expr_stmt|;
name|totalCount
operator|-=
name|node
operator|.
name|elemCount
expr_stmt|;
return|return
name|rebalance
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|// Removes the maximum node from this subtree to be reused elsewhere
end_comment

begin_function
annotation|@
name|CheckForNull
DECL|method|removeMax (AvlNode<E> node)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|removeMax
parameter_list|(
name|AvlNode
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
return|return
name|left
return|;
block|}
else|else
block|{
name|right
operator|=
name|right
operator|.
name|removeMax
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|distinctElements
operator|--
expr_stmt|;
name|totalCount
operator|-=
name|node
operator|.
name|elemCount
expr_stmt|;
return|return
name|rebalance
argument_list|()
return|;
block|}
block|}
end_function

begin_function
DECL|method|recomputeMultiset ()
specifier|private
name|void
name|recomputeMultiset
parameter_list|()
block|{
name|this
operator|.
name|distinctElements
operator|=
literal|1
operator|+
name|TreeMultiset
operator|.
name|distinctElements
argument_list|(
name|left
argument_list|)
operator|+
name|TreeMultiset
operator|.
name|distinctElements
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|this
operator|.
name|totalCount
operator|=
name|elemCount
operator|+
name|totalCount
argument_list|(
name|left
argument_list|)
operator|+
name|totalCount
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|recomputeHeight ()
specifier|private
name|void
name|recomputeHeight
parameter_list|()
block|{
name|this
operator|.
name|height
operator|=
literal|1
operator|+
name|Math
operator|.
name|max
argument_list|(
name|height
argument_list|(
name|left
argument_list|)
argument_list|,
name|height
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|recompute ()
specifier|private
name|void
name|recompute
parameter_list|()
block|{
name|recomputeMultiset
argument_list|()
expr_stmt|;
name|recomputeHeight
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
DECL|method|rebalance ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|rebalance
parameter_list|()
block|{
switch|switch
condition|(
name|balanceFactor
argument_list|()
condition|)
block|{
case|case
operator|-
literal|2
case|:
comment|// requireNonNull is safe because right must exist in order to get a negative factor.
name|requireNonNull
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|.
name|balanceFactor
argument_list|()
operator|>
literal|0
condition|)
block|{
name|right
operator|=
name|right
operator|.
name|rotateRight
argument_list|()
expr_stmt|;
block|}
return|return
name|rotateLeft
argument_list|()
return|;
case|case
literal|2
case|:
comment|// requireNonNull is safe because left must exist in order to get a positive factor.
name|requireNonNull
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|.
name|balanceFactor
argument_list|()
operator|<
literal|0
condition|)
block|{
name|left
operator|=
name|left
operator|.
name|rotateLeft
argument_list|()
expr_stmt|;
block|}
return|return
name|rotateRight
argument_list|()
return|;
default|default:
name|recomputeHeight
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_function

begin_function
DECL|method|balanceFactor ()
specifier|private
name|int
name|balanceFactor
parameter_list|()
block|{
return|return
name|height
argument_list|(
name|left
argument_list|)
operator|-
name|height
argument_list|(
name|right
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|rotateLeft ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|rotateLeft
parameter_list|()
block|{
name|checkState
argument_list|(
name|right
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newTop
init|=
name|right
decl_stmt|;
name|this
operator|.
name|right
operator|=
name|newTop
operator|.
name|left
expr_stmt|;
name|newTop
operator|.
name|left
operator|=
name|this
expr_stmt|;
name|newTop
operator|.
name|totalCount
operator|=
name|this
operator|.
name|totalCount
expr_stmt|;
name|newTop
operator|.
name|distinctElements
operator|=
name|this
operator|.
name|distinctElements
expr_stmt|;
name|this
operator|.
name|recompute
argument_list|()
expr_stmt|;
name|newTop
operator|.
name|recomputeHeight
argument_list|()
expr_stmt|;
return|return
name|newTop
return|;
block|}
end_function

begin_function
DECL|method|rotateRight ()
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|rotateRight
parameter_list|()
block|{
name|checkState
argument_list|(
name|left
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|newTop
init|=
name|left
decl_stmt|;
name|this
operator|.
name|left
operator|=
name|newTop
operator|.
name|right
expr_stmt|;
name|newTop
operator|.
name|right
operator|=
name|this
expr_stmt|;
name|newTop
operator|.
name|totalCount
operator|=
name|this
operator|.
name|totalCount
expr_stmt|;
name|newTop
operator|.
name|distinctElements
operator|=
name|this
operator|.
name|distinctElements
expr_stmt|;
name|this
operator|.
name|recompute
argument_list|()
expr_stmt|;
name|newTop
operator|.
name|recomputeHeight
argument_list|()
expr_stmt|;
return|return
name|newTop
return|;
block|}
end_function

begin_function
DECL|method|totalCount (@heckForNull AvlNode<?> node)
specifier|private
specifier|static
name|long
name|totalCount
parameter_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|totalCount
return|;
block|}
end_function

begin_function
DECL|method|height (@heckForNull AvlNode<?> node)
specifier|private
specifier|static
name|int
name|height
parameter_list|(
annotation|@
name|CheckForNull
name|AvlNode
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|node
operator|.
name|height
return|;
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|ceiling (Comparator<? super E> comparator, @ParametricNullness E e)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|ceiling
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|left
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|left
operator|.
name|ceiling
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|(
name|right
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|right
operator|.
name|ceiling
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|CheckForNull
DECL|method|floor (Comparator<? super E> comparator, @ParametricNullness E e)
specifier|private
name|AvlNode
argument_list|<
name|E
argument_list|>
name|floor
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|,
annotation|@
name|ParametricNullness
name|E
name|e
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|right
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|MoreObjects
operator|.
name|firstNonNull
argument_list|(
name|right
operator|.
name|floor
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|(
name|left
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|left
operator|.
name|floor
argument_list|(
name|comparator
argument_list|,
name|e
argument_list|)
return|;
block|}
block|}
end_function

begin_function
annotation|@
name|ParametricNullness
DECL|method|getElement ()
name|E
name|getElement
parameter_list|()
block|{
comment|// For discussion of this cast, see the comment on the elem field.
return|return
name|uncheckedCastNullableTToT
argument_list|(
name|elem
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|getCount ()
name|int
name|getCount
parameter_list|()
block|{
return|return
name|elemCount
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Multisets
operator|.
name|immutableEntry
argument_list|(
name|getElement
argument_list|()
argument_list|,
name|getCount
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|}    private
DECL|method|successor (AvlNode<T> a, AvlNode<T> b)
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|void
name|successor
argument_list|(
name|AvlNode
argument_list|<
name|T
argument_list|>
name|a
argument_list|,
name|AvlNode
argument_list|<
name|T
argument_list|>
name|b
argument_list|)
block|{
name|a
operator|.
name|succ
operator|=
name|b
block|;
name|b
operator|.
name|pred
operator|=
name|a
block|;   }
DECL|method|successor ( AvlNode<T> a, AvlNode<T> b, AvlNode<T> c)
specifier|private
specifier|static
operator|<
name|T
expr|extends @
name|Nullable
name|Object
operator|>
name|void
name|successor
argument_list|(
name|AvlNode
argument_list|<
name|T
argument_list|>
name|a
argument_list|,
name|AvlNode
argument_list|<
name|T
argument_list|>
name|b
argument_list|,
name|AvlNode
argument_list|<
name|T
argument_list|>
name|c
argument_list|)
block|{
name|successor
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
block|;
name|successor
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
block|;   }
comment|/*    * TODO(jlevy): Decide whether entrySet() should return entries with an equals() method that    * calls the comparator to compare the two keys. If that change is made,    * AbstractMultiset.equals() can simply check whether two multisets have equal entry sets.    */
comment|/**    * @serialData the comparator, the number of distinct elements, the first element, its count, the    *     second element, its count, and so on    */
expr|@
name|GwtIncompatible
comment|// java.io.ObjectOutputStream
DECL|method|writeObject (ObjectOutputStream stream)
specifier|private
name|void
name|writeObject
argument_list|(
name|ObjectOutputStream
name|stream
argument_list|)
throws|throws
name|IOException
block|{
name|stream
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|stream
operator|.
name|writeObject
argument_list|(
name|elementSet
argument_list|()
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Serialization
operator|.
name|writeMultiset
argument_list|(
name|this
argument_list|,
name|stream
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|GwtIncompatible
comment|// java.io.ObjectInputStream
DECL|method|readObject (ObjectInputStream stream)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|stream
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// reading data stored by writeObject
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
init|=
operator|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
operator|)
name|stream
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|AbstractSortedMultiset
operator|.
name|class
argument_list|,
literal|"comparator"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|TreeMultiset
operator|.
name|class
argument_list|,
literal|"range"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|GeneralRange
operator|.
name|all
argument_list|(
name|comparator
argument_list|)
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|TreeMultiset
operator|.
name|class
argument_list|,
literal|"rootReference"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
operator|new
name|Reference
argument_list|<
name|AvlNode
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|AvlNode
argument_list|<
name|E
argument_list|>
name|header
init|=
operator|new
name|AvlNode
argument_list|<>
argument_list|()
decl_stmt|;
name|Serialization
operator|.
name|getFieldSetter
argument_list|(
name|TreeMultiset
operator|.
name|class
argument_list|,
literal|"header"
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|successor
argument_list|(
name|header
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|Serialization
operator|.
name|populateMultiset
argument_list|(
name|this
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
annotation|@
name|GwtIncompatible
comment|// not needed in emulated source
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
end_decl_stmt

unit|}
end_unit

