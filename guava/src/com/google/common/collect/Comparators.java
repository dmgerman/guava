begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2016 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_comment
comment|/**  * Provides static methods for working with {@link Comparator} instances. For many other helpful  * comparator utilities, see either {@code Comparator} itself (for Java 8 or later), or  * {@code com.google.common.collect.Ordering} (otherwise).  *  *<h3>Relationship to {@code Ordering}</h3>  *  *<p>In light of the significant enhancements to {@code Comparator} in Java 8, the overwhelming  * majority of usages of {@code Ordering} can be written using only built-in JDK APIs. Because of  * this, and because it's awkward to have to convert comparators into {@code Ordering} instances,  * {@code Ordering} and its methods are planned for deletion. This class is intended to  * "fill the gap" and provide those features of {@code Ordering} not already provided by the JDK.  *  * @since 21.0  * @author Louis Wasserman  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
DECL|class|Comparators
specifier|public
specifier|final
class|class
name|Comparators
block|{
DECL|method|Comparators ()
specifier|private
name|Comparators
parameter_list|()
block|{}
comment|/**    * Returns a new comparator which sorts iterables by comparing corresponding elements pairwise    * until a nonzero result is found; imposes "dictionary order." If the end of one iterable is    * reached, but not the other, the shorter iterable is considered to be less than the longer one.    * For example, a lexicographical natural ordering over integers considers {@code    * []< [1]< [1, 1]< [1, 2]< [2]}.    *    *<p>Note that {@code Collections.reverseOrder(lexicographical(comparator))} is not    * equivalent to {@code lexicographical(Collections.reverseOrder(comparator))} (consider how each    * would order {@code [1]} and {@code [1, 1]}).    */
comment|// Note: 90% of the time we don't add type parameters or wildcards that serve only to "tweak" the
comment|// desired return type. However, *nested* generics introduce a special class of problems that we
comment|// think tip it over into being worthwhile.
DECL|method|lexicographical (Comparator<T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|S
extends|extends
name|T
parameter_list|>
name|Comparator
argument_list|<
name|Iterable
argument_list|<
name|S
argument_list|>
argument_list|>
name|lexicographical
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|LexicographicalOrdering
argument_list|<
name|S
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if each element in {@code iterable} after the first is greater than or    * equal to the element that preceded it, according to the specified comparator. Note that this    * is always true when the iterable has fewer than two elements.    */
DECL|method|isInOrder (Iterable<? extends T> iterable, Comparator<T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|isInOrder
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|prev
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns {@code true} if each element in {@code iterable} after the first is<i>strictly</i>    * greater than the element that preceded it, according to the specified comparator. Note that    * this is always true when the iterable has fewer than two elements.    */
DECL|method|isInStrictOrder ( Iterable<? extends T> iterable, Comparator<T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|isInStrictOrder
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|,
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|prev
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparator
operator|.
name|compare
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

