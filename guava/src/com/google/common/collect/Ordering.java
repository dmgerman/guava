begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A comparator, with additional methods to support common operations. This is an "enriched" version  * of {@code Comparator} for pre-Java-8 users, in the same sense that {@link FluentIterable} is an  * enriched {@link Iterable} for pre-Java-8 users.  *  *<h3>Three types of methods</h3>  *  * Like other fluent types, there are three types of methods present: methods for<i>acquiring</i>,  *<i>chaining</i>, and<i>using</i>.  *  *<h4>Acquiring</h4>  *  *<p>The common ways to get an instance of {@code Ordering} are:  *  *<ul>  *<li>Subclass it and implement {@link #compare} instead of implementing {@link Comparator}  *       directly  *<li>Pass a<i>pre-existing</i> {@link Comparator} instance to {@link #from(Comparator)}  *<li>Use the natural ordering, {@link Ordering#natural}  *</ul>  *  *<h4>Chaining</h4>  *  *<p>Then you can use the<i>chaining</i> methods to get an altered version of that {@code  * Ordering}, including:  *  *<ul>  *<li>{@link #reverse}  *<li>{@link #compound(Comparator)}  *<li>{@link #onResultOf(Function)}  *<li>{@link #nullsFirst} / {@link #nullsLast}  *</ul>  *  *<h4>Using</h4>  *  *<p>Finally, use the resulting {@code Ordering} anywhere a {@link Comparator} is required, or use  * any of its special operations, such as:  *  *<ul>  *<li>{@link #immutableSortedCopy}  *<li>{@link #isOrdered} / {@link #isStrictlyOrdered}  *<li>{@link #min} / {@link #max}  *</ul>  *  *<h3>Understanding complex orderings</h3>  *  *<p>Complex chained orderings like the following example can be challenging to understand.  *  *<pre>{@code  * Ordering<Foo> ordering =  *     Ordering.natural()  *         .nullsFirst()  *         .onResultOf(getBarFunction)  *         .nullsLast();  * }</pre>  *  * Note that each chaining method returns a new ordering instance which is backed by the previous  * instance, but has the chance to act on values<i>before</i> handing off to that backing instance.  * As a result, it usually helps to read chained ordering expressions<i>backwards</i>. For example,  * when {@code compare} is called on the above ordering:  *  *<ol>  *<li>First, if only one {@code Foo} is null, that null value is treated as<i>greater</i>  *<li>Next, non-null {@code Foo} values are passed to {@code getBarFunction} (we will be  *       comparing {@code Bar} values from now on)  *<li>Next, if only one {@code Bar} is null, that null value is treated as<i>lesser</i>  *<li>Finally, natural ordering is used (i.e. the result of {@code Bar.compareTo(Bar)} is  *       returned)  *</ol>  *  *<p>Alas, {@link #reverse} is a little different. As you read backwards through a chain and  * encounter a call to {@code reverse}, continue working backwards until a result is determined, and  * then reverse that result.  *  *<h3>Additional notes</h3>  *  *<p>Except as noted, the orderings returned by the factory methods of this class are serializable  * if and only if the provided instances that back them are. For example, if {@code ordering} and  * {@code function} can themselves be serialized, then {@code ordering.onResultOf(function)} can as  * well.  *  *<h3>For Java 8 users</h3>  *  *<p>If you are using Java 8, this class is now obsolete. Most of its functionality is now provided  * by {@link java.util.stream.Stream Stream} and by {@link Comparator} itself, and the rest can now  * be found as static methods in our new {@link Comparators} class. See each method below for  * further instructions. Whenever possible, you should change any references of type {@code  * Ordering} to be of type {@code Comparator} instead. However, at this time we have no plan to  *<i>deprecate</i> this class.  *  *<p>Many replacements involve adopting {@code Stream}, and these changes can sometimes make your  * code verbose. Whenever following this advice, you should check whether {@code Stream} could be  * adopted more comprehensively in your code; the end result may be quite a bit simpler.  *  *<h3>See also</h3>  *  *<p>See the Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/OrderingExplained">{@code Ordering}</a>.  *  * @author Jesse Wilson  * @author Kevin Bourrillion  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Ordering
specifier|public
specifier|abstract
class|class
name|Ordering
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparator
argument_list|<
name|T
argument_list|>
block|{
comment|// Natural order
comment|/**    * Returns a serializable ordering that uses the natural order of the values. The ordering throws    * a {@link NullPointerException} when passed a null parameter.    *    *<p>The type specification is {@code<C extends Comparable>}, instead of the technically correct    * {@code<C extends Comparable<? super C>>}, to support legacy types from before Java 5.    *    *<p><b>Java 8 users:</b> use {@link Comparator#naturalOrder} instead.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// TODO(kevinb): right way to explain this??
DECL|method|natural ()
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|>
name|Ordering
argument_list|<
name|C
argument_list|>
name|natural
parameter_list|()
block|{
return|return
operator|(
name|Ordering
argument_list|<
name|C
argument_list|>
operator|)
name|NaturalOrdering
operator|.
name|INSTANCE
return|;
block|}
comment|// Static factories
comment|/**    * Returns an ordering based on an<i>existing</i> comparator instance. Note that it is    * unnecessary to create a<i>new</i> anonymous inner class implementing {@code Comparator} just    * to pass it in here. Instead, simply subclass {@code Ordering} and implement its {@code compare}    * method directly.    *    *<p><b>Java 8 users:</b> this class is now obsolete as explained in the class documentation, so    * there is no need to use this method.    *    * @param comparator the comparator that defines the order    * @return comparator itself if it is already an {@code Ordering}; otherwise an ordering that    *     wraps that comparator    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|from (Comparator<T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|from
parameter_list|(
name|Comparator
argument_list|<
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|(
name|comparator
operator|instanceof
name|Ordering
operator|)
condition|?
operator|(
name|Ordering
argument_list|<
name|T
argument_list|>
operator|)
name|comparator
else|:
operator|new
name|ComparatorOrdering
argument_list|<
name|T
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
annotation|@
name|Deprecated
DECL|method|from (Ordering<T> ordering)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|from
parameter_list|(
name|Ordering
argument_list|<
name|T
argument_list|>
name|ordering
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|ordering
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering that compares objects according to the order in which they appear in the    * given list. Only objects present in the list (according to {@link Object#equals}) may be    * compared. This comparator imposes a "partial ordering" over the type {@code T}. Subsequent    * changes to the {@code valuesInOrder} list will have no effect on the returned comparator. Null    * values in the list are not supported.    *    *<p>The returned comparator throws a {@link ClassCastException} when it receives an input    * parameter that isn't among the provided values.    *    *<p>The generated comparator is serializable if all the provided values are serializable.    *    * @param valuesInOrder the values that the returned comparator will be able to compare, in the    *     order the comparator should induce    * @return the comparator described above    * @throws NullPointerException if any of the provided values is null    * @throws IllegalArgumentException if {@code valuesInOrder} contains any duplicate values    *     (according to {@link Object#equals})    */
comment|// TODO(kevinb): provide replacement
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|explicit (List<T> valuesInOrder)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|explicit
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|valuesInOrder
parameter_list|)
block|{
return|return
operator|new
name|ExplicitOrdering
argument_list|<
name|T
argument_list|>
argument_list|(
name|valuesInOrder
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering that compares objects according to the order in which they are given to    * this method. Only objects present in the argument list (according to {@link Object#equals}) may    * be compared. This comparator imposes a "partial ordering" over the type {@code T}. Null values    * in the argument list are not supported.    *    *<p>The returned comparator throws a {@link ClassCastException} when it receives an input    * parameter that isn't among the provided values.    *    *<p>The generated comparator is serializable if all the provided values are serializable.    *    * @param leastValue the value which the returned comparator should consider the "least" of all    *     values    * @param remainingValuesInOrder the rest of the values that the returned comparator will be able    *     to compare, in the order the comparator should follow    * @return the comparator described above    * @throws NullPointerException if any of the provided values is null    * @throws IllegalArgumentException if any duplicate values (according to {@link    *     Object#equals(Object)}) are present among the method arguments    */
comment|// TODO(kevinb): provide replacement
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|explicit (T leastValue, T... remainingValuesInOrder)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|explicit
parameter_list|(
name|T
name|leastValue
parameter_list|,
name|T
modifier|...
name|remainingValuesInOrder
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|Lists
operator|.
name|asList
argument_list|(
name|leastValue
argument_list|,
name|remainingValuesInOrder
argument_list|)
argument_list|)
return|;
block|}
comment|// Ordering<Object> singletons
comment|/**    * Returns an ordering which treats all values as equal, indicating "no ordering." Passing this    * ordering to any<i>stable</i> sort algorithm results in no change to the order of elements.    * Note especially that {@link #sortedCopy} and {@link #immutableSortedCopy} are stable, and in    * the returned instance these are implemented by simply copying the source list.    *    *<p>Example:    *    *<pre>{@code    * Ordering.allEqual().nullsLast().sortedCopy(    *     asList(t, null, e, s, null, t, null))    * }</pre>    *    *<p>Assuming {@code t}, {@code e} and {@code s} are non-null, this returns {@code [t, e, s, t,    * null, null, null]} regardless of the true comparison order of those three values (which might    * not even implement {@link Comparable} at all).    *    *<p><b>Warning:</b> by definition, this comparator is not<i>consistent with equals</i> (as    * defined {@linkplain Comparator here}). Avoid its use in APIs, such as {@link    * TreeSet#TreeSet(Comparator)}, where such consistency is expected.    *    *<p>The returned comparator is serializable.    *    *<p><b>Java 8 users:</b> Use the lambda expression {@code (a, b) -> 0} instead (in certain cases    * you may need to cast that to {@code Comparator<YourType>}).    *    * @since 13.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|allEqual ()
specifier|public
specifier|static
name|Ordering
argument_list|<
name|Object
argument_list|>
name|allEqual
parameter_list|()
block|{
return|return
name|AllEqualOrdering
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Returns an ordering that compares objects by the natural ordering of their string    * representations as returned by {@code toString()}. It does not support null values.    *    *<p>The comparator is serializable.    *    *<p><b>Java 8 users:</b> Use {@code Comparator.comparing(Object::toString)} instead.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|usingToString ()
specifier|public
specifier|static
name|Ordering
argument_list|<
name|Object
argument_list|>
name|usingToString
parameter_list|()
block|{
return|return
name|UsingToStringOrdering
operator|.
name|INSTANCE
return|;
block|}
comment|/**    * Returns an arbitrary ordering over all objects, for which {@code compare(a, b) == 0} implies    * {@code a == b} (identity equality). There is no meaning whatsoever to the order imposed, but it    * is constant for the life of the VM.    *    *<p>Because the ordering is identity-based, it is not "consistent with {@link    * Object#equals(Object)}" as defined by {@link Comparator}. Use caution when building a {@link    * SortedSet} or {@link SortedMap} from it, as the resulting collection will not behave exactly    * according to spec.    *    *<p>This ordering is not serializable, as its implementation relies on {@link    * System#identityHashCode(Object)}, so its behavior cannot be preserved across serialization.    *    * @since 2.0    */
comment|// TODO(kevinb): copy to Comparators, etc.
DECL|method|arbitrary ()
specifier|public
specifier|static
name|Ordering
argument_list|<
name|Object
argument_list|>
name|arbitrary
parameter_list|()
block|{
return|return
name|ArbitraryOrderingHolder
operator|.
name|ARBITRARY_ORDERING
return|;
block|}
DECL|class|ArbitraryOrderingHolder
specifier|private
specifier|static
class|class
name|ArbitraryOrderingHolder
block|{
DECL|field|ARBITRARY_ORDERING
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Object
argument_list|>
name|ARBITRARY_ORDERING
init|=
operator|new
name|ArbitraryOrdering
argument_list|()
decl_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|class|ArbitraryOrdering
specifier|static
class|class
name|ArbitraryOrdering
extends|extends
name|Ordering
argument_list|<
name|Object
argument_list|>
block|{
DECL|field|counter
specifier|private
specifier|final
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|uids
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|uids
init|=
name|Platform
operator|.
name|tryWeakKeys
argument_list|(
operator|new
name|MapMaker
argument_list|()
argument_list|)
operator|.
name|makeMap
argument_list|()
decl_stmt|;
DECL|method|getUid (Object obj)
specifier|private
name|Integer
name|getUid
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|Integer
name|uid
init|=
name|uids
operator|.
name|get
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|==
literal|null
condition|)
block|{
comment|// One or more integer values could be skipped in the event of a race
comment|// to generate a UID for the same object from multiple threads, but
comment|// that shouldn't be a problem.
name|uid
operator|=
name|counter
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
name|Integer
name|alreadySet
init|=
name|uids
operator|.
name|putIfAbsent
argument_list|(
name|obj
argument_list|,
name|uid
argument_list|)
decl_stmt|;
if|if
condition|(
name|alreadySet
operator|!=
literal|null
condition|)
block|{
name|uid
operator|=
name|alreadySet
expr_stmt|;
block|}
block|}
return|return
name|uid
return|;
block|}
annotation|@
name|Override
DECL|method|compare (Object left, Object right)
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|==
name|right
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
name|int
name|leftCode
init|=
name|identityHashCode
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|int
name|rightCode
init|=
name|identityHashCode
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftCode
operator|!=
name|rightCode
condition|)
block|{
return|return
name|leftCode
operator|<
name|rightCode
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|// identityHashCode collision (rare, but not as rare as you'd think)
name|int
name|result
init|=
name|getUid
argument_list|(
name|left
argument_list|)
operator|.
name|compareTo
argument_list|(
name|getUid
argument_list|(
name|right
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
comment|// extremely, extremely unlikely.
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Ordering.arbitrary()"
return|;
block|}
comment|/*      * We need to be able to mock identityHashCode() calls for tests, because it      * can take 1-10 seconds to find colliding objects. Mocking frameworks that      * can do magic to mock static method calls still can't do so for a system      * class, so we need the indirection. In production, Hotspot should still      * recognize that the call is 1-morphic and should still be willing to      * inline it if necessary.      */
DECL|method|identityHashCode (Object object)
name|int
name|identityHashCode
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|object
argument_list|)
return|;
block|}
block|}
comment|// Constructor
comment|/**    * Constructs a new instance of this class (only invokable by the subclass constructor, typically    * implicit).    */
DECL|method|Ordering ()
specifier|protected
name|Ordering
parameter_list|()
block|{}
comment|// Instance-based factories (and any static equivalents)
comment|/**    * Returns the reverse of this ordering; the {@code Ordering} equivalent to {@link    * Collections#reverseOrder(Comparator)}.    *    *<p><b>Java 8 users:</b> Use {@code thisComparator.reversed()} instead.    */
comment|// type parameter<S> lets us avoid the extra<String> in statements like:
comment|// Ordering<String> o = Ordering.<String>natural().reverse();
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|reverse ()
specifier|public
parameter_list|<
name|S
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|S
argument_list|>
name|reverse
parameter_list|()
block|{
return|return
operator|new
name|ReverseOrdering
argument_list|<
name|S
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering that treats {@code null} as less than all other values and uses {@code    * this} to compare non-null values.    *    *<p><b>Java 8 users:</b> Use {@code Comparator.nullsFirst(thisComparator)} instead.    */
comment|// type parameter<S> lets us avoid the extra<String> in statements like:
comment|// Ordering<String> o = Ordering.<String>natural().nullsFirst();
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|nullsFirst ()
specifier|public
parameter_list|<
name|S
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|S
argument_list|>
name|nullsFirst
parameter_list|()
block|{
return|return
operator|new
name|NullsFirstOrdering
argument_list|<
name|S
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering that treats {@code null} as greater than all other values and uses this    * ordering to compare non-null values.    *    *<p><b>Java 8 users:</b> Use {@code Comparator.nullsLast(thisComparator)} instead.    */
comment|// type parameter<S> lets us avoid the extra<String> in statements like:
comment|// Ordering<String> o = Ordering.<String>natural().nullsLast();
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|nullsLast ()
specifier|public
parameter_list|<
name|S
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|S
argument_list|>
name|nullsLast
parameter_list|()
block|{
return|return
operator|new
name|NullsLastOrdering
argument_list|<
name|S
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns a new ordering on {@code F} which orders elements by first applying a function to them,    * then comparing those results using {@code this}. For example, to compare objects by their    * string forms, in a case-insensitive manner, use:    *    *<pre>{@code    * Ordering.from(String.CASE_INSENSITIVE_ORDER)    *     .onResultOf(Functions.toStringFunction())    * }</pre>    *    *<p><b>Java 8 users:</b> Use {@code Comparator.comparing(function, thisComparator)} instead (you    * can omit the comparator if it is the natural order).    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|onResultOf (Function<F, ? extends T> function)
specifier|public
parameter_list|<
name|F
parameter_list|>
name|Ordering
argument_list|<
name|F
argument_list|>
name|onResultOf
parameter_list|(
name|Function
argument_list|<
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|ByFunctionOrdering
argument_list|<>
argument_list|(
name|function
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|onKeys ()
parameter_list|<
name|T2
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|Entry
argument_list|<
name|T2
argument_list|,
name|?
argument_list|>
argument_list|>
name|onKeys
parameter_list|()
block|{
return|return
name|onResultOf
argument_list|(
name|Maps
operator|.
expr|<
name|T2
operator|>
name|keyFunction
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering which first uses the ordering {@code this}, but which in the event of a    * "tie", then delegates to {@code secondaryComparator}. For example, to sort a bug list first by    * status and second by priority, you might use {@code byStatus.compound(byPriority)}. For a    * compound ordering with three or more components, simply chain multiple calls to this method.    *    *<p>An ordering produced by this method, or a chain of calls to this method, is equivalent to    * one created using {@link Ordering#compound(Iterable)} on the same component comparators.    *    *<p><b>Java 8 users:</b> Use {@code thisComparator.thenComparing(secondaryComparator)} instead.    * Depending on what {@code secondaryComparator} is, one of the other overloads of {@code    * thenComparing} may be even more useful.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|compound (Comparator<? super U> secondaryComparator)
specifier|public
parameter_list|<
name|U
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|U
argument_list|>
name|compound
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|U
argument_list|>
name|secondaryComparator
parameter_list|)
block|{
return|return
operator|new
name|CompoundOrdering
argument_list|<
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|secondaryComparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an ordering which tries each given comparator in order until a non-zero result is    * found, returning that result, and returning zero only if all comparators return zero. The    * returned ordering is based on the state of the {@code comparators} iterable at the time it was    * provided to this method.    *    *<p>The returned ordering is equivalent to that produced using {@code    * Ordering.from(comp1).compound(comp2).compound(comp3) . . .}.    *    *<p><b>Warning:</b> Supplying an argument with undefined iteration order, such as a {@link    * HashSet}, will produce non-deterministic results.    *    *<p><b>Java 8 users:</b> Use a chain of calls to {@link Comparator#thenComparing(Comparator)},    * or {@code comparatorCollection.stream().reduce(Comparator::thenComparing).get()} (if the    * collection might be empty, also provide a default comparator as the {@code identity} parameter    * to {@code reduce}).    *    * @param comparators the comparators to try in order    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|compound (Iterable<? extends Comparator<? super T>> comparators)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|compound
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
argument_list|>
name|comparators
parameter_list|)
block|{
return|return
operator|new
name|CompoundOrdering
argument_list|<
name|T
argument_list|>
argument_list|(
name|comparators
argument_list|)
return|;
block|}
comment|/**    * Returns a new ordering which sorts iterables by comparing corresponding elements pairwise until    * a nonzero result is found; imposes "dictionary order". If the end of one iterable is reached,    * but not the other, the shorter iterable is considered to be less than the longer one. For    * example, a lexicographical natural ordering over integers considers {@code []< [1]< [1, 1]<    * [1, 2]< [2]}.    *    *<p>Note that {@code ordering.lexicographical().reverse()} is not equivalent to {@code    * ordering.reverse().lexicographical()} (consider how each would order {@code [1]} and {@code [1,    * 1]}).    *    *<p><b>Java 8 users:</b> Use {@link Comparators#lexicographical(Comparator)} instead.    *    * @since 2.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
comment|// type parameter<S> lets us avoid the extra<String> in statements like:
comment|// Ordering<Iterable<String>> o =
comment|//     Ordering.<String>natural().lexicographical();
DECL|method|lexicographical ()
specifier|public
parameter_list|<
name|S
extends|extends
name|T
parameter_list|>
name|Ordering
argument_list|<
name|Iterable
argument_list|<
name|S
argument_list|>
argument_list|>
name|lexicographical
parameter_list|()
block|{
comment|/*      * Note that technically the returned ordering should be capable of      * handling not just {@code Iterable<S>} instances, but also any {@code      * Iterable<? extends S>}. However, the need for this comes up so rarely      * that it doesn't justify making everyone else deal with the very ugly      * wildcard.      */
return|return
operator|new
name|LexicographicalOrdering
argument_list|<
name|S
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|// Regular instance methods
comment|// Override to add @Nullable
annotation|@
name|CanIgnoreReturnValue
comment|// TODO(kak): Consider removing this
annotation|@
name|Override
DECL|method|compare (@ullable T left, @Nullable T right)
specifier|public
specifier|abstract
name|int
name|compare
parameter_list|(
annotation|@
name|Nullable
name|T
name|left
parameter_list|,
annotation|@
name|Nullable
name|T
name|right
parameter_list|)
function_decl|;
comment|/**    * Returns the least of the specified values according to this ordering. If there are multiple    * least values, the first of those is returned. The iterator will be left exhausted: its {@code    * hasNext()} method will return {@code false}.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterator).min(thisComparator).get()} instead    * (but note that it does not guarantee which tied minimum element is returned).    *    * @param iterator the iterator whose minimum element is to be determined    * @throws NoSuchElementException if {@code iterator} is empty    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    * @since 11.0    */
DECL|method|min (Iterator<E> iterator)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|min
parameter_list|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|)
block|{
comment|// let this throw NoSuchElementException as necessary
name|E
name|minSoFar
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|minSoFar
operator|=
name|min
argument_list|(
name|minSoFar
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|minSoFar
return|;
block|}
comment|/**    * Returns the least of the specified values according to this ordering. If there are multiple    * least values, the first of those is returned.    *    *<p><b>Java 8 users:</b> If {@code iterable} is a {@link Collection}, use {@code    * Collections.min(collection, thisComparator)} instead. Otherwise, use {@code    * Streams.stream(iterable).min(thisComparator).get()} instead. Note that these alternatives do    * not guarantee which tied minimum element is returned)    *    * @param iterable the iterable whose minimum element is to be determined    * @throws NoSuchElementException if {@code iterable} is empty    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|min (Iterable<E> iterable)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|min
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|min
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the lesser of the two values according to this ordering. If the values compare as 0,    * the first is returned.    *    *<p><b>Implementation note:</b> this method is invoked by the default implementations of the    * other {@code min} overloads, so overriding it will affect their behavior.    *    *<p><b>Note:</b> Consider using {@code Comparators.min(a, b, thisComparator)} instead. If {@code    * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.min(a, b)}.    *    * @param a value to compare, returned if less than or equal to b.    * @param b value to compare.    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|min (@ullable E a, @Nullable E b)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|min
parameter_list|(
annotation|@
name|Nullable
name|E
name|a
parameter_list|,
annotation|@
name|Nullable
name|E
name|b
parameter_list|)
block|{
return|return
operator|(
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<=
literal|0
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/**    * Returns the least of the specified values according to this ordering. If there are multiple    * least values, the first of those is returned.    *    *<p><b>Java 8 users:</b> Use {@code Collections.min(Arrays.asList(a, b, c...), thisComparator)}    * instead (but note that it does not guarantee which tied minimum element is returned).    *    * @param a value to compare, returned if less than or equal to the rest.    * @param b value to compare    * @param c value to compare    * @param rest values to compare    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|min (@ullable E a, @Nullable E b, @Nullable E c, E... rest)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|min
parameter_list|(
annotation|@
name|Nullable
name|E
name|a
parameter_list|,
annotation|@
name|Nullable
name|E
name|b
parameter_list|,
annotation|@
name|Nullable
name|E
name|c
parameter_list|,
name|E
modifier|...
name|rest
parameter_list|)
block|{
name|E
name|minSoFar
init|=
name|min
argument_list|(
name|min
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|r
range|:
name|rest
control|)
block|{
name|minSoFar
operator|=
name|min
argument_list|(
name|minSoFar
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|minSoFar
return|;
block|}
comment|/**    * Returns the greatest of the specified values according to this ordering. If there are multiple    * greatest values, the first of those is returned. The iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterator).max(thisComparator).get()} instead    * (but note that it does not guarantee which tied maximum element is returned).    *    * @param iterator the iterator whose maximum element is to be determined    * @throws NoSuchElementException if {@code iterator} is empty    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    * @since 11.0    */
DECL|method|max (Iterator<E> iterator)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|max
parameter_list|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|)
block|{
comment|// let this throw NoSuchElementException as necessary
name|E
name|maxSoFar
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|maxSoFar
operator|=
name|max
argument_list|(
name|maxSoFar
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|maxSoFar
return|;
block|}
comment|/**    * Returns the greatest of the specified values according to this ordering. If there are multiple    * greatest values, the first of those is returned.    *    *<p><b>Java 8 users:</b> If {@code iterable} is a {@link Collection}, use {@code    * Collections.max(collection, thisComparator)} instead. Otherwise, use {@code    * Streams.stream(iterable).max(thisComparator).get()} instead. Note that these alternatives do    * not guarantee which tied maximum element is returned)    *    * @param iterable the iterable whose maximum element is to be determined    * @throws NoSuchElementException if {@code iterable} is empty    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|max (Iterable<E> iterable)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|max
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|max
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the greater of the two values according to this ordering. If the values compare as 0,    * the first is returned.    *    *<p><b>Implementation note:</b> this method is invoked by the default implementations of the    * other {@code max} overloads, so overriding it will affect their behavior.    *    *<p><b>Note:</b> Consider using {@code Comparators.max(a, b, thisComparator)} instead. If {@code    * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.max(a, b)}.    *    * @param a value to compare, returned if greater than or equal to b.    * @param b value to compare.    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|max (@ullable E a, @Nullable E b)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|max
parameter_list|(
annotation|@
name|Nullable
name|E
name|a
parameter_list|,
annotation|@
name|Nullable
name|E
name|b
parameter_list|)
block|{
return|return
operator|(
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/**    * Returns the greatest of the specified values according to this ordering. If there are multiple    * greatest values, the first of those is returned.    *    *<p><b>Java 8 users:</b> Use {@code Collections.max(Arrays.asList(a, b, c...), thisComparator)}    * instead (but note that it does not guarantee which tied maximum element is returned).    *    * @param a value to compare, returned if greater than or equal to the rest.    * @param b value to compare    * @param c value to compare    * @param rest values to compare    * @throws ClassCastException if the parameters are not<i>mutually comparable</i> under this    *     ordering.    */
DECL|method|max (@ullable E a, @Nullable E b, @Nullable E c, E... rest)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|E
name|max
parameter_list|(
annotation|@
name|Nullable
name|E
name|a
parameter_list|,
annotation|@
name|Nullable
name|E
name|b
parameter_list|,
annotation|@
name|Nullable
name|E
name|c
parameter_list|,
name|E
modifier|...
name|rest
parameter_list|)
block|{
name|E
name|maxSoFar
init|=
name|max
argument_list|(
name|max
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|r
range|:
name|rest
control|)
block|{
name|maxSoFar
operator|=
name|max
argument_list|(
name|maxSoFar
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|maxSoFar
return|;
block|}
comment|/**    * Returns the {@code k} least elements of the given iterable according to this ordering, in order    * from least to greatest. If there are fewer than {@code k} elements present, all will be    * included.    *    *<p>The implementation does not necessarily use a<i>stable</i> sorting algorithm; when multiple    * elements are equivalent, it is undefined which will come first.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterable).collect(Comparators.least(k,    * thisComparator))} instead.    *    * @return an immutable {@code RandomAccess} list of the {@code k} least elements in ascending    *     order    * @throws IllegalArgumentException if {@code k} is negative    * @since 8.0    */
DECL|method|leastOf (Iterable<E> iterable, int k)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|leastOf
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|size
argument_list|()
operator|<=
literal|2L
operator|*
name|k
condition|)
block|{
comment|// In this case, just dumping the collection to an array and sorting is
comment|// faster than using the implementation for Iterator, which is
comment|// specialized for k much smaller than n.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// c only contains E's and doesn't escape
name|E
index|[]
name|array
init|=
operator|(
name|E
index|[]
operator|)
name|collection
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|.
name|length
operator|>
name|k
condition|)
block|{
name|array
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|array
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|leastOf
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|k
argument_list|)
return|;
block|}
comment|/**    * Returns the {@code k} least elements from the given iterator according to this ordering, in    * order from least to greatest. If there are fewer than {@code k} elements present, all will be    * included.    *    *<p>The implementation does not necessarily use a<i>stable</i> sorting algorithm; when multiple    * elements are equivalent, it is undefined which will come first.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterator).collect(Comparators.least(k,    * thisComparator))} instead.    *    * @return an immutable {@code RandomAccess} list of the {@code k} least elements in ascending    *     order    * @throws IllegalArgumentException if {@code k} is negative    * @since 14.0    */
DECL|method|leastOf (Iterator<E> iterator, int k)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|leastOf
parameter_list|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkNonnegative
argument_list|(
name|k
argument_list|,
literal|"k"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|||
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
condition|)
block|{
comment|// k is really large; just do a straightforward sorted-copy-and-sublist
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
name|k
condition|)
block|{
name|list
operator|.
name|subList
argument_list|(
name|k
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|list
operator|.
name|trimToSize
argument_list|()
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|list
argument_list|)
return|;
block|}
else|else
block|{
name|TopKSelector
argument_list|<
name|E
argument_list|>
name|selector
init|=
name|TopKSelector
operator|.
name|least
argument_list|(
name|k
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|selector
operator|.
name|offerAll
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
return|return
name|selector
operator|.
name|topK
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the {@code k} greatest elements of the given iterable according to this ordering, in    * order from greatest to least. If there are fewer than {@code k} elements present, all will be    * included.    *    *<p>The implementation does not necessarily use a<i>stable</i> sorting algorithm; when multiple    * elements are equivalent, it is undefined which will come first.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterable).collect(Comparators.greatest(k,    * thisComparator))} instead.    *    * @return an immutable {@code RandomAccess} list of the {@code k} greatest elements in    *<i>descending order</i>    * @throws IllegalArgumentException if {@code k} is negative    * @since 8.0    */
DECL|method|greatestOf (Iterable<E> iterable, int k)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|greatestOf
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
name|int
name|k
parameter_list|)
block|{
comment|// TODO(kevinb): see if delegation is hurting performance noticeably
comment|// TODO(kevinb): if we change this implementation, add full unit tests.
return|return
name|reverse
argument_list|()
operator|.
name|leastOf
argument_list|(
name|iterable
argument_list|,
name|k
argument_list|)
return|;
block|}
comment|/**    * Returns the {@code k} greatest elements from the given iterator according to this ordering, in    * order from greatest to least. If there are fewer than {@code k} elements present, all will be    * included.    *    *<p>The implementation does not necessarily use a<i>stable</i> sorting algorithm; when multiple    * elements are equivalent, it is undefined which will come first.    *    *<p><b>Java 8 users:</b> Use {@code Streams.stream(iterator).collect(Comparators.greatest(k,    * thisComparator))} instead.    *    * @return an immutable {@code RandomAccess} list of the {@code k} greatest elements in    *<i>descending order</i>    * @throws IllegalArgumentException if {@code k} is negative    * @since 14.0    */
DECL|method|greatestOf (Iterator<E> iterator, int k)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|greatestOf
parameter_list|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|,
name|int
name|k
parameter_list|)
block|{
return|return
name|reverse
argument_list|()
operator|.
name|leastOf
argument_list|(
name|iterator
argument_list|,
name|k
argument_list|)
return|;
block|}
comment|/**    * Returns a<b>mutable</b> list containing {@code elements} sorted by this ordering; use this    * only when the resulting list may need further modification, or may contain {@code null}. The    * input is not modified. The returned list is serializable and has random access.    *    *<p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard elements that are    * duplicates according to the comparator. The sort performed is<i>stable</i>, meaning that such    * elements will appear in the returned list in the same order they appeared in {@code elements}.    *    *<p><b>Performance note:</b> According to our    * benchmarking    * on Open JDK 7, {@link #immutableSortedCopy} generally performs better (in both time and space)    * than this method, and this method in turn generally performs better than copying the list and    * calling {@link Collections#sort(List)}.    */
comment|// TODO(kevinb): rerun benchmarks including new options
DECL|method|sortedCopy (Iterable<E> elements)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|sortedCopy
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// does not escape, and contains only E's
name|E
index|[]
name|array
init|=
operator|(
name|E
index|[]
operator|)
name|Iterables
operator|.
name|toArray
argument_list|(
name|elements
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an<b>immutable</b> list containing {@code elements} sorted by this ordering. The input    * is not modified.    *    *<p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard elements that are    * duplicates according to the comparator. The sort performed is<i>stable</i>, meaning that such    * elements will appear in the returned list in the same order they appeared in {@code elements}.    *    *<p><b>Performance note:</b> According to our    * benchmarking    * on Open JDK 7, this method is the most efficient way to make a sorted copy of a collection.    *    * @throws NullPointerException if any element of {@code elements} is {@code null}    * @since 3.0    */
comment|// TODO(kevinb): rerun benchmarks including new options
DECL|method|immutableSortedCopy (Iterable<E> elements)
specifier|public
parameter_list|<
name|E
extends|extends
name|T
parameter_list|>
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|immutableSortedCopy
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|sortedCopyOf
argument_list|(
name|this
argument_list|,
name|elements
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if each element in {@code iterable} after the first is greater than or    * equal to the element that preceded it, according to this ordering. Note that this is always    * true when the iterable has fewer than two elements.    *    *<p><b>Java 8 users:</b> Use the equivalent {@link Comparators#isInOrder(Iterable, Comparator)}    * instead, since the rest of {@code Ordering} is mostly obsolete (as explained in the class    * documentation).    */
DECL|method|isOrdered (Iterable<? extends T> iterable)
specifier|public
name|boolean
name|isOrdered
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|prev
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns {@code true} if each element in {@code iterable} after the first is<i>strictly</i>    * greater than the element that preceded it, according to this ordering. Note that this is always    * true when the iterable has fewer than two elements.    *    *<p><b>Java 8 users:</b> Use the equivalent {@link Comparators#isInStrictOrder(Iterable,    * Comparator)} instead, since the rest of {@code Ordering} is mostly obsolete (as explained in    * the class documentation).    */
DECL|method|isStrictlyOrdered (Iterable<? extends T> iterable)
specifier|public
name|boolean
name|isStrictlyOrdered
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|prev
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * {@link Collections#binarySearch(List, Object, Comparator) Searches} {@code sortedList} for    * {@code key} using the binary search algorithm. The list must be sorted using this ordering.    *    * @param sortedList the list to be searched    * @param key the key to be searched for    * @deprecated Use {@link Collections#binarySearch(List, Object, Comparator)} directly.    */
annotation|@
name|Deprecated
DECL|method|binarySearch (List<? extends T> sortedList, @Nullable T key)
specifier|public
name|int
name|binarySearch
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|sortedList
parameter_list|,
annotation|@
name|Nullable
name|T
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|binarySearch
argument_list|(
name|sortedList
argument_list|,
name|key
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Exception thrown by a {@link Ordering#explicit(List)} or {@link Ordering#explicit(Object,    * Object[])} comparator when comparing a value outside the set of values it can compare.    * Extending {@link ClassCastException} may seem odd, but it is required.    */
annotation|@
name|VisibleForTesting
DECL|class|IncomparableValueException
specifier|static
class|class
name|IncomparableValueException
extends|extends
name|ClassCastException
block|{
DECL|field|value
specifier|final
name|Object
name|value
decl_stmt|;
DECL|method|IncomparableValueException (Object value)
name|IncomparableValueException
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|super
argument_list|(
literal|"Cannot compare value: "
operator|+
name|value
argument_list|)
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|// Never make these public
DECL|field|LEFT_IS_GREATER
specifier|static
specifier|final
name|int
name|LEFT_IS_GREATER
init|=
literal|1
decl_stmt|;
DECL|field|RIGHT_IS_GREATER
specifier|static
specifier|final
name|int
name|RIGHT_IS_GREATER
init|=
operator|-
literal|1
decl_stmt|;
block|}
end_class

end_unit

