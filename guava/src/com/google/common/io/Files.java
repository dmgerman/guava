begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|MappedByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
operator|.
name|MapMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_comment
comment|/**  * Provides utility methods for working with files.  *  *<p>All method parameters must be non-null unless documented otherwise.  *  * @author Chris Nokleberg  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|Files
specifier|public
specifier|final
class|class
name|Files
block|{
comment|/** Maximum loop count when creating temp directories. */
DECL|field|TEMP_DIR_ATTEMPTS
specifier|private
specifier|static
specifier|final
name|int
name|TEMP_DIR_ATTEMPTS
init|=
literal|10000
decl_stmt|;
DECL|method|Files ()
specifier|private
name|Files
parameter_list|()
block|{}
comment|/**    * Returns a buffered reader that reads from a file using the given    * character set.    *    * @param file the file to read from    * @param charset the character set used when writing the file    * @return the buffered reader    */
DECL|method|newReader (File file, Charset charset)
specifier|public
specifier|static
name|BufferedReader
name|newReader
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a buffered writer that writes to a file using the given    * character set.    *    * @param file the file to write to    * @param charset the character set used when writing the file    * @return the buffered writer    */
DECL|method|newWriter (File file, Charset charset)
specifier|public
specifier|static
name|BufferedWriter
name|newWriter
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a factory that will supply instances of {@link FileInputStream}    * that read from a file.    *    * @param file the file to read from    * @return the factory    */
DECL|method|newInputStreamSupplier ( final File file)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|FileInputStream
argument_list|>
name|newInputStreamSupplier
parameter_list|(
specifier|final
name|File
name|file
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|new
name|InputSupplier
argument_list|<
name|FileInputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileInputStream
name|getInput
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a factory that will supply instances of {@link FileOutputStream}    * that write to a file.    *    * @param file the file to write to    * @return the factory    */
DECL|method|newOutputStreamSupplier ( File file)
specifier|public
specifier|static
name|OutputSupplier
argument_list|<
name|FileOutputStream
argument_list|>
name|newOutputStreamSupplier
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|newOutputStreamSupplier
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a factory that will supply instances of {@link FileOutputStream}    * that write to or append to a file.    *    * @param file the file to write to    * @param append if true, the encoded characters will be appended to the file;    *     otherwise the file is overwritten    * @return the factory    */
DECL|method|newOutputStreamSupplier ( final File file, final boolean append)
specifier|public
specifier|static
name|OutputSupplier
argument_list|<
name|FileOutputStream
argument_list|>
name|newOutputStreamSupplier
parameter_list|(
specifier|final
name|File
name|file
parameter_list|,
specifier|final
name|boolean
name|append
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|new
name|OutputSupplier
argument_list|<
name|FileOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileOutputStream
name|getOutput
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|,
name|append
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a factory that will supply instances of    * {@link InputStreamReader} that read a file using the given character set.    *    * @param file the file to read from    * @param charset the character set used when reading the file    * @return the factory    */
DECL|method|newReaderSupplier (File file, Charset charset)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|InputStreamReader
argument_list|>
name|newReaderSupplier
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
return|return
name|CharStreams
operator|.
name|newReaderSupplier
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|/**    * Returns a factory that will supply instances of {@link OutputStreamWriter}    * that write to a file using the given character set.    *    * @param file the file to write to    * @param charset the character set used when writing the file    * @return the factory    */
DECL|method|newWriterSupplier (File file, Charset charset)
specifier|public
specifier|static
name|OutputSupplier
argument_list|<
name|OutputStreamWriter
argument_list|>
name|newWriterSupplier
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
return|return
name|newWriterSupplier
argument_list|(
name|file
argument_list|,
name|charset
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a factory that will supply instances of {@link OutputStreamWriter}    * that write to or append to a file using the given character set.    *    * @param file the file to write to    * @param charset the character set used when writing the file    * @param append if true, the encoded characters will be appended to the file;    *     otherwise the file is overwritten    * @return the factory    */
DECL|method|newWriterSupplier (File file, Charset charset, boolean append)
specifier|public
specifier|static
name|OutputSupplier
argument_list|<
name|OutputStreamWriter
argument_list|>
name|newWriterSupplier
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|boolean
name|append
parameter_list|)
block|{
return|return
name|CharStreams
operator|.
name|newWriterSupplier
argument_list|(
name|newOutputStreamSupplier
argument_list|(
name|file
argument_list|,
name|append
argument_list|)
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|/**    * Reads all bytes from a file into a byte array.    *    * @param file the file to read from    * @return a byte array containing all the bytes from file    * @throws IllegalArgumentException if the file is bigger than the largest    *     possible byte array (2^31 - 1)    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray (File file)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|length
argument_list|()
operator|<=
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Some special files are length 0 but have content nonetheless.
return|return
name|ByteStreams
operator|.
name|toByteArray
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Avoid an extra allocation and copy.
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|file
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
name|ByteStreams
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
block|}
comment|/**    * Reads all characters from a file into a {@link String}, using the given    * character set.    *    * @param file the file to read from    * @param charset the character set used when reading the file    * @return a string containing all the characters from the file    * @throws IOException if an I/O error occurs    */
DECL|method|toString (File file, Charset charset)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|String
argument_list|(
name|toByteArray
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Copies to a file all bytes from an {@link InputStream} supplied by a    * factory.    *    * @param from the input factory    * @param to the destination file    * @throws IOException if an I/O error occurs    */
DECL|method|copy (InputSupplier<? extends InputStream> from, File to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteStreams
operator|.
name|copy
argument_list|(
name|from
argument_list|,
name|newOutputStreamSupplier
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Overwrites a file with the contents of a byte array.    *    * @param from the bytes to write    * @param to the destination file    * @throws IOException if an I/O error occurs    */
DECL|method|write (byte[] from, File to)
specifier|public
specifier|static
name|void
name|write
parameter_list|(
name|byte
index|[]
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteStreams
operator|.
name|write
argument_list|(
name|from
argument_list|,
name|newOutputStreamSupplier
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all bytes from a file to an {@link OutputStream} supplied by    * a factory.    *    * @param from the source file    * @param to the output factory    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, OutputSupplier<? extends OutputStream> to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|OutputSupplier
argument_list|<
name|?
extends|extends
name|OutputStream
argument_list|>
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteStreams
operator|.
name|copy
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|from
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all bytes from a file to an output stream.    *    * @param from the source file    * @param to the output stream    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, OutputStream to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteStreams
operator|.
name|copy
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|from
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all the bytes from one file to another.    *.    * @param from the source file    * @param to the destination file    * @throws IOException if an I/O error occurs    * @throws IllegalArgumentException if {@code from.equals(to)}    */
DECL|method|copy (File from, File to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
argument_list|,
literal|"Source %s and destination %s must be different"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|from
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies to a file all characters from a {@link Readable} and    * {@link Closeable} object supplied by a factory, using the given    * character set.    *    * @param from the readable supplier    * @param to the destination file    * @param charset the character set used when writing the file    * @throws IOException if an I/O error occurs    */
DECL|method|copy ( InputSupplier<R> from, File to, Charset charset)
specifier|public
specifier|static
parameter_list|<
name|R
extends|extends
name|Readable
operator|&
name|Closeable
parameter_list|>
name|void
name|copy
parameter_list|(
name|InputSupplier
argument_list|<
name|R
argument_list|>
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
name|CharStreams
operator|.
name|copy
argument_list|(
name|from
argument_list|,
name|newWriterSupplier
argument_list|(
name|to
argument_list|,
name|charset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes a character sequence (such as a string) to a file using the given    * character set.    *    * @param from the character sequence to write    * @param to the destination file    * @param charset the character set used when writing the file    * @throws IOException if an I/O error occurs    */
DECL|method|write (CharSequence from, File to, Charset charset)
specifier|public
specifier|static
name|void
name|write
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|charset
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Appends a character sequence (such as a string) to a file using the given    * character set.    *    * @param from the character sequence to append    * @param to the destination file    * @param charset the character set used when writing the file    * @throws IOException if an I/O error occurs    */
DECL|method|append (CharSequence from, File to, Charset charset)
specifier|public
specifier|static
name|void
name|append
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|charset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Private helper method. Writes a character sequence to a file,    * optionally appending.    *    * @param from the character sequence to append    * @param to the destination file    * @param charset the character set used when writing the file    * @param append true to append, false to overwrite    * @throws IOException if an I/O error occurs    */
DECL|method|write (CharSequence from, File to, Charset charset, boolean append)
specifier|private
specifier|static
name|void
name|write
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|boolean
name|append
parameter_list|)
throws|throws
name|IOException
block|{
name|CharStreams
operator|.
name|write
argument_list|(
name|from
argument_list|,
name|newWriterSupplier
argument_list|(
name|to
argument_list|,
name|charset
argument_list|,
name|append
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all characters from a file to a {@link Appendable}&    * {@link Closeable} object supplied by a factory, using the given    * character set.    *    * @param from the source file    * @param charset the character set used when reading the file    * @param to the appendable supplier    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, Charset charset, OutputSupplier<W> to)
specifier|public
specifier|static
parameter_list|<
name|W
extends|extends
name|Appendable
operator|&
name|Closeable
parameter_list|>
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|OutputSupplier
argument_list|<
name|W
argument_list|>
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|CharStreams
operator|.
name|copy
argument_list|(
name|newReaderSupplier
argument_list|(
name|from
argument_list|,
name|charset
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all characters from a file to an appendable object,    * using the given character set.    *    * @param from the source file    * @param charset the character set used when reading the file    * @param to the appendable object    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, Charset charset, Appendable to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|Appendable
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|CharStreams
operator|.
name|copy
argument_list|(
name|newReaderSupplier
argument_list|(
name|from
argument_list|,
name|charset
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the files contains the same bytes.    *    * @throws IOException if an I/O error occurs    */
DECL|method|equal (File file1, File file2)
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
name|File
name|file1
parameter_list|,
name|File
name|file2
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|file1
operator|==
name|file2
operator|||
name|file1
operator|.
name|equals
argument_list|(
name|file2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|/*      * Some operating systems may return zero as the length for files      * denoting system-dependent entities such as devices or pipes, in      * which case we must fall back on comparing the bytes directly.      */
name|long
name|len1
init|=
name|file1
operator|.
name|length
argument_list|()
decl_stmt|;
name|long
name|len2
init|=
name|file2
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
literal|0
operator|&&
name|len2
operator|!=
literal|0
operator|&&
name|len1
operator|!=
name|len2
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ByteStreams
operator|.
name|equal
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file1
argument_list|)
argument_list|,
name|newInputStreamSupplier
argument_list|(
name|file2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Atomically creates a new directory somewhere beneath the system's    * temporary directory (as defined by the {@code java.io.tmpdir} system    * property), and returns its name.    *    *<p>Use this method instead of {@link File#createTempFile(String, String)}    * when you wish to create a directory, not a regular file.  A common pitfall    * is to call {@code createTempFile}, delete the file and create a    * directory in its place, but this leads a race condition which can be    * exploited to create security vulnerabilities, especially when executable    * files are to be written into the directory.    *    *<p>This method assumes that the temporary volume is writable, has free    * inodes and free blocks, and that it will not be called thousands of times    * per second.    *    * @return the newly-created directory    * @throws IllegalStateException if the directory could not be created    */
DECL|method|createTempDir ()
specifier|public
specifier|static
name|File
name|createTempDir
parameter_list|()
block|{
name|File
name|baseDir
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|baseName
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|"-"
decl_stmt|;
for|for
control|(
name|int
name|counter
init|=
literal|0
init|;
name|counter
operator|<
name|TEMP_DIR_ATTEMPTS
condition|;
name|counter
operator|++
control|)
block|{
name|File
name|tempDir
init|=
operator|new
name|File
argument_list|(
name|baseDir
argument_list|,
name|baseName
operator|+
name|counter
argument_list|)
decl_stmt|;
if|if
condition|(
name|tempDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
return|return
name|tempDir
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to create directory within "
operator|+
name|TEMP_DIR_ATTEMPTS
operator|+
literal|" attempts (tried "
operator|+
name|baseName
operator|+
literal|"0 to "
operator|+
name|baseName
operator|+
operator|(
name|TEMP_DIR_ATTEMPTS
operator|-
literal|1
operator|)
operator|+
literal|')'
argument_list|)
throw|;
block|}
comment|/**    * Creates an empty file or updates the last updated timestamp on the    * same as the unix command of the same name.    *    * @param file the file to create or update    * @throws IOException if an I/O error occurs    */
DECL|method|touch (File file)
specifier|public
specifier|static
name|void
name|touch
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|createNewFile
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|setLastModified
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to update modification time of "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates any necessary but nonexistent parent directories of the specified    * file. Note that if this operation fails it may have succeeded in creating    * some (but not all) of the necessary parent directories.    *    * @throws IOException if an I/O error occurs, or if any necessary but    *     nonexistent parent directories of the specified file could not be    *     created.    * @since 4.0    */
DECL|method|createParentDirs (File file)
specifier|public
specifier|static
name|void
name|createParentDirs
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|parent
init|=
name|file
operator|.
name|getCanonicalFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|/*        * The given directory is a filesystem root. All zero of its ancestors        * exist. This doesn't mean that the root itself exists -- consider x:\ on        * a Windows machine without such a drive -- or even that the caller can        * create it, but this method makes no such guarantees even for non-root        * files.        */
return|return;
block|}
name|parent
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to create parent directories of "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
comment|/**    * Moves the file from one path to another. This method can rename a file or    * move it to a different directory, like the Unix {@code mv} command.    *    * @param from the source file    * @param to the destination file    * @throws IOException if an I/O error occurs    * @throws IllegalArgumentException if {@code from.equals(to)}    */
DECL|method|move (File from, File to)
specifier|public
specifier|static
name|void
name|move
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
argument_list|,
literal|"Source %s and destination %s must be different"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|renameTo
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|delete
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|to
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|to
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|from
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Reads the first line from a file. The line does not include    * line-termination characters, but does include other leading and    * trailing whitespace.    *    * @param file the file to read from    * @param charset the character set used when writing the file    * @return the first line, or null if the file is empty    * @throws IOException if an I/O error occurs    */
DECL|method|readFirstLine (File file, Charset charset)
specifier|public
specifier|static
name|String
name|readFirstLine
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|CharStreams
operator|.
name|readFirstLine
argument_list|(
name|Files
operator|.
name|newReaderSupplier
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Reads all of the lines from a file. The lines do not include    * line-termination characters, but do include other leading and    * trailing whitespace.    *    * @param file the file to read from    * @param charset the character set used when writing the file    * @return a mutable {@link List} containing all the lines    * @throws IOException if an I/O error occurs    */
DECL|method|readLines (File file, Charset charset)
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|readLines
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|CharStreams
operator|.
name|readLines
argument_list|(
name|Files
operator|.
name|newReaderSupplier
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Streams lines from a {@link File}, stopping when our callback returns    * false, or we have read all of the lines.    *    * @param file the file to read from    * @param charset the character set used when writing the file    * @param callback the {@link LineProcessor} to use to handle the lines    * @return the output of processing the lines    * @throws IOException if an I/O error occurs    */
DECL|method|readLines (File file, Charset charset, LineProcessor<T> callback)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readLines
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|LineProcessor
argument_list|<
name|T
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|CharStreams
operator|.
name|readLines
argument_list|(
name|Files
operator|.
name|newReaderSupplier
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
argument_list|,
name|callback
argument_list|)
return|;
block|}
comment|/**    * Process the bytes of a file.    *    *<p>(If this seems too complicated, maybe you're looking for    * {@link #toByteArray}.)    *    * @param file the file to read    * @param processor the object to which the bytes of the file are passed.    * @return the result of the byte processor    * @throws IOException if an I/O error occurs    */
DECL|method|readBytes (File file, ByteProcessor<T> processor)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readBytes
parameter_list|(
name|File
name|file
parameter_list|,
name|ByteProcessor
argument_list|<
name|T
argument_list|>
name|processor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ByteStreams
operator|.
name|readBytes
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file
argument_list|)
argument_list|,
name|processor
argument_list|)
return|;
block|}
comment|/**    * Computes and returns the checksum value for a file.    * The checksum object is reset when this method returns successfully.    *    * @param file the file to read    * @param checksum the checksum object    * @return the result of {@link Checksum#getValue} after updating the    *     checksum object with all of the bytes in the file    * @throws IOException if an I/O error occurs    */
DECL|method|getChecksum (File file, Checksum checksum)
specifier|public
specifier|static
name|long
name|getChecksum
parameter_list|(
name|File
name|file
parameter_list|,
name|Checksum
name|checksum
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ByteStreams
operator|.
name|getChecksum
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file
argument_list|)
argument_list|,
name|checksum
argument_list|)
return|;
block|}
comment|/**    * Computes and returns the digest value for a file.    * The digest object is reset when this method returns successfully.    *    * @param file the file to read    * @param md the digest object    * @return the result of {@link MessageDigest#digest()} after updating the    *     digest object with all of the bytes in this file    * @throws IOException if an I/O error occurs    */
DECL|method|getDigest (File file, MessageDigest md)
specifier|public
specifier|static
name|byte
index|[]
name|getDigest
parameter_list|(
name|File
name|file
parameter_list|,
name|MessageDigest
name|md
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ByteStreams
operator|.
name|getDigest
argument_list|(
name|newInputStreamSupplier
argument_list|(
name|file
argument_list|)
argument_list|,
name|md
argument_list|)
return|;
block|}
comment|/**    * Fully maps a file read-only in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.    *    *<p>Files are mapped from offset 0 to its length.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @return a read-only buffer reflecting {@code file}    * @throws FileNotFoundException if the {@code file} does not exist    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|map
argument_list|(
name|file
argument_list|,
name|MapMode
operator|.
name|READ_ONLY
argument_list|)
return|;
block|}
comment|/**    * Fully maps a file in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}    * using the requested {@link MapMode}.    *    *<p>Files are mapped from offset 0 to its length.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @param mode the mode to use when mapping {@code file}    * @return a buffer reflecting {@code file}    * @throws FileNotFoundException if the {@code file} does not exist    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file, MapMode mode)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|,
name|MapMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|map
argument_list|(
name|file
argument_list|,
name|mode
argument_list|,
name|file
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Maps a file in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}    * using the requested {@link MapMode}.    *    *<p>Files are mapped from offset 0 to {@code size}.    *    *<p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist,    * it will be created with the requested {@code size}. Thus this method is    * useful for creating memory mapped files which do not yet exist.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @param mode the mode to use when mapping {@code file}    * @return a buffer reflecting {@code file}    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file, MapMode mode, long size)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|,
name|MapMode
name|mode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
argument_list|,
name|mode
operator|==
name|MapMode
operator|.
name|READ_ONLY
condition|?
literal|"r"
else|:
literal|"rw"
argument_list|)
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
try|try
block|{
name|MappedByteBuffer
name|mbb
init|=
name|map
argument_list|(
name|raf
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|mbb
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|raf
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|map (RandomAccessFile raf, MapMode mode, long size)
specifier|private
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|RandomAccessFile
name|raf
parameter_list|,
name|MapMode
name|mode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|FileChannel
name|channel
init|=
name|raf
operator|.
name|getChannel
argument_list|()
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
try|try
block|{
name|MappedByteBuffer
name|mbb
init|=
name|channel
operator|.
name|map
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|mbb
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|channel
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the lexically cleaned form of the path name,<i>usually</i> (but    * not always) equivalent to the original. The following heuristics are used:    *    *<ul>    *<li>empty string becomes .    *<li>. stays as .    *<li>fold out ./    *<li>fold out ../ when possible    *<li>collapse multiple slashes    *<li>delete trailing slashes (unless the path is just "/")    *</ul>    *    * These heuristics do not always match the behavior of the filesystem. In    * particular, consider the path {@code a/../b}, which {@code simplifyPath}    * will change to {@code b}. If {@code a} is a symlink to {@code x}, {@code    * a/../b} may refer to a sibling of {@code x}, rather than the sibling of    * {@code a} referred to by {@code b}.    *    * @since 11.0    */
DECL|method|simplifyPath (String pathname)
specifier|public
specifier|static
name|String
name|simplifyPath
parameter_list|(
name|String
name|pathname
parameter_list|)
block|{
if|if
condition|(
name|pathname
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|"."
return|;
block|}
comment|// split the path apart
name|Iterable
argument_list|<
name|String
argument_list|>
name|components
init|=
name|Splitter
operator|.
name|on
argument_list|(
literal|'/'
argument_list|)
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// resolve ., .., and //
for|for
control|(
name|String
name|component
range|:
name|components
control|)
block|{
if|if
condition|(
name|component
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|component
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|path
operator|.
name|get
argument_list|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|path
operator|.
name|remove
argument_list|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
block|}
comment|// put it back together
name|String
name|result
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|'/'
argument_list|)
operator|.
name|join
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathname
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|result
operator|=
literal|"/"
operator|+
name|result
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|startsWith
argument_list|(
literal|"/../"
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|substring
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|equals
argument_list|(
literal|"/.."
argument_list|)
condition|)
block|{
name|result
operator|=
literal|"/"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
literal|"."
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the<a href="http://en.wikipedia.org/wiki/Filename_extension">file    * extension</a> for the given file name, or the empty string if the file has    * no extension.  The result does not include the '{@code .}'.    *    * @since 11.0    */
DECL|method|getFileExtension (String fileName)
specifier|public
specifier|static
name|String
name|getFileExtension
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
operator|(
name|dotIndex
operator|==
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
name|fileName
operator|.
name|substring
argument_list|(
name|dotIndex
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
end_class

end_unit

