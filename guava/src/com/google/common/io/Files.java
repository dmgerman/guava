begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|FileWriteMode
operator|.
name|APPEND
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeTraverser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|HashCode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|HashFunction
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|MappedByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
operator|.
name|MapMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Provides utility methods for working with files.  *  *<p>All method parameters must be non-null unless documented otherwise.  *  * @author Chris Nokleberg  * @author Colin Decker  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|Files
specifier|public
specifier|final
class|class
name|Files
block|{
comment|/** Maximum loop count when creating temp directories. */
DECL|field|TEMP_DIR_ATTEMPTS
specifier|private
specifier|static
specifier|final
name|int
name|TEMP_DIR_ATTEMPTS
init|=
literal|10000
decl_stmt|;
DECL|method|Files ()
specifier|private
name|Files
parameter_list|()
block|{}
comment|/**    * Returns a buffered reader that reads from a file using the given character set.    *    * @param file the file to read from    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @return the buffered reader    */
DECL|method|newReader (File file, Charset charset)
specifier|public
specifier|static
name|BufferedReader
name|newReader
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|charset
argument_list|)
expr_stmt|;
return|return
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a buffered writer that writes to a file using the given character set.    *    * @param file the file to write to    * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @return the buffered writer    */
DECL|method|newWriter (File file, Charset charset)
specifier|public
specifier|static
name|BufferedWriter
name|newWriter
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|charset
argument_list|)
expr_stmt|;
return|return
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteSource} for reading bytes from the given file.    *    * @since 14.0    */
DECL|method|asByteSource (File file)
specifier|public
specifier|static
name|ByteSource
name|asByteSource
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
operator|new
name|FileByteSource
argument_list|(
name|file
argument_list|)
return|;
block|}
DECL|class|FileByteSource
specifier|private
specifier|static
specifier|final
class|class
name|FileByteSource
extends|extends
name|ByteSource
block|{
DECL|field|file
specifier|private
specifier|final
name|File
name|file
decl_stmt|;
DECL|method|FileByteSource (File file)
specifier|private
name|FileByteSource
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openStream ()
specifier|public
name|FileInputStream
name|openStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|sizeIfKnown ()
specifier|public
name|Optional
argument_list|<
name|Long
argument_list|>
name|sizeIfKnown
parameter_list|()
block|{
if|if
condition|(
name|file
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|file
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|absent
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|long
name|size
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|file
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|byte
index|[]
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|Closer
name|closer
init|=
name|Closer
operator|.
name|create
argument_list|()
decl_stmt|;
try|try
block|{
name|FileInputStream
name|in
init|=
name|closer
operator|.
name|register
argument_list|(
name|openStream
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|readFile
argument_list|(
name|in
argument_list|,
name|in
operator|.
name|getChannel
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|closer
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Files.asByteSource("
operator|+
name|file
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Reads a file of the given expected size from the given input stream, if it will fit into a byte    * array. This method handles the case where the file size changes between when the size is read    * and when the contents are read from the stream.    */
DECL|method|readFile (InputStream in, long expectedSize)
specifier|static
name|byte
index|[]
name|readFile
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|expectedSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|expectedSize
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
literal|"file is too large to fit in a byte array: "
operator|+
name|expectedSize
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
comment|// some special files may return size 0 but have content, so read
comment|// the file normally in that case
return|return
name|expectedSize
operator|==
literal|0
condition|?
name|ByteStreams
operator|.
name|toByteArray
argument_list|(
name|in
argument_list|)
else|:
name|ByteStreams
operator|.
name|toByteArray
argument_list|(
name|in
argument_list|,
operator|(
name|int
operator|)
name|expectedSize
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}    * control how the file is opened for writing. When no mode is provided, the file will be    * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes    * will append to the end of the file without truncating it.    *    * @since 14.0    */
DECL|method|asByteSink (File file, FileWriteMode... modes)
specifier|public
specifier|static
name|ByteSink
name|asByteSink
parameter_list|(
name|File
name|file
parameter_list|,
name|FileWriteMode
modifier|...
name|modes
parameter_list|)
block|{
return|return
operator|new
name|FileByteSink
argument_list|(
name|file
argument_list|,
name|modes
argument_list|)
return|;
block|}
DECL|class|FileByteSink
specifier|private
specifier|static
specifier|final
class|class
name|FileByteSink
extends|extends
name|ByteSink
block|{
DECL|field|file
specifier|private
specifier|final
name|File
name|file
decl_stmt|;
DECL|field|modes
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|FileWriteMode
argument_list|>
name|modes
decl_stmt|;
DECL|method|FileByteSink (File file, FileWriteMode... modes)
specifier|private
name|FileByteSink
parameter_list|(
name|File
name|file
parameter_list|,
name|FileWriteMode
modifier|...
name|modes
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|this
operator|.
name|modes
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|modes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openStream ()
specifier|public
name|FileOutputStream
name|openStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|,
name|modes
operator|.
name|contains
argument_list|(
name|APPEND
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Files.asByteSink("
operator|+
name|file
operator|+
literal|", "
operator|+
name|modes
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Returns a new {@link CharSource} for reading character data from the given file using the given    * character set.    *    * @since 14.0    */
DECL|method|asCharSource (File file, Charset charset)
specifier|public
specifier|static
name|CharSource
name|asCharSource
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
return|return
name|asByteSource
argument_list|(
name|file
argument_list|)
operator|.
name|asCharSource
argument_list|(
name|charset
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link CharSink} for writing character data to the given file using the given    * character set. The given {@code modes} control how the file is opened for writing. When no mode    * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND    * APPEND} mode is provided, writes will append to the end of the file without truncating it.    *    * @since 14.0    */
DECL|method|asCharSink (File file, Charset charset, FileWriteMode... modes)
specifier|public
specifier|static
name|CharSink
name|asCharSink
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|FileWriteMode
modifier|...
name|modes
parameter_list|)
block|{
return|return
name|asByteSink
argument_list|(
name|file
argument_list|,
name|modes
argument_list|)
operator|.
name|asCharSink
argument_list|(
name|charset
argument_list|)
return|;
block|}
DECL|method|modes (boolean append)
specifier|private
specifier|static
name|FileWriteMode
index|[]
name|modes
parameter_list|(
name|boolean
name|append
parameter_list|)
block|{
return|return
name|append
condition|?
operator|new
name|FileWriteMode
index|[]
block|{
name|FileWriteMode
operator|.
name|APPEND
block|}
else|:
operator|new
name|FileWriteMode
index|[
literal|0
index|]
return|;
block|}
comment|/**    * Reads all bytes from a file into a byte array.    *    * @param file the file to read from    * @return a byte array containing all the bytes from file    * @throws IllegalArgumentException if the file is bigger than the largest possible byte array    *     (2^31 - 1)    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray (File file)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asByteSource
argument_list|(
name|file
argument_list|)
operator|.
name|read
argument_list|()
return|;
block|}
comment|/**    * Reads all characters from a file into a {@link String}, using the given character set.    *    * @param file the file to read from    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @return a string containing all the characters from the file    * @throws IOException if an I/O error occurs    */
DECL|method|toString (File file, Charset charset)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asCharSource
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
operator|.
name|read
argument_list|()
return|;
block|}
comment|/**    * Overwrites a file with the contents of a byte array.    *    * @param from the bytes to write    * @param to the destination file    * @throws IOException if an I/O error occurs    */
DECL|method|write (byte[] from, File to)
specifier|public
specifier|static
name|void
name|write
parameter_list|(
name|byte
index|[]
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|asByteSink
argument_list|(
name|to
argument_list|)
operator|.
name|write
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all bytes from a file to an output stream.    *    * @param from the source file    * @param to the output stream    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, OutputStream to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|asByteSource
argument_list|(
name|from
argument_list|)
operator|.
name|copyTo
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all the bytes from one file to another.    *    *<p>Copying is not an atomic operation - in the case of an I/O error, power loss, process    * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you    * need to guard against those conditions, you should employ other file-level synchronization.    *    *<p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten    * with the contents of {@code from}. If {@code to} and {@code from} refer to the<i>same</i>    * file, the contents of that file will be deleted.    *    * @param from the source file    * @param to the destination file    * @throws IOException if an I/O error occurs    * @throws IllegalArgumentException if {@code from.equals(to)}    */
DECL|method|copy (File from, File to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkArgument
argument_list|(
operator|!
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
argument_list|,
literal|"Source %s and destination %s must be different"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|asByteSource
argument_list|(
name|from
argument_list|)
operator|.
name|copyTo
argument_list|(
name|asByteSink
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes a character sequence (such as a string) to a file using the given character set.    *    * @param from the character sequence to write    * @param to the destination file    * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @throws IOException if an I/O error occurs    */
DECL|method|write (CharSequence from, File to, Charset charset)
specifier|public
specifier|static
name|void
name|write
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
name|asCharSink
argument_list|(
name|to
argument_list|,
name|charset
argument_list|)
operator|.
name|write
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/**    * Appends a character sequence (such as a string) to a file using the given character set.    *    * @param from the character sequence to append    * @param to the destination file    * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @throws IOException if an I/O error occurs    */
DECL|method|append (CharSequence from, File to, Charset charset)
specifier|public
specifier|static
name|void
name|append
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|charset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Private helper method. Writes a character sequence to a file, optionally appending.    *    * @param from the character sequence to append    * @param to the destination file    * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @param append true to append, false to overwrite    * @throws IOException if an I/O error occurs    */
DECL|method|write (CharSequence from, File to, Charset charset, boolean append)
specifier|private
specifier|static
name|void
name|write
parameter_list|(
name|CharSequence
name|from
parameter_list|,
name|File
name|to
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|boolean
name|append
parameter_list|)
throws|throws
name|IOException
block|{
name|asCharSink
argument_list|(
name|to
argument_list|,
name|charset
argument_list|,
name|modes
argument_list|(
name|append
argument_list|)
argument_list|)
operator|.
name|write
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies all characters from a file to an appendable object, using the given character set.    *    * @param from the source file    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @param to the appendable object    * @throws IOException if an I/O error occurs    */
DECL|method|copy (File from, Charset charset, Appendable to)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|File
name|from
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|Appendable
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|asCharSource
argument_list|(
name|from
argument_list|,
name|charset
argument_list|)
operator|.
name|copyTo
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the files contains the same bytes.    *    * @throws IOException if an I/O error occurs    */
DECL|method|equal (File file1, File file2)
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
name|File
name|file1
parameter_list|,
name|File
name|file2
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|file1
operator|==
name|file2
operator|||
name|file1
operator|.
name|equals
argument_list|(
name|file2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|/*      * Some operating systems may return zero as the length for files denoting system-dependent      * entities such as devices or pipes, in which case we must fall back on comparing the bytes      * directly.      */
name|long
name|len1
init|=
name|file1
operator|.
name|length
argument_list|()
decl_stmt|;
name|long
name|len2
init|=
name|file2
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
literal|0
operator|&&
name|len2
operator|!=
literal|0
operator|&&
name|len1
operator|!=
name|len2
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|asByteSource
argument_list|(
name|file1
argument_list|)
operator|.
name|contentEquals
argument_list|(
name|asByteSource
argument_list|(
name|file2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Atomically creates a new directory somewhere beneath the system's temporary directory (as    * defined by the {@code java.io.tmpdir} system property), and returns its name.    *    *<p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to    * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},    * delete the file and create a directory in its place, but this leads a race condition which can    * be exploited to create security vulnerabilities, especially when executable files are to be    * written into the directory.    *    *<p>This method assumes that the temporary volume is writable, has free inodes and free blocks,    * and that it will not be called thousands of times per second.    *    * @return the newly-created directory    * @throws IllegalStateException if the directory could not be created    */
DECL|method|createTempDir ()
specifier|public
specifier|static
name|File
name|createTempDir
parameter_list|()
block|{
name|File
name|baseDir
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|baseName
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|"-"
decl_stmt|;
for|for
control|(
name|int
name|counter
init|=
literal|0
init|;
name|counter
operator|<
name|TEMP_DIR_ATTEMPTS
condition|;
name|counter
operator|++
control|)
block|{
name|File
name|tempDir
init|=
operator|new
name|File
argument_list|(
name|baseDir
argument_list|,
name|baseName
operator|+
name|counter
argument_list|)
decl_stmt|;
if|if
condition|(
name|tempDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
return|return
name|tempDir
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to create directory within "
operator|+
name|TEMP_DIR_ATTEMPTS
operator|+
literal|" attempts (tried "
operator|+
name|baseName
operator|+
literal|"0 to "
operator|+
name|baseName
operator|+
operator|(
name|TEMP_DIR_ATTEMPTS
operator|-
literal|1
operator|)
operator|+
literal|')'
argument_list|)
throw|;
block|}
comment|/**    * Creates an empty file or updates the last updated timestamp on the same as the unix command of    * the same name.    *    * @param file the file to create or update    * @throws IOException if an I/O error occurs    */
DECL|method|touch (File file)
specifier|public
specifier|static
name|void
name|touch
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|createNewFile
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|setLastModified
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to update modification time of "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates any necessary but nonexistent parent directories of the specified file. Note that if    * this operation fails it may have succeeded in creating some (but not all) of the necessary    * parent directories.    *    * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent    *     directories of the specified file could not be created.    * @since 4.0    */
DECL|method|createParentDirs (File file)
specifier|public
specifier|static
name|void
name|createParentDirs
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|File
name|parent
init|=
name|file
operator|.
name|getCanonicalFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|/*        * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't        * mean that the root itself exists -- consider x:\ on a Windows machine without such a drive        * -- or even that the caller can create it, but this method makes no such guarantees even for        * non-root files.        */
return|return;
block|}
name|parent
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to create parent directories of "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
comment|/**    * Moves a file from one path to another. This method can rename a file and/or move it to a    * different directory. In either case {@code to} must be the target path for the file itself; not    * just the new name for the file or the path to the new parent directory.    *    * @param from the source file    * @param to the destination file    * @throws IOException if an I/O error occurs    * @throws IllegalArgumentException if {@code from.equals(to)}    */
DECL|method|move (File from, File to)
specifier|public
specifier|static
name|void
name|move
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
operator|!
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
argument_list|,
literal|"Source %s and destination %s must be different"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|renameTo
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|delete
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|to
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|to
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|from
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Reads the first line from a file. The line does not include line-termination characters, but    * does include other leading and trailing whitespace.    *    * @param file the file to read from    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @return the first line, or null if the file is empty    * @throws IOException if an I/O error occurs    */
DECL|method|readFirstLine (File file, Charset charset)
specifier|public
specifier|static
name|String
name|readFirstLine
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asCharSource
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
operator|.
name|readFirstLine
argument_list|()
return|;
block|}
comment|/**    * Reads all of the lines from a file. The lines do not include line-termination characters, but    * do include other leading and trailing whitespace.    *    *<p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use    * {@code Files.asCharSource(file, charset).readLines()}.    *    * @param file the file to read from    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @return a mutable {@link List} containing all the lines    * @throws IOException if an I/O error occurs    */
DECL|method|readLines (File file, Charset charset)
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|readLines
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// don't use asCharSource(file, charset).readLines() because that returns
comment|// an immutable list, which would change the behavior of this method
return|return
name|readLines
argument_list|(
name|file
argument_list|,
name|charset
argument_list|,
operator|new
name|LineProcessor
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|processLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|result
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Streams lines from a {@link File}, stopping when our callback returns false, or we have read    * all of the lines.    *    * @param file the file to read from    * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for    *     helpful predefined constants    * @param callback the {@link LineProcessor} to use to handle the lines    * @return the output of processing the lines    * @throws IOException if an I/O error occurs    */
annotation|@
name|CanIgnoreReturnValue
comment|// some processors won't return a useful result
DECL|method|readLines (File file, Charset charset, LineProcessor<T> callback)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readLines
parameter_list|(
name|File
name|file
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|LineProcessor
argument_list|<
name|T
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asCharSource
argument_list|(
name|file
argument_list|,
name|charset
argument_list|)
operator|.
name|readLines
argument_list|(
name|callback
argument_list|)
return|;
block|}
comment|/**    * Process the bytes of a file.    *    *<p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)    *    * @param file the file to read    * @param processor the object to which the bytes of the file are passed.    * @return the result of the byte processor    * @throws IOException if an I/O error occurs    */
annotation|@
name|CanIgnoreReturnValue
comment|// some processors won't return a useful result
DECL|method|readBytes (File file, ByteProcessor<T> processor)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readBytes
parameter_list|(
name|File
name|file
parameter_list|,
name|ByteProcessor
argument_list|<
name|T
argument_list|>
name|processor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asByteSource
argument_list|(
name|file
argument_list|)
operator|.
name|read
argument_list|(
name|processor
argument_list|)
return|;
block|}
comment|/**    * Computes the hash code of the {@code file} using {@code hashFunction}.    *    * @param file the file to read    * @param hashFunction the hash function to use to hash the data    * @return the {@link HashCode} of all of the bytes in the file    * @throws IOException if an I/O error occurs    * @since 12.0    */
DECL|method|hash (File file, HashFunction hashFunction)
specifier|public
specifier|static
name|HashCode
name|hash
parameter_list|(
name|File
name|file
parameter_list|,
name|HashFunction
name|hashFunction
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|asByteSource
argument_list|(
name|file
argument_list|)
operator|.
name|hash
argument_list|(
name|hashFunction
argument_list|)
return|;
block|}
comment|/**    * Fully maps a file read-only in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.    *    *<p>Files are mapped from offset 0 to its length.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @return a read-only buffer reflecting {@code file}    * @throws FileNotFoundException if the {@code file} does not exist    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|map
argument_list|(
name|file
argument_list|,
name|MapMode
operator|.
name|READ_ONLY
argument_list|)
return|;
block|}
comment|/**    * Fully maps a file in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested    * {@link MapMode}.    *    *<p>Files are mapped from offset 0 to its length.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @param mode the mode to use when mapping {@code file}    * @return a buffer reflecting {@code file}    * @throws FileNotFoundException if the {@code file} does not exist    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file, MapMode mode)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|,
name|MapMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|map
argument_list|(
name|file
argument_list|,
name|mode
argument_list|,
name|file
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Maps a file in to memory as per    * {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested    * {@link MapMode}.    *    *<p>Files are mapped from offset 0 to {@code size}.    *    *<p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created    * with the requested {@code size}. Thus this method is useful for creating memory mapped files    * which do not yet exist.    *    *<p>This only works for files<= {@link Integer#MAX_VALUE} bytes.    *    * @param file the file to map    * @param mode the mode to use when mapping {@code file}    * @return a buffer reflecting {@code file}    * @throws IOException if an I/O error occurs    *    * @see FileChannel#map(MapMode, long, long)    * @since 2.0    */
DECL|method|map (File file, MapMode mode, long size)
specifier|public
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|File
name|file
parameter_list|,
name|MapMode
name|mode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|Closer
name|closer
init|=
name|Closer
operator|.
name|create
argument_list|()
decl_stmt|;
try|try
block|{
name|RandomAccessFile
name|raf
init|=
name|closer
operator|.
name|register
argument_list|(
operator|new
name|RandomAccessFile
argument_list|(
name|file
argument_list|,
name|mode
operator|==
name|MapMode
operator|.
name|READ_ONLY
condition|?
literal|"r"
else|:
literal|"rw"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|map
argument_list|(
name|raf
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|closer
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|map (RandomAccessFile raf, MapMode mode, long size)
specifier|private
specifier|static
name|MappedByteBuffer
name|map
parameter_list|(
name|RandomAccessFile
name|raf
parameter_list|,
name|MapMode
name|mode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|Closer
name|closer
init|=
name|Closer
operator|.
name|create
argument_list|()
decl_stmt|;
try|try
block|{
name|FileChannel
name|channel
init|=
name|closer
operator|.
name|register
argument_list|(
name|raf
operator|.
name|getChannel
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|channel
operator|.
name|map
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|closer
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the lexically cleaned form of the path name,<i>usually</i> (but not always) equivalent    * to the original. The following heuristics are used:    *    *<ul>    *<li>empty string becomes .    *<li>. stays as .    *<li>fold out ./    *<li>fold out ../ when possible    *<li>collapse multiple slashes    *<li>delete trailing slashes (unless the path is just "/")    *</ul>    *    *<p>These heuristics do not always match the behavior of the filesystem. In particular, consider    * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a    * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the    * sibling of {@code a} referred to by {@code b}.    *    * @since 11.0    */
DECL|method|simplifyPath (String pathname)
specifier|public
specifier|static
name|String
name|simplifyPath
parameter_list|(
name|String
name|pathname
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|"."
return|;
block|}
comment|// split the path apart
name|Iterable
argument_list|<
name|String
argument_list|>
name|components
init|=
name|Splitter
operator|.
name|on
argument_list|(
literal|'/'
argument_list|)
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// resolve ., .., and //
for|for
control|(
name|String
name|component
range|:
name|components
control|)
block|{
if|if
condition|(
name|component
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|component
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|path
operator|.
name|get
argument_list|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|path
operator|.
name|remove
argument_list|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
block|}
comment|// put it back together
name|String
name|result
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|'/'
argument_list|)
operator|.
name|join
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathname
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|result
operator|=
literal|"/"
operator|+
name|result
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|startsWith
argument_list|(
literal|"/../"
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|substring
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|equals
argument_list|(
literal|"/.."
argument_list|)
condition|)
block|{
name|result
operator|=
literal|"/"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
literal|"."
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the<a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> for    * the given file name, or the empty string if the file has no extension. The result does not    * include the '{@code .}'.    *    * @since 11.0    */
DECL|method|getFileExtension (String fullName)
specifier|public
specifier|static
name|String
name|getFileExtension
parameter_list|(
name|String
name|fullName
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
name|String
name|fileName
init|=
operator|new
name|File
argument_list|(
name|fullName
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
operator|(
name|dotIndex
operator|==
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
name|fileName
operator|.
name|substring
argument_list|(
name|dotIndex
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**    * Returns the file name without its    *<a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> or path. This is    * similar to the {@code basename} unix command. The result does not include the '{@code .}'.    *    * @param file The name of the file to trim the extension from. This can be either a fully    *     qualified file name (including a path) or just a file name.    * @return The file name without its path or extension.    * @since 14.0    */
DECL|method|getNameWithoutExtension (String file)
specifier|public
specifier|static
name|String
name|getNameWithoutExtension
parameter_list|(
name|String
name|file
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|String
name|fileName
init|=
operator|new
name|File
argument_list|(
name|file
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
operator|(
name|dotIndex
operator|==
operator|-
literal|1
operator|)
condition|?
name|fileName
else|:
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotIndex
argument_list|)
return|;
block|}
comment|/**    * Returns a {@link TreeTraverser} instance for {@link File} trees.    *    *<p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no    * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In    * this case, iterables created by this traverser could contain files that are outside of the    * given directory or even be infinite if there is a symbolic link loop.    *    * @since 15.0    */
DECL|method|fileTreeTraverser ()
specifier|public
specifier|static
name|TreeTraverser
argument_list|<
name|File
argument_list|>
name|fileTreeTraverser
parameter_list|()
block|{
return|return
name|FILE_TREE_TRAVERSER
return|;
block|}
DECL|field|FILE_TREE_TRAVERSER
specifier|private
specifier|static
specifier|final
name|TreeTraverser
argument_list|<
name|File
argument_list|>
name|FILE_TREE_TRAVERSER
init|=
operator|new
name|TreeTraverser
argument_list|<
name|File
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|File
argument_list|>
name|children
parameter_list|(
name|File
name|file
parameter_list|)
block|{
comment|// check isDirectory() just because it may be faster than listFiles() on a non-directory
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|File
index|[]
name|files
init|=
name|file
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|files
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Files.fileTreeTraverser()"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns a predicate that returns the result of {@link File#isDirectory} on input files.    *    * @since 15.0    */
DECL|method|isDirectory ()
specifier|public
specifier|static
name|Predicate
argument_list|<
name|File
argument_list|>
name|isDirectory
parameter_list|()
block|{
return|return
name|FilePredicate
operator|.
name|IS_DIRECTORY
return|;
block|}
comment|/**    * Returns a predicate that returns the result of {@link File#isFile} on input files.    *    * @since 15.0    */
DECL|method|isFile ()
specifier|public
specifier|static
name|Predicate
argument_list|<
name|File
argument_list|>
name|isFile
parameter_list|()
block|{
return|return
name|FilePredicate
operator|.
name|IS_FILE
return|;
block|}
DECL|enum|FilePredicate
specifier|private
enum|enum
name|FilePredicate
implements|implements
name|Predicate
argument_list|<
name|File
argument_list|>
block|{
DECL|enumConstant|IS_DIRECTORY
name|IS_DIRECTORY
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|file
operator|.
name|isDirectory
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Files.isDirectory()"
return|;
block|}
block|}
block|,
DECL|enumConstant|IS_FILE
name|IS_FILE
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|file
operator|.
name|isFile
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Files.isFile()"
return|;
block|}
block|}
block|;   }
block|}
end_class

end_unit

