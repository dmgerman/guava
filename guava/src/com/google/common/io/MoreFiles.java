begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|getOnlyElement
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|LinkOption
operator|.
name|NOFOLLOW_LINKS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|graph
operator|.
name|SuccessorsFunction
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|graph
operator|.
name|Traverser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|j2objc
operator|.
name|annotations
operator|.
name|J2ObjCIncompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Channels
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SeekableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryIteratorException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystemException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|LinkOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NotDirectoryException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|OpenOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|SecureDirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|BasicFileAttributeView
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|BasicFileAttributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|FileAttribute
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|FileTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utilities for use with {@link Path} instances, intended to complement {@link Files}.  *  *<p>Many methods provided by Guava's {@code Files} class for {@link java.io.File} instances are  * now available via the JDK's {@link java.nio.file.Files} class for {@code Path} - check the JDK's  * class if a sibling method from {@code Files} appears to be missing from this class.  *  * @since 21.0  * @author Colin Decker  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
annotation|@
name|J2ObjCIncompatible
comment|// java.nio.file
DECL|class|MoreFiles
specifier|public
specifier|final
class|class
name|MoreFiles
block|{
DECL|method|MoreFiles ()
specifier|private
name|MoreFiles
parameter_list|()
block|{}
comment|/**    * Returns a view of the given {@code path} as a {@link ByteSource}.    *    *<p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file    * and may affect the behavior of the returned source and the streams it provides. See {@link    * StandardOpenOption} for the standard options that may be provided. Providing no options is    * equivalent to providing the {@link StandardOpenOption#READ READ} option.    */
DECL|method|asByteSource (Path path, OpenOption... options)
specifier|public
specifier|static
name|ByteSource
name|asByteSource
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
return|return
operator|new
name|PathByteSource
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
return|;
block|}
DECL|class|PathByteSource
specifier|private
specifier|static
specifier|final
class|class
name|PathByteSource
extends|extends
name|ByteSource
block|{
DECL|field|FOLLOW_LINKS
specifier|private
specifier|static
specifier|final
name|LinkOption
index|[]
name|FOLLOW_LINKS
init|=
block|{}
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
DECL|field|options
specifier|private
specifier|final
name|OpenOption
index|[]
name|options
decl_stmt|;
DECL|field|followLinks
specifier|private
specifier|final
name|boolean
name|followLinks
decl_stmt|;
DECL|method|PathByteSource (Path path, OpenOption... options)
specifier|private
name|PathByteSource
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|followLinks
operator|=
name|followLinks
argument_list|(
name|this
operator|.
name|options
argument_list|)
expr_stmt|;
comment|// TODO(cgdecker): validate the provided options... for example, just WRITE seems wrong
block|}
DECL|method|followLinks (OpenOption[] options)
specifier|private
specifier|static
name|boolean
name|followLinks
parameter_list|(
name|OpenOption
index|[]
name|options
parameter_list|)
block|{
for|for
control|(
name|OpenOption
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|==
name|NOFOLLOW_LINKS
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|openStream ()
specifier|public
name|InputStream
name|openStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|newInputStream
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
return|;
block|}
DECL|method|readAttributes ()
specifier|private
name|BasicFileAttributes
name|readAttributes
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|readAttributes
argument_list|(
name|path
argument_list|,
name|BasicFileAttributes
operator|.
name|class
argument_list|,
name|followLinks
condition|?
name|FOLLOW_LINKS
else|:
operator|new
name|LinkOption
index|[]
block|{
name|NOFOLLOW_LINKS
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|sizeIfKnown ()
specifier|public
name|Optional
argument_list|<
name|Long
argument_list|>
name|sizeIfKnown
parameter_list|()
block|{
name|BasicFileAttributes
name|attrs
decl_stmt|;
try|try
block|{
name|attrs
operator|=
name|readAttributes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Failed to get attributes; we don't know the size.
return|return
name|Optional
operator|.
name|absent
argument_list|()
return|;
block|}
comment|// Don't return a size for directories or symbolic links; their sizes are implementation
comment|// specific and they can't be read as bytes using the read methods anyway.
if|if
condition|(
name|attrs
operator|.
name|isDirectory
argument_list|()
operator|||
name|attrs
operator|.
name|isSymbolicLink
argument_list|()
condition|)
block|{
return|return
name|Optional
operator|.
name|absent
argument_list|()
return|;
block|}
return|return
name|Optional
operator|.
name|of
argument_list|(
name|attrs
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|long
name|size
parameter_list|()
throws|throws
name|IOException
block|{
name|BasicFileAttributes
name|attrs
init|=
name|readAttributes
argument_list|()
decl_stmt|;
comment|// Don't return a size for directories or symbolic links; their sizes are implementation
comment|// specific and they can't be read as bytes using the read methods anyway.
if|if
condition|(
name|attrs
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"can't read: is a directory"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|attrs
operator|.
name|isSymbolicLink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"can't read: is a symbolic link"
argument_list|)
throw|;
block|}
return|return
name|attrs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|byte
index|[]
name|read
parameter_list|()
throws|throws
name|IOException
block|{
try|try
init|(
name|SeekableByteChannel
name|channel
init|=
name|Files
operator|.
name|newByteChannel
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
init|)
block|{
return|return
name|ByteStreams
operator|.
name|toByteArray
argument_list|(
name|Channels
operator|.
name|newInputStream
argument_list|(
name|channel
argument_list|)
argument_list|,
name|channel
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|asCharSource (Charset charset)
specifier|public
name|CharSource
name|asCharSource
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
if|if
condition|(
name|options
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// If no OpenOptions were passed, delegate to Files.lines, which could have performance
comment|// advantages. (If OpenOptions were passed we can't, because Files.lines doesn't have an
comment|// overload taking OpenOptions, meaning we can't guarantee the same behavior w.r.t. things
comment|// like following/not following symlinks.
return|return
operator|new
name|AsCharSource
argument_list|(
name|charset
argument_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FilesLinesLeak"
argument_list|)
comment|// the user needs to close it in this case
annotation|@
name|Override
specifier|public
name|Stream
argument_list|<
name|String
argument_list|>
name|lines
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|lines
argument_list|(
name|path
argument_list|,
name|charset
argument_list|)
return|;
block|}
block|}
return|;
block|}
return|return
name|super
operator|.
name|asCharSource
argument_list|(
name|charset
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"MoreFiles.asByteSource("
operator|+
name|path
operator|+
literal|", "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Returns a view of the given {@code path} as a {@link ByteSink}.    *    *<p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file    * and may affect the behavior of the returned sink and the streams it provides. See {@link    * StandardOpenOption} for the standard options that may be provided. Providing no options is    * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link    * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE    * WRITE} options.    */
DECL|method|asByteSink (Path path, OpenOption... options)
specifier|public
specifier|static
name|ByteSink
name|asByteSink
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
return|return
operator|new
name|PathByteSink
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
return|;
block|}
DECL|class|PathByteSink
specifier|private
specifier|static
specifier|final
class|class
name|PathByteSink
extends|extends
name|ByteSink
block|{
DECL|field|path
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
DECL|field|options
specifier|private
specifier|final
name|OpenOption
index|[]
name|options
decl_stmt|;
DECL|method|PathByteSink (Path path, OpenOption... options)
specifier|private
name|PathByteSink
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// TODO(cgdecker): validate the provided options... for example, just READ seems wrong
block|}
annotation|@
name|Override
DECL|method|openStream ()
specifier|public
name|OutputStream
name|openStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|newOutputStream
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"MoreFiles.asByteSink("
operator|+
name|path
operator|+
literal|", "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Returns a view of the given {@code path} as a {@link CharSource} using the given {@code    * charset}.    *    *<p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file    * and may affect the behavior of the returned source and the streams it provides. See {@link    * StandardOpenOption} for the standard options that may be provided. Providing no options is    * equivalent to providing the {@link StandardOpenOption#READ READ} option.    */
DECL|method|asCharSource (Path path, Charset charset, OpenOption... options)
specifier|public
specifier|static
name|CharSource
name|asCharSource
parameter_list|(
name|Path
name|path
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
return|return
name|asByteSource
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
operator|.
name|asCharSource
argument_list|(
name|charset
argument_list|)
return|;
block|}
comment|/**    * Returns a view of the given {@code path} as a {@link CharSink} using the given {@code charset}.    *    *<p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file    * and may affect the behavior of the returned sink and the streams it provides. See {@link    * StandardOpenOption} for the standard options that may be provided. Providing no options is    * equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link    * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE    * WRITE} options.    */
DECL|method|asCharSink (Path path, Charset charset, OpenOption... options)
specifier|public
specifier|static
name|CharSink
name|asCharSink
parameter_list|(
name|Path
name|path
parameter_list|,
name|Charset
name|charset
parameter_list|,
name|OpenOption
modifier|...
name|options
parameter_list|)
block|{
return|return
name|asByteSink
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
operator|.
name|asCharSink
argument_list|(
name|charset
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable list of paths to the files contained in the given directory.    *    * @throws NoSuchFileException if the file does not exist<i>(optional specific exception)</i>    * @throws NotDirectoryException if the file could not be opened because it is not a directory    *<i>(optional specific exception)</i>    * @throws IOException if an I/O error occurs    */
DECL|method|listFiles (Path dir)
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|Path
argument_list|>
name|listFiles
parameter_list|(
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|dir
argument_list|)
init|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|stream
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DirectoryIteratorException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
block|}
comment|/**    * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser    * starts from a {@link Path} and will return all files and directories it encounters.    *    *<p>The returned traverser attempts to avoid following symbolic links to directories. However,    * the traverser cannot guarantee that it will not follow symbolic links to directories as it is    * possible for a directory to be replaced with a symbolic link between checking if the file is a    * directory and actually reading the contents of that directory.    *    *<p>If the {@link Path} passed to one of the traversal methods does not exist or is not a    * directory, no exception will be thrown and the returned {@link Iterable} will contain a single    * element: that path.    *    *<p>{@link DirectoryIteratorException} may be thrown when iterating {@link Iterable} instances    * created by this traverser if an {@link IOException} is thrown by a call to {@link    * #listFiles(Path)}.    *    *<p>Example: {@code MoreFiles.fileTraverser().depthFirstPreOrder(Paths.get("/"))} may return the    * following paths: {@code ["/", "/etc", "/etc/config.txt", "/etc/fonts", "/home", "/home/alice",    * ...]}    *    * @since 23.5    */
DECL|method|fileTraverser ()
specifier|public
specifier|static
name|Traverser
argument_list|<
name|Path
argument_list|>
name|fileTraverser
parameter_list|()
block|{
return|return
name|Traverser
operator|.
name|forTree
argument_list|(
name|FILE_TREE
argument_list|)
return|;
block|}
DECL|field|FILE_TREE
specifier|private
specifier|static
specifier|final
name|SuccessorsFunction
argument_list|<
name|Path
argument_list|>
name|FILE_TREE
init|=
operator|new
name|SuccessorsFunction
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|Path
argument_list|>
name|successors
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|fileTreeChildren
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|method|fileTreeChildren (Path dir)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|Path
argument_list|>
name|fileTreeChildren
parameter_list|(
name|Path
name|dir
parameter_list|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|dir
argument_list|,
name|NOFOLLOW_LINKS
argument_list|)
condition|)
block|{
try|try
block|{
return|return
name|listFiles
argument_list|(
name|dir
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// the exception thrown when iterating a DirectoryStream if an I/O exception occurs
throw|throw
operator|new
name|DirectoryIteratorException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|/**    * Returns a predicate that returns the result of {@link java.nio.file.Files#isDirectory(Path,    * LinkOption...)} on input paths with the given link options.    */
DECL|method|isDirectory (LinkOption... options)
specifier|public
specifier|static
name|Predicate
argument_list|<
name|Path
argument_list|>
name|isDirectory
parameter_list|(
name|LinkOption
modifier|...
name|options
parameter_list|)
block|{
specifier|final
name|LinkOption
index|[]
name|optionsCopy
init|=
name|options
operator|.
name|clone
argument_list|()
decl_stmt|;
return|return
operator|new
name|Predicate
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Path
name|input
parameter_list|)
block|{
return|return
name|Files
operator|.
name|isDirectory
argument_list|(
name|input
argument_list|,
name|optionsCopy
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"MoreFiles.isDirectory("
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|optionsCopy
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
return|;
block|}
comment|/** Returns whether or not the file with the given name in the given dir is a directory. */
DECL|method|isDirectory ( SecureDirectoryStream<Path> dir, Path name, LinkOption... options)
specifier|private
specifier|static
name|boolean
name|isDirectory
parameter_list|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
name|dir
parameter_list|,
name|Path
name|name
parameter_list|,
name|LinkOption
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dir
operator|.
name|getFileAttributeView
argument_list|(
name|name
argument_list|,
name|BasicFileAttributeView
operator|.
name|class
argument_list|,
name|options
argument_list|)
operator|.
name|readAttributes
argument_list|()
operator|.
name|isDirectory
argument_list|()
return|;
block|}
comment|/**    * Returns a predicate that returns the result of {@link java.nio.file.Files#isRegularFile(Path,    * LinkOption...)} on input paths with the given link options.    */
DECL|method|isRegularFile (LinkOption... options)
specifier|public
specifier|static
name|Predicate
argument_list|<
name|Path
argument_list|>
name|isRegularFile
parameter_list|(
name|LinkOption
modifier|...
name|options
parameter_list|)
block|{
specifier|final
name|LinkOption
index|[]
name|optionsCopy
init|=
name|options
operator|.
name|clone
argument_list|()
decl_stmt|;
return|return
operator|new
name|Predicate
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Path
name|input
parameter_list|)
block|{
return|return
name|Files
operator|.
name|isRegularFile
argument_list|(
name|input
argument_list|,
name|optionsCopy
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"MoreFiles.isRegularFile("
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|optionsCopy
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns true if the files located by the given paths exist, are not directories, and contain    * the same bytes.    *    * @throws IOException if an I/O error occurs    * @since 22.0    */
DECL|method|equal (Path path1, Path path2)
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
name|Path
name|path1
parameter_list|,
name|Path
name|path2
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|path1
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|Files
operator|.
name|isSameFile
argument_list|(
name|path1
argument_list|,
name|path2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|/*      * Some operating systems may return zero as the length for files denoting system-dependent      * entities such as devices or pipes, in which case we must fall back on comparing the bytes      * directly.      */
name|ByteSource
name|source1
init|=
name|asByteSource
argument_list|(
name|path1
argument_list|)
decl_stmt|;
name|ByteSource
name|source2
init|=
name|asByteSource
argument_list|(
name|path2
argument_list|)
decl_stmt|;
name|long
name|len1
init|=
name|source1
operator|.
name|sizeIfKnown
argument_list|()
operator|.
name|or
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
name|long
name|len2
init|=
name|source2
operator|.
name|sizeIfKnown
argument_list|()
operator|.
name|or
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
literal|0
operator|&&
name|len2
operator|!=
literal|0
operator|&&
name|len1
operator|!=
name|len2
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|source1
operator|.
name|contentEquals
argument_list|(
name|source2
argument_list|)
return|;
block|}
comment|/**    * Like the unix command of the same name, creates an empty file or updates the last modified    * timestamp of the existing file at the given path to the current system time.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GoodTime"
argument_list|)
comment|// reading system time without TimeSource
DECL|method|touch (Path path)
specifier|public
specifier|static
name|void
name|touch
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
try|try
block|{
name|Files
operator|.
name|setLastModifiedTime
argument_list|(
name|path
argument_list|,
name|FileTime
operator|.
name|fromMillis
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|e
parameter_list|)
block|{
try|try
block|{
name|Files
operator|.
name|createFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|ignore
parameter_list|)
block|{
comment|// The file didn't exist when we called setLastModifiedTime, but it did when we called
comment|// createFile, so something else created the file in between. The end result is
comment|// what we wanted: a new file that probably has its last modified time set to approximately
comment|// now. Or it could have an arbitrary last modified time set by the creator, but that's no
comment|// different than if another process set its last modified time to something else after we
comment|// created it here.
block|}
block|}
block|}
comment|/**    * Creates any necessary but nonexistent parent directories of the specified path. Note that if    * this operation fails, it may have succeeded in creating some (but not all) of the necessary    * parent directories. The parent directory is created with the given {@code attrs}.    *    * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent    *     directories of the specified file could not be created.    */
DECL|method|createParentDirectories (Path path, FileAttribute<?>... attrs)
specifier|public
specifier|static
name|void
name|createParentDirectories
parameter_list|(
name|Path
name|path
parameter_list|,
name|FileAttribute
argument_list|<
name|?
argument_list|>
modifier|...
name|attrs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Interestingly, unlike File.getCanonicalFile(), Path/Files provides no way of getting the
comment|// canonical (absolute, normalized, symlinks resolved, etc.) form of a path to a nonexistent
comment|// file. getCanonicalFile() can at least get the canonical form of the part of the path which
comment|// actually exists and then append the normalized remainder of the path to that.
name|Path
name|normalizedAbsolutePath
init|=
name|path
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|normalize
argument_list|()
decl_stmt|;
name|Path
name|parent
init|=
name|normalizedAbsolutePath
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// The given directory is a filesystem root. All zero of its ancestors exist. This doesn't
comment|// mean that the root itself exists -- consider x:\ on a Windows machine without such a
comment|// drive -- or even that the caller can create it, but this method makes no such guarantees
comment|// even for non-root files.
return|return;
block|}
comment|// Check if the parent is a directory first because createDirectories will fail if the parent
comment|// exists and is a symlink to a directory... we'd like for this to succeed in that case.
comment|// (I'm kind of surprised that createDirectories would fail in that case; doesn't seem like
comment|// what you'd want to happen.)
if|if
condition|(
operator|!
name|Files
operator|.
name|isDirectory
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|Files
operator|.
name|createDirectories
argument_list|(
name|parent
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Files
operator|.
name|isDirectory
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to create parent directories of "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Returns the<a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> for    * the file at the given path, or the empty string if the file has no extension. The result does    * not include the '{@code .}'.    *    *<p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's    * name as determined by {@link Path#getFileName}. It does not account for any filesystem-specific    * behavior that the {@link Path} API does not already account for. For example, on NTFS it will    * report {@code "txt"} as the extension for the filename {@code "foo.exe:.txt"} even though NTFS    * will drop the {@code ":.txt"} part of the name when the file is actually created on the    * filesystem due to NTFS's<a href="https://goo.gl/vTpJi4">Alternate Data Streams</a>.    */
DECL|method|getFileExtension (Path path)
specifier|public
specifier|static
name|String
name|getFileExtension
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|Path
name|name
init|=
name|path
operator|.
name|getFileName
argument_list|()
decl_stmt|;
comment|// null for empty paths and root-only paths
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|String
name|fileName
init|=
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
name|dotIndex
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
name|fileName
operator|.
name|substring
argument_list|(
name|dotIndex
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**    * Returns the file name without its<a    * href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> or path. This is    * similar to the {@code basename} unix command. The result does not include the '{@code .}'.    */
DECL|method|getNameWithoutExtension (Path path)
specifier|public
specifier|static
name|String
name|getNameWithoutExtension
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|Path
name|name
init|=
name|path
operator|.
name|getFileName
argument_list|()
decl_stmt|;
comment|// null for empty paths and root-only paths
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|String
name|fileName
init|=
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
return|return
name|dotIndex
operator|==
operator|-
literal|1
condition|?
name|fileName
else|:
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotIndex
argument_list|)
return|;
block|}
comment|/**    * Deletes the file or directory at the given {@code path} recursively. Deletes symbolic links,    * not their targets (subject to the caveat below).    *    *<p>If an I/O exception occurs attempting to read, open or delete any file under the given    * directory, this method skips that file and continues. All such exceptions are collected and,    * after attempting to delete all files, an {@code IOException} is thrown containing those    * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.    *    *<h2>Warning: Security of recursive deletes</h2>    *    *<p>On a file system that supports symbolic links and does<i>not</i> support {@link    * SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories    * that are<i>outside</i> the directory being deleted. This can happen if, after checking that a    * file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to    * an outside directory before the call that opens the directory to read its entries.    *    *<p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't    * guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,    * pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.    *    * @throws NoSuchFileException if {@code path} does not exist<i>(optional specific exception)</i>    * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be    *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not    *     specified    * @throws IOException if {@code path} or any file in the subtree rooted at it can't be deleted    *     for any reason    */
DECL|method|deleteRecursively (Path path, RecursiveDeleteOption... options)
specifier|public
specifier|static
name|void
name|deleteRecursively
parameter_list|(
name|Path
name|path
parameter_list|,
name|RecursiveDeleteOption
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|parentPath
init|=
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentPath
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileSystemException
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|"can't delete recursively"
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
comment|// created lazily if needed
try|try
block|{
name|boolean
name|sdsSupported
init|=
literal|false
decl_stmt|;
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|parent
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|parentPath
argument_list|)
init|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|SecureDirectoryStream
condition|)
block|{
name|sdsSupported
operator|=
literal|true
expr_stmt|;
name|exceptions
operator|=
name|deleteRecursivelySecure
argument_list|(
operator|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
operator|)
name|parent
argument_list|,
name|path
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sdsSupported
condition|)
block|{
name|checkAllowsInsecure
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|exceptions
operator|=
name|deleteRecursivelyInsecure
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exceptions
operator|!=
literal|null
condition|)
block|{
name|throwDeleteFailed
argument_list|(
name|path
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes all files within the directory at the given {@code path} {@linkplain #deleteRecursively    * recursively}. Does not delete the directory itself. Deletes symbolic links, not their targets    * (subject to the caveat below). If {@code path} itself is a symbolic link to a directory, that    * link is followed and the contents of the directory it targets are deleted.    *    *<p>If an I/O exception occurs attempting to read, open or delete any file under the given    * directory, this method skips that file and continues. All such exceptions are collected and,    * after attempting to delete all files, an {@code IOException} is thrown containing those    * exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.    *    *<h2>Warning: Security of recursive deletes</h2>    *    *<p>On a file system that supports symbolic links and does<i>not</i> support {@link    * SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories    * that are<i>outside</i> the directory being deleted. This can happen if, after checking that a    * file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to    * an outside directory before the call that opens the directory to read its entries.    *    *<p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't    * guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,    * pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.    *    * @throws NoSuchFileException if {@code path} does not exist<i>(optional specific exception)</i>    * @throws NotDirectoryException if the file at {@code path} is not a directory<i>(optional    *     specific exception)</i>    * @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be    *     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not    *     specified    * @throws IOException if one or more files can't be deleted for any reason    */
DECL|method|deleteDirectoryContents (Path path, RecursiveDeleteOption... options)
specifier|public
specifier|static
name|void
name|deleteDirectoryContents
parameter_list|(
name|Path
name|path
parameter_list|,
name|RecursiveDeleteOption
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
comment|// created lazily if needed
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|path
argument_list|)
init|)
block|{
if|if
condition|(
name|stream
operator|instanceof
name|SecureDirectoryStream
condition|)
block|{
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
name|sds
init|=
operator|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
operator|)
name|stream
decl_stmt|;
name|exceptions
operator|=
name|deleteDirectoryContentsSecure
argument_list|(
name|sds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkAllowsInsecure
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|exceptions
operator|=
name|deleteDirectoryContentsInsecure
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exceptions
operator|!=
literal|null
condition|)
block|{
name|throwDeleteFailed
argument_list|(
name|path
argument_list|,
name|exceptions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of exceptions    * that occurred or null if no exceptions were thrown.    */
DECL|method|deleteRecursivelySecure ( SecureDirectoryStream<Path> dir, Path path)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|deleteRecursivelySecure
parameter_list|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
name|dir
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isDirectory
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|NOFOLLOW_LINKS
argument_list|)
condition|)
block|{
try|try
init|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
name|childDir
init|=
name|dir
operator|.
name|newDirectoryStream
argument_list|(
name|path
argument_list|,
name|NOFOLLOW_LINKS
argument_list|)
init|)
block|{
name|exceptions
operator|=
name|deleteDirectoryContentsSecure
argument_list|(
name|childDir
argument_list|)
expr_stmt|;
block|}
comment|// If exceptions is not null, something went wrong trying to delete the contents of the
comment|// directory, so we shouldn't try to delete the directory as it will probably fail.
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
name|dir
operator|.
name|deleteDirectory
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dir
operator|.
name|deleteFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|exceptions
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|addException
argument_list|(
name|exceptions
argument_list|,
name|e
argument_list|)
return|;
block|}
block|}
comment|/**    * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.    */
DECL|method|deleteDirectoryContentsSecure ( SecureDirectoryStream<Path> dir)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|deleteDirectoryContentsSecure
parameter_list|(
name|SecureDirectoryStream
argument_list|<
name|Path
argument_list|>
name|dir
parameter_list|)
block|{
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Path
name|path
range|:
name|dir
control|)
block|{
name|exceptions
operator|=
name|concat
argument_list|(
name|exceptions
argument_list|,
name|deleteRecursivelySecure
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|getFileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exceptions
return|;
block|}
catch|catch
parameter_list|(
name|DirectoryIteratorException
name|e
parameter_list|)
block|{
return|return
name|addException
argument_list|(
name|exceptions
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.    */
DECL|method|deleteRecursivelyInsecure (Path path)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|deleteRecursivelyInsecure
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|path
argument_list|,
name|NOFOLLOW_LINKS
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|path
argument_list|)
init|)
block|{
name|exceptions
operator|=
name|deleteDirectoryContentsInsecure
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If exceptions is not null, something went wrong trying to delete the contents of the
comment|// directory, so we shouldn't try to delete the directory as it will probably fail.
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|exceptions
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|addException
argument_list|(
name|exceptions
argument_list|,
name|e
argument_list|)
return|;
block|}
block|}
comment|/**    * Simple, insecure method for deleting the contents of a directory for file systems that don't    * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or null    * if no exceptions were thrown.    */
DECL|method|deleteDirectoryContentsInsecure ( DirectoryStream<Path> dir)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|deleteDirectoryContentsInsecure
parameter_list|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|dir
parameter_list|)
block|{
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Path
name|entry
range|:
name|dir
control|)
block|{
name|exceptions
operator|=
name|concat
argument_list|(
name|exceptions
argument_list|,
name|deleteRecursivelyInsecure
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exceptions
return|;
block|}
catch|catch
parameter_list|(
name|DirectoryIteratorException
name|e
parameter_list|)
block|{
return|return
name|addException
argument_list|(
name|exceptions
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a path to the parent directory of the given path. If the path actually has a parent    * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path    * is a root or is the empty path.    */
DECL|method|getParentPath (Path path)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Path
name|getParentPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|Path
name|parent
init|=
name|path
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// Paths that have a parent:
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// "/foo" ("/")
comment|// "foo/bar" ("foo")
comment|// "C:\foo" ("C:\")
comment|// "\foo" ("\" - current drive for process on Windows)
comment|// "C:foo" ("C:" - working dir of drive C on Windows)
return|return
name|parent
return|;
block|}
comment|// Paths that don't have a parent:
if|if
condition|(
name|path
operator|.
name|getNameCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// "/", "C:\", "\" (no parent)
comment|// "" (undefined, though typically parent of working dir)
comment|// "C:" (parent of working dir of drive C on Windows)
comment|//
comment|// For working dir paths ("" and "C:"), return null because:
comment|//   A) it's not specified that "" is the path to the working directory.
comment|//   B) if we're getting this path for recursive delete, it's typically not possible to
comment|//      delete the working dir with a relative path anyway, so it's ok to fail.
comment|//   C) if we're getting it for opening a new SecureDirectoryStream, there's no need to get
comment|//      the parent path anyway since we can safely open a DirectoryStream to the path without
comment|//      worrying about a symlink.
return|return
literal|null
return|;
block|}
else|else
block|{
comment|// "foo" (working dir)
return|return
name|path
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getPath
argument_list|(
literal|"."
argument_list|)
return|;
block|}
block|}
comment|/** Checks that the given options allow an insecure delete, throwing an exception if not. */
DECL|method|checkAllowsInsecure (Path path, RecursiveDeleteOption[] options)
specifier|private
specifier|static
name|void
name|checkAllowsInsecure
parameter_list|(
name|Path
name|path
parameter_list|,
name|RecursiveDeleteOption
index|[]
name|options
parameter_list|)
throws|throws
name|InsecureRecursiveDeleteException
block|{
if|if
condition|(
operator|!
name|Arrays
operator|.
name|asList
argument_list|(
name|options
argument_list|)
operator|.
name|contains
argument_list|(
name|RecursiveDeleteOption
operator|.
name|ALLOW_INSECURE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InsecureRecursiveDeleteException
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Adds the given exception to the given collection, creating the collection if it's null. Returns    * the collection.    */
DECL|method|addException ( @ullable Collection<IOException> exceptions, IOException e)
specifier|private
specifier|static
name|Collection
argument_list|<
name|IOException
argument_list|>
name|addException
parameter_list|(
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
parameter_list|,
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
name|exceptions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// don't need Set semantics
block|}
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|exceptions
return|;
block|}
comment|/**    * Concatenates the contents of the two given collections of exceptions. If either collection is    * null, the other collection is returned. Otherwise, the elements of {@code other} are added to    * {@code exceptions} and {@code exceptions} is returned.    */
DECL|method|concat ( @ullable Collection<IOException> exceptions, @Nullable Collection<IOException> other)
specifier|private
specifier|static
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|concat
parameter_list|(
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
parameter_list|,
annotation|@
name|Nullable
name|Collection
argument_list|<
name|IOException
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|exceptions
operator|==
literal|null
condition|)
block|{
return|return
name|other
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|!=
literal|null
condition|)
block|{
name|exceptions
operator|.
name|addAll
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
return|return
name|exceptions
return|;
block|}
comment|/**    * Throws an exception indicating that one or more files couldn't be deleted when deleting {@code    * path} or its contents.    *    *<p>If there is only one exception in the collection, and it is a {@link NoSuchFileException}    * thrown because {@code path} itself didn't exist, then throws that exception. Otherwise, the    * thrown exception contains all the exceptions in the given collection as suppressed exceptions.    */
DECL|method|throwDeleteFailed (Path path, Collection<IOException> exceptions)
specifier|private
specifier|static
name|void
name|throwDeleteFailed
parameter_list|(
name|Path
name|path
parameter_list|,
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
parameter_list|)
throws|throws
name|FileSystemException
block|{
name|NoSuchFileException
name|pathNotFound
init|=
name|pathNotFound
argument_list|(
name|path
argument_list|,
name|exceptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathNotFound
operator|!=
literal|null
condition|)
block|{
throw|throw
name|pathNotFound
throw|;
block|}
comment|// TODO(cgdecker): Should there be a custom exception type for this?
comment|// Also, should we try to include the Path of each file we may have failed to delete rather
comment|// than just the exceptions that occurred?
name|FileSystemException
name|deleteFailed
init|=
operator|new
name|FileSystemException
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|"failed to delete one or more files; see suppressed exceptions for details"
argument_list|)
decl_stmt|;
for|for
control|(
name|IOException
name|e
range|:
name|exceptions
control|)
block|{
name|deleteFailed
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|deleteFailed
throw|;
block|}
DECL|method|pathNotFound ( Path path, Collection<IOException> exceptions)
specifier|private
specifier|static
annotation|@
name|Nullable
name|NoSuchFileException
name|pathNotFound
parameter_list|(
name|Path
name|path
parameter_list|,
name|Collection
argument_list|<
name|IOException
argument_list|>
name|exceptions
parameter_list|)
block|{
if|if
condition|(
name|exceptions
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|IOException
name|exception
init|=
name|getOnlyElement
argument_list|(
name|exceptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|exception
operator|instanceof
name|NoSuchFileException
condition|)
block|{
name|NoSuchFileException
name|noSuchFileException
init|=
operator|(
name|NoSuchFileException
operator|)
name|exception
decl_stmt|;
if|if
condition|(
name|noSuchFileException
operator|.
name|getFile
argument_list|()
operator|.
name|equals
argument_list|(
name|getParentPath
argument_list|(
name|path
argument_list|)
operator|.
name|resolve
argument_list|(
name|path
operator|.
name|getFileName
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|noSuchFileException
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

