begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * Provides utility methods for working with byte arrays and I/O streams.  *  * @author Chris Nokleberg  * @author Colin Decker  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|ByteStreams
specifier|public
specifier|final
class|class
name|ByteStreams
block|{
DECL|field|BUF_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUF_SIZE
init|=
literal|8192
decl_stmt|;
DECL|method|ByteStreams ()
specifier|private
name|ByteStreams
parameter_list|()
block|{}
comment|/**    * Copies all bytes from the input stream to the output stream.    * Does not close or flush either stream.    *    * @param from the input stream to read from    * @param to the output stream to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (InputStream from, OutputStream to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|InputStream
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|r
init|=
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|total
operator|+=
name|r
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Copies all bytes from the readable channel to the writable channel.    * Does not close or flush either channel.    *    * @param from the readable channel to read from    * @param to the writable channel to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (ReadableByteChannel from, WritableByteChannel to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|ReadableByteChannel
name|from
parameter_list|,
name|WritableByteChannel
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|BUF_SIZE
argument_list|)
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|total
operator|+=
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Reads all bytes from an input stream into a byte array.    * Does not close the stream.    *    * @param in the input stream to read from    * @return a byte array containing all the bytes from the stream    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray (InputStream in)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|copy
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Reads all bytes from an input stream into a byte array. The given    * expected size is used to create an initial byte array, but if the actual    * number of bytes read from the stream differs, the correct result will be    * returned anyway.    */
DECL|method|toByteArray ( InputStream in, int expectedSize)
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|int
name|expectedSize
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|expectedSize
index|]
decl_stmt|;
name|int
name|remaining
init|=
name|expectedSize
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|int
name|off
init|=
name|expectedSize
operator|-
name|remaining
decl_stmt|;
name|int
name|read
init|=
name|in
operator|.
name|read
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|==
operator|-
literal|1
condition|)
block|{
comment|// end of stream before reading expectedSize bytes
comment|// just return the bytes read so far
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|)
return|;
block|}
name|remaining
operator|-=
name|read
expr_stmt|;
block|}
comment|// bytes is now full
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|bytes
return|;
block|}
comment|// the stream was longer, so read the rest normally
name|FastByteArrayOutputStream
name|out
init|=
operator|new
name|FastByteArrayOutputStream
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|// write the byte we read when testing for end of stream
name|copy
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
operator|+
name|out
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeTo
argument_list|(
name|result
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * BAOS that provides limited access to its internal byte array.    */
DECL|class|FastByteArrayOutputStream
specifier|private
specifier|static
specifier|final
class|class
name|FastByteArrayOutputStream
extends|extends
name|ByteArrayOutputStream
block|{
comment|/**      * Writes the contents of the internal buffer to the given array starting      * at the given offset. Assumes the array has space to hold count bytes.      */
DECL|method|writeTo (byte[] b, int off)
name|void
name|writeTo
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code    * bytes} array from the beginning.    */
DECL|method|newDataInput (byte[] bytes)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
name|newDataInput
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code    * bytes} array, starting at the given position.    *    * @throws IndexOutOfBoundsException if {@code start} is negative or greater    *     than the length of the array    */
DECL|method|newDataInput (byte[] bytes, int start)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|newDataInput
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|start
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the given    * {@code ByteArrayInputStream}. The given input stream is not reset before    * being read from by the returned {@code ByteArrayDataInput}.    *    * @since 17.0    */
DECL|method|newDataInput ( ByteArrayInputStream byteArrayInputStream)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|ByteArrayInputStream
name|byteArrayInputStream
parameter_list|)
block|{
return|return
operator|new
name|ByteArrayDataInputStream
argument_list|(
name|checkNotNull
argument_list|(
name|byteArrayInputStream
argument_list|)
argument_list|)
return|;
block|}
DECL|class|ByteArrayDataInputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataInputStream
implements|implements
name|ByteArrayDataInput
block|{
DECL|field|input
specifier|final
name|DataInput
name|input
decl_stmt|;
DECL|method|ByteArrayDataInputStream (ByteArrayInputStream byteArrayInputStream)
name|ByteArrayDataInputStream
parameter_list|(
name|ByteArrayInputStream
name|byteArrayInputStream
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
operator|new
name|DataInputStream
argument_list|(
name|byteArrayInputStream
argument_list|)
expr_stmt|;
block|}
DECL|method|readFully (byte b[])
annotation|@
name|Override
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readFully (byte b[], int off, int len)
annotation|@
name|Override
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|skipBytes (int n)
annotation|@
name|Override
specifier|public
name|int
name|skipBytes
parameter_list|(
name|int
name|n
parameter_list|)
block|{
try|try
block|{
return|return
name|input
operator|.
name|skipBytes
argument_list|(
name|n
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readBoolean ()
annotation|@
name|Override
specifier|public
name|boolean
name|readBoolean
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readBoolean
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readByte ()
annotation|@
name|Override
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|readUnsignedByte ()
annotation|@
name|Override
specifier|public
name|int
name|readUnsignedByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readShort ()
annotation|@
name|Override
specifier|public
name|short
name|readShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readUnsignedShort ()
annotation|@
name|Override
specifier|public
name|int
name|readUnsignedShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readChar ()
annotation|@
name|Override
specifier|public
name|char
name|readChar
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readChar
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readInt ()
annotation|@
name|Override
specifier|public
name|int
name|readInt
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readInt
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readLong ()
annotation|@
name|Override
specifier|public
name|long
name|readLong
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLong
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readFloat ()
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readFloat
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readDouble ()
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readDouble
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readLine ()
annotation|@
name|Override
specifier|public
name|String
name|readLine
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLine
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readUTF ()
annotation|@
name|Override
specifier|public
name|String
name|readUTF
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUTF
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance with a default size.    */
DECL|method|newDataOutput ()
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|()
block|{
return|return
name|newDataOutput
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance sized to hold    * {@code size} bytes before resizing.    *    * @throws IllegalArgumentException if {@code size} is negative    */
DECL|method|newDataOutput (int size)
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"Invalid size: %s"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|newDataOutput
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance which writes to the    * given {@code ByteArrayOutputStream}. The given output stream is not reset    * before being written to by the returned {@code ByteArrayDataOutput} and    * new data will be appended to any existing content.    *    *<p>Note that if the given output stream was not empty or is modified after    * the {@code ByteArrayDataOutput} is created, the contract for    * {@link ByteArrayDataOutput#toByteArray} will not be honored (the bytes    * returned in the byte array may not be exactly what was written via calls to    * {@code ByteArrayDataOutput}).    *    * @since 17.0    */
DECL|method|newDataOutput ( ByteArrayOutputStream byteArrayOutputSteam)
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|(
name|ByteArrayOutputStream
name|byteArrayOutputSteam
parameter_list|)
block|{
return|return
operator|new
name|ByteArrayDataOutputStream
argument_list|(
name|checkNotNull
argument_list|(
name|byteArrayOutputSteam
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// for writeBytes
DECL|class|ByteArrayDataOutputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataOutputStream
implements|implements
name|ByteArrayDataOutput
block|{
DECL|field|output
specifier|final
name|DataOutput
name|output
decl_stmt|;
DECL|field|byteArrayOutputSteam
specifier|final
name|ByteArrayOutputStream
name|byteArrayOutputSteam
decl_stmt|;
DECL|method|ByteArrayDataOutputStream (ByteArrayOutputStream byteArrayOutputSteam)
name|ByteArrayDataOutputStream
parameter_list|(
name|ByteArrayOutputStream
name|byteArrayOutputSteam
parameter_list|)
block|{
name|this
operator|.
name|byteArrayOutputSteam
operator|=
name|byteArrayOutputSteam
expr_stmt|;
name|output
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|byteArrayOutputSteam
argument_list|)
expr_stmt|;
block|}
DECL|method|write (int b)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|write (byte[] b)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|write (byte[] b, int off, int len)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBoolean (boolean v)
annotation|@
name|Override
specifier|public
name|void
name|writeBoolean
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBoolean
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeByte (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeByte
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBytes (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBytes
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeChar (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeChar
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChar
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeChars (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeChars
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChars
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeDouble (double v)
annotation|@
name|Override
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeDouble
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeFloat (float v)
annotation|@
name|Override
specifier|public
name|void
name|writeFloat
parameter_list|(
name|float
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeFloat
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeInt (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeLong (long v)
annotation|@
name|Override
specifier|public
name|void
name|writeLong
parameter_list|(
name|long
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeLong
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeShort (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeShort
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeShort
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeUTF (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeUTF
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeUTF
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|toByteArray ()
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|byteArrayOutputSteam
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
DECL|field|NULL_OUTPUT_STREAM
specifier|private
specifier|static
specifier|final
name|OutputStream
name|NULL_OUTPUT_STREAM
init|=
operator|new
name|OutputStream
argument_list|()
block|{
comment|/** Discards the specified byte. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{         }
comment|/** Discards the specified byte array. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/** Discards the specified byte array. */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteStreams.nullOutputStream()"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns an {@link OutputStream} that simply discards written bytes.    *    * @since 14.0 (since 1.0 as com.google.common.io.NullOutputStream)    */
DECL|method|nullOutputStream ()
specifier|public
specifier|static
name|OutputStream
name|nullOutputStream
parameter_list|()
block|{
return|return
name|NULL_OUTPUT_STREAM
return|;
block|}
comment|/**    * Wraps a {@link InputStream}, limiting the number of bytes which can be    * read.    *    * @param in the input stream to be wrapped    * @param limit the maximum number of bytes to be read    * @return a length-limited {@link InputStream}    * @since 14.0 (since 1.0 as com.google.common.io.LimitInputStream)    */
DECL|method|limit (InputStream in, long limit)
specifier|public
specifier|static
name|InputStream
name|limit
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
return|return
operator|new
name|LimitedInputStream
argument_list|(
name|in
argument_list|,
name|limit
argument_list|)
return|;
block|}
DECL|class|LimitedInputStream
specifier|private
specifier|static
specifier|final
class|class
name|LimitedInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|left
specifier|private
name|long
name|left
decl_stmt|;
DECL|field|mark
specifier|private
name|long
name|mark
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|LimitedInputStream (InputStream in, long limit)
name|LimitedInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|limit
operator|>=
literal|0
argument_list|,
literal|"limit must be non-negative"
argument_list|)
expr_stmt|;
name|left
operator|=
name|limit
expr_stmt|;
block|}
DECL|method|available ()
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|in
operator|.
name|available
argument_list|()
argument_list|,
name|left
argument_list|)
return|;
block|}
comment|// it's okay to mark even if mark isn't supported, as reset won't work
DECL|method|mark (int readLimit)
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{
name|in
operator|.
name|mark
argument_list|(
name|readLimit
argument_list|)
expr_stmt|;
name|mark
operator|=
name|left
expr_stmt|;
block|}
DECL|method|read ()
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
operator|--
name|left
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|read (byte[] b, int off, int len)
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
name|left
operator|-=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|reset ()
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark not supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mark
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark not set"
argument_list|)
throw|;
block|}
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
name|left
operator|=
name|mark
expr_stmt|;
block|}
DECL|method|skip (long n)
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|n
operator|=
name|Math
operator|.
name|min
argument_list|(
name|n
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|long
name|skipped
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|left
operator|-=
name|skipped
expr_stmt|;
return|return
name|skipped
return|;
block|}
block|}
comment|/**    * Attempts to read enough bytes from the stream to fill the given byte array,    * with the same behavior as {@link DataInput#readFully(byte[])}.    * Does not close the stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @throws EOFException if this stream reaches the end before reading all    *     the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully (InputStream in, byte[] b)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempts to read {@code len} bytes from the stream into the given array    * starting at {@code off}, with the same behavior as    * {@link DataInput#readFully(byte[], int, int)}. Does not close the    * stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @param off an int specifying the offset into the data.    * @param len an int specifying the number of bytes to read.    * @throws EOFException if this stream reaches the end before reading all    *     the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully ( InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|read
init|=
name|read
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
name|len
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"reached end of stream after reading "
operator|+
name|read
operator|+
literal|" bytes; "
operator|+
name|len
operator|+
literal|" bytes expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Discards {@code n} bytes of data from the input stream. This method    * will block until the full amount has been skipped. Does not close the    * stream.    *    * @param in the input stream to read from    * @param n the number of bytes to skip    * @throws EOFException if this stream reaches the end before skipping all    *     the bytes    * @throws IOException if an I/O error occurs, or the stream does not    *     support skipping    */
DECL|method|skipFully (InputStream in, long n)
specifier|public
specifier|static
name|void
name|skipFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|toSkip
init|=
name|n
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|long
name|amt
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|==
literal|0
condition|)
block|{
comment|// Force a blocking read to avoid infinite loop
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|long
name|skipped
init|=
name|toSkip
operator|-
name|n
decl_stmt|;
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"reached end of stream after skipping "
operator|+
name|skipped
operator|+
literal|" bytes; "
operator|+
name|toSkip
operator|+
literal|" bytes expected"
argument_list|)
throw|;
block|}
name|n
operator|--
expr_stmt|;
block|}
else|else
block|{
name|n
operator|-=
name|amt
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Process the bytes of the given input stream using the given processor.    *    * @param input the input stream to process    * @param processor the object to which to pass the bytes of the stream    * @return the result of the byte processor    * @throws IOException if an I/O error occurs    * @since 14.0    */
DECL|method|readBytes ( InputStream input, ByteProcessor<T> processor)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readBytes
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|ByteProcessor
argument_list|<
name|T
argument_list|>
name|processor
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|processor
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|int
name|read
decl_stmt|;
do|do
block|{
name|read
operator|=
name|input
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|read
operator|!=
operator|-
literal|1
operator|&&
name|processor
operator|.
name|processBytes
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|read
argument_list|)
condition|)
do|;
return|return
name|processor
operator|.
name|getResult
argument_list|()
return|;
block|}
comment|/**    * Reads some bytes from an input stream and stores them into the buffer array    * {@code b}. This method blocks until {@code len} bytes of input data have    * been read into the array, or end of file is detected. The number of bytes    * read is returned, possibly zero. Does not close the stream.    *    *<p>A caller can detect EOF if the number of bytes read is less than    * {@code len}. All subsequent calls on the same stream will return zero.    *    *<p>If {@code b} is null, a {@code NullPointerException} is thrown. If    * {@code off} is negative, or {@code len} is negative, or {@code off+len} is    * greater than the length of the array {@code b}, then an    * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then    * no bytes are read. Otherwise, the first byte read is stored into element    * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number    * of bytes read is, at most, equal to {@code len}.    *    * @param in the input stream to read from    * @param b the buffer into which the data is read    * @param off an int specifying the offset into the data    * @param len an int specifying the number of bytes to read    * @return the number of bytes read    * @throws IOException if an I/O error occurs    */
DECL|method|read (InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|int
name|read
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotNull
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len is negative"
argument_list|)
throw|;
block|}
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|total
argument_list|,
name|len
operator|-
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|total
operator|+=
name|result
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
block|}
end_class

end_unit

