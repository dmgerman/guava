begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.reflect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericArrayType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|TypeVariable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|WildcardType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * An object of this class encapsulates type mappings from type variables. Mappings are established  * with {@link #where} and types are resolved using {@link #resolveType}.  *  *<p>Note that usually type mappings are already implied by the static type hierarchy (for example,  * the {@code E} type variable declared by class {@code List} naturally maps to {@code String} in  * the context of {@code class MyStringList implements List<String>}. In such case, prefer to use  * {@link TypeToken#resolveType} since it's simpler and more type safe. This class should only be  * used when the type mapping isn't implied by the static type hierarchy, but provided through other  * means such as an annotation or external configuration file.  *  * @author Ben Yu  * @since 15.0  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|TypeResolver
specifier|public
specifier|final
class|class
name|TypeResolver
block|{
DECL|field|typeTable
specifier|private
specifier|final
name|TypeTable
name|typeTable
decl_stmt|;
DECL|method|TypeResolver ()
specifier|public
name|TypeResolver
parameter_list|()
block|{
name|this
operator|.
name|typeTable
operator|=
operator|new
name|TypeTable
argument_list|()
expr_stmt|;
block|}
DECL|method|TypeResolver (TypeTable typeTable)
specifier|private
name|TypeResolver
parameter_list|(
name|TypeTable
name|typeTable
parameter_list|)
block|{
name|this
operator|.
name|typeTable
operator|=
name|typeTable
expr_stmt|;
block|}
DECL|method|accordingTo (Type type)
specifier|static
name|TypeResolver
name|accordingTo
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|TypeResolver
argument_list|()
operator|.
name|where
argument_list|(
name|TypeMappingIntrospector
operator|.
name|getTypeMappings
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in    * {@code actual}.    *    *<p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code    * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain    * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve    * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and    * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they    * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination    * thereof.    *    * @param formal The type whose type variables or itself is mapped to other type(s). It's almost    *        always a bug if {@code formal} isn't a type variable and contains no type variable. Make    *        sure you are passing the two parameters in the right order.    * @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet    *        other type variables, in which case these type variables will be further resolved if    *        corresponding mappings exist in the current {@code TypeResolver} instance.    */
DECL|method|where (Type formal, Type actual)
specifier|public
name|TypeResolver
name|where
parameter_list|(
name|Type
name|formal
parameter_list|,
name|Type
name|actual
parameter_list|)
block|{
name|Map
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|mappings
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|populateTypeMappings
argument_list|(
name|mappings
argument_list|,
name|checkNotNull
argument_list|(
name|formal
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|where
argument_list|(
name|mappings
argument_list|)
return|;
block|}
comment|/** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */
DECL|method|where (Map<TypeVariableKey, ? extends Type> mappings)
name|TypeResolver
name|where
parameter_list|(
name|Map
argument_list|<
name|TypeVariableKey
argument_list|,
name|?
extends|extends
name|Type
argument_list|>
name|mappings
parameter_list|)
block|{
return|return
operator|new
name|TypeResolver
argument_list|(
name|typeTable
operator|.
name|where
argument_list|(
name|mappings
argument_list|)
argument_list|)
return|;
block|}
DECL|method|populateTypeMappings ( final Map<TypeVariableKey, Type> mappings, Type from, final Type to)
specifier|private
specifier|static
name|void
name|populateTypeMappings
parameter_list|(
specifier|final
name|Map
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|mappings
parameter_list|,
name|Type
name|from
parameter_list|,
specifier|final
name|Type
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|to
operator|instanceof
name|WildcardType
operator|!=
name|from
operator|instanceof
name|WildcardType
condition|)
block|{
comment|// When we are saying "assuming<?> is T, there really isn't any useful type mapping.
comment|// Similarly, saying "assuming T is<?>" is meaningless. Of course it is.
return|return;
block|}
operator|new
name|TypeVisitor
argument_list|()
block|{
annotation|@
name|Override
name|void
name|visitTypeVariable
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|typeVariable
parameter_list|)
block|{
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|TypeVariableKey
argument_list|(
name|typeVariable
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitWildcardType
parameter_list|(
name|WildcardType
name|fromWildcardType
parameter_list|)
block|{
name|WildcardType
name|toWildcardType
init|=
name|expectArgument
argument_list|(
name|WildcardType
operator|.
name|class
argument_list|,
name|to
argument_list|)
decl_stmt|;
name|Type
index|[]
name|fromUpperBounds
init|=
name|fromWildcardType
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
name|Type
index|[]
name|toUpperBounds
init|=
name|toWildcardType
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
name|Type
index|[]
name|fromLowerBounds
init|=
name|fromWildcardType
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|Type
index|[]
name|toLowerBounds
init|=
name|toWildcardType
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|fromUpperBounds
operator|.
name|length
operator|==
name|toUpperBounds
operator|.
name|length
operator|&&
name|fromLowerBounds
operator|.
name|length
operator|==
name|toLowerBounds
operator|.
name|length
argument_list|,
literal|"Incompatible type: %s vs. %s"
argument_list|,
name|fromWildcardType
argument_list|,
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fromUpperBounds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|populateTypeMappings
argument_list|(
name|mappings
argument_list|,
name|fromUpperBounds
index|[
name|i
index|]
argument_list|,
name|toUpperBounds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fromLowerBounds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|populateTypeMappings
argument_list|(
name|mappings
argument_list|,
name|fromLowerBounds
index|[
name|i
index|]
argument_list|,
name|toLowerBounds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|void
name|visitParameterizedType
parameter_list|(
name|ParameterizedType
name|fromParameterizedType
parameter_list|)
block|{
name|ParameterizedType
name|toParameterizedType
init|=
name|expectArgument
argument_list|(
name|ParameterizedType
operator|.
name|class
argument_list|,
name|to
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|fromParameterizedType
operator|.
name|getRawType
argument_list|()
operator|.
name|equals
argument_list|(
name|toParameterizedType
operator|.
name|getRawType
argument_list|()
argument_list|)
argument_list|,
literal|"Inconsistent raw type: %s vs. %s"
argument_list|,
name|fromParameterizedType
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|Type
index|[]
name|fromArgs
init|=
name|fromParameterizedType
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
name|Type
index|[]
name|toArgs
init|=
name|toParameterizedType
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|fromArgs
operator|.
name|length
operator|==
name|toArgs
operator|.
name|length
argument_list|,
literal|"%s not compatible with %s"
argument_list|,
name|fromParameterizedType
argument_list|,
name|toParameterizedType
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fromArgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|populateTypeMappings
argument_list|(
name|mappings
argument_list|,
name|fromArgs
index|[
name|i
index|]
argument_list|,
name|toArgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|void
name|visitGenericArrayType
parameter_list|(
name|GenericArrayType
name|fromArrayType
parameter_list|)
block|{
name|Type
name|componentType
init|=
name|Types
operator|.
name|getComponentType
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|componentType
operator|!=
literal|null
argument_list|,
literal|"%s is not an array type."
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|populateTypeMappings
argument_list|(
name|mappings
argument_list|,
name|fromArrayType
operator|.
name|getGenericComponentType
argument_list|()
argument_list|,
name|componentType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|fromClass
parameter_list|)
block|{
comment|// Can't map from a raw class to anything other than itself.
comment|// You can't say "assuming String is Integer".
comment|// And we don't support "assuming String is T"; user has to say "assuming T is String".
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No type mapping from "
operator|+
name|fromClass
argument_list|)
throw|;
block|}
block|}
operator|.
name|visit
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/**    * Resolves all type variables in {@code type} and all downstream types and    * returns a corresponding type with type variables resolved.    */
DECL|method|resolveType (Type type)
specifier|public
name|Type
name|resolveType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|TypeVariable
condition|)
block|{
return|return
name|typeTable
operator|.
name|resolve
argument_list|(
operator|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
operator|)
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
return|return
name|resolveParameterizedType
argument_list|(
operator|(
name|ParameterizedType
operator|)
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
return|return
name|resolveGenericArrayType
argument_list|(
operator|(
name|GenericArrayType
operator|)
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|WildcardType
condition|)
block|{
return|return
name|resolveWildcardType
argument_list|(
operator|(
name|WildcardType
operator|)
name|type
argument_list|)
return|;
block|}
else|else
block|{
comment|// if Class<?>, no resolution needed, we are done.
return|return
name|type
return|;
block|}
block|}
DECL|method|resolveTypes (Type[] types)
specifier|private
name|Type
index|[]
name|resolveTypes
parameter_list|(
name|Type
index|[]
name|types
parameter_list|)
block|{
name|Type
index|[]
name|result
init|=
operator|new
name|Type
index|[
name|types
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|resolveType
argument_list|(
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|resolveWildcardType (WildcardType type)
specifier|private
name|WildcardType
name|resolveWildcardType
parameter_list|(
name|WildcardType
name|type
parameter_list|)
block|{
name|Type
index|[]
name|lowerBounds
init|=
name|type
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|Type
index|[]
name|upperBounds
init|=
name|type
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
return|return
operator|new
name|Types
operator|.
name|WildcardTypeImpl
argument_list|(
name|resolveTypes
argument_list|(
name|lowerBounds
argument_list|)
argument_list|,
name|resolveTypes
argument_list|(
name|upperBounds
argument_list|)
argument_list|)
return|;
block|}
DECL|method|resolveGenericArrayType (GenericArrayType type)
specifier|private
name|Type
name|resolveGenericArrayType
parameter_list|(
name|GenericArrayType
name|type
parameter_list|)
block|{
name|Type
name|componentType
init|=
name|type
operator|.
name|getGenericComponentType
argument_list|()
decl_stmt|;
name|Type
name|resolvedComponentType
init|=
name|resolveType
argument_list|(
name|componentType
argument_list|)
decl_stmt|;
return|return
name|Types
operator|.
name|newArrayType
argument_list|(
name|resolvedComponentType
argument_list|)
return|;
block|}
DECL|method|resolveParameterizedType (ParameterizedType type)
specifier|private
name|ParameterizedType
name|resolveParameterizedType
parameter_list|(
name|ParameterizedType
name|type
parameter_list|)
block|{
name|Type
name|owner
init|=
name|type
operator|.
name|getOwnerType
argument_list|()
decl_stmt|;
name|Type
name|resolvedOwner
init|=
operator|(
name|owner
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|resolveType
argument_list|(
name|owner
argument_list|)
decl_stmt|;
name|Type
name|resolvedRawType
init|=
name|resolveType
argument_list|(
name|type
operator|.
name|getRawType
argument_list|()
argument_list|)
decl_stmt|;
name|Type
index|[]
name|args
init|=
name|type
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
name|Type
index|[]
name|resolvedArgs
init|=
name|resolveTypes
argument_list|(
name|args
argument_list|)
decl_stmt|;
return|return
name|Types
operator|.
name|newParameterizedTypeWithOwner
argument_list|(
name|resolvedOwner
argument_list|,
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|resolvedRawType
argument_list|,
name|resolvedArgs
argument_list|)
return|;
block|}
DECL|method|expectArgument (Class<T> type, Object arg)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|expectArgument
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|arg
parameter_list|)
block|{
try|try
block|{
return|return
name|type
operator|.
name|cast
argument_list|(
name|arg
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|arg
operator|+
literal|" is not a "
operator|+
name|type
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** A TypeTable maintains mapping from {@link TypeVariable} to types. */
DECL|class|TypeTable
specifier|private
specifier|static
class|class
name|TypeTable
block|{
DECL|field|map
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|map
decl_stmt|;
DECL|method|TypeTable ()
name|TypeTable
parameter_list|()
block|{
name|this
operator|.
name|map
operator|=
name|ImmutableMap
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
DECL|method|TypeTable (ImmutableMap<TypeVariableKey, Type> map)
specifier|private
name|TypeTable
parameter_list|(
name|ImmutableMap
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */
DECL|method|where (Map<TypeVariableKey, ? extends Type> mappings)
specifier|final
name|TypeTable
name|where
parameter_list|(
name|Map
argument_list|<
name|TypeVariableKey
argument_list|,
name|?
extends|extends
name|Type
argument_list|>
name|mappings
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|TypeVariableKey
argument_list|,
name|?
extends|extends
name|Type
argument_list|>
name|mapping
range|:
name|mappings
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TypeVariableKey
name|variable
init|=
name|mapping
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Type
name|type
init|=
name|mapping
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
operator|!
name|variable
operator|.
name|equalsType
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"Type variable %s bound to itself"
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|variable
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TypeTable
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
DECL|method|resolve (final TypeVariable<?> var)
specifier|final
name|Type
name|resolve
parameter_list|(
specifier|final
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|var
parameter_list|)
block|{
specifier|final
name|TypeTable
name|unguarded
init|=
name|this
decl_stmt|;
name|TypeTable
name|guarded
init|=
operator|new
name|TypeTable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Type
name|resolveInternal
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|intermediateVar
parameter_list|,
name|TypeTable
name|forDependent
parameter_list|)
block|{
if|if
condition|(
name|intermediateVar
operator|.
name|getGenericDeclaration
argument_list|()
operator|.
name|equals
argument_list|(
name|var
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|intermediateVar
return|;
block|}
return|return
name|unguarded
operator|.
name|resolveInternal
argument_list|(
name|intermediateVar
argument_list|,
name|forDependent
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|resolveInternal
argument_list|(
name|var
argument_list|,
name|guarded
argument_list|)
return|;
block|}
comment|/**      * Resolves {@code var} using the encapsulated type mapping. If it maps to yet another      * non-reified type or has bounds, {@code forDependants} is used to do further resolution, which      * doesn't try to resolve any type variable on generic declarations that are already being      * resolved.      *      *<p>Should only be called and overridden by {@link #resolve(TypeVariable)}.      */
DECL|method|resolveInternal (TypeVariable<?> var, TypeTable forDependants)
name|Type
name|resolveInternal
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|var
parameter_list|,
name|TypeTable
name|forDependants
parameter_list|)
block|{
name|Type
name|type
init|=
name|map
operator|.
name|get
argument_list|(
operator|new
name|TypeVariableKey
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|Type
index|[]
name|bounds
init|=
name|var
operator|.
name|getBounds
argument_list|()
decl_stmt|;
if|if
condition|(
name|bounds
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|var
return|;
block|}
name|Type
index|[]
name|resolvedBounds
init|=
operator|new
name|TypeResolver
argument_list|(
name|forDependants
argument_list|)
operator|.
name|resolveTypes
argument_list|(
name|bounds
argument_list|)
decl_stmt|;
comment|/*          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's          * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't          * recognize instances of our TypeVariable implementation. This is a problem because users          * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To          * work with all JDK versions, TypeResolver must return the appropriate TypeVariable          * implementation in each of the three possible cases:          *          * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.          * Therefore, we can always create our own TypeVariable.          *          * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate          * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:          *          * 2a. If the resolved types are identical to the original types, then we can return the          * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.          *          * 2b. If the resolved types are different from the original types, things are trickier. The          * only way to get a TypeVariable instance for the resolved types is to create our own. The          * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We          * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has          * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new          * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK          * TypeVariable must have a different declaration or name. The only TypeVariable that our          * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK          * TypeVariable implementation at all.          */
if|if
condition|(
name|Types
operator|.
name|NativeTypeVariableEquals
operator|.
name|NATIVE_TYPE_VARIABLE_ONLY
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|bounds
argument_list|,
name|resolvedBounds
argument_list|)
condition|)
block|{
return|return
name|var
return|;
block|}
return|return
name|Types
operator|.
name|newArtificialTypeVariable
argument_list|(
name|var
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|,
name|var
operator|.
name|getName
argument_list|()
argument_list|,
name|resolvedBounds
argument_list|)
return|;
block|}
comment|// in case the type is yet another type variable.
return|return
operator|new
name|TypeResolver
argument_list|(
name|forDependants
argument_list|)
operator|.
name|resolveType
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
DECL|class|TypeMappingIntrospector
specifier|private
specifier|static
specifier|final
class|class
name|TypeMappingIntrospector
extends|extends
name|TypeVisitor
block|{
DECL|field|wildcardCapturer
specifier|private
specifier|static
specifier|final
name|WildcardCapturer
name|wildcardCapturer
init|=
operator|new
name|WildcardCapturer
argument_list|()
decl_stmt|;
DECL|field|mappings
specifier|private
specifier|final
name|Map
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|mappings
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|/**      * Returns type mappings using type parameters and type arguments found in      * the generic superclass and the super interfaces of {@code contextClass}.      */
DECL|method|getTypeMappings ( Type contextType)
specifier|static
name|ImmutableMap
argument_list|<
name|TypeVariableKey
argument_list|,
name|Type
argument_list|>
name|getTypeMappings
parameter_list|(
name|Type
name|contextType
parameter_list|)
block|{
name|TypeMappingIntrospector
name|introspector
init|=
operator|new
name|TypeMappingIntrospector
argument_list|()
decl_stmt|;
name|introspector
operator|.
name|visit
argument_list|(
name|wildcardCapturer
operator|.
name|capture
argument_list|(
name|contextType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|introspector
operator|.
name|mappings
argument_list|)
return|;
block|}
DECL|method|visitClass (Class<?> clazz)
annotation|@
name|Override
name|void
name|visitClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
name|visit
argument_list|(
name|clazz
operator|.
name|getGenericSuperclass
argument_list|()
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|clazz
operator|.
name|getGenericInterfaces
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|visitParameterizedType (ParameterizedType parameterizedType)
annotation|@
name|Override
name|void
name|visitParameterizedType
parameter_list|(
name|ParameterizedType
name|parameterizedType
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|rawClass
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|parameterizedType
operator|.
name|getRawType
argument_list|()
decl_stmt|;
name|TypeVariable
argument_list|<
name|?
argument_list|>
index|[]
name|vars
init|=
name|rawClass
operator|.
name|getTypeParameters
argument_list|()
decl_stmt|;
name|Type
index|[]
name|typeArgs
init|=
name|parameterizedType
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|vars
operator|.
name|length
operator|==
name|typeArgs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|map
argument_list|(
operator|new
name|TypeVariableKey
argument_list|(
name|vars
index|[
name|i
index|]
argument_list|)
argument_list|,
name|typeArgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|visit
argument_list|(
name|rawClass
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|parameterizedType
operator|.
name|getOwnerType
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|visitTypeVariable (TypeVariable<?> t)
annotation|@
name|Override
name|void
name|visitTypeVariable
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|visit
argument_list|(
name|t
operator|.
name|getBounds
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|visitWildcardType (WildcardType t)
annotation|@
name|Override
name|void
name|visitWildcardType
parameter_list|(
name|WildcardType
name|t
parameter_list|)
block|{
name|visit
argument_list|(
name|t
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|map (final TypeVariableKey var, final Type arg)
specifier|private
name|void
name|map
parameter_list|(
specifier|final
name|TypeVariableKey
name|var
parameter_list|,
specifier|final
name|Type
name|arg
parameter_list|)
block|{
if|if
condition|(
name|mappings
operator|.
name|containsKey
argument_list|(
name|var
argument_list|)
condition|)
block|{
comment|// Mapping already established
comment|// This is possible when following both superClass -> enclosingClass
comment|// and enclosingclass -> superClass paths.
comment|// Since we follow the path of superclass first, enclosing second,
comment|// superclass mapping should take precedence.
return|return;
block|}
comment|// First, check whether var -> arg forms a cycle
for|for
control|(
name|Type
name|t
init|=
name|arg
init|;
name|t
operator|!=
literal|null
condition|;
name|t
operator|=
name|mappings
operator|.
name|get
argument_list|(
name|TypeVariableKey
operator|.
name|forLookup
argument_list|(
name|t
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|var
operator|.
name|equalsType
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|// cycle detected, remove the entire cycle from the mapping so that
comment|// each type variable resolves deterministically to itself.
comment|// Otherwise, a F -> T cycle will end up resolving both F and T
comment|// nondeterministically to either F or T.
for|for
control|(
name|Type
name|x
init|=
name|arg
init|;
name|x
operator|!=
literal|null
condition|;
name|x
operator|=
name|mappings
operator|.
name|remove
argument_list|(
name|TypeVariableKey
operator|.
name|forLookup
argument_list|(
name|x
argument_list|)
argument_list|)
control|)
block|{}
return|return;
block|}
block|}
name|mappings
operator|.
name|put
argument_list|(
name|var
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This is needed when resolving types against a context with wildcards
comment|// For example:
comment|// class Holder<T> {
comment|//   void set(T data) {...}
comment|// }
comment|// Holder<List<?>> should *not* resolve the set() method to set(List<?> data).
comment|// Instead, it should create a capture of the wildcard so that set() rejects any List<T>.
DECL|class|WildcardCapturer
specifier|private
specifier|static
specifier|final
class|class
name|WildcardCapturer
block|{
DECL|field|id
specifier|private
specifier|final
name|AtomicInteger
name|id
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|method|capture (Type type)
name|Type
name|capture
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
return|return
name|type
return|;
block|}
if|if
condition|(
name|type
operator|instanceof
name|TypeVariable
condition|)
block|{
return|return
name|type
return|;
block|}
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
name|GenericArrayType
name|arrayType
init|=
operator|(
name|GenericArrayType
operator|)
name|type
decl_stmt|;
return|return
name|Types
operator|.
name|newArrayType
argument_list|(
name|capture
argument_list|(
name|arrayType
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|parameterizedType
init|=
operator|(
name|ParameterizedType
operator|)
name|type
decl_stmt|;
return|return
name|Types
operator|.
name|newParameterizedTypeWithOwner
argument_list|(
name|captureNullable
argument_list|(
name|parameterizedType
operator|.
name|getOwnerType
argument_list|()
argument_list|)
argument_list|,
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|parameterizedType
operator|.
name|getRawType
argument_list|()
argument_list|,
name|capture
argument_list|(
name|parameterizedType
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|wildcardType
init|=
operator|(
name|WildcardType
operator|)
name|type
decl_stmt|;
name|Type
index|[]
name|lowerBounds
init|=
name|wildcardType
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// ? extends something changes to capture-of
name|Type
index|[]
name|upperBounds
init|=
name|wildcardType
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
name|String
name|name
init|=
literal|"capture#"
operator|+
name|id
operator|.
name|incrementAndGet
argument_list|()
operator|+
literal|"-of ? extends "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|'&'
argument_list|)
operator|.
name|join
argument_list|(
name|upperBounds
argument_list|)
decl_stmt|;
return|return
name|Types
operator|.
name|newArtificialTypeVariable
argument_list|(
name|WildcardCapturer
operator|.
name|class
argument_list|,
name|name
argument_list|,
name|wildcardType
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// TODO(benyu): handle ? super T somehow.
return|return
name|type
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"must have been one of the known types"
argument_list|)
throw|;
block|}
DECL|method|captureNullable (@ullable Type type)
specifier|private
name|Type
name|captureNullable
parameter_list|(
annotation|@
name|Nullable
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|capture
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|method|capture (Type[] types)
specifier|private
name|Type
index|[]
name|capture
parameter_list|(
name|Type
index|[]
name|types
parameter_list|)
block|{
name|Type
index|[]
name|result
init|=
operator|new
name|Type
index|[
name|types
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|capture
argument_list|(
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Wraps around {@code TypeVariable<?>} to ensure that any two type variables are equal as long as    * they are declared by the same {@link java.lang.reflect.GenericDeclaration} and have the same    * name, even if their bounds differ.    *    *<p>While resolving a type variable from a {var -> type} map, we don't care whether the    * type variable's bound has been partially resolved. As long as the type variable "identity"    * matches.    *    *<p>On the other hand, if for example we are resolving List<A extends B> to    * List<A extends String>, we need to compare that<A extends B> is unequal to    *<A extends String> in order to decide to use the transformed type instead of the original    * type.    */
DECL|class|TypeVariableKey
specifier|static
specifier|final
class|class
name|TypeVariableKey
block|{
DECL|field|var
specifier|private
specifier|final
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|var
decl_stmt|;
DECL|method|TypeVariableKey (TypeVariable<?> var)
name|TypeVariableKey
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|var
parameter_list|)
block|{
name|this
operator|.
name|var
operator|=
name|checkNotNull
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|var
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|,
name|var
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|TypeVariableKey
condition|)
block|{
name|TypeVariableKey
name|that
init|=
operator|(
name|TypeVariableKey
operator|)
name|obj
decl_stmt|;
return|return
name|equalsTypeVariable
argument_list|(
name|that
operator|.
name|var
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|var
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable. */
DECL|method|forLookup (Type t)
specifier|static
name|Object
name|forLookup
parameter_list|(
name|Type
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|TypeVariable
condition|)
block|{
return|return
operator|new
name|TypeVariableKey
argument_list|(
operator|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
operator|)
name|t
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by      * the same {@code GenericDeclaration}.      */
DECL|method|equalsType (Type type)
name|boolean
name|equalsType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|TypeVariable
condition|)
block|{
return|return
name|equalsTypeVariable
argument_list|(
operator|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
operator|)
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|equalsTypeVariable (TypeVariable<?> that)
specifier|private
name|boolean
name|equalsTypeVariable
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|that
parameter_list|)
block|{
return|return
name|var
operator|.
name|getGenericDeclaration
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|)
operator|&&
name|var
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

