begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.reflect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|transform
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericArrayType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericDeclaration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|TypeVariable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|WildcardType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Utilities for working with {@link Type}.  *  * @author Ben Yu  */
end_comment

begin_class
DECL|class|Types
specifier|final
class|class
name|Types
block|{
comment|/** Class#toString without the "class " and "interface " prefixes */
DECL|field|TYPE_TO_STRING
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Type
argument_list|,
name|String
argument_list|>
name|TYPE_TO_STRING
init|=
operator|new
name|Function
argument_list|<
name|Type
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|Type
name|from
parameter_list|)
block|{
return|return
name|Types
operator|.
name|toString
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|COMMA_JOINER
specifier|private
specifier|static
specifier|final
name|Joiner
name|COMMA_JOINER
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|useForNull
argument_list|(
literal|"null"
argument_list|)
decl_stmt|;
comment|/** Returns the array type of {@code componentType}. */
DECL|method|newArrayType (Type componentType)
specifier|static
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
if|if
condition|(
name|componentType
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|wildcard
init|=
operator|(
name|WildcardType
operator|)
name|componentType
decl_stmt|;
name|Type
index|[]
name|lowerBounds
init|=
name|wildcard
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|lowerBounds
operator|.
name|length
operator|<=
literal|1
argument_list|,
literal|"Wildcard cannot have more than one lower bounds."
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|supertypeOf
argument_list|(
name|newArrayType
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|Type
index|[]
name|upperBounds
init|=
name|wildcard
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
name|checkArgument
argument_list|(
name|upperBounds
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"Wildcard should have only one upper bound."
argument_list|)
expr_stmt|;
return|return
name|subtypeOf
argument_list|(
name|newArrayType
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|newArrayType
argument_list|(
name|componentType
argument_list|)
return|;
block|}
comment|/**    * Returns a type where {@code rawType} is parameterized by    * {@code arguments} and is owned by {@code ownerType}.    */
DECL|method|newParameterizedTypeWithOwner ( @ullable Type ownerType, Class<?> rawType, Type... arguments)
specifier|static
name|ParameterizedType
name|newParameterizedTypeWithOwner
parameter_list|(
annotation|@
name|Nullable
name|Type
name|ownerType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
modifier|...
name|arguments
parameter_list|)
block|{
if|if
condition|(
name|ownerType
operator|==
literal|null
condition|)
block|{
return|return
name|newParameterizedType
argument_list|(
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|// ParameterizedTypeImpl constructor already checks, but we want to throw NPE before IAE
name|checkNotNull
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
operator|!=
literal|null
argument_list|,
literal|"Owner type for unenclosed %s"
argument_list|,
name|rawType
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParameterizedTypeImpl
argument_list|(
name|ownerType
argument_list|,
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/**    * Returns a type where {@code rawType} is parameterized by    * {@code arguments}.    */
DECL|method|newParameterizedType (Class<?> rawType, Type... arguments)
specifier|static
name|ParameterizedType
name|newParameterizedType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|ParameterizedTypeImpl
argument_list|(
name|ClassOwnership
operator|.
name|JVM_BEHAVIOR
operator|.
name|getOwnerType
argument_list|(
name|rawType
argument_list|)
argument_list|,
name|rawType
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/** Decides what owner type to use for constructing {@link ParameterizedType} from a raw class. */
DECL|enum|ClassOwnership
specifier|private
enum|enum
name|ClassOwnership
block|{
DECL|enumConstant|OWNED_BY_ENCLOSING_CLASS
name|OWNED_BY_ENCLOSING_CLASS
block|{
annotation|@
name|Nullable
annotation|@
name|Override
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
block|{
return|return
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|LOCAL_CLASS_HAS_NO_OWNER
name|LOCAL_CLASS_HAS_NO_OWNER
block|{
annotation|@
name|Nullable
annotation|@
name|Override
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
block|{
if|if
condition|(
name|rawType
operator|.
name|isLocalClass
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|rawType
operator|.
name|getEnclosingClass
argument_list|()
return|;
block|}
block|}
block|}
block|;
DECL|method|getOwnerType (Class<?> rawType)
annotation|@
name|Nullable
specifier|abstract
name|Class
argument_list|<
name|?
argument_list|>
name|getOwnerType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|)
function_decl|;
DECL|field|JVM_BEHAVIOR
specifier|static
specifier|final
name|ClassOwnership
name|JVM_BEHAVIOR
init|=
name|detectJvmBehavior
argument_list|()
decl_stmt|;
DECL|method|detectJvmBehavior ()
specifier|private
specifier|static
name|ClassOwnership
name|detectJvmBehavior
parameter_list|()
block|{
class|class
name|LocalClass
parameter_list|<
name|T
parameter_list|>
block|{}
name|Class
argument_list|<
name|?
argument_list|>
name|subclass
init|=
operator|new
name|LocalClass
argument_list|<
name|String
argument_list|>
argument_list|()
block|{}
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|ParameterizedType
name|parameterizedType
init|=
operator|(
name|ParameterizedType
operator|)
name|subclass
operator|.
name|getGenericSuperclass
argument_list|()
decl_stmt|;
for|for
control|(
name|ClassOwnership
name|behavior
range|:
name|ClassOwnership
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|behavior
operator|.
name|getOwnerType
argument_list|(
name|LocalClass
operator|.
name|class
argument_list|)
operator|==
name|parameterizedType
operator|.
name|getOwnerType
argument_list|()
condition|)
block|{
return|return
name|behavior
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**    * Returns a new {@link TypeVariable} that belongs to {@code declaration} with    * {@code name} and {@code bounds}.    */
DECL|method|newTypeVariable ( D declaration, String name, Type... bounds)
specifier|static
parameter_list|<
name|D
extends|extends
name|GenericDeclaration
parameter_list|>
name|TypeVariable
argument_list|<
name|D
argument_list|>
name|newTypeVariable
parameter_list|(
name|D
name|declaration
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
modifier|...
name|bounds
parameter_list|)
block|{
return|return
operator|new
name|TypeVariableImpl
argument_list|<
name|D
argument_list|>
argument_list|(
name|declaration
argument_list|,
name|name
argument_list|,
operator|(
name|bounds
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
operator|new
name|Type
index|[]
block|{
name|Object
operator|.
name|class
block|}
else|:
name|bounds
argument_list|)
return|;
block|}
comment|/** Returns a new {@link WildcardType} with {@code upperBound}. */
DECL|method|subtypeOf (Type upperBound)
annotation|@
name|VisibleForTesting
specifier|static
name|WildcardType
name|subtypeOf
parameter_list|(
name|Type
name|upperBound
parameter_list|)
block|{
return|return
operator|new
name|WildcardTypeImpl
argument_list|(
operator|new
name|Type
index|[
literal|0
index|]
argument_list|,
operator|new
name|Type
index|[]
block|{
name|upperBound
block|}
argument_list|)
return|;
block|}
comment|/** Returns a new {@link WildcardType} with {@code lowerBound}. */
DECL|method|supertypeOf (Type lowerBound)
annotation|@
name|VisibleForTesting
specifier|static
name|WildcardType
name|supertypeOf
parameter_list|(
name|Type
name|lowerBound
parameter_list|)
block|{
return|return
operator|new
name|WildcardTypeImpl
argument_list|(
operator|new
name|Type
index|[]
block|{
name|lowerBound
block|}
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Object
operator|.
name|class
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns human readable string representation of {@code type}.    *<ul>    *<li> For array type {@code Foo[]}, {@code "com.mypackage.Foo[]"} are    * returned.    *<li> For any class, {@code theClass.getName()} are returned.    *<li> For all other types, {@code type.toString()} are returned.    *</ul>    */
DECL|method|toString (Type type)
specifier|static
name|String
name|toString
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|instanceof
name|Class
operator|)
condition|?
operator|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
operator|)
operator|.
name|getName
argument_list|()
else|:
name|type
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getComponentType (Type type)
annotation|@
name|Nullable
specifier|static
name|Type
name|getComponentType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|Type
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Type
argument_list|>
argument_list|()
decl_stmt|;
operator|new
name|TypeVisitor
argument_list|()
block|{
annotation|@
name|Override
name|void
name|visitTypeVariable
parameter_list|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|subtypeOfComponentType
argument_list|(
name|t
operator|.
name|getBounds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitWildcardType
parameter_list|(
name|WildcardType
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|subtypeOfComponentType
argument_list|(
name|t
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitGenericArrayType
parameter_list|(
name|GenericArrayType
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|t
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|visitClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|result
operator|.
name|set
argument_list|(
name|t
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|visit
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null    * otherwise.    */
DECL|method|subtypeOfComponentType (Type[] bounds)
annotation|@
name|Nullable
specifier|private
specifier|static
name|Type
name|subtypeOfComponentType
parameter_list|(
name|Type
index|[]
name|bounds
parameter_list|)
block|{
for|for
control|(
name|Type
name|bound
range|:
name|bounds
control|)
block|{
name|Type
name|componentType
init|=
name|getComponentType
argument_list|(
name|bound
argument_list|)
decl_stmt|;
if|if
condition|(
name|componentType
operator|!=
literal|null
condition|)
block|{
comment|// Only the first bound can be a class or array.
comment|// Bounds after the first can only be interfaces.
if|if
condition|(
name|componentType
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|componentClass
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|componentType
decl_stmt|;
if|if
condition|(
name|componentClass
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
return|return
name|componentClass
return|;
block|}
block|}
return|return
name|subtypeOf
argument_list|(
name|componentType
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|class|GenericArrayTypeImpl
specifier|private
specifier|static
specifier|final
class|class
name|GenericArrayTypeImpl
implements|implements
name|GenericArrayType
implements|,
name|Serializable
block|{
DECL|field|componentType
specifier|private
specifier|final
name|Type
name|componentType
decl_stmt|;
DECL|method|GenericArrayTypeImpl (Type componentType)
name|GenericArrayTypeImpl
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
name|this
operator|.
name|componentType
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|componentType
argument_list|)
expr_stmt|;
block|}
DECL|method|getGenericComponentType ()
annotation|@
name|Override
specifier|public
name|Type
name|getGenericComponentType
parameter_list|()
block|{
return|return
name|componentType
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Types
operator|.
name|toString
argument_list|(
name|componentType
argument_list|)
operator|+
literal|"[]"
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|componentType
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|GenericArrayType
condition|)
block|{
name|GenericArrayType
name|that
init|=
operator|(
name|GenericArrayType
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|getGenericComponentType
argument_list|()
argument_list|,
name|that
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|ParameterizedTypeImpl
specifier|private
specifier|static
specifier|final
class|class
name|ParameterizedTypeImpl
implements|implements
name|ParameterizedType
implements|,
name|Serializable
block|{
DECL|field|ownerType
specifier|private
specifier|final
name|Type
name|ownerType
decl_stmt|;
DECL|field|argumentsList
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|argumentsList
decl_stmt|;
DECL|field|rawType
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
decl_stmt|;
DECL|method|ParameterizedTypeImpl ( @ullable Type ownerType, Class<?> rawType, Type[] typeArguments)
name|ParameterizedTypeImpl
parameter_list|(
annotation|@
name|Nullable
name|Type
name|ownerType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Type
index|[]
name|typeArguments
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|rawType
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|typeArguments
operator|.
name|length
operator|==
name|rawType
operator|.
name|getTypeParameters
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|disallowPrimitiveType
argument_list|(
name|typeArguments
argument_list|,
literal|"type parameter"
argument_list|)
expr_stmt|;
name|this
operator|.
name|ownerType
operator|=
name|ownerType
expr_stmt|;
name|this
operator|.
name|rawType
operator|=
name|rawType
expr_stmt|;
name|this
operator|.
name|argumentsList
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|typeArguments
argument_list|)
expr_stmt|;
block|}
DECL|method|getActualTypeArguments ()
annotation|@
name|Override
specifier|public
name|Type
index|[]
name|getActualTypeArguments
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|argumentsList
argument_list|)
return|;
block|}
DECL|method|getRawType ()
annotation|@
name|Override
specifier|public
name|Type
name|getRawType
parameter_list|()
block|{
return|return
name|rawType
return|;
block|}
DECL|method|getOwnerType ()
annotation|@
name|Override
specifier|public
name|Type
name|getOwnerType
parameter_list|()
block|{
return|return
name|ownerType
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|ownerType
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|Types
operator|.
name|toString
argument_list|(
name|ownerType
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|rawType
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'<'
argument_list|)
operator|.
name|append
argument_list|(
name|COMMA_JOINER
operator|.
name|join
argument_list|(
name|transform
argument_list|(
name|argumentsList
argument_list|,
name|TYPE_TO_STRING
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|ownerType
operator|==
literal|null
condition|?
literal|0
else|:
name|ownerType
operator|.
name|hashCode
argument_list|()
operator|)
operator|^
name|argumentsList
operator|.
name|hashCode
argument_list|()
operator|^
name|rawType
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object other)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|ParameterizedType
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ParameterizedType
name|that
init|=
operator|(
name|ParameterizedType
operator|)
name|other
decl_stmt|;
return|return
name|getRawType
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getRawType
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|getOwnerType
argument_list|()
argument_list|,
name|that
operator|.
name|getOwnerType
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|getActualTypeArguments
argument_list|()
argument_list|,
name|that
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|TypeVariableImpl
specifier|private
specifier|static
specifier|final
class|class
name|TypeVariableImpl
parameter_list|<
name|D
extends|extends
name|GenericDeclaration
parameter_list|>
implements|implements
name|TypeVariable
argument_list|<
name|D
argument_list|>
block|{
DECL|field|genericDeclaration
specifier|private
specifier|final
name|D
name|genericDeclaration
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|bounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|bounds
decl_stmt|;
DECL|method|TypeVariableImpl (D genericDeclaration, String name, Type[] bounds)
name|TypeVariableImpl
parameter_list|(
name|D
name|genericDeclaration
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
index|[]
name|bounds
parameter_list|)
block|{
name|disallowPrimitiveType
argument_list|(
name|bounds
argument_list|,
literal|"bound for type variable"
argument_list|)
expr_stmt|;
name|this
operator|.
name|genericDeclaration
operator|=
name|checkNotNull
argument_list|(
name|genericDeclaration
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|checkNotNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|bounds
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
DECL|method|getBounds ()
annotation|@
name|Override
specifier|public
name|Type
index|[]
name|getBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|bounds
argument_list|)
return|;
block|}
DECL|method|getGenericDeclaration ()
annotation|@
name|Override
specifier|public
name|D
name|getGenericDeclaration
parameter_list|()
block|{
return|return
name|genericDeclaration
return|;
block|}
DECL|method|getName ()
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|genericDeclaration
operator|.
name|hashCode
argument_list|()
operator|^
name|name
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|TypeVariable
condition|)
block|{
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|TypeVariable
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|genericDeclaration
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getGenericDeclaration
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|WildcardTypeImpl
specifier|static
specifier|final
class|class
name|WildcardTypeImpl
implements|implements
name|WildcardType
implements|,
name|Serializable
block|{
DECL|field|lowerBounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|lowerBounds
decl_stmt|;
DECL|field|upperBounds
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|upperBounds
decl_stmt|;
DECL|method|WildcardTypeImpl (Type[] lowerBounds, Type[] upperBounds)
name|WildcardTypeImpl
parameter_list|(
name|Type
index|[]
name|lowerBounds
parameter_list|,
name|Type
index|[]
name|upperBounds
parameter_list|)
block|{
name|disallowPrimitiveType
argument_list|(
name|lowerBounds
argument_list|,
literal|"lower bound for wildcard"
argument_list|)
expr_stmt|;
name|disallowPrimitiveType
argument_list|(
name|upperBounds
argument_list|,
literal|"upper bound for wildcard"
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowerBounds
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|lowerBounds
argument_list|)
expr_stmt|;
name|this
operator|.
name|upperBounds
operator|=
name|JavaVersion
operator|.
name|CURRENT
operator|.
name|usedInGenericType
argument_list|(
name|upperBounds
argument_list|)
expr_stmt|;
block|}
DECL|method|getLowerBounds ()
annotation|@
name|Override
specifier|public
name|Type
index|[]
name|getLowerBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|lowerBounds
argument_list|)
return|;
block|}
DECL|method|getUpperBounds ()
annotation|@
name|Override
specifier|public
name|Type
index|[]
name|getUpperBounds
parameter_list|()
block|{
return|return
name|toArray
argument_list|(
name|upperBounds
argument_list|)
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|that
init|=
operator|(
name|WildcardType
operator|)
name|obj
decl_stmt|;
return|return
name|lowerBounds
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|that
operator|.
name|getLowerBounds
argument_list|()
argument_list|)
argument_list|)
operator|&&
name|upperBounds
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|that
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|lowerBounds
operator|.
name|hashCode
argument_list|()
operator|^
name|upperBounds
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"?"
argument_list|)
decl_stmt|;
for|for
control|(
name|Type
name|lowerBound
range|:
name|lowerBounds
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" super "
argument_list|)
operator|.
name|append
argument_list|(
name|Types
operator|.
name|toString
argument_list|(
name|lowerBound
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Type
name|upperBound
range|:
name|filterUpperBounds
argument_list|(
name|upperBounds
argument_list|)
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" extends "
argument_list|)
operator|.
name|append
argument_list|(
name|Types
operator|.
name|toString
argument_list|(
name|upperBound
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|toArray (Collection<Type> types)
specifier|private
specifier|static
name|Type
index|[]
name|toArray
parameter_list|(
name|Collection
argument_list|<
name|Type
argument_list|>
name|types
parameter_list|)
block|{
return|return
name|types
operator|.
name|toArray
argument_list|(
operator|new
name|Type
index|[
name|types
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|filterUpperBounds (Iterable<Type> bounds)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|Type
argument_list|>
name|filterUpperBounds
parameter_list|(
name|Iterable
argument_list|<
name|Type
argument_list|>
name|bounds
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|filter
argument_list|(
name|bounds
argument_list|,
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
expr|<
name|Type
operator|>
name|equalTo
argument_list|(
name|Object
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|disallowPrimitiveType (Type[] types, String usedAs)
specifier|private
specifier|static
name|void
name|disallowPrimitiveType
parameter_list|(
name|Type
index|[]
name|types
parameter_list|,
name|String
name|usedAs
parameter_list|)
block|{
for|for
control|(
name|Type
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
decl_stmt|;
name|checkArgument
argument_list|(
operator|!
name|cls
operator|.
name|isPrimitive
argument_list|()
argument_list|,
literal|"Primitive type '%s' used as %s"
argument_list|,
name|cls
argument_list|,
name|usedAs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns the {@code Class} object of arrays with {@code componentType}. */
DECL|method|getArrayClass (Class<?> componentType)
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getArrayClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|componentType
parameter_list|)
block|{
comment|// TODO(user): This is not the most efficient way to handle generic
comment|// arrays, but is there another way to extract the array class in a
comment|// non-hacky way (i.e. using String value class names- "[L...")?
return|return
name|Array
operator|.
name|newInstance
argument_list|(
name|componentType
argument_list|,
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
return|;
block|}
comment|// TODO(benyu): Once we are on Java 7, delete this abstraction
DECL|enum|JavaVersion
enum|enum
name|JavaVersion
block|{
DECL|enumConstant|JAVA6
name|JAVA6
block|{
annotation|@
name|Override
name|GenericArrayType
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|componentType
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
decl_stmt|;
if|if
condition|(
name|cls
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|cls
operator|.
name|getComponentType
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|type
return|;
block|}
block|}
block|,
DECL|enumConstant|JAVA7
name|JAVA7
block|{
annotation|@
name|Override
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
if|if
condition|(
name|componentType
operator|instanceof
name|Class
condition|)
block|{
return|return
name|getArrayClass
argument_list|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|componentType
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|componentType
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|;
DECL|field|CURRENT
specifier|static
specifier|final
name|JavaVersion
name|CURRENT
init|=
operator|(
operator|new
name|TypeCapture
argument_list|<
name|int
index|[]
argument_list|>
argument_list|()
block|{}
operator|.
name|capture
argument_list|()
operator|instanceof
name|Class
block|)
operator|?
name|JAVA7
operator|:
name|JAVA6
enum|;
DECL|method|newArrayType (Type componentType)
specifier|abstract
name|Type
name|newArrayType
parameter_list|(
name|Type
name|componentType
parameter_list|)
function_decl|;
DECL|method|usedInGenericType (Type type)
specifier|abstract
name|Type
name|usedInGenericType
parameter_list|(
name|Type
name|type
parameter_list|)
function_decl|;
DECL|method|usedInGenericType (Type[] types)
specifier|final
name|ImmutableList
argument_list|<
name|Type
argument_list|>
name|usedInGenericType
parameter_list|(
name|Type
index|[]
name|types
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Type
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Type
name|type
range|:
name|types
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|usedInGenericType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
end_class

begin_constructor
DECL|method|Types ()
specifier|private
name|Types
parameter_list|()
block|{}
end_constructor

unit|}
end_unit

