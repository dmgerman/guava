begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|NEGATIVE_INFINITY
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|NaN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|POSITIVE_INFINITY
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|sort
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Doubles
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Provides a fluent API for calculating<a  * href="http://en.wikipedia.org/wiki/Quantile">quantiles</a>.  *  *<h3>Examples</h3>  *  *<p>To compute the median:  *  *<pre>{@code  * double myMedian = median().compute(myDataset);  * }</pre>  *  * where {@link #median()} has been statically imported.  *  *<p>To compute the 99th percentile:  *  *<pre>{@code  * double myPercentile99 = percentiles().index(99).compute(myDataset);  * }</pre>  *  * where {@link #percentiles()} has been statically imported.  *  *<p>To compute median and the 90th and 99th percentiles:  *  *<pre>{@code  * Map<Integer, Double> myPercentiles =  *     percentiles().indexes(50, 90, 99).compute(myDataset);  * }</pre>  *  * where {@link #percentiles()} has been statically imported: {@code myPercentiles} maps the keys  * 50, 90, and 99, to their corresponding quantile values.  *  *<p>To compute quartiles, use {@link #quartiles()} instead of {@link #percentiles()}. To compute  * arbitrary q-quantiles, use {@link #scale scale(q)}.  *  *<p>These examples all take a copy of your dataset. If you have a double array, you are okay with  * it being arbitrarily reordered, and you want to avoid that copy, you can use {@code  * computeInPlace} instead of {@code compute}.  *  *<h3>Definition and notes on interpolation</h3>  *  *<p>The definition of the kth q-quantile of N values is as follows: define x = k * (N - 1) / q; if  * x is an integer, the result is the value which would appear at index x in the sorted dataset  * (unless there are {@link Double#NaN NaN} values, see below); otherwise, the result is the average  * of the values which would appear at the indexes floor(x) and ceil(x) weighted by (1-frac(x)) and  * frac(x) respectively. This is the same definition as used by Excel and by S, it is the Type 7  * definition in<a  * href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html">R</a>, and it is  * described by<a  * href="http://en.wikipedia.org/wiki/Quantile#Estimating_the_quantiles_of_a_population">  * wikipedia</a> as providing "Linear interpolation of the modes for the order statistics for the  * uniform distribution on [0,1]."  *  *<h3>Handling of non-finite values</h3>  *  *<p>If any values in the input are {@link Double#NaN NaN} then all values returned are {@link  * Double#NaN NaN}. (This is the one occasion when the behaviour is not the same as you'd get from  * sorting with {@link java.util.Arrays#sort(double[]) Arrays.sort(double[])} or {@link  * java.util.Collections#sort(java.util.List) Collections.sort(List&lt;Double&gt;)} and selecting  * the required value(s). Those methods would sort {@link Double#NaN NaN} as if it is greater than  * any other value and place them at the end of the dataset, even after {@link  * Double#POSITIVE_INFINITY POSITIVE_INFINITY}.)  *  *<p>Otherwise, {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and {@link  * Double#POSITIVE_INFINITY POSITIVE_INFINITY} sort to the beginning and the end of the dataset, as  * you would expect.  *  *<p>If required to do a weighted average between an infinity and a finite value, or between an  * infinite value and itself, the infinite value is returned. If required to do a weighted average  * between {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and {@link Double#POSITIVE_INFINITY  * POSITIVE_INFINITY}, {@link Double#NaN NaN} is returned (note that this will only happen if the  * dataset contains no finite values).  *  *<h3>Performance</h3>  *  *<p>The average time complexity of the computation is O(N) in the size of the dataset. There is a  * worst case time complexity of O(N^2). You are extremely unlikely to hit this quadratic case on  * randomly ordered data (the probability decreases faster than exponentially in N), but if you are  * passing in unsanitized user data then a malicious user could force it. A light shuffle of the  * data using an unpredictable seed should normally be enough to thwart this attack.  *  *<p>The time taken to compute multiple quantiles on the same dataset using {@link Scale#indexes  * indexes} is generally less than the total time taken to compute each of them separately, and  * sometimes much less. For example, on a large enough dataset, computing the 90th and 99th  * percentiles together takes about 55% as long as computing them separately.  *  *<p>When calling {@link ScaleAndIndex#compute} (in {@linkplain ScaleAndIndexes#compute either  * form}), the memory requirement is 8*N bytes for the copy of the dataset plus an overhead which is  * independent of N (but depends on the quantiles being computed). When calling {@link  * ScaleAndIndex#computeInPlace computeInPlace} (in {@linkplain ScaleAndIndexes#computeInPlace  * either form}), only the overhead is required. The number of object allocations is independent of  * N in both cases.  *  * @author Pete Gillin  * @since 20.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|Quantiles
specifier|public
specifier|final
class|class
name|Quantiles
block|{
comment|/** Specifies the computation of a median (i.e. the 1st 2-quantile). */
DECL|method|median ()
specifier|public
specifier|static
name|ScaleAndIndex
name|median
parameter_list|()
block|{
return|return
name|scale
argument_list|(
literal|2
argument_list|)
operator|.
name|index
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/** Specifies the computation of quartiles (i.e. 4-quantiles). */
DECL|method|quartiles ()
specifier|public
specifier|static
name|Scale
name|quartiles
parameter_list|()
block|{
return|return
name|scale
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/** Specifies the computation of percentiles (i.e. 100-quantiles). */
DECL|method|percentiles ()
specifier|public
specifier|static
name|Scale
name|percentiles
parameter_list|()
block|{
return|return
name|scale
argument_list|(
literal|100
argument_list|)
return|;
block|}
comment|/**    * Specifies the computation of q-quantiles.    *    * @param scale the scale for the quantiles to be calculated, i.e. the q of the q-quantiles, which    *     must be positive    */
DECL|method|scale (int scale)
specifier|public
specifier|static
name|Scale
name|scale
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
return|return
operator|new
name|Scale
argument_list|(
name|scale
argument_list|)
return|;
block|}
comment|/**    * Describes the point in a fluent API chain where only the scale (i.e. the q in q-quantiles) has    * been specified.    *    * @since 20.0    */
DECL|class|Scale
specifier|public
specifier|static
specifier|final
class|class
name|Scale
block|{
DECL|field|scale
specifier|private
specifier|final
name|int
name|scale
decl_stmt|;
DECL|method|Scale (int scale)
specifier|private
name|Scale
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|scale
operator|>
literal|0
argument_list|,
literal|"Quantile scale must be positive"
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
block|}
comment|/**      * Specifies a single quantile index to be calculated, i.e. the k in the kth q-quantile.      *      * @param index the quantile index, which must be in the inclusive range [0, q] for q-quantiles      */
DECL|method|index (int index)
specifier|public
name|ScaleAndIndex
name|index
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|ScaleAndIndex
argument_list|(
name|scale
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**      * Specifies multiple quantile indexes to be calculated, each index being the k in the kth      * q-quantile.      *      * @param indexes the quantile indexes, each of which must be in the inclusive range [0, q] for      *     q-quantiles; the order of the indexes is unimportant, duplicates will be ignored, and the      *     set will be snapshotted when this method is called      * @throws IllegalArgumentException if {@code indexes} is empty      */
DECL|method|indexes (int... indexes)
specifier|public
name|ScaleAndIndexes
name|indexes
parameter_list|(
name|int
modifier|...
name|indexes
parameter_list|)
block|{
return|return
operator|new
name|ScaleAndIndexes
argument_list|(
name|scale
argument_list|,
name|indexes
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Specifies multiple quantile indexes to be calculated, each index being the k in the kth      * q-quantile.      *      * @param indexes the quantile indexes, each of which must be in the inclusive range [0, q] for      *     q-quantiles; the order of the indexes is unimportant, duplicates will be ignored, and the      *     set will be snapshotted when this method is called      * @throws IllegalArgumentException if {@code indexes} is empty      */
DECL|method|indexes (Collection<Integer> indexes)
specifier|public
name|ScaleAndIndexes
name|indexes
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|)
block|{
return|return
operator|new
name|ScaleAndIndexes
argument_list|(
name|scale
argument_list|,
name|Ints
operator|.
name|toArray
argument_list|(
name|indexes
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Describes the point in a fluent API chain where the scale and a single quantile index (i.e. the    * q and the k in the kth q-quantile) have been specified.    *    * @since 20.0    */
DECL|class|ScaleAndIndex
specifier|public
specifier|static
specifier|final
class|class
name|ScaleAndIndex
block|{
DECL|field|scale
specifier|private
specifier|final
name|int
name|scale
decl_stmt|;
DECL|field|index
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
DECL|method|ScaleAndIndex (int scale, int index)
specifier|private
name|ScaleAndIndex
parameter_list|(
name|int
name|scale
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|checkIndex
argument_list|(
name|index
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
comment|/**      * Computes the quantile value of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles (with any associated lost of precision), and which will not be mutated by      *     this call (it is copied instead)      * @return the quantile value      */
DECL|method|compute (Collection<? extends Number> dataset)
specifier|public
name|double
name|compute
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|Doubles
operator|.
name|toArray
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile value of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will not      *     be mutated by this call (it is copied instead)      * @return the quantile value      */
DECL|method|compute (double... dataset)
specifier|public
name|double
name|compute
parameter_list|(
name|double
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|dataset
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile value of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles (with any associated lost of precision), and which will not be mutated by      *     this call (it is copied instead)      * @return the quantile value      */
DECL|method|compute (long... dataset)
specifier|public
name|double
name|compute
parameter_list|(
name|long
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|longsToDoubles
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile value of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles, and which will not be mutated by this call (it is copied instead)      * @return the quantile value      */
DECL|method|compute (int... dataset)
specifier|public
name|double
name|compute
parameter_list|(
name|int
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|intsToDoubles
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile value of the given dataset, performing the computation in-place.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, and which will      *     be arbitrarily reordered by this method call      * @return the quantile value      */
DECL|method|computeInPlace (double... dataset)
specifier|public
name|double
name|computeInPlace
parameter_list|(
name|double
modifier|...
name|dataset
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|dataset
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"Cannot calculate quantiles of an empty dataset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsNaN
argument_list|(
name|dataset
argument_list|)
condition|)
block|{
return|return
name|NaN
return|;
block|}
comment|// Calculate the quotient and remainder in the integer division x = k * (N-1) / q, i.e.
comment|// index * (dataset.length - 1) / scale. If there is no remainder, we can just find the value
comment|// whose index in the sorted dataset equals the quotient; if there is a remainder, we
comment|// interpolate between that and the next value.
comment|// Since index and (dataset.length - 1) are non-negative ints, their product can be expressed
comment|// as a long, without risk of overflow:
name|long
name|numerator
init|=
operator|(
name|long
operator|)
name|index
operator|*
operator|(
name|dataset
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
comment|// non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to get
comment|// a rounded ratio and a remainder which can be expressed as ints, without risk of overflow:
name|int
name|quotient
init|=
operator|(
name|int
operator|)
name|LongMath
operator|.
name|divide
argument_list|(
name|numerator
argument_list|,
name|scale
argument_list|,
name|RoundingMode
operator|.
name|DOWN
argument_list|)
decl_stmt|;
name|int
name|remainder
init|=
call|(
name|int
call|)
argument_list|(
name|numerator
operator|-
operator|(
name|long
operator|)
name|quotient
operator|*
name|scale
argument_list|)
decl_stmt|;
name|selectInPlace
argument_list|(
name|quotient
argument_list|,
name|dataset
argument_list|,
literal|0
argument_list|,
name|dataset
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
return|return
name|dataset
index|[
name|quotient
index|]
return|;
block|}
else|else
block|{
name|selectInPlace
argument_list|(
name|quotient
operator|+
literal|1
argument_list|,
name|dataset
argument_list|,
name|quotient
operator|+
literal|1
argument_list|,
name|dataset
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|interpolate
argument_list|(
name|dataset
index|[
name|quotient
index|]
argument_list|,
name|dataset
index|[
name|quotient
operator|+
literal|1
index|]
argument_list|,
name|remainder
argument_list|,
name|scale
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Describes the point in a fluent API chain where the scale and a multiple quantile indexes (i.e.    * the q and a set of values for the k in the kth q-quantile) have been specified.    *    * @since 20.0    */
DECL|class|ScaleAndIndexes
specifier|public
specifier|static
specifier|final
class|class
name|ScaleAndIndexes
block|{
DECL|field|scale
specifier|private
specifier|final
name|int
name|scale
decl_stmt|;
DECL|field|indexes
specifier|private
specifier|final
name|int
index|[]
name|indexes
decl_stmt|;
DECL|method|ScaleAndIndexes (int scale, int[] indexes)
specifier|private
name|ScaleAndIndexes
parameter_list|(
name|int
name|scale
parameter_list|,
name|int
index|[]
name|indexes
parameter_list|)
block|{
for|for
control|(
name|int
name|index
range|:
name|indexes
control|)
block|{
name|checkIndex
argument_list|(
name|index
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|checkArgument
argument_list|(
name|indexes
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"Indexes must be a non empty array"
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
name|this
operator|.
name|indexes
operator|=
name|indexes
expr_stmt|;
block|}
comment|/**      * Computes the quantile values of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles (with any associated lost of precision), and which will not be mutated by      *     this call (it is copied instead)      * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and      *     the values the corresponding quantile values      */
DECL|method|compute (Collection<? extends Number> dataset)
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|compute
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|Doubles
operator|.
name|toArray
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile values of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will not      *     be mutated by this call (it is copied instead)      * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and      *     the values the corresponding quantile values      */
DECL|method|compute (double... dataset)
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|compute
parameter_list|(
name|double
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|dataset
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile values of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles (with any associated lost of precision), and which will not be mutated by      *     this call (it is copied instead)      * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and      *     the values the corresponding quantile values      */
DECL|method|compute (long... dataset)
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|compute
parameter_list|(
name|long
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|longsToDoubles
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile values of the given dataset.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be      *     cast to doubles, and which will not be mutated by this call (it is copied instead)      * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and      *     the values the corresponding quantile values      */
DECL|method|compute (int... dataset)
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|compute
parameter_list|(
name|int
modifier|...
name|dataset
parameter_list|)
block|{
return|return
name|computeInPlace
argument_list|(
name|intsToDoubles
argument_list|(
name|dataset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Computes the quantile values of the given dataset, performing the computation in-place.      *      * @param dataset the dataset to do the calculation on, which must be non-empty, and which will      *     be arbitrarily reordered by this method call      * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and      *     the values the corresponding quantile values      */
DECL|method|computeInPlace (double... dataset)
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|computeInPlace
parameter_list|(
name|double
modifier|...
name|dataset
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|dataset
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"Cannot calculate quantiles of an empty dataset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsNaN
argument_list|(
name|dataset
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|nanMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|indexes
control|)
block|{
name|nanMap
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|NaN
argument_list|)
expr_stmt|;
block|}
return|return
name|unmodifiableMap
argument_list|(
name|nanMap
argument_list|)
return|;
block|}
comment|// Calculate the quotients and remainders in the integer division x = k * (N - 1) / q, i.e.
comment|// index * (dataset.length - 1) / scale for each index in indexes. For each, if there is no
comment|// remainder, we can just select the value whose index in the sorted dataset equals the
comment|// quotient; if there is a remainder, we interpolate between that and the next value.
name|int
index|[]
name|quotients
init|=
operator|new
name|int
index|[
name|indexes
operator|.
name|length
index|]
decl_stmt|;
name|int
index|[]
name|remainders
init|=
operator|new
name|int
index|[
name|indexes
operator|.
name|length
index|]
decl_stmt|;
comment|// The indexes to select. In the worst case, we'll need one each side of each quantile.
name|int
index|[]
name|requiredSelections
init|=
operator|new
name|int
index|[
name|indexes
operator|.
name|length
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|requiredSelectionsCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Since index and (dataset.length - 1) are non-negative ints, their product can be
comment|// expressed as a long, without risk of overflow:
name|long
name|numerator
init|=
operator|(
name|long
operator|)
name|indexes
index|[
name|i
index|]
operator|*
operator|(
name|dataset
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Since scale is a positive int, index is in [0, scale], and (dataset.length - 1) is a
comment|// non-negative int, we can do long-arithmetic on index * (dataset.length - 1) / scale to
comment|// get a rounded ratio and a remainder which can be expressed as ints, without risk of
comment|// overflow:
name|int
name|quotient
init|=
operator|(
name|int
operator|)
name|LongMath
operator|.
name|divide
argument_list|(
name|numerator
argument_list|,
name|scale
argument_list|,
name|RoundingMode
operator|.
name|DOWN
argument_list|)
decl_stmt|;
name|int
name|remainder
init|=
call|(
name|int
call|)
argument_list|(
name|numerator
operator|-
operator|(
name|long
operator|)
name|quotient
operator|*
name|scale
argument_list|)
decl_stmt|;
name|quotients
index|[
name|i
index|]
operator|=
name|quotient
expr_stmt|;
name|remainders
index|[
name|i
index|]
operator|=
name|remainder
expr_stmt|;
name|requiredSelections
index|[
name|requiredSelectionsCount
index|]
operator|=
name|quotient
expr_stmt|;
name|requiredSelectionsCount
operator|++
expr_stmt|;
if|if
condition|(
name|remainder
operator|!=
literal|0
condition|)
block|{
name|requiredSelections
index|[
name|requiredSelectionsCount
index|]
operator|=
name|quotient
operator|+
literal|1
expr_stmt|;
name|requiredSelectionsCount
operator|++
expr_stmt|;
block|}
block|}
name|sort
argument_list|(
name|requiredSelections
argument_list|,
literal|0
argument_list|,
name|requiredSelectionsCount
argument_list|)
expr_stmt|;
name|selectAllInPlace
argument_list|(
name|requiredSelections
argument_list|,
literal|0
argument_list|,
name|requiredSelectionsCount
operator|-
literal|1
argument_list|,
name|dataset
argument_list|,
literal|0
argument_list|,
name|dataset
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|ret
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|quotient
init|=
name|quotients
index|[
name|i
index|]
decl_stmt|;
name|int
name|remainder
init|=
name|remainders
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
name|ret
operator|.
name|put
argument_list|(
name|indexes
index|[
name|i
index|]
argument_list|,
name|dataset
index|[
name|quotient
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|put
argument_list|(
name|indexes
index|[
name|i
index|]
argument_list|,
name|interpolate
argument_list|(
name|dataset
index|[
name|quotient
index|]
argument_list|,
name|dataset
index|[
name|quotient
operator|+
literal|1
index|]
argument_list|,
name|remainder
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|unmodifiableMap
argument_list|(
name|ret
argument_list|)
return|;
block|}
block|}
comment|/** Returns whether any of the values in {@code dataset} are {@code NaN}. */
DECL|method|containsNaN (double... dataset)
specifier|private
specifier|static
name|boolean
name|containsNaN
parameter_list|(
name|double
modifier|...
name|dataset
parameter_list|)
block|{
for|for
control|(
name|double
name|value
range|:
name|dataset
control|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns a value a fraction {@code (remainder / scale)} of the way between {@code lower} and    * {@code upper}. Assumes that {@code lower<= upper}. Correctly handles infinities (but not    * {@code NaN}).    */
DECL|method|interpolate (double lower, double upper, double remainder, double scale)
specifier|private
specifier|static
name|double
name|interpolate
parameter_list|(
name|double
name|lower
parameter_list|,
name|double
name|upper
parameter_list|,
name|double
name|remainder
parameter_list|,
name|double
name|scale
parameter_list|)
block|{
if|if
condition|(
name|lower
operator|==
name|NEGATIVE_INFINITY
condition|)
block|{
if|if
condition|(
name|upper
operator|==
name|POSITIVE_INFINITY
condition|)
block|{
comment|// Return NaN when lower == NEGATIVE_INFINITY and upper == POSITIVE_INFINITY:
return|return
name|NaN
return|;
block|}
comment|// Return NEGATIVE_INFINITY when NEGATIVE_INFINITY == lower<= upper< POSITIVE_INFINITY:
return|return
name|NEGATIVE_INFINITY
return|;
block|}
if|if
condition|(
name|upper
operator|==
name|POSITIVE_INFINITY
condition|)
block|{
comment|// Return POSITIVE_INFINITY when NEGATIVE_INFINITY< lower<= upper == POSITIVE_INFINITY:
return|return
name|POSITIVE_INFINITY
return|;
block|}
return|return
name|lower
operator|+
operator|(
name|upper
operator|-
name|lower
operator|)
operator|*
name|remainder
operator|/
name|scale
return|;
block|}
DECL|method|checkIndex (int index, int scale)
specifier|private
specifier|static
name|void
name|checkIndex
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|scale
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Quantile indexes must be between 0 and the scale, which is "
operator|+
name|scale
argument_list|)
throw|;
block|}
block|}
DECL|method|longsToDoubles (long[] longs)
specifier|private
specifier|static
name|double
index|[]
name|longsToDoubles
parameter_list|(
name|long
index|[]
name|longs
parameter_list|)
block|{
name|int
name|len
init|=
name|longs
operator|.
name|length
decl_stmt|;
name|double
index|[]
name|doubles
init|=
operator|new
name|double
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|doubles
index|[
name|i
index|]
operator|=
name|longs
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|doubles
return|;
block|}
DECL|method|intsToDoubles (int[] ints)
specifier|private
specifier|static
name|double
index|[]
name|intsToDoubles
parameter_list|(
name|int
index|[]
name|ints
parameter_list|)
block|{
name|int
name|len
init|=
name|ints
operator|.
name|length
decl_stmt|;
name|double
index|[]
name|doubles
init|=
operator|new
name|double
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|doubles
index|[
name|i
index|]
operator|=
name|ints
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|doubles
return|;
block|}
comment|/**    * Performs an in-place selection to find the element which would appear at a given index in a    * dataset if it were sorted. The following preconditions should hold:    *    *<ul>    *<li>{@code required}, {@code from}, and {@code to} should all be indexes into {@code array};    *<li>{@code required} should be in the range [{@code from}, {@code to}];    *<li>all the values with indexes in the range [0, {@code from}) should be less than or equal    *       to all the values with indexes in the range [{@code from}, {@code to}];    *<li>all the values with indexes in the range ({@code to}, {@code array.length - 1}] should be    *       greater than or equal to all the values with indexes in the range [{@code from}, {@code    *       to}].    *</ul>    *    * This method will reorder the values with indexes in the range [{@code from}, {@code to}] such    * that all the values with indexes in the range [{@code from}, {@code required}) are less than or    * equal to the value with index {@code required}, and all the values with indexes in the range    * ({@code required}, {@code to}] are greater than or equal to that value. Therefore, the value at    * {@code required} is the value which would appear at that index in the sorted dataset.    */
DECL|method|selectInPlace (int required, double[] array, int from, int to)
specifier|private
specifier|static
name|void
name|selectInPlace
parameter_list|(
name|int
name|required
parameter_list|,
name|double
index|[]
name|array
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|// If we are looking for the least element in the range, we can just do a linear search for it.
comment|// (We will hit this whenever we are doing quantile interpolation: our first selection finds
comment|// the lower value, our second one finds the upper value by looking for the next least element.)
if|if
condition|(
name|required
operator|==
name|from
condition|)
block|{
name|int
name|min
init|=
name|from
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
name|from
operator|+
literal|1
init|;
name|index
operator|<=
name|to
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|array
index|[
name|min
index|]
operator|>
name|array
index|[
name|index
index|]
condition|)
block|{
name|min
operator|=
name|index
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|!=
name|from
condition|)
block|{
name|swap
argument_list|(
name|array
argument_list|,
name|min
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Let's play quickselect! We'll repeatedly partition the range [from, to] containing the
comment|// required element, as long as it has more than one element.
while|while
condition|(
name|to
operator|>
name|from
condition|)
block|{
name|int
name|partitionPoint
init|=
name|partition
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionPoint
operator|>=
name|required
condition|)
block|{
name|to
operator|=
name|partitionPoint
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|partitionPoint
operator|<=
name|required
condition|)
block|{
name|from
operator|=
name|partitionPoint
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Performs a partition operation on the slice of {@code array} with elements in the range [{@code    * from}, {@code to}]. Uses the median of {@code from}, {@code to}, and the midpoint between them    * as a pivot. Returns the index which the slice is partitioned around, i.e. if it returns {@code    * ret} then we know that the values with indexes in [{@code from}, {@code ret}) are less than or    * equal to the value at {@code ret} and the values with indexes in ({@code ret}, {@code to}] are    * greater than or equal to that.    */
DECL|method|partition (double[] array, int from, int to)
specifier|private
specifier|static
name|int
name|partition
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|// Select a pivot, and move it to the start of the slice i.e. to index from.
name|movePivotToStartOfSlice
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|double
name|pivot
init|=
name|array
index|[
name|from
index|]
decl_stmt|;
comment|// Move all elements with indexes in (from, to] which are greater than the pivot to the end of
comment|// the array. Keep track of where those elements begin.
name|int
name|partitionPoint
init|=
name|to
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|to
init|;
name|i
operator|>
name|from
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|>
name|pivot
condition|)
block|{
name|swap
argument_list|(
name|array
argument_list|,
name|partitionPoint
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|partitionPoint
operator|--
expr_stmt|;
block|}
block|}
comment|// We now know that all elements with indexes in (from, partitionPoint] are less than or equal
comment|// to the pivot at from, and all elements with indexes in (partitionPoint, to] are greater than
comment|// it. We swap the pivot into partitionPoint and we know the array is partitioned around that.
name|swap
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|partitionPoint
argument_list|)
expr_stmt|;
return|return
name|partitionPoint
return|;
block|}
comment|/**    * Selects the pivot to use, namely the median of the values at {@code from}, {@code to}, and    * halfway between the two (rounded down), from {@code array}, and ensure (by swapping elements if    * necessary) that that pivot value appears at the start of the slice i.e. at {@code from}.    * Expects that {@code from} is strictly less than {@code to}.    */
DECL|method|movePivotToStartOfSlice (double[] array, int from, int to)
specifier|private
specifier|static
name|void
name|movePivotToStartOfSlice
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|int
name|mid
init|=
operator|(
name|from
operator|+
name|to
operator|)
operator|>>>
literal|1
decl_stmt|;
comment|// We want to make a swap such that either array[to]<= array[from]<= array[mid], or
comment|// array[mid]<= array[from]<= array[to]. We know that from< to, so we know mid< to
comment|// (although it's possible that mid == from, if to == from + 1). Note that the postcondition
comment|// would be impossible to fulfil if mid == to unless we also have array[from] == array[to].
name|boolean
name|toLessThanMid
init|=
operator|(
name|array
index|[
name|to
index|]
operator|<
name|array
index|[
name|mid
index|]
operator|)
decl_stmt|;
name|boolean
name|midLessThanFrom
init|=
operator|(
name|array
index|[
name|mid
index|]
operator|<
name|array
index|[
name|from
index|]
operator|)
decl_stmt|;
name|boolean
name|toLessThanFrom
init|=
operator|(
name|array
index|[
name|to
index|]
operator|<
name|array
index|[
name|from
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|toLessThanMid
operator|==
name|midLessThanFrom
condition|)
block|{
comment|// Either array[to]< array[mid]< array[from] or array[from]<= array[mid]<= array[to].
name|swap
argument_list|(
name|array
argument_list|,
name|mid
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toLessThanMid
operator|!=
name|toLessThanFrom
condition|)
block|{
comment|// Either array[from]<= array[to]< array[mid] or array[mid]<= array[to]< array[from].
name|swap
argument_list|(
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|// The postcondition now holds. So the median, our chosen pivot, is at from.
block|}
comment|/**    * Performs an in-place selection, like {@link #selectInPlace}, to select all the indexes {@code    * allRequired[i]} for {@code i} in the range [{@code requiredFrom}, {@code requiredTo}]. These    * indexes must be sorted in the array and must all be in the range [{@code from}, {@code to}].    */
DECL|method|selectAllInPlace ( int[] allRequired, int requiredFrom, int requiredTo, double[] array, int from, int to)
specifier|private
specifier|static
name|void
name|selectAllInPlace
parameter_list|(
name|int
index|[]
name|allRequired
parameter_list|,
name|int
name|requiredFrom
parameter_list|,
name|int
name|requiredTo
parameter_list|,
name|double
index|[]
name|array
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|// Choose the first selection to do...
name|int
name|requiredChosen
init|=
name|chooseNextSelection
argument_list|(
name|allRequired
argument_list|,
name|requiredFrom
argument_list|,
name|requiredTo
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
name|int
name|required
init|=
name|allRequired
index|[
name|requiredChosen
index|]
decl_stmt|;
comment|// ...do the first selection...
name|selectInPlace
argument_list|(
name|required
argument_list|,
name|array
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|// ...then recursively perform the selections in the range below...
name|int
name|requiredBelow
init|=
name|requiredChosen
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|requiredBelow
operator|>=
name|requiredFrom
operator|&&
name|allRequired
index|[
name|requiredBelow
index|]
operator|==
name|required
condition|)
block|{
name|requiredBelow
operator|--
expr_stmt|;
comment|// skip duplicates of required in the range below
block|}
if|if
condition|(
name|requiredBelow
operator|>=
name|requiredFrom
condition|)
block|{
name|selectAllInPlace
argument_list|(
name|allRequired
argument_list|,
name|requiredFrom
argument_list|,
name|requiredBelow
argument_list|,
name|array
argument_list|,
name|from
argument_list|,
name|required
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// ...and then recursively perform the selections in the range above.
name|int
name|requiredAbove
init|=
name|requiredChosen
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|requiredAbove
operator|<=
name|requiredTo
operator|&&
name|allRequired
index|[
name|requiredAbove
index|]
operator|==
name|required
condition|)
block|{
name|requiredAbove
operator|++
expr_stmt|;
comment|// skip duplicates of required in the range above
block|}
if|if
condition|(
name|requiredAbove
operator|<=
name|requiredTo
condition|)
block|{
name|selectAllInPlace
argument_list|(
name|allRequired
argument_list|,
name|requiredAbove
argument_list|,
name|requiredTo
argument_list|,
name|array
argument_list|,
name|required
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Chooses the next selection to do from the required selections. It is required that the array    * {@code allRequired} is sorted and that {@code allRequired[i]} are in the range [{@code from},    * {@code to}] for all {@code i} in the range [{@code requiredFrom}, {@code requiredTo}]. The    * value returned by this method is the {@code i} in that range such that {@code allRequired[i]}    * is as close as possible to the center of the range [{@code from}, {@code to}]. Choosing the    * value closest to the center of the range first is the most efficient strategy because it    * minimizes the size of the subranges from which the remaining selections must be done.    */
DECL|method|chooseNextSelection ( int[] allRequired, int requiredFrom, int requiredTo, int from, int to)
specifier|private
specifier|static
name|int
name|chooseNextSelection
parameter_list|(
name|int
index|[]
name|allRequired
parameter_list|,
name|int
name|requiredFrom
parameter_list|,
name|int
name|requiredTo
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|requiredFrom
operator|==
name|requiredTo
condition|)
block|{
return|return
name|requiredFrom
return|;
comment|// only one thing to choose, so choose it
block|}
comment|// Find the center and round down. The true center is either centerFloor or halfway between
comment|// centerFloor and centerFloor + 1.
name|int
name|centerFloor
init|=
operator|(
name|from
operator|+
name|to
operator|)
operator|>>>
literal|1
decl_stmt|;
comment|// Do a binary search until we're down to the range of two which encloses centerFloor (unless
comment|// all values are lower or higher than centerFloor, in which case we find the two highest or
comment|// lowest respectively). If centerFloor is in allRequired, we will definitely find it. If not,
comment|// but centerFloor + 1 is, we'll definitely find that. The closest value to the true (unrounded)
comment|// center will be at either low or high.
name|int
name|low
init|=
name|requiredFrom
decl_stmt|;
name|int
name|high
init|=
name|requiredTo
decl_stmt|;
while|while
condition|(
name|high
operator|>
name|low
operator|+
literal|1
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|allRequired
index|[
name|mid
index|]
operator|>
name|centerFloor
condition|)
block|{
name|high
operator|=
name|mid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allRequired
index|[
name|mid
index|]
operator|<
name|centerFloor
condition|)
block|{
name|low
operator|=
name|mid
expr_stmt|;
block|}
else|else
block|{
return|return
name|mid
return|;
comment|// allRequired[mid] = centerFloor, so we can't get closer than that
block|}
block|}
comment|// Now pick the closest of the two candidates. Note that there is no rounding here.
if|if
condition|(
name|from
operator|+
name|to
operator|-
name|allRequired
index|[
name|low
index|]
operator|-
name|allRequired
index|[
name|high
index|]
operator|>
literal|0
condition|)
block|{
return|return
name|high
return|;
block|}
else|else
block|{
return|return
name|low
return|;
block|}
block|}
comment|/** Swaps the values at {@code i} and {@code j} in {@code array}. */
DECL|method|swap (double[] array, int i, int j)
specifier|private
specifier|static
name|void
name|swap
parameter_list|(
name|double
index|[]
name|array
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|double
name|temp
init|=
name|array
index|[
name|i
index|]
decl_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_class

end_unit

