begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkNoOverflow
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkNonNegative
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkPositive
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkRoundingUnnecessary
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|abs
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|HALF_EVEN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|HALF_UP
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|UnsignedLongs
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_comment
comment|/**  * A class for arithmetic on values of type {@code long}. Where possible, methods are defined and  * named analogously to their {@code BigInteger} counterparts.  *  *<p>The implementations of many methods in this class are based on material from Henry S. Warren,  * Jr.'s<i>Hacker's Delight</i>, (Addison Wesley, 2002).  *  *<p>Similar functionality for {@code int} and for {@link BigInteger} can be found in  * {@link IntMath} and {@link BigIntegerMath} respectively.  For other common operations on  * {@code long} values, see {@link com.google.common.primitives.Longs}.  *  * @author Louis Wasserman  * @since 11.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|LongMath
specifier|public
specifier|final
class|class
name|LongMath
block|{
comment|// NOTE: Whenever both tests are cheap and functional, it's faster to use&, | instead of&&, ||
comment|/**    * Returns {@code true} if {@code x} represents a power of two.    *    *<p>This differs from {@code Long.bitCount(x) == 1}, because    * {@code Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.    */
DECL|method|isPowerOfTwo (long x)
specifier|public
specifier|static
name|boolean
name|isPowerOfTwo
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
name|x
operator|>
literal|0
operator|&
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
comment|/**    * Returns 1 if {@code x< y} as unsigned longs, and 0 otherwise.  Assumes that x - y fits into a    * signed long.  The implementation is branch-free, and benchmarks suggest it is measurably    * faster than the straightforward ternary expression.    */
annotation|@
name|VisibleForTesting
DECL|method|lessThanBranchFree (long x, long y)
specifier|static
name|int
name|lessThanBranchFree
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
comment|// Returns the sign bit of x - y.
return|return
call|(
name|int
call|)
argument_list|(
operator|~
operator|~
operator|(
name|x
operator|-
name|y
operator|)
operator|>>>
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|/**    * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.    *    * @throws IllegalArgumentException if {@code x<= 0}    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}    *         is not a power of two    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
comment|// TODO(kevinb): remove after this warning is disabled globally
DECL|method|log2 (long x, RoundingMode mode)
specifier|public
specifier|static
name|int
name|log2
parameter_list|(
name|long
name|x
parameter_list|,
name|RoundingMode
name|mode
parameter_list|)
block|{
name|checkPositive
argument_list|(
literal|"x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNNECESSARY
case|:
name|checkRoundingUnnecessary
argument_list|(
name|isPowerOfTwo
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DOWN
case|:
case|case
name|FLOOR
case|:
return|return
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|x
argument_list|)
return|;
case|case
name|UP
case|:
case|case
name|CEILING
case|:
return|return
name|Long
operator|.
name|SIZE
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|x
operator|-
literal|1
argument_list|)
return|;
case|case
name|HALF_DOWN
case|:
case|case
name|HALF_UP
case|:
case|case
name|HALF_EVEN
case|:
comment|// Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5
name|int
name|leadingZeros
init|=
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|long
name|cmp
init|=
name|MAX_POWER_OF_SQRT2_UNSIGNED
operator|>>>
name|leadingZeros
decl_stmt|;
comment|// floor(2^(logFloor + 0.5))
name|int
name|logFloor
init|=
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator|-
name|leadingZeros
decl_stmt|;
return|return
name|logFloor
operator|+
name|lessThanBranchFree
argument_list|(
name|cmp
argument_list|,
name|x
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"impossible"
argument_list|)
throw|;
block|}
block|}
comment|/** The biggest half power of two that fits into an unsigned long */
DECL|field|MAX_POWER_OF_SQRT2_UNSIGNED
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|long
name|MAX_POWER_OF_SQRT2_UNSIGNED
init|=
literal|0xB504F333F9DE6484L
decl_stmt|;
comment|/**    * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.    *    * @throws IllegalArgumentException if {@code x<= 0}    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}    *         is not a power of ten    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
comment|// TODO(kevinb): remove after this warning is disabled globally
DECL|method|log10 (long x, RoundingMode mode)
specifier|public
specifier|static
name|int
name|log10
parameter_list|(
name|long
name|x
parameter_list|,
name|RoundingMode
name|mode
parameter_list|)
block|{
name|checkPositive
argument_list|(
literal|"x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|int
name|logFloor
init|=
name|log10Floor
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|long
name|floorPow
init|=
name|powersOf10
index|[
name|logFloor
index|]
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNNECESSARY
case|:
name|checkRoundingUnnecessary
argument_list|(
name|x
operator|==
name|floorPow
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|FLOOR
case|:
case|case
name|DOWN
case|:
return|return
name|logFloor
return|;
case|case
name|CEILING
case|:
case|case
name|UP
case|:
return|return
name|logFloor
operator|+
name|lessThanBranchFree
argument_list|(
name|floorPow
argument_list|,
name|x
argument_list|)
return|;
case|case
name|HALF_DOWN
case|:
case|case
name|HALF_UP
case|:
case|case
name|HALF_EVEN
case|:
comment|// sqrt(10) is irrational, so log10(x)-logFloor is never exactly 0.5
return|return
name|logFloor
operator|+
name|lessThanBranchFree
argument_list|(
name|halfPowersOf10
index|[
name|logFloor
index|]
argument_list|,
name|x
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|log10Floor (long x)
specifier|static
name|int
name|log10Floor
parameter_list|(
name|long
name|x
parameter_list|)
block|{
comment|/*      * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.      *      * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),      * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x))      * is 6, then 64<= x< 128, so floor(log10(x)) is either 1 or 2.      */
name|int
name|y
init|=
name|maxLog10ForLeadingZeros
index|[
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
comment|/*      * y is the higher of the two possible values of floor(log10(x)). If x< 10^y, then we want the      * lower of the two possible values, or y - 1, otherwise, we want y.      */
return|return
name|y
operator|-
name|lessThanBranchFree
argument_list|(
name|x
argument_list|,
name|powersOf10
index|[
name|y
index|]
argument_list|)
return|;
block|}
comment|// maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))
DECL|field|maxLog10ForLeadingZeros
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|byte
index|[]
name|maxLog10ForLeadingZeros
init|=
block|{
literal|19
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|field|powersOf10
specifier|static
specifier|final
name|long
index|[]
name|powersOf10
init|=
block|{
literal|1L
block|,
literal|10L
block|,
literal|100L
block|,
literal|1000L
block|,
literal|10000L
block|,
literal|100000L
block|,
literal|1000000L
block|,
literal|10000000L
block|,
literal|100000000L
block|,
literal|1000000000L
block|,
literal|10000000000L
block|,
literal|100000000000L
block|,
literal|1000000000000L
block|,
literal|10000000000000L
block|,
literal|100000000000000L
block|,
literal|1000000000000000L
block|,
literal|10000000000000000L
block|,
literal|100000000000000000L
block|,
literal|1000000000000000000L
block|}
decl_stmt|;
comment|// halfPowersOf10[i] = largest long less than 10^(i + 0.5)
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|field|halfPowersOf10
specifier|static
specifier|final
name|long
index|[]
name|halfPowersOf10
init|=
block|{
literal|3L
block|,
literal|31L
block|,
literal|316L
block|,
literal|3162L
block|,
literal|31622L
block|,
literal|316227L
block|,
literal|3162277L
block|,
literal|31622776L
block|,
literal|316227766L
block|,
literal|3162277660L
block|,
literal|31622776601L
block|,
literal|316227766016L
block|,
literal|3162277660168L
block|,
literal|31622776601683L
block|,
literal|316227766016837L
block|,
literal|3162277660168379L
block|,
literal|31622776601683793L
block|,
literal|316227766016837933L
block|,
literal|3162277660168379331L
block|}
decl_stmt|;
comment|/**    * Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to    * {@code BigInteger.valueOf(b).pow(k).longValue()}. This implementation runs in {@code O(log k)}    * time.    *    * @throws IllegalArgumentException if {@code k< 0}    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|pow (long b, int k)
specifier|public
specifier|static
name|long
name|pow
parameter_list|(
name|long
name|b
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|checkNonNegative
argument_list|(
literal|"exponent"
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|2
operator|<=
name|b
operator|&&
name|b
operator|<=
literal|2
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|b
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|k
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
operator|(
operator|-
literal|1
operator|)
case|:
return|return
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
case|case
literal|2
case|:
return|return
operator|(
name|k
operator|<
name|Long
operator|.
name|SIZE
operator|)
condition|?
literal|1L
operator|<<
name|k
else|:
literal|0
return|;
case|case
operator|(
operator|-
literal|2
operator|)
case|:
if|if
condition|(
name|k
operator|<
name|Long
operator|.
name|SIZE
condition|)
block|{
return|return
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
literal|1L
operator|<<
name|k
else|:
operator|-
operator|(
literal|1L
operator|<<
name|k
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
for|for
control|(
name|long
name|accum
init|=
literal|1
init|;
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
return|return
name|accum
return|;
case|case
literal|1
case|:
return|return
name|accum
operator|*
name|b
return|;
default|default:
name|accum
operator|*=
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|b
expr_stmt|;
name|b
operator|*=
name|b
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the square root of {@code x}, rounded with the specified rounding mode.    *    * @throws IllegalArgumentException if {@code x< 0}    * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and    *         {@code sqrt(x)} is not an integer    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|sqrt (long x, RoundingMode mode)
specifier|public
specifier|static
name|long
name|sqrt
parameter_list|(
name|long
name|x
parameter_list|,
name|RoundingMode
name|mode
parameter_list|)
block|{
name|checkNonNegative
argument_list|(
literal|"x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|fitsInInt
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|IntMath
operator|.
name|sqrt
argument_list|(
operator|(
name|int
operator|)
name|x
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/*      * Let k be the true value of floor(sqrt(x)), so that      *      *            k * k<= x<  (k + 1) * (k + 1)      * (double) (k * k)<= (double) x<= (double) ((k + 1) * (k + 1))      *          since casting to double is nondecreasing.      *          Note that the right-hand inequality is no longer strict.      * Math.sqrt(k * k)<= Math.sqrt(x)<= Math.sqrt((k + 1) * (k + 1))      *          since Math.sqrt is monotonic.      * (long) Math.sqrt(k * k)<= (long) Math.sqrt(x)<= (long) Math.sqrt((k + 1) * (k + 1))      *          since casting to long is monotonic      * k<= (long) Math.sqrt(x)<= k + 1      *          since (long) Math.sqrt(k * k) == k, as checked exhaustively in      *          {@link LongMathTest#testSqrtOfPerfectSquareAsDoubleIsPerfect}      */
name|long
name|guess
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|// Note: guess is always<= FLOOR_SQRT_MAX_LONG.
name|long
name|guessSquared
init|=
name|guess
operator|*
name|guess
decl_stmt|;
comment|// Note (2013-2-26): benchmarks indicate that, inscrutably enough, using if statements is
comment|// faster here than using lessThanBranchFree.
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNNECESSARY
case|:
name|checkRoundingUnnecessary
argument_list|(
name|guessSquared
operator|==
name|x
argument_list|)
expr_stmt|;
return|return
name|guess
return|;
case|case
name|FLOOR
case|:
case|case
name|DOWN
case|:
if|if
condition|(
name|x
operator|<
name|guessSquared
condition|)
block|{
return|return
name|guess
operator|-
literal|1
return|;
block|}
return|return
name|guess
return|;
case|case
name|CEILING
case|:
case|case
name|UP
case|:
if|if
condition|(
name|x
operator|>
name|guessSquared
condition|)
block|{
return|return
name|guess
operator|+
literal|1
return|;
block|}
return|return
name|guess
return|;
case|case
name|HALF_DOWN
case|:
case|case
name|HALF_UP
case|:
case|case
name|HALF_EVEN
case|:
name|long
name|sqrtFloor
init|=
name|guess
operator|-
operator|(
operator|(
name|x
operator|<
name|guessSquared
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|long
name|halfSquare
init|=
name|sqrtFloor
operator|*
name|sqrtFloor
operator|+
name|sqrtFloor
decl_stmt|;
comment|/*          * We wish to test whether or not x<= (sqrtFloor + 0.5)^2 = halfSquare + 0.25. Since both          * x and halfSquare are integers, this is equivalent to testing whether or not x<=          * halfSquare. (We have to deal with overflow, though.)          *          * If we treat halfSquare as an unsigned long, we know that          *            sqrtFloor^2<= x< (sqrtFloor + 1)^2          * halfSquare - sqrtFloor<= x< halfSquare + sqrtFloor + 1          * so |x - halfSquare|<= sqrtFloor.  Therefore, it's safe to treat x - halfSquare as a          * signed long, so lessThanBranchFree is safe for use.          */
return|return
name|sqrtFloor
operator|+
name|lessThanBranchFree
argument_list|(
name|halfSquare
argument_list|,
name|x
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**    * Returns the result of dividing {@code p} by {@code q}, rounding using the specified    * {@code RoundingMode}.    *    * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}    *         is not an integer multiple of {@code b}    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|divide (long p, long q, RoundingMode mode)
specifier|public
specifier|static
name|long
name|divide
parameter_list|(
name|long
name|p
parameter_list|,
name|long
name|q
parameter_list|,
name|RoundingMode
name|mode
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|long
name|div
init|=
name|p
operator|/
name|q
decl_stmt|;
comment|// throws if q == 0
name|long
name|rem
init|=
name|p
operator|-
name|q
operator|*
name|div
decl_stmt|;
comment|// equals p % q
if|if
condition|(
name|rem
operator|==
literal|0
condition|)
block|{
return|return
name|div
return|;
block|}
comment|/*      * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to      * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of      * p / q.      *      * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.      */
name|int
name|signum
init|=
literal|1
operator||
call|(
name|int
call|)
argument_list|(
operator|(
name|p
operator|^
name|q
operator|)
operator|>>
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|boolean
name|increment
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNNECESSARY
case|:
name|checkRoundingUnnecessary
argument_list|(
name|rem
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DOWN
case|:
name|increment
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|UP
case|:
name|increment
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|CEILING
case|:
name|increment
operator|=
name|signum
operator|>
literal|0
expr_stmt|;
break|break;
case|case
name|FLOOR
case|:
name|increment
operator|=
name|signum
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|HALF_EVEN
case|:
case|case
name|HALF_DOWN
case|:
case|case
name|HALF_UP
case|:
name|long
name|absRem
init|=
name|abs
argument_list|(
name|rem
argument_list|)
decl_stmt|;
name|long
name|cmpRemToHalfDivisor
init|=
name|absRem
operator|-
operator|(
name|abs
argument_list|(
name|q
argument_list|)
operator|-
name|absRem
operator|)
decl_stmt|;
comment|// subtracting two nonnegative longs can't overflow
comment|// cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).
if|if
condition|(
name|cmpRemToHalfDivisor
operator|==
literal|0
condition|)
block|{
comment|// exactly on the half mark
name|increment
operator|=
operator|(
name|mode
operator|==
name|HALF_UP
operator||
operator|(
name|mode
operator|==
name|HALF_EVEN
operator|&
operator|(
name|div
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
name|cmpRemToHalfDivisor
operator|>
literal|0
expr_stmt|;
comment|// closer to the UP value
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
return|return
name|increment
condition|?
name|div
operator|+
name|signum
else|:
name|div
return|;
block|}
comment|/**    * Returns {@code x mod m}, a non-negative value less than {@code m}.    * This differs from {@code x % m}, which might be negative.    *    *<p>For example:    *    *<pre> {@code    *    * mod(7, 4) == 3    * mod(-7, 4) == 1    * mod(-1, 4) == 3    * mod(-8, 4) == 0    * mod(8, 4) == 0}</pre>    *    * @throws ArithmeticException if {@code m<= 0}    * @see<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">    *      Remainder Operator</a>    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|mod (long x, int m)
specifier|public
specifier|static
name|int
name|mod
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|m
parameter_list|)
block|{
comment|// Cast is safe because the result is guaranteed in the range [0, m)
return|return
operator|(
name|int
operator|)
name|mod
argument_list|(
name|x
argument_list|,
operator|(
name|long
operator|)
name|m
argument_list|)
return|;
block|}
comment|/**    * Returns {@code x mod m}, a non-negative value less than {@code m}.    * This differs from {@code x % m}, which might be negative.    *    *<p>For example:    *    *<pre> {@code    *    * mod(7, 4) == 3    * mod(-7, 4) == 1    * mod(-1, 4) == 3    * mod(-8, 4) == 0    * mod(8, 4) == 0}</pre>    *    * @throws ArithmeticException if {@code m<= 0}    * @see<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">    *      Remainder Operator</a>    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|mod (long x, long m)
specifier|public
specifier|static
name|long
name|mod
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Modulus must be positive"
argument_list|)
throw|;
block|}
name|long
name|result
init|=
name|x
operator|%
name|m
decl_stmt|;
return|return
operator|(
name|result
operator|>=
literal|0
operator|)
condition|?
name|result
else|:
name|result
operator|+
name|m
return|;
block|}
comment|/**    * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if    * {@code a == 0&& b == 0}.    *    * @throws IllegalArgumentException if {@code a< 0} or {@code b< 0}    */
DECL|method|gcd (long a, long b)
specifier|public
specifier|static
name|long
name|gcd
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
comment|/*      * The reason we require both arguments to be>= 0 is because otherwise, what do you return on      * gcd(0, Long.MIN_VALUE)? BigInteger.gcd would return positive 2^63, but positive 2^63 isn't      * an int.      */
name|checkNonNegative
argument_list|(
literal|"a"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|checkNonNegative
argument_list|(
literal|"b"
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
comment|// 0 % b == 0, so b divides a, but the converse doesn't hold.
comment|// BigInteger.gcd is consistent with this decision.
return|return
name|b
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
return|return
name|a
return|;
comment|// similar logic
block|}
comment|/*      * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm.      * This is>60% faster than the Euclidean algorithm in benchmarks.      */
name|int
name|aTwos
init|=
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|a
operator|>>=
name|aTwos
expr_stmt|;
comment|// divide out all 2s
name|int
name|bTwos
init|=
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|b
operator|>>=
name|bTwos
expr_stmt|;
comment|// divide out all 2s
while|while
condition|(
name|a
operator|!=
name|b
condition|)
block|{
comment|// both a, b are odd
comment|// The key to the binary GCD algorithm is as follows:
comment|// Both a and b are odd.  Assume a> b; then gcd(a - b, b) = gcd(a, b).
comment|// But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.
comment|// We bend over backwards to avoid branching, adapting a technique from
comment|// http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax
name|long
name|delta
init|=
name|a
operator|-
name|b
decl_stmt|;
comment|// can't overflow, since a and b are nonnegative
name|long
name|minDeltaOrZero
init|=
name|delta
operator|&
operator|(
name|delta
operator|>>
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|// equivalent to Math.min(delta, 0)
name|a
operator|=
name|delta
operator|-
name|minDeltaOrZero
operator|-
name|minDeltaOrZero
expr_stmt|;
comment|// sets a to Math.abs(a - b)
comment|// a is now nonnegative and even
name|b
operator|+=
name|minDeltaOrZero
expr_stmt|;
comment|// sets b to min(old a, b)
name|a
operator|>>=
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// divide out all 2s, since 2 doesn't divide b
block|}
return|return
name|a
operator|<<
name|min
argument_list|(
name|aTwos
argument_list|,
name|bTwos
argument_list|)
return|;
block|}
comment|/**    * Returns the sum of {@code a} and {@code b}, provided it does not overflow.    *    * @throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|checkedAdd (long a, long b)
specifier|public
specifier|static
name|long
name|checkedAdd
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|result
init|=
name|a
operator|+
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
operator|(
name|a
operator|^
name|b
operator|)
operator|<
literal|0
operator||
operator|(
name|a
operator|^
name|result
operator|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the difference of {@code a} and {@code b}, provided it does not overflow.    *    * @throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|checkedSubtract (long a, long b)
specifier|public
specifier|static
name|long
name|checkedSubtract
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|result
init|=
name|a
operator|-
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
operator|(
name|a
operator|^
name|b
operator|)
operator|>=
literal|0
operator||
operator|(
name|a
operator|^
name|result
operator|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the product of {@code a} and {@code b}, provided it does not overflow.    *    * @throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|checkedMultiply (long a, long b)
specifier|public
specifier|static
name|long
name|checkedMultiply
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
comment|// Hacker's Delight, Section 2-12
name|int
name|leadingZeros
init|=
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|a
argument_list|)
operator|+
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
operator|~
name|a
argument_list|)
operator|+
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|b
argument_list|)
operator|+
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
operator|~
name|b
argument_list|)
decl_stmt|;
comment|/*      * If leadingZeros> Long.SIZE + 1 it's definitely fine, if it's< Long.SIZE it's definitely      * bad. We do the leadingZeros check to avoid the division below if at all possible.      *      * Otherwise, if b == Long.MIN_VALUE, then the only allowed values of a are 0 and 1. We take      * care of all a< 0 with their own check, because in particular, the case a == -1 will      * incorrectly pass the division check below.      *      * In all other cases, we check that either a is 0 or the result is consistent with division.      */
if|if
condition|(
name|leadingZeros
operator|>
name|Long
operator|.
name|SIZE
operator|+
literal|1
condition|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
name|checkNoOverflow
argument_list|(
name|leadingZeros
operator|>=
name|Long
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|checkNoOverflow
argument_list|(
name|a
operator|>=
literal|0
operator||
name|b
operator|!=
name|Long
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
name|long
name|result
init|=
name|a
operator|*
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
name|a
operator|==
literal|0
operator|||
name|result
operator|/
name|a
operator|==
name|b
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the {@code b} to the {@code k}th power, provided it does not overflow.    *    * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed    *         {@code long} arithmetic    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|checkedPow (long b, int k)
specifier|public
specifier|static
name|long
name|checkedPow
parameter_list|(
name|long
name|b
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|checkNonNegative
argument_list|(
literal|"exponent"
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|>=
operator|-
literal|2
operator|&
name|b
operator|<=
literal|2
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|b
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|k
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
operator|(
operator|-
literal|1
operator|)
case|:
return|return
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
case|case
literal|2
case|:
name|checkNoOverflow
argument_list|(
name|k
operator|<
name|Long
operator|.
name|SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1L
operator|<<
name|k
return|;
case|case
operator|(
operator|-
literal|2
operator|)
case|:
name|checkNoOverflow
argument_list|(
name|k
operator|<
name|Long
operator|.
name|SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
operator|(
literal|1L
operator|<<
name|k
operator|)
else|:
operator|(
operator|-
literal|1L
operator|<<
name|k
operator|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|long
name|accum
init|=
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
return|return
name|accum
return|;
case|case
literal|1
case|:
return|return
name|checkedMultiply
argument_list|(
name|accum
argument_list|,
name|b
argument_list|)
return|;
default|default:
if|if
condition|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|accum
operator|=
name|checkedMultiply
argument_list|(
name|accum
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|k
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|checkNoOverflow
argument_list|(
name|b
operator|<=
name|FLOOR_SQRT_MAX_LONG
argument_list|)
expr_stmt|;
name|b
operator|*=
name|b
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|FLOOR_SQRT_MAX_LONG
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|long
name|FLOOR_SQRT_MAX_LONG
init|=
literal|3037000499L
decl_stmt|;
comment|/**    * Returns {@code n!}, that is, the product of the first {@code n} positive    * integers, {@code 1} if {@code n == 0}, or {@link Long#MAX_VALUE} if the    * result does not fit in a {@code long}.    *    * @throws IllegalArgumentException if {@code n< 0}    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"TODO"
argument_list|)
DECL|method|factorial (int n)
specifier|public
specifier|static
name|long
name|factorial
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|checkNonNegative
argument_list|(
literal|"n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|<
name|factorials
operator|.
name|length
operator|)
condition|?
name|factorials
index|[
name|n
index|]
else|:
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
DECL|field|factorials
specifier|static
specifier|final
name|long
index|[]
name|factorials
init|=
block|{
literal|1L
block|,
literal|1L
block|,
literal|1L
operator|*
literal|2
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
operator|*
literal|16
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
operator|*
literal|16
operator|*
literal|17
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
operator|*
literal|16
operator|*
literal|17
operator|*
literal|18
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
operator|*
literal|16
operator|*
literal|17
operator|*
literal|18
operator|*
literal|19
block|,
literal|1L
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
operator|*
literal|13
operator|*
literal|14
operator|*
literal|15
operator|*
literal|16
operator|*
literal|17
operator|*
literal|18
operator|*
literal|19
operator|*
literal|20
block|}
decl_stmt|;
comment|/**    * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and    * {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.    *    * @throws IllegalArgumentException if {@code n< 0}, {@code k< 0}, or {@code k> n}    */
DECL|method|binomial (int n, int k)
specifier|public
specifier|static
name|long
name|binomial
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|checkNonNegative
argument_list|(
literal|"n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|checkNonNegative
argument_list|(
literal|"k"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|k
operator|<=
name|n
argument_list|,
literal|"k (%s)> n (%s)"
argument_list|,
name|k
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|(
name|n
operator|>>
literal|1
operator|)
condition|)
block|{
name|k
operator|=
name|n
operator|-
name|k
expr_stmt|;
block|}
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|1
return|;
case|case
literal|1
case|:
return|return
name|n
return|;
default|default:
if|if
condition|(
name|n
operator|<
name|factorials
operator|.
name|length
condition|)
block|{
return|return
name|factorials
index|[
name|n
index|]
operator|/
operator|(
name|factorials
index|[
name|k
index|]
operator|*
name|factorials
index|[
name|n
operator|-
name|k
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>=
name|biggestBinomials
operator|.
name|length
operator|||
name|n
operator|>
name|biggestBinomials
index|[
name|k
index|]
condition|)
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|<
name|biggestSimpleBinomials
operator|.
name|length
operator|&&
name|n
operator|<=
name|biggestSimpleBinomials
index|[
name|k
index|]
condition|)
block|{
comment|// guaranteed not to overflow
name|long
name|result
init|=
name|n
operator|--
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|k
condition|;
name|n
operator|--
operator|,
name|i
operator|++
control|)
block|{
name|result
operator|*=
name|n
expr_stmt|;
name|result
operator|/=
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|int
name|nBits
init|=
name|LongMath
operator|.
name|log2
argument_list|(
name|n
argument_list|,
name|RoundingMode
operator|.
name|CEILING
argument_list|)
decl_stmt|;
name|long
name|result
init|=
literal|1
decl_stmt|;
name|long
name|numerator
init|=
name|n
operator|--
decl_stmt|;
name|long
name|denominator
init|=
literal|1
decl_stmt|;
name|int
name|numeratorBits
init|=
name|nBits
decl_stmt|;
comment|// This is an upper bound on log2(numerator, ceiling).
comment|/*            * We want to do this in long math for speed, but want to avoid overflow. We adapt the            * technique previously used by BigIntegerMath: maintain separate numerator and            * denominator accumulators, multiplying the fraction into result when near overflow.            */
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
operator|,
name|n
operator|--
control|)
block|{
if|if
condition|(
name|numeratorBits
operator|+
name|nBits
operator|<
name|Long
operator|.
name|SIZE
operator|-
literal|1
condition|)
block|{
comment|// It's definitely safe to multiply into numerator and denominator.
name|numerator
operator|*=
name|n
expr_stmt|;
name|denominator
operator|*=
name|i
expr_stmt|;
name|numeratorBits
operator|+=
name|nBits
expr_stmt|;
block|}
else|else
block|{
comment|// It might not be safe to multiply into numerator and denominator,
comment|// so multiply (numerator / denominator) into result.
name|result
operator|=
name|multiplyFraction
argument_list|(
name|result
argument_list|,
name|numerator
argument_list|,
name|denominator
argument_list|)
expr_stmt|;
name|numerator
operator|=
name|n
expr_stmt|;
name|denominator
operator|=
name|i
expr_stmt|;
name|numeratorBits
operator|=
name|nBits
expr_stmt|;
block|}
block|}
return|return
name|multiplyFraction
argument_list|(
name|result
argument_list|,
name|numerator
argument_list|,
name|denominator
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Returns (x * numerator / denominator), which is assumed to come out to an integral value.    */
DECL|method|multiplyFraction (long x, long numerator, long denominator)
specifier|static
name|long
name|multiplyFraction
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|numerator
parameter_list|,
name|long
name|denominator
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
return|return
name|numerator
operator|/
name|denominator
return|;
block|}
name|long
name|commonDivisor
init|=
name|gcd
argument_list|(
name|x
argument_list|,
name|denominator
argument_list|)
decl_stmt|;
name|x
operator|/=
name|commonDivisor
expr_stmt|;
name|denominator
operator|/=
name|commonDivisor
expr_stmt|;
comment|// We know gcd(x, denominator) = 1, and x * numerator / denominator is exact,
comment|// so denominator must be a divisor of numerator.
return|return
name|x
operator|*
operator|(
name|numerator
operator|/
name|denominator
operator|)
return|;
block|}
comment|/*    * binomial(biggestBinomials[k], k) fits in a long, but not    * binomial(biggestBinomials[k] + 1, k).    */
DECL|field|biggestBinomials
specifier|static
specifier|final
name|int
index|[]
name|biggestBinomials
init|=
block|{
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
block|,
literal|3810779
block|,
literal|121977
block|,
literal|16175
block|,
literal|4337
block|,
literal|1733
block|,
literal|887
block|,
literal|534
block|,
literal|361
block|,
literal|265
block|,
literal|206
block|,
literal|169
block|,
literal|143
block|,
literal|125
block|,
literal|111
block|,
literal|101
block|,
literal|94
block|,
literal|88
block|,
literal|83
block|,
literal|79
block|,
literal|76
block|,
literal|74
block|,
literal|72
block|,
literal|70
block|,
literal|69
block|,
literal|68
block|,
literal|67
block|,
literal|67
block|,
literal|66
block|,
literal|66
block|,
literal|66
block|,
literal|66
block|}
decl_stmt|;
comment|/*    * binomial(biggestSimpleBinomials[k], k) doesn't need to use the slower GCD-based impl,    * but binomial(biggestSimpleBinomials[k] + 1, k) does.    */
DECL|field|biggestSimpleBinomials
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|int
index|[]
name|biggestSimpleBinomials
init|=
block|{
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
block|,
literal|2642246
block|,
literal|86251
block|,
literal|11724
block|,
literal|3218
block|,
literal|1313
block|,
literal|684
block|,
literal|419
block|,
literal|287
block|,
literal|214
block|,
literal|169
block|,
literal|139
block|,
literal|119
block|,
literal|105
block|,
literal|95
block|,
literal|87
block|,
literal|81
block|,
literal|76
block|,
literal|73
block|,
literal|70
block|,
literal|68
block|,
literal|66
block|,
literal|64
block|,
literal|63
block|,
literal|62
block|,
literal|62
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|}
decl_stmt|;
comment|// These values were generated by using checkedMultiply to see when the simple multiply/divide
comment|// algorithm would lead to an overflow.
DECL|method|fitsInInt (long x)
specifier|static
name|boolean
name|fitsInInt
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|x
operator|==
name|x
return|;
block|}
comment|/**    * Returns the arithmetic mean of {@code x} and {@code y}, rounded toward    * negative infinity. This method is resilient to overflow.    *    * @since 14.0    */
DECL|method|mean (long x, long y)
specifier|public
specifier|static
name|long
name|mean
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
comment|// Efficient method for computing the arithmetic mean.
comment|// The alternative (x + y) / 2 fails for large values.
comment|// The alternative (x + y)>>> 1 fails for negative values.
return|return
operator|(
name|x
operator|&
name|y
operator|)
operator|+
operator|(
operator|(
name|x
operator|^
name|y
operator|)
operator|>>
literal|1
operator|)
return|;
block|}
comment|/*    * If n<= millerRabinBases[i][0], then testing n against bases millerRabinBases[i][1..]    * suffices to prove its primality.  Values from miller-rabin.appspot.com.    *    * NOTE: We could get slightly better bases that would be treated as unsigned, but benchmarks    * showed negligible performance improvements.    */
DECL|field|millerRabinBaseSets
specifier|private
specifier|static
specifier|final
name|long
index|[]
index|[]
name|millerRabinBaseSets
init|=
block|{
block|{
literal|291830
block|,
literal|126401071349994536L
block|}
block|,
block|{
literal|885594168
block|,
literal|725270293939359937L
block|,
literal|3569819667048198375L
block|}
block|,
block|{
literal|273919523040L
block|,
literal|15
block|,
literal|7363882082L
block|,
literal|992620450144556L
block|}
block|,
block|{
literal|47636622961200L
block|,
literal|2
block|,
literal|2570940
block|,
literal|211991001
block|,
literal|3749873356L
block|}
block|,
block|{
literal|7999252175582850L
block|,
literal|2
block|,
literal|4130806001517L
block|,
literal|149795463772692060L
block|,
literal|186635894390467037L
block|,
literal|3967304179347715805L
block|}
block|,
block|{
literal|585226005592931976L
block|,
literal|2
block|,
literal|123635709730000L
block|,
literal|9233062284813009L
block|,
literal|43835965440333360L
block|,
literal|761179012939631437L
block|,
literal|1263739024124850375L
block|}
block|,
block|{
name|Long
operator|.
name|MAX_VALUE
block|,
literal|2
block|,
literal|325
block|,
literal|9375
block|,
literal|28178
block|,
literal|450775
block|,
literal|9780504
block|,
literal|1795265022
block|}
block|}
decl_stmt|;
DECL|enum|MillerRabinTester
specifier|private
enum|enum
name|MillerRabinTester
block|{
comment|/**      * Works for inputs<= FLOOR_SQRT_MAX_LONG.      */
DECL|enumConstant|SMALL
name|SMALL
block|{
annotation|@
name|Override
name|long
name|mulMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|,
name|long
name|m
parameter_list|)
block|{
comment|/*          * NOTE(user, 2015-Feb-12): Benchmarks suggest that changing this to          * UnsignedLongs.remainder and increasing the threshold to 2^32 doesn't pay for itself,          * and adding another enum constant hurts performance further -- I suspect because          * bimorphic implementation is a sweet spot for the JVM.          */
return|return
operator|(
name|a
operator|*
name|b
operator|)
operator|%
name|m
return|;
block|}
annotation|@
name|Override
name|long
name|squareMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|m
parameter_list|)
block|{
return|return
operator|(
name|a
operator|*
name|a
operator|)
operator|%
name|m
return|;
block|}
block|}
block|,
comment|/**      * Works for all nonnegative signed longs.      */
DECL|enumConstant|LARGE
name|LARGE
block|{
comment|/**        * Returns (a + b) mod m.  Precondition: 0<= a, b< m< 2^63.        */
specifier|private
name|long
name|plusMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|,
name|long
name|m
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>=
name|m
operator|-
name|b
operator|)
condition|?
operator|(
name|a
operator|+
name|b
operator|-
name|m
operator|)
else|:
operator|(
name|a
operator|+
name|b
operator|)
return|;
block|}
comment|/**        * Returns (a * 2^32) mod m.  a may be any unsigned long.        */
specifier|private
name|long
name|times2ToThe32Mod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|m
parameter_list|)
block|{
name|int
name|remainingPowersOf2
init|=
literal|32
decl_stmt|;
do|do
block|{
name|int
name|shift
init|=
name|Math
operator|.
name|min
argument_list|(
name|remainingPowersOf2
argument_list|,
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
comment|// shift is either the number of powers of 2 left to multiply a by, or the biggest shift
comment|// possible while keeping a in an unsigned long.
name|a
operator|=
name|UnsignedLongs
operator|.
name|remainder
argument_list|(
name|a
operator|<<
name|shift
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|remainingPowersOf2
operator|-=
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|remainingPowersOf2
operator|>
literal|0
condition|)
do|;
return|return
name|a
return|;
block|}
annotation|@
name|Override
name|long
name|mulMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|,
name|long
name|m
parameter_list|)
block|{
name|long
name|aHi
init|=
name|a
operator|>>>
literal|32
decl_stmt|;
comment|//< 2^31
name|long
name|bHi
init|=
name|b
operator|>>>
literal|32
decl_stmt|;
comment|//< 2^31
name|long
name|aLo
init|=
name|a
operator|&
literal|0xFFFFFFFFL
decl_stmt|;
comment|//< 2^32
name|long
name|bLo
init|=
name|b
operator|&
literal|0xFFFFFFFFL
decl_stmt|;
comment|//< 2^32
comment|/*          * a * b == aHi * bHi * 2^64 + (aHi * bLo + aLo * bHi) * 2^63 + aLo * bLo.          *       == (aHi * bHi * 2^32 + aHi * bLo + aLo * bHi) * 2^32 + aLo * bLo          *          * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts          * any unsigned long, we don't have to do a mod on every operation, only when intermediate          * results can exceed 2^63.          */
name|long
name|result
init|=
name|times2ToThe32Mod
argument_list|(
name|aHi
operator|*
name|bHi
comment|/*< 2^62 */
argument_list|,
name|m
argument_list|)
decl_stmt|;
comment|//< m< 2^63
name|result
operator|+=
name|aHi
operator|*
name|bLo
expr_stmt|;
comment|// aHi * bLo< 2^63, result< 2^64
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|result
operator|=
name|UnsignedLongs
operator|.
name|remainder
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|// result< 2^63 again
name|result
operator|+=
name|aLo
operator|*
name|bHi
expr_stmt|;
comment|// aLo * bHi< 2^63, result< 2^64
name|result
operator|=
name|times2ToThe32Mod
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// result< m< 2^63
return|return
name|plusMod
argument_list|(
name|result
argument_list|,
name|UnsignedLongs
operator|.
name|remainder
argument_list|(
name|aLo
operator|*
name|bLo
comment|/*< 2^64 */
argument_list|,
name|m
argument_list|)
argument_list|,
name|m
argument_list|)
return|;
block|}
annotation|@
name|Override
name|long
name|squareMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|m
parameter_list|)
block|{
name|long
name|aHi
init|=
name|a
operator|>>>
literal|32
decl_stmt|;
comment|//< 2^31
name|long
name|aLo
init|=
name|a
operator|&
literal|0xFFFFFFFFL
decl_stmt|;
comment|//< 2^32
comment|/*          * a^2 == aHi^2 * 2^64 + aHi * aLo * 2^33 + aLo^2          *     == (aHi^2 * 2^32 + aHi * aLo * 2) * 2^32 + aLo^2          * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts          * any unsigned long, we don't have to do a mod on every operation, only when intermediate          * results can exceed 2^63.          */
name|long
name|result
init|=
name|times2ToThe32Mod
argument_list|(
name|aHi
operator|*
name|aHi
comment|/*< 2^62 */
argument_list|,
name|m
argument_list|)
decl_stmt|;
comment|//< m< 2^63
name|long
name|hiLo
init|=
name|aHi
operator|*
name|aLo
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|hiLo
operator|<
literal|0
condition|)
block|{
name|hiLo
operator|=
name|UnsignedLongs
operator|.
name|remainder
argument_list|(
name|hiLo
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|// hiLo< 2^63
name|result
operator|+=
name|hiLo
expr_stmt|;
comment|// result< 2^64
name|result
operator|=
name|times2ToThe32Mod
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|// result< m< 2^63
return|return
name|plusMod
argument_list|(
name|result
argument_list|,
name|UnsignedLongs
operator|.
name|remainder
argument_list|(
name|aLo
operator|*
name|aLo
comment|/*< 2^64 */
argument_list|,
name|m
argument_list|)
argument_list|,
name|m
argument_list|)
return|;
block|}
block|}
block|;
DECL|method|test (long base, long n)
specifier|static
name|boolean
name|test
parameter_list|(
name|long
name|base
parameter_list|,
name|long
name|n
parameter_list|)
block|{
comment|// Since base will be considered % n, it's okay if base> FLOOR_SQRT_MAX_LONG,
comment|// so long as n<= FLOOR_SQRT_MAX_LONG.
return|return
operator|(
operator|(
name|n
operator|<=
name|FLOOR_SQRT_MAX_LONG
operator|)
condition|?
name|SMALL
else|:
name|LARGE
operator|)
operator|.
name|testWitness
argument_list|(
name|base
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/**      * Returns a * b mod m.      */
DECL|method|mulMod (long a, long b, long m)
specifier|abstract
name|long
name|mulMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|,
name|long
name|m
parameter_list|)
function_decl|;
comment|/**      * Returns a^2 mod m.      */
DECL|method|squareMod (long a, long m)
specifier|abstract
name|long
name|squareMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|m
parameter_list|)
function_decl|;
comment|/**      * Returns a^p mod m.      */
DECL|method|powMod (long a, long p, long m)
specifier|private
name|long
name|powMod
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|p
parameter_list|,
name|long
name|m
parameter_list|)
block|{
name|long
name|res
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
name|mulMod
argument_list|(
name|res
argument_list|,
name|a
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|squareMod
argument_list|(
name|a
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**      * Returns true if n is a strong probable prime relative to the specified base.      */
DECL|method|testWitness (long base, long n)
specifier|private
name|boolean
name|testWitness
parameter_list|(
name|long
name|base
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|int
name|r
init|=
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|n
operator|-
literal|1
argument_list|)
decl_stmt|;
name|long
name|d
init|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|>>
name|r
decl_stmt|;
name|base
operator|%=
name|n
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Calculate a := base^d mod n.
name|long
name|a
init|=
name|powMod
argument_list|(
name|base
argument_list|,
name|d
argument_list|,
name|n
argument_list|)
decl_stmt|;
comment|// n passes this test if
comment|//    base^d = 1 (mod n)
comment|// or base^(2^j * d) = -1 (mod n) for some 0<= j< r.
if|if
condition|(
name|a
operator|==
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|n
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|++
name|j
operator|==
name|r
condition|)
block|{
return|return
literal|false
return|;
block|}
name|a
operator|=
name|squareMod
argument_list|(
name|a
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
DECL|method|LongMath ()
specifier|private
name|LongMath
parameter_list|()
block|{}
block|}
end_class

end_unit

