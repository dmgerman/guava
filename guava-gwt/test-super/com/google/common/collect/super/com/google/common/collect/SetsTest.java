begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|unmodifiableIterable
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newEnumSet
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newHashSet
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newLinkedHashSet
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|powerSet
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|IteratorFeature
operator|.
name|UNMODIFIABLE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptySet
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singleton
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|truth0
operator|.
name|Truth
operator|.
name|ASSERT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|IteratorTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|MinimalIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|EqualsTester
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Unit test for {@code Sets}.  *  * @author Kevin Bourrillion  * @author Jared Levy  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|SetsTest
specifier|public
class|class
name|SetsTest
extends|extends
name|TestCase
block|{
DECL|field|KNOWN_ORDER
specifier|private
specifier|static
specifier|final
name|IteratorTester
operator|.
name|KnownOrder
name|KNOWN_ORDER
init|=
name|IteratorTester
operator|.
name|KnownOrder
operator|.
name|KNOWN_ORDER
decl_stmt|;
DECL|field|EMPTY_COLLECTION
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|Integer
argument_list|>
name|EMPTY_COLLECTION
init|=
name|Arrays
operator|.
expr|<
name|Integer
operator|>
name|asList
argument_list|()
decl_stmt|;
DECL|field|SOME_COLLECTION
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|Integer
argument_list|>
name|SOME_COLLECTION
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
DECL|field|SOME_ITERABLE
specifier|private
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|SOME_ITERABLE
init|=
operator|new
name|Iterable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|SOME_COLLECTION
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|LONGER_LIST
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|LONGER_LIST
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|8
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
decl_stmt|;
DECL|field|SOME_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|SOME_COMPARATOR
init|=
name|Collections
operator|.
name|reverseOrder
argument_list|()
decl_stmt|;
DECL|enum|SomeEnum
DECL|enumConstant|A
DECL|enumConstant|B
DECL|enumConstant|C
DECL|enumConstant|D
specifier|private
enum|enum
name|SomeEnum
block|{
name|A
block|,
name|B
block|,
name|C
block|,
name|D
block|}
DECL|method|testImmutableEnumSet ()
specifier|public
name|void
name|testImmutableEnumSet
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|units
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|SomeEnum
operator|.
name|D
argument_list|,
name|SomeEnum
operator|.
name|B
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|units
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
try|try
block|{
name|units
operator|.
name|remove
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"ImmutableEnumSet should throw an exception on remove()"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|units
operator|.
name|add
argument_list|(
name|SomeEnum
operator|.
name|C
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"ImmutableEnumSet should throw an exception on add()"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testImmutableEnumSet_fromIterable ()
specifier|public
name|void
name|testImmutableEnumSet_fromIterable
parameter_list|()
block|{
name|ImmutableSet
argument_list|<
name|SomeEnum
argument_list|>
name|none
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|MinimalIterable
operator|.
expr|<
name|SomeEnum
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|none
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|ImmutableSet
argument_list|<
name|SomeEnum
argument_list|>
name|one
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|MinimalIterable
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|)
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|one
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|item
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|)
expr_stmt|;
name|ImmutableSet
argument_list|<
name|SomeEnum
argument_list|>
name|two
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|MinimalIterable
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|D
argument_list|,
name|SomeEnum
operator|.
name|B
argument_list|)
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|two
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|prepended (byte b, byte[] array)
specifier|private
specifier|static
name|byte
index|[]
name|prepended
parameter_list|(
name|byte
name|b
parameter_list|,
name|byte
index|[]
name|array
parameter_list|)
block|{
name|byte
index|[]
name|out
init|=
operator|new
name|byte
index|[
name|array
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
DECL|method|testNewEnumSet_empty ()
specifier|public
name|void
name|testNewEnumSet_empty
parameter_list|()
block|{
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|copy
init|=
name|newEnumSet
argument_list|(
name|Collections
operator|.
expr|<
name|SomeEnum
operator|>
name|emptySet
argument_list|()
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewEnumSet_enumSet ()
specifier|public
name|void
name|testNewEnumSet_enumSet
parameter_list|()
block|{
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|set
argument_list|,
name|newEnumSet
argument_list|(
name|set
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewEnumSet_collection ()
specifier|public
name|void
name|testNewEnumSet_collection
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|set
argument_list|,
name|newEnumSet
argument_list|(
name|set
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewEnumSet_iterable ()
specifier|public
name|void
name|testNewEnumSet_iterable
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|set
argument_list|,
name|newEnumSet
argument_list|(
name|unmodifiableIterable
argument_list|(
name|set
argument_list|)
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetEmpty ()
specifier|public
name|void
name|testNewHashSetEmpty
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetVarArgs ()
specifier|public
name|void
name|testNewHashSetVarArgs
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetFromCollection ()
specifier|public
name|void
name|testNewHashSetFromCollection
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SOME_COLLECTION
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|SOME_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetFromIterable ()
specifier|public
name|void
name|testNewHashSetFromIterable
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SOME_ITERABLE
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|SOME_ITERABLE
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetWithExpectedSizeSmall ()
specifier|public
name|void
name|testNewHashSetWithExpectedSizeSmall
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetWithExpectedSizeLarge ()
specifier|public
name|void
name|testNewHashSetWithExpectedSizeLarge
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewHashSetFromIterator ()
specifier|public
name|void
name|testNewHashSetFromIterator
parameter_list|()
block|{
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SOME_COLLECTION
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|SOME_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewConcurrentHashSetEmpty ()
specifier|public
name|void
name|testNewConcurrentHashSetEmpty
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newConcurrentHashSet
argument_list|()
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewConcurrentHashSetFromCollection ()
specifier|public
name|void
name|testNewConcurrentHashSetFromCollection
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newConcurrentHashSet
argument_list|(
name|SOME_COLLECTION
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|SOME_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewLinkedHashSetEmpty ()
specifier|public
name|void
name|testNewLinkedHashSetEmpty
parameter_list|()
block|{
name|LinkedHashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|verifyLinkedHashSetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewLinkedHashSetFromCollection ()
specifier|public
name|void
name|testNewLinkedHashSetFromCollection
parameter_list|()
block|{
name|LinkedHashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
name|LONGER_LIST
argument_list|)
decl_stmt|;
name|verifyLinkedHashSetContents
argument_list|(
name|set
argument_list|,
name|LONGER_LIST
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewLinkedHashSetFromIterable ()
specifier|public
name|void
name|testNewLinkedHashSetFromIterable
parameter_list|()
block|{
name|LinkedHashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
operator|new
name|Iterable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|LONGER_LIST
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|verifyLinkedHashSetContents
argument_list|(
name|set
argument_list|,
name|LONGER_LIST
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewLinkedHashSetWithExpectedSizeSmall ()
specifier|public
name|void
name|testNewLinkedHashSetWithExpectedSizeSmall
parameter_list|()
block|{
name|LinkedHashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSetWithExpectedSize
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewLinkedHashSetWithExpectedSizeLarge ()
specifier|public
name|void
name|testNewLinkedHashSetWithExpectedSizeLarge
parameter_list|()
block|{
name|LinkedHashSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSetWithExpectedSize
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewTreeSetEmpty ()
specifier|public
name|void
name|testNewTreeSetEmpty
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
name|verifySortedSetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewTreeSetEmptyDerived ()
specifier|public
name|void
name|testNewTreeSetEmptyDerived
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Derived
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|set
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|set
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testNewTreeSetEmptyNonGeneric ()
specifier|public
name|void
name|testNewTreeSetEmptyNonGeneric
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|LegacyComparable
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|set
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|set
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testNewTreeSetFromCollection ()
specifier|public
name|void
name|testNewTreeSetFromCollection
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|SOME_COLLECTION
argument_list|)
decl_stmt|;
name|verifySortedSetContents
argument_list|(
name|set
argument_list|,
name|SOME_COLLECTION
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewTreeSetFromIterable ()
specifier|public
name|void
name|testNewTreeSetFromIterable
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|SOME_ITERABLE
argument_list|)
decl_stmt|;
name|verifySortedSetContents
argument_list|(
name|set
argument_list|,
name|SOME_ITERABLE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewTreeSetFromIterableDerived ()
specifier|public
name|void
name|testNewTreeSetFromIterableDerived
parameter_list|()
block|{
name|Iterable
argument_list|<
name|Derived
argument_list|>
name|iterable
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
decl_stmt|;
name|TreeSet
argument_list|<
name|Derived
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|set
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testNewTreeSetFromIterableNonGeneric ()
specifier|public
name|void
name|testNewTreeSetFromIterableNonGeneric
parameter_list|()
block|{
name|Iterable
argument_list|<
name|LegacyComparable
argument_list|>
name|iterable
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
decl_stmt|;
name|TreeSet
argument_list|<
name|LegacyComparable
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|set
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testNewTreeSetEmptyWithComparator ()
specifier|public
name|void
name|testNewTreeSetEmptyWithComparator
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|SOME_COMPARATOR
argument_list|)
decl_stmt|;
name|verifySortedSetContents
argument_list|(
name|set
argument_list|,
name|EMPTY_COLLECTION
argument_list|,
name|SOME_COMPARATOR
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewIdentityHashSet ()
specifier|public
name|void
name|testNewIdentityHashSet
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
name|Integer
name|value1
init|=
operator|new
name|Integer
argument_list|(
literal|12357
argument_list|)
decl_stmt|;
name|Integer
name|value2
init|=
operator|new
name|Integer
argument_list|(
literal|12357
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|set
operator|.
name|add
argument_list|(
name|value1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|set
operator|.
name|contains
argument_list|(
name|value2
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|set
operator|.
name|contains
argument_list|(
name|value1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|set
operator|.
name|add
argument_list|(
name|value2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|set
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfEnumSet ()
specifier|public
name|void
name|testComplementOfEnumSet
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|units
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|otherUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|units
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|otherUnits
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfEnumSetWithType ()
specifier|public
name|void
name|testComplementOfEnumSetWithType
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|units
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|otherUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|units
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|otherUnits
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfRegularSet ()
specifier|public
name|void
name|testComplementOfRegularSet
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|units
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|otherUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|units
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|otherUnits
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfRegularSetWithType ()
specifier|public
name|void
name|testComplementOfRegularSetWithType
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|units
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SomeEnum
operator|.
name|B
argument_list|,
name|SomeEnum
operator|.
name|D
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|otherUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|units
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|otherUnits
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SomeEnum
operator|.
name|A
argument_list|,
name|SomeEnum
operator|.
name|C
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfEmptySet ()
specifier|public
name|void
name|testComplementOfEmptySet
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|noUnits
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|allUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|noUnits
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|,
name|allUnits
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfFullSet ()
specifier|public
name|void
name|testComplementOfFullSet
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|allUnits
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|SomeEnum
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|noUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|allUnits
argument_list|,
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|noUnits
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfEmptyEnumSetWithoutType ()
specifier|public
name|void
name|testComplementOfEmptyEnumSetWithoutType
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|noUnits
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|SomeEnum
argument_list|>
name|allUnits
init|=
name|Sets
operator|.
name|complementOf
argument_list|(
name|noUnits
argument_list|)
decl_stmt|;
name|verifySetContents
argument_list|(
name|allUnits
argument_list|,
name|EnumSet
operator|.
name|allOf
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplementOfEmptySetWithoutTypeDoesntWork ()
specifier|public
name|void
name|testComplementOfEmptySetWithoutTypeDoesntWork
parameter_list|()
block|{
name|Set
argument_list|<
name|SomeEnum
argument_list|>
name|set
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
try|try
block|{
name|Sets
operator|.
name|complementOf
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testNewSetFromMap ()
specifier|public
name|void
name|testNewSetFromMap
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|SOME_COLLECTION
argument_list|)
expr_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|SOME_COLLECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|testNewSetFromMapIllegal ()
specifier|public
name|void
name|testNewSetFromMapIllegal
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Sets
operator|.
name|newSetFromMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
comment|// TODO: the overwhelming number of suppressions below suggests that maybe
comment|// it's not worth having a varargs form of this method at all...
comment|/**    * The 0-ary cartesian product is a single empty list.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_zeroary ()
specifier|public
name|void
name|testCartesianProduct_zeroary
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|()
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|list
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * A unary cartesian product is one list of size 1 for each element in the    * input set.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_unary ()
specifier|public
name|void
name|testCartesianProduct_unary
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|list
argument_list|(
literal|1
argument_list|)
argument_list|,
name|list
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary0x0 ()
specifier|public
name|void
name|testCartesianProduct_binary0x0
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|mt
init|=
name|emptySet
argument_list|()
decl_stmt|;
name|assertEmpty
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|mt
argument_list|,
name|mt
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary0x1 ()
specifier|public
name|void
name|testCartesianProduct_binary0x1
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|mt
init|=
name|emptySet
argument_list|()
decl_stmt|;
name|assertEmpty
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|mt
argument_list|,
name|set
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary1x0 ()
specifier|public
name|void
name|testCartesianProduct_binary1x0
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|mt
init|=
name|emptySet
argument_list|()
decl_stmt|;
name|assertEmpty
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mt
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertEmpty (Set<? extends List<?>> set)
specifier|private
specifier|static
name|void
name|assertEmpty
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|?
argument_list|>
argument_list|>
name|set
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|set
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|set
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|set
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary1x1 ()
specifier|public
name|void
name|testCartesianProduct_binary1x1
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|item
argument_list|(
name|list
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary1x2 ()
specifier|public
name|void
name|testCartesianProduct_binary1x2
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|list
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_binary2x2 ()
specifier|public
name|void
name|testCartesianProduct_binary2x2
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|set
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|list
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|list
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|list
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_2x2x2 ()
specifier|public
name|void
name|testCartesianProduct_2x2x2
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|list
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|list
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_contains ()
specifier|public
name|void
name|testCartesianProduct_contains
parameter_list|()
block|{
name|Set
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|actual
init|=
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|set
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|contains
argument_list|(
name|list
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|contains
argument_list|(
name|list
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|contains
argument_list|(
name|list
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|contains
argument_list|(
name|list
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|actual
operator|.
name|contains
argument_list|(
name|list
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_unrelatedTypes ()
specifier|public
name|void
name|testCartesianProduct_unrelatedTypes
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|x
init|=
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|y
init|=
name|set
argument_list|(
literal|"3"
argument_list|,
literal|"4"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|exp1
init|=
name|list
argument_list|(
operator|(
name|Object
operator|)
literal|1
argument_list|,
literal|"3"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|exp2
init|=
name|list
argument_list|(
operator|(
name|Object
operator|)
literal|1
argument_list|,
literal|"4"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|exp3
init|=
name|list
argument_list|(
operator|(
name|Object
operator|)
literal|2
argument_list|,
literal|"3"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|exp4
init|=
name|list
argument_list|(
operator|(
name|Object
operator|)
literal|2
argument_list|,
literal|"4"
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|Sets
operator|.
expr|<
name|Object
operator|>
name|cartesianProduct
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
operator|.
name|has
argument_list|()
operator|.
name|exactly
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|,
name|exp3
argument_list|,
name|exp4
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProductTooBig ()
specifier|public
name|void
name|testCartesianProductTooBig
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
init|=
name|ContiguousSet
operator|.
name|create
argument_list|(
name|Range
operator|.
name|closed
argument_list|(
literal|0
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|DiscreteDomain
operator|.
name|integers
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|,
name|set
argument_list|,
name|set
argument_list|,
name|set
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IAE"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// varargs!
DECL|method|testCartesianProduct_hashCode ()
specifier|public
name|void
name|testCartesianProduct_hashCode
parameter_list|()
block|{
comment|// Run through the same cartesian products we tested above
name|Set
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|degenerate
init|=
name|Sets
operator|.
name|cartesianProduct
argument_list|()
decl_stmt|;
name|checkHashCode
argument_list|(
name|degenerate
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|3
operator|*
literal|2
decl_stmt|;
comment|// tickle overflow-related problems
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
name|num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|mt
init|=
name|emptySet
argument_list|()
decl_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|mt
argument_list|,
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|mt
argument_list|,
name|set
argument_list|(
name|num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
name|num
argument_list|)
argument_list|,
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
name|num
argument_list|)
argument_list|,
name|set
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|,
name|num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|,
name|num
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|,
name|num
operator|-
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|3
argument_list|,
name|num
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// a bigger one
name|checkHashCode
argument_list|(
name|Sets
operator|.
name|cartesianProduct
argument_list|(
name|set
argument_list|(
literal|1
argument_list|,
name|num
argument_list|,
name|num
operator|+
literal|1
argument_list|)
argument_list|,
name|set
argument_list|(
literal|2
argument_list|)
argument_list|,
name|set
argument_list|(
literal|3
argument_list|,
name|num
operator|+
literal|2
argument_list|)
argument_list|,
name|set
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testPowerSetEmpty ()
specifier|public
name|void
name|testPowerSetEmpty
parameter_list|()
block|{
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|elements
init|=
name|ImmutableSet
operator|.
name|of
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|powerSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|,
name|powerSet
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|powerSet
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPowerSetContents ()
specifier|public
name|void
name|testPowerSetContents
parameter_list|()
block|{
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|elements
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|powerSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
operator|*
literal|1
operator|+
literal|4
operator|*
literal|2
operator|+
literal|4
operator|*
literal|3
argument_list|,
name|powerSet
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|expected
init|=
name|newHashSet
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|almostPowerSet
init|=
name|newHashSet
argument_list|(
name|expected
argument_list|)
decl_stmt|;
name|almostPowerSet
operator|.
name|remove
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|almostPowerSet
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|expected
argument_list|,
name|powerSet
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|almostPowerSet
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
for|for
control|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|subset
range|:
name|expected
control|)
block|{
name|assertTrue
argument_list|(
name|powerSet
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|powerSet
operator|.
name|contains
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|powerSet
operator|.
name|contains
argument_list|(
name|singleton
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|powerSet
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|powerSet
operator|.
name|contains
argument_list|(
literal|"notASet"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testPowerSetIteration_manual ()
specifier|public
name|void
name|testPowerSetIteration_manual
parameter_list|()
block|{
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|elements
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
comment|// The API doesn't promise this iteration order, but it's convenient here.
name|Iterator
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|i
init|=
name|powerSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|2
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|3
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|i
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPowerSetIteration_iteratorTester_fast ()
specifier|public
name|void
name|testPowerSetIteration_iteratorTester_fast
parameter_list|()
block|{
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|elements
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|expected
init|=
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
operator|new
name|IteratorTester
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
literal|4
argument_list|,
name|UNMODIFIABLE
argument_list|,
name|expected
argument_list|,
name|KNOWN_ORDER
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|newTargetIterator
parameter_list|()
block|{
return|return
name|powerSet
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
operator|.
name|test
argument_list|()
expr_stmt|;
block|}
DECL|method|testPowerSetSize ()
specifier|public
name|void
name|testPowerSetSize
parameter_list|()
block|{
name|assertPowerSetSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertPowerSetSize
argument_list|(
literal|2
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|assertPowerSetSize
argument_list|(
literal|4
argument_list|,
literal|'a'
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
name|assertPowerSetSize
argument_list|(
literal|8
argument_list|,
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|assertPowerSetSize
argument_list|(
literal|16
argument_list|,
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'d'
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
name|assertPowerSetSize
argument_list|(
literal|1
operator|<<
literal|30
argument_list|,
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'c'
argument_list|,
literal|'d'
argument_list|,
literal|'e'
argument_list|,
literal|'f'
argument_list|,
literal|'g'
argument_list|,
literal|'h'
argument_list|,
literal|'i'
argument_list|,
literal|'j'
argument_list|,
literal|'k'
argument_list|,
literal|'l'
argument_list|,
literal|'m'
argument_list|,
literal|'n'
argument_list|,
literal|'o'
argument_list|,
literal|'p'
argument_list|,
literal|'q'
argument_list|,
literal|'r'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'u'
argument_list|,
literal|'v'
argument_list|,
literal|'w'
argument_list|,
literal|'x'
argument_list|,
literal|'y'
argument_list|,
literal|'z'
argument_list|,
literal|'1'
argument_list|,
literal|'2'
argument_list|,
literal|'3'
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
block|}
DECL|method|testPowerSetCreationErrors ()
specifier|public
name|void
name|testPowerSetCreationErrors
parameter_list|()
block|{
try|try
block|{
name|powerSet
argument_list|(
name|newHashSet
argument_list|(
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'c'
argument_list|,
literal|'d'
argument_list|,
literal|'e'
argument_list|,
literal|'f'
argument_list|,
literal|'g'
argument_list|,
literal|'h'
argument_list|,
literal|'i'
argument_list|,
literal|'j'
argument_list|,
literal|'k'
argument_list|,
literal|'l'
argument_list|,
literal|'m'
argument_list|,
literal|'n'
argument_list|,
literal|'o'
argument_list|,
literal|'p'
argument_list|,
literal|'q'
argument_list|,
literal|'r'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'u'
argument_list|,
literal|'v'
argument_list|,
literal|'w'
argument_list|,
literal|'x'
argument_list|,
literal|'y'
argument_list|,
literal|'z'
argument_list|,
literal|'1'
argument_list|,
literal|'2'
argument_list|,
literal|'3'
argument_list|,
literal|'4'
argument_list|,
literal|'5'
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|powerSet
argument_list|(
name|singleton
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPowerSetEqualsAndHashCode_verifyAgainstHashSet ()
specifier|public
name|void
name|testPowerSetEqualsAndHashCode_verifyAgainstHashSet
parameter_list|()
block|{
name|ImmutableList
argument_list|<
name|Integer
argument_list|>
name|allElements
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|4233352
argument_list|,
literal|3284593
argument_list|,
literal|3794208
argument_list|,
literal|3849533
argument_list|,
literal|4013967
argument_list|,
literal|2902658
argument_list|,
literal|1886275
argument_list|,
literal|2131109
argument_list|,
literal|985872
argument_list|,
literal|1843868
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|elements
init|=
name|newHashSet
argument_list|(
name|allElements
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet1
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|powerSet2
init|=
name|powerSet
argument_list|(
name|elements
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|powerSet1
argument_list|,
name|powerSet2
argument_list|,
name|toHashSets
argument_list|(
name|powerSet1
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|9999999
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
literal|"notASet"
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|toHashSets
argument_list|(
name|powerSet1
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|,
name|powerSet1
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test that a hash code miscomputed by "input.hashCode() * tooFarValue / 2"    * is correct under our {@code hashCode} implementation.    */
DECL|method|testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero ()
specifier|public
name|void
name|testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|sumToEighthMaxIntElements
init|=
name|newHashSet
argument_list|(
name|objectWithHashCode
argument_list|(
literal|1
operator|<<
literal|29
argument_list|)
argument_list|,
name|objectWithHashCode
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|assertPowerSetHashCode
argument_list|(
literal|1
operator|<<
literal|30
argument_list|,
name|sumToEighthMaxIntElements
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Object
argument_list|>
name|sumToQuarterMaxIntElements
init|=
name|newHashSet
argument_list|(
name|objectWithHashCode
argument_list|(
literal|1
operator|<<
literal|30
argument_list|)
argument_list|,
name|objectWithHashCode
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|assertPowerSetHashCode
argument_list|(
literal|1
operator|<<
literal|31
argument_list|,
name|sumToQuarterMaxIntElements
argument_list|)
expr_stmt|;
block|}
DECL|method|testPowerSetShowOff ()
specifier|public
name|void
name|testPowerSetShowOff
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|zero
init|=
name|ImmutableSet
operator|.
name|of
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
name|one
init|=
name|powerSet
argument_list|(
name|zero
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|two
init|=
name|powerSet
argument_list|(
name|one
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
argument_list|>
name|four
init|=
name|powerSet
argument_list|(
name|two
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
argument_list|>
argument_list|>
name|sixteen
init|=
name|powerSet
argument_list|(
name|four
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
argument_list|>
argument_list|>
argument_list|>
name|sixtyFiveThousandish
init|=
name|powerSet
argument_list|(
name|sixteen
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
operator|<<
literal|16
argument_list|,
name|sixtyFiveThousandish
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|powerSet
argument_list|(
name|makeSetOfZeroToTwentyNine
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|makeSetOfZeroToTwentyNine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|powerSet
argument_list|(
name|makeSetOfZeroToTwentyNine
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|30
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|makeSetOfZeroToTwentyNine ()
specifier|private
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|makeSetOfZeroToTwentyNine
parameter_list|()
block|{
comment|// TODO: use Range once it's publicly available
name|Set
argument_list|<
name|Integer
argument_list|>
name|zeroToTwentyNine
init|=
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|zeroToTwentyNine
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|zeroToTwentyNine
return|;
block|}
DECL|method|toHashSets (Set<Set<E>> powerSet)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|toHashSets
parameter_list|(
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|powerSet
parameter_list|)
block|{
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|result
init|=
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|E
argument_list|>
name|subset
range|:
name|powerSet
control|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|objectWithHashCode (final int hashCode)
specifier|private
specifier|static
name|Object
name|objectWithHashCode
parameter_list|(
specifier|final
name|int
name|hashCode
parameter_list|)
block|{
return|return
operator|new
name|Object
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hashCode
return|;
block|}
block|}
return|;
block|}
DECL|method|assertPowerSetHashCode (int expected, Set<?> elements)
specifier|private
specifier|static
name|void
name|assertPowerSetHashCode
parameter_list|(
name|int
name|expected
parameter_list|,
name|Set
argument_list|<
name|?
argument_list|>
name|elements
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|powerSet
argument_list|(
name|elements
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|assertPowerSetSize (int i, Object... elements)
specifier|private
specifier|static
name|void
name|assertPowerSetSize
parameter_list|(
name|int
name|i
parameter_list|,
name|Object
modifier|...
name|elements
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|powerSet
argument_list|(
name|newHashSet
argument_list|(
name|elements
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|checkHashCode (Set<?> set)
specifier|private
specifier|static
name|void
name|checkHashCode
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|set
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|Sets
operator|.
name|newHashSet
argument_list|(
name|set
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|,
name|set
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|set (E... elements)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|)
return|;
block|}
DECL|method|list (E... elements)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|)
return|;
block|}
comment|/**    * Utility method to verify that the given LinkedHashSet is equal to and    * hashes identically to a set constructed with the elements in the given    * collection.  Also verifies that the ordering in the set is the same    * as the ordering of the given contents.    */
DECL|method|verifyLinkedHashSetContents ( LinkedHashSet<E> set, Collection<E> contents)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|void
name|verifyLinkedHashSetContents
parameter_list|(
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|contents
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"LinkedHashSet should have preserved order for iteration"
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|set
argument_list|)
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility method to verify that the given SortedSet is equal to and    * hashes identically to a set constructed with the elements in the    * given iterable.  Also verifies that the comparator is the same as the    * given comparator.    */
DECL|method|verifySortedSetContents ( SortedSet<E> set, Iterable<E> iterable, @Nullable Comparator<E> comparator)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|void
name|verifySortedSetContents
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|set
parameter_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|set
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|verifySetContents
argument_list|(
name|set
argument_list|,
name|iterable
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility method that verifies that the given set is equal to and hashes    * identically to a set constructed with the elements in the given iterable.    */
DECL|method|verifySetContents (Set<E> set, Iterable<E> contents)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|void
name|verifySetContents
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
name|contents
parameter_list|)
block|{
name|Set
argument_list|<
name|E
argument_list|>
name|expected
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|contents
operator|instanceof
name|Set
condition|)
block|{
name|expected
operator|=
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|contents
expr_stmt|;
block|}
else|else
block|{
name|expected
operator|=
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|E
name|element
range|:
name|contents
control|)
block|{
name|expected
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simple base class to verify that we handle generics correctly.    */
DECL|class|Base
specifier|static
class|class
name|Base
implements|implements
name|Comparable
argument_list|<
name|Base
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|s
specifier|private
specifier|final
name|String
name|s
decl_stmt|;
DECL|method|Base (String s)
specifier|public
name|Base
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// delegate to 's'
return|return
name|s
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object other)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|instanceof
name|Base
condition|)
block|{
return|return
name|s
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Base
operator|)
name|other
operator|)
operator|.
name|s
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|compareTo (Base o)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Base
name|o
parameter_list|)
block|{
return|return
name|s
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|s
argument_list|)
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Simple derived class to verify that we handle generics correctly.    */
DECL|class|Derived
specifier|static
class|class
name|Derived
extends|extends
name|Base
block|{
DECL|method|Derived (String s)
specifier|public
name|Derived
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|method|ensureNotDirectlyModifiable (SortedSet<Integer> unmod)
name|void
name|ensureNotDirectlyModifiable
parameter_list|(
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|unmod
parameter_list|)
block|{
try|try
block|{
name|unmod
operator|.
name|add
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|unmod
operator|.
name|remove
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|unmod
operator|.
name|addAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
init|=
name|unmod
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
block|}
block|}
end_class

end_unit

