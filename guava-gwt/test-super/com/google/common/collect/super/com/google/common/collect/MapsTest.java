begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|transformEntries
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|transformValues
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|Helpers
operator|.
name|mapEntry
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertThat
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|ValueDifferenceImpl
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetsTest
operator|.
name|Derived
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|EqualsTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|SerializableTester
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_comment
comment|/**  * Unit test for {@code Maps}.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Jared Levy  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|MapsTest
specifier|public
class|class
name|MapsTest
extends|extends
name|TestCase
block|{
DECL|field|SOME_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|SOME_COMPARATOR
init|=
name|Collections
operator|.
name|reverseOrder
argument_list|()
decl_stmt|;
DECL|method|testHashMap ()
specifier|public
name|void
name|testHashMap
parameter_list|()
block|{
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashMapWithInitialMap ()
specifier|public
name|void
name|testHashMapWithInitialMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashMapGeneralizesTypes ()
specifier|public
name|void
name|testHashMapGeneralizesTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|(
operator|(
name|Map
argument_list|<
name|?
extends|extends
name|Object
argument_list|,
name|?
extends|extends
name|Object
argument_list|>
operator|)
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testCapacityForNegativeSizeFails ()
specifier|public
name|void
name|testCapacityForNegativeSizeFails
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
name|capacity
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Negative expected size must result in IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCapacityForLargeSizes ()
specifier|public
name|void
name|testCapacityForLargeSizes
parameter_list|()
block|{
name|int
index|[]
name|largeExpectedSizes
init|=
operator|new
name|int
index|[]
block|{
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|-
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|+
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
for|for
control|(
name|int
name|expectedSize
range|:
name|largeExpectedSizes
control|)
block|{
name|int
name|capacity
init|=
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"capacity ("
operator|+
name|capacity
operator|+
literal|") must be>= expectedSize ("
operator|+
name|expectedSize
operator|+
literal|")"
argument_list|,
name|capacity
operator|>=
name|expectedSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testLinkedHashMap ()
specifier|public
name|void
name|testLinkedHashMap
parameter_list|()
block|{
name|LinkedHashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|method|testLinkedHashMapWithInitialMap ()
specifier|public
name|void
name|testLinkedHashMapWithInitialMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
block|{
name|put
argument_list|(
literal|"Hello"
argument_list|,
literal|"World"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"first"
argument_list|,
literal|"second"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"polygene"
argument_list|,
literal|"lubricants"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"alpha"
argument_list|,
literal|"betical"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iter
init|=
name|copy
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Hello"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"World"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"first"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"second"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"polygene"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"lubricants"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"alpha"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"betical"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLinkedHashMapGeneralizesTypes ()
specifier|public
name|void
name|testLinkedHashMapGeneralizesTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|Maps
operator|.
expr|<
name|Object
decl_stmt|,
name|Object
decl|>
name|newLinkedHashMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testIdentityHashMap ()
specifier|public
name|void
name|testIdentityHashMap
parameter_list|()
block|{
name|IdentityHashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcurrentMap ()
specifier|public
name|void
name|testConcurrentMap
parameter_list|()
block|{
name|ConcurrentMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMap ()
specifier|public
name|void
name|testTreeMap
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapDerived ()
specifier|public
name|void
name|testTreeMapDerived
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Derived
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapNonGeneric ()
specifier|public
name|void
name|testTreeMapNonGeneric
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|LegacyComparable
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapWithComparator ()
specifier|public
name|void
name|testTreeMapWithComparator
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|SOME_COMPARATOR
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|SOME_COMPARATOR
argument_list|,
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapWithInitialMap ()
specifier|public
name|void
name|testTreeMapWithInitialMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|copy
operator|.
name|comparator
argument_list|()
argument_list|,
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|enum|SomeEnum
DECL|enumConstant|SOME_INSTANCE
specifier|public
enum|enum
name|SomeEnum
block|{
name|SOME_INSTANCE
block|}
DECL|method|testEnumMap ()
specifier|public
name|void
name|testEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapNullClass ()
specifier|public
name|void
name|testEnumMapNullClass
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
expr|<
name|SomeEnum
operator|,
name|Long
operator|>
name|newEnumMap
argument_list|(
operator|(
name|Class
argument_list|<
name|MapsTest
operator|.
name|SomeEnum
argument_list|>
operator|)
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"no exception thrown"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testEnumMapWithInitialEnumMap ()
specifier|public
name|void
name|testEnumMapWithInitialEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialEmptyEnumMap ()
specifier|public
name|void
name|testEnumMapWithInitialEmptyEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialMap ()
specifier|public
name|void
name|testEnumMapWithInitialMap
parameter_list|()
block|{
name|HashMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialEmptyMap ()
specifier|public
name|void
name|testEnumMapWithInitialEmptyMap
parameter_list|()
block|{
name|Map
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Empty map must result in an IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testToStringImplWithNullKeys ()
specifier|public
name|void
name|testToStringImplWithNullKeys
parameter_list|()
throws|throws
name|Exception
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|hashmap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|hashmap
operator|.
name|put
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
expr_stmt|;
name|hashmap
operator|.
name|put
argument_list|(
literal|null
argument_list|,
literal|"baz"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hashmap
operator|.
name|toString
argument_list|()
argument_list|,
name|Maps
operator|.
name|toStringImpl
argument_list|(
name|hashmap
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testToStringImplWithNullValues ()
specifier|public
name|void
name|testToStringImplWithNullValues
parameter_list|()
throws|throws
name|Exception
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|hashmap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|hashmap
operator|.
name|put
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
expr_stmt|;
name|hashmap
operator|.
name|put
argument_list|(
literal|"baz"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hashmap
operator|.
name|toString
argument_list|()
argument_list|,
name|Maps
operator|.
name|toStringImpl
argument_list|(
name|hashmap
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|EMPTY
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|SINGLETON
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SINGLETON
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
DECL|method|testMapDifferenceEmptyEmpty ()
specifier|public
name|void
name|testMapDifferenceEmptyEmpty
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|EMPTY
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"equal"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceEmptySingleton ()
specifier|public
name|void
name|testMapDifferenceEmptySingleton
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|EMPTY
argument_list|,
name|SINGLETON
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on right={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceSingletonEmpty ()
specifier|public
name|void
name|testMapDifferenceSingletonEmpty
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SINGLETON
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceTypical ()
specifier|public
name|void
name|testMapDifferenceTypical
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={2=b, 4=d}: only on right={6=z}: "
operator|+
literal|"value differences={3=(c, f), 5=(e, g)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"f"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"g"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(f, c), 5=(g, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceEquals ()
specifier|public
name|void
name|testMapDifferenceEquals
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right2
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"h"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|original
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|same
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|reverse
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right2
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|original
argument_list|,
name|same
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|reverse
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|diff2
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testMapDifferencePredicateTypical ()
specifier|public
name|void
name|testMapDifferencePredicateTypical
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"A"
argument_list|,
literal|3
argument_list|,
literal|"F"
argument_list|,
literal|5
argument_list|,
literal|"G"
argument_list|,
literal|6
argument_list|,
literal|"Z"
argument_list|)
decl_stmt|;
comment|// TODO(kevinb): replace with Ascii.caseInsensitiveEquivalence() when it
comment|// exists
name|Equivalence
argument_list|<
name|String
argument_list|>
name|caseInsensitiveEquivalence
init|=
name|Equivalence
operator|.
name|equals
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|caseInsensitiveEquivalence
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"Z"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"F"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"G"
argument_list|)
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={2=b, 4=d}: only on right={6=Z}: "
operator|+
literal|"value differences={3=(c, F), 5=(e, G)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|caseInsensitiveEquivalence
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"Z"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"A"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"F"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"G"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=Z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(F, c), 5=(G, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|SORTED_EMPTY
specifier|private
specifier|static
specifier|final
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SORTED_EMPTY
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
DECL|field|SORTED_SINGLETON
specifier|private
specifier|static
specifier|final
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SORTED_SINGLETON
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
DECL|method|testMapDifferenceOfSortedMapIsSorted ()
specifier|public
name|void
name|testMapDifferenceOfSortedMapIsSorted
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|SORTED_SINGLETON
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|difference
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|map
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|difference
operator|instanceof
name|SortedMapDifference
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceEmptyEmpty ()
specifier|public
name|void
name|testSortedMapDifferenceEmptyEmpty
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|SORTED_EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"equal"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceEmptySingleton ()
specifier|public
name|void
name|testSortedMapDifferenceEmptySingleton
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|SORTED_SINGLETON
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on right={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceSingletonEmpty ()
specifier|public
name|void
name|testSortedMapDifferenceSingletonEmpty
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|SORTED_EMPTY
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceTypical ()
specifier|public
name|void
name|testSortedMapDifferenceTypical
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableSortedMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|String
decl|>
name|reverseOrder
argument_list|()
decl|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
decl|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
decl|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"c"
argument_list|)
decl|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
decl|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"e"
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesDiffering
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={4=d, 2=b}: only on right={6=z}: "
operator|+
literal|"value differences={5=(e, g), 3=(c, f)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"f"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"g"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(f, c), 5=(g, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceImmutable ()
specifier|public
name|void
name|testSortedMapDifferenceImmutable
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|left
operator|.
name|put
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|diff1
operator|.
name|entriesDiffering
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
try|try
block|{
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testSortedMapDifferenceEquals ()
specifier|public
name|void
name|testSortedMapDifferenceEquals
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right2
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"h"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|original
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|same
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|reverse
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right2
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|original
argument_list|,
name|same
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|reverse
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|diff2
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|field|LENGTH_FUNCTION
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|LENGTH_FUNCTION
init|=
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|length
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|testAsMap ()
specifier|public
name|void
name|testAsMap
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|"three"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"five"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAsMapReadsThrough ()
specifier|public
name|void
name|testAsMapReadsThrough
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|strings
argument_list|,
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|strings
operator|.
name|add
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testAsMapWritesThrough ()
specifier|public
name|void
name|testAsMapWritesThrough
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|strings
argument_list|,
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|,
name|map
operator|.
name|remove
argument_list|(
literal|"two"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|strings
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|"one"
argument_list|,
literal|"three"
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAsMapEmpty ()
specifier|public
name|void
name|testAsMapEmpty
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableSet
operator|.
name|of
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"five"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|NonNavigableSortedSet
specifier|private
specifier|static
class|class
name|NonNavigableSortedSet
extends|extends
name|ForwardingSortedSet
argument_list|<
name|String
argument_list|>
block|{
DECL|field|delegate
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|String
argument_list|>
name|delegate
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|SortedSet
argument_list|<
name|String
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
DECL|method|testAsMapReturnsSortedMapForSortedSetInput ()
specifier|public
name|void
name|testAsMapReturnsSortedMapForSortedSetInput
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|NonNavigableSortedSet
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|asMap
argument_list|(
name|set
argument_list|,
name|Functions
operator|.
name|identity
argument_list|()
argument_list|)
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testAsMapSorted ()
specifier|public
name|void
name|testAsMapSorted
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|NonNavigableSortedSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|strings
argument_list|,
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|"three"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"five"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|tailMap
argument_list|(
literal|"onea"
argument_list|)
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|subMap
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|)
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAsMapSortedReadsThrough ()
specifier|public
name|void
name|testAsMapSortedReadsThrough
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|NonNavigableSortedSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|strings
argument_list|,
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|strings
operator|.
name|add
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|headMap
init|=
name|map
operator|.
name|headMap
argument_list|(
literal|"two"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|,
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|headMap
argument_list|)
expr_stmt|;
name|strings
operator|.
name|add
argument_list|(
literal|"five"
argument_list|)
expr_stmt|;
name|strings
operator|.
name|remove
argument_list|(
literal|"one"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"five"
argument_list|,
literal|4
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|headMap
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"five"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAsMapSortedWritesThrough ()
specifier|public
name|void
name|testAsMapSortedWritesThrough
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|NonNavigableSortedSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|strings
argument_list|,
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|,
name|map
operator|.
name|remove
argument_list|(
literal|"two"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|strings
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|"one"
argument_list|,
literal|"three"
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAsMapSortedSubViewKeySetsDoNotSupportAdd ()
specifier|public
name|void
name|testAsMapSortedSubViewKeySetsDoNotSupportAdd
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
operator|new
name|NonNavigableSortedSet
argument_list|()
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
try|try
block|{
name|map
operator|.
name|subMap
argument_list|(
literal|"a"
argument_list|,
literal|"z"
argument_list|)
operator|.
name|keySet
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|map
operator|.
name|tailMap
argument_list|(
literal|"a"
argument_list|)
operator|.
name|keySet
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|map
operator|.
name|headMap
argument_list|(
literal|"r"
argument_list|)
operator|.
name|keySet
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|map
operator|.
name|headMap
argument_list|(
literal|"r"
argument_list|)
operator|.
name|tailMap
argument_list|(
literal|"m"
argument_list|)
operator|.
name|keySet
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testAsMapSortedEmpty ()
specifier|public
name|void
name|testAsMapSortedEmpty
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|NonNavigableSortedSet
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|asMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"five"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testToMap ()
specifier|public
name|void
name|testToMap
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|toMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testToMapIterator ()
specifier|public
name|void
name|testToMapIterator
parameter_list|()
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|toMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testToMapWithDuplicateKeys ()
specifier|public
name|void
name|testToMapWithDuplicateKeys
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|,
literal|"two"
argument_list|,
literal|"one"
argument_list|)
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|toMap
argument_list|(
name|strings
argument_list|,
name|LENGTH_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|,
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|mapEntry
argument_list|(
literal|"one"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"two"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|mapEntry
argument_list|(
literal|"three"
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testToMapWithNullKeys ()
specifier|public
name|void
name|testToMapWithNullKeys
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"one"
argument_list|,
literal|null
argument_list|,
literal|"three"
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|toMap
argument_list|(
name|strings
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testToMapWithNullValues ()
specifier|public
name|void
name|testToMapWithNullValues
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"two"
argument_list|,
literal|"three"
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|toMap
argument_list|(
name|strings
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|field|INT_TO_STRING_MAP
specifier|private
specifier|static
specifier|final
name|BiMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|INT_TO_STRING_MAP
init|=
operator|new
name|ImmutableBiMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|method|testUniqueIndexCollection ()
specifier|public
name|void
name|testUniqueIndexCollection
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testUniqueIndexIterable ()
specifier|public
name|void
name|testUniqueIndexIterable
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
operator|new
name|Iterable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testUniqueIndexIterator ()
specifier|public
name|void
name|testUniqueIndexIterator
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
comment|/** Can't create the map if more than one value maps to the same key. */
DECL|method|testUniqueIndexDuplicates ()
specifier|public
name|void
name|testUniqueIndexDuplicates
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"uno"
argument_list|)
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
literal|"Multimaps.index"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Null values are not allowed. */
DECL|method|testUniqueIndexNullValue ()
specifier|public
name|void
name|testUniqueIndexNullValue
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|listWithNull
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|listWithNull
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
comment|/** Null keys aren't allowed either. */
DECL|method|testUniqueIndexNullKey ()
specifier|public
name|void
name|testUniqueIndexNullKey
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|oneStringList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|oneStringList
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testAsConverter_nominal ()
specifier|public
name|void
name|testAsConverter_nominal
parameter_list|()
throws|throws
name|Exception
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|biMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|assertSame
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAsConverter_inverse ()
specifier|public
name|void
name|testAsConverter_inverse
parameter_list|()
throws|throws
name|Exception
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|biMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|assertSame
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|converter
operator|.
name|reverse
argument_list|()
operator|.
name|convert
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAsConverter_noMapping ()
specifier|public
name|void
name|testAsConverter_noMapping
parameter_list|()
throws|throws
name|Exception
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
try|try
block|{
name|converter
operator|.
name|convert
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testAsConverter_nullConversions ()
specifier|public
name|void
name|testAsConverter_nullConversions
parameter_list|()
throws|throws
name|Exception
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|converter
operator|.
name|convert
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|converter
operator|.
name|reverse
argument_list|()
operator|.
name|convert
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testAsConverter_isAView ()
specifier|public
name|void
name|testAsConverter_isAView
parameter_list|()
throws|throws
name|Exception
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|biMap
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|biMap
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
literal|1
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
literal|"one"
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|2
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
literal|"two"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|converter
operator|.
name|convert
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
name|biMap
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|1
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
literal|"one"
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|2
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
literal|"two"
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|3
argument_list|,
name|converter
operator|.
name|convert
argument_list|(
literal|"three"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testAsConverter_withNullMapping ()
specifier|public
name|void
name|testAsConverter_withNullMapping
parameter_list|()
throws|throws
name|Exception
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|biMap
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|biMap
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|biMap
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
operator|.
name|convert
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testAsConverter_toString ()
specifier|public
name|void
name|testAsConverter_toString
parameter_list|()
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Maps.asConverter({one=1, two=2})"
argument_list|,
name|converter
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAsConverter_serialization ()
specifier|public
name|void
name|testAsConverter_serialization
parameter_list|()
block|{
name|ImmutableBiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|biMap
init|=
name|ImmutableBiMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Converter
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|converter
init|=
name|Maps
operator|.
name|asConverter
argument_list|(
name|biMap
argument_list|)
decl_stmt|;
name|SerializableTester
operator|.
name|reserializeAndAssert
argument_list|(
name|converter
argument_list|)
expr_stmt|;
block|}
DECL|method|testUnmodifiableBiMap ()
specifier|public
name|void
name|testUnmodifiableBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|mod
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|BiMap
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
name|unmod
init|=
name|Maps
operator|.
expr|<
name|Number
decl_stmt|,
name|String
decl|>
name|unmodifiableBiMap
argument_list|(
name|mod
argument_list|)
decl_stmt|;
comment|/* No aliasing on inverse operations. */
name|assertSame
argument_list|(
name|unmod
operator|.
name|inverse
argument_list|()
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|unmod
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Unmodifiable is a view. */
name|mod
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
name|unmod
operator|.
name|get
argument_list|(
literal|4
argument_list|)
operator|.
name|equals
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
operator|.
name|equals
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UnsupportedOperationException on direct modifications. */
try|try
block|{
name|unmod
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|unmod
operator|.
name|forcePut
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|unmod
operator|.
name|putAll
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
comment|/* UnsupportedOperationException on indirect modifications. */
name|BiMap
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|inverse
init|=
name|unmod
operator|.
name|inverse
argument_list|()
decl_stmt|;
try|try
block|{
name|inverse
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|inverse
operator|.
name|forcePut
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|inverse
operator|.
name|putAll
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|Set
argument_list|<
name|String
argument_list|>
name|values
init|=
name|unmod
operator|.
name|values
argument_list|()
decl_stmt|;
try|try
block|{
name|values
operator|.
name|remove
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
argument_list|>
name|entries
init|=
name|unmod
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|entries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setValue
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry2
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|entries
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
try|try
block|{
name|entry2
operator|.
name|setValue
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testImmutableEntry ()
specifier|public
name|void
name|testImmutableEntry
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|e
init|=
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|e
operator|.
name|setValue
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
literal|"foo=1"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|101575
argument_list|,
name|e
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testImmutableEntryNull ()
specifier|public
name|void
name|testImmutableEntryNull
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|e
init|=
name|Maps
operator|.
name|immutableEntry
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|,
operator|(
name|Integer
operator|)
literal|null
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|e
operator|.
name|setValue
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
literal|"null=null"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link SynchronizedBiMapTest} for more tests. */
DECL|method|testSynchronizedBiMap ()
specifier|public
name|void
name|testSynchronizedBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|bimap
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|bimap
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|sync
init|=
name|Maps
operator|.
name|synchronizedBiMap
argument_list|(
name|bimap
argument_list|)
decl_stmt|;
name|bimap
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sync
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|bimap
operator|.
name|inverse
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|sync
operator|.
name|inverse
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|NOT_LENGTH_3
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|NOT_LENGTH_3
init|=
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
name|input
operator|.
name|length
argument_list|()
operator|!=
literal|3
return|;
block|}
block|}
decl_stmt|;
DECL|field|EVEN
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Integer
argument_list|>
name|EVEN
init|=
operator|new
name|Predicate
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Integer
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
name|input
operator|%
literal|2
operator|==
literal|0
return|;
block|}
block|}
decl_stmt|;
DECL|field|CORRECT_LENGTH
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|CORRECT_LENGTH
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|()
operator|==
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|SQRT_FUNCTION
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|SQRT_FUNCTION
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Double
name|apply
parameter_list|(
name|Integer
name|in
parameter_list|)
block|{
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|in
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressUnderAndroid
DECL|class|FilteredMapTest
specifier|public
specifier|static
class|class
name|FilteredMapTest
extends|extends
name|TestCase
block|{
DECL|method|createUnfiltered ()
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|createUnfiltered
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|newHashMap
argument_list|()
return|;
block|}
DECL|method|testFilteredKeysIllegalPut ()
specifier|public
name|void
name|testFilteredKeysIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testFilteredKeysIllegalPutAll ()
specifier|public
name|void
name|testFilteredKeysIllegalPutAll
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|,
literal|"zzz"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredKeysFilteredReflectsBackingChanges ()
specifier|public
name|void
name|testFilteredKeysFilteredReflectsBackingChanges
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|remove
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesIllegalPut ()
specifier|public
name|void
name|testFilteredValuesIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesIllegalPutAll ()
specifier|public
name|void
name|testFilteredValuesIllegalPutAll
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"zzz"
argument_list|,
literal|5
argument_list|,
literal|"b"
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesIllegalSetValue ()
specifier|public
name|void
name|testFilteredValuesIllegalSetValue
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
name|filtered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setValue
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesClear ()
specifier|public
name|void
name|testFilteredValuesClear
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|filtered
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesIllegalPut ()
specifier|public
name|void
name|testFilteredEntriesIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|CORRECT_LENGTH
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"chicken"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"cow"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesIllegalPutAll ()
specifier|public
name|void
name|testFilteredEntriesIllegalPutAll
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|CORRECT_LENGTH
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"chicken"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"sheep"
argument_list|,
literal|5
argument_list|,
literal|"cow"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesObjectPredicate ()
specifier|public
name|void
name|testFilteredEntriesObjectPredicate
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Object
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|alwaysFalse
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|filtered
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesWildCardEntryPredicate ()
specifier|public
name|void
name|testFilteredEntriesWildCardEntryPredicate
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|predicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|input
parameter_list|)
block|{
return|return
literal|"cat"
operator|.
name|equals
argument_list|(
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|Integer
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
operator|==
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"dog"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressUnderAndroid
DECL|class|FilteredSortedMapTest
specifier|public
specifier|static
class|class
name|FilteredSortedMapTest
extends|extends
name|FilteredMapTest
block|{
annotation|@
name|Override
DECL|method|createUnfiltered ()
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|createUnfiltered
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|newTreeMap
argument_list|()
return|;
block|}
DECL|method|testFilterKeysIdentifiesSortedMap ()
specifier|public
name|void
name|testFilterKeysIdentifiesSortedMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterKeys
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|NOT_LENGTH_3
argument_list|)
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilterValuesIdentifiesSortedMap ()
specifier|public
name|void
name|testFilterValuesIdentifiesSortedMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterValues
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|EVEN
argument_list|)
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilterEntriesIdentifiesSortedMap ()
specifier|public
name|void
name|testFilterEntriesIdentifiesSortedMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterEntries
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|CORRECT_LENGTH
argument_list|)
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirstAndLastKeyFilteredMap ()
specifier|public
name|void
name|testFirstAndLastKeyFilteredMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"apple"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|CORRECT_LENGTH
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"banana"
argument_list|,
name|filtered
operator|.
name|firstKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"cat"
argument_list|,
name|filtered
operator|.
name|lastKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testHeadSubTailMap_FilteredMap ()
specifier|public
name|void
name|testHeadSubTailMap_FilteredMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"apple"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|CORRECT_LENGTH
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|)
argument_list|,
name|filtered
operator|.
name|headMap
argument_list|(
literal|"dog"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|filtered
operator|.
name|headMap
argument_list|(
literal|"banana"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|,
literal|"dog"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|filtered
operator|.
name|headMap
argument_list|(
literal|"emu"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|)
argument_list|,
name|filtered
operator|.
name|subMap
argument_list|(
literal|"banana"
argument_list|,
literal|"dog"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"dog"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|filtered
operator|.
name|subMap
argument_list|(
literal|"cat"
argument_list|,
literal|"emu"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"dog"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|filtered
operator|.
name|tailMap
argument_list|(
literal|"cat"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"banana"
argument_list|,
literal|6
argument_list|,
literal|"dog"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|filtered
operator|.
name|tailMap
argument_list|(
literal|"banana"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressUnderAndroid
DECL|class|FilteredBiMapTest
specifier|public
specifier|static
class|class
name|FilteredBiMapTest
extends|extends
name|FilteredMapTest
block|{
annotation|@
name|Override
DECL|method|createUnfiltered ()
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|createUnfiltered
parameter_list|()
block|{
return|return
name|HashBiMap
operator|.
name|create
argument_list|()
return|;
block|}
DECL|method|testFilterKeysIdentifiesBiMap ()
specifier|public
name|void
name|testFilterKeysIdentifiesBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterKeys
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|NOT_LENGTH_3
argument_list|)
operator|instanceof
name|BiMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilterValuesIdentifiesBiMap ()
specifier|public
name|void
name|testFilterValuesIdentifiesBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterValues
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|EVEN
argument_list|)
operator|instanceof
name|BiMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilterEntriesIdentifiesBiMap ()
specifier|public
name|void
name|testFilterEntriesIdentifiesBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|createUnfiltered
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|Maps
operator|.
name|filterEntries
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
operator|)
name|map
argument_list|,
name|CORRECT_LENGTH
argument_list|)
operator|instanceof
name|BiMap
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransformValues ()
specifier|public
name|void
name|testTransformValues
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|transformed
init|=
name|transformValues
argument_list|(
name|map
argument_list|,
name|SQRT_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2.0
argument_list|,
literal|"b"
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformValuesSecretlySorted ()
specifier|public
name|void
name|testTransformValuesSecretlySorted
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|sortedNotNavigable
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|9
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|transformed
init|=
name|transformValues
argument_list|(
name|map
argument_list|,
name|SQRT_FUNCTION
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2.0
argument_list|,
literal|"b"
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|transformed
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformEntries ()
specifier|public
name|void
name|testTransformEntries
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"4"
argument_list|,
literal|"b"
argument_list|,
literal|"9"
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
name|concat
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|key
operator|+
name|value
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|transformEntries
argument_list|(
name|map
argument_list|,
name|concat
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a4"
argument_list|,
literal|"b"
argument_list|,
literal|"b9"
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformEntriesSecretlySorted ()
specifier|public
name|void
name|testTransformEntriesSecretlySorted
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"4"
argument_list|,
literal|"b"
argument_list|,
literal|"9"
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
name|concat
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|key
operator|+
name|value
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|transformEntries
argument_list|(
name|map
argument_list|,
name|concat
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a4"
argument_list|,
literal|"b"
argument_list|,
literal|"b9"
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|transformed
operator|instanceof
name|SortedMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|testTransformEntriesGenerics ()
specifier|public
name|void
name|testTransformEntriesGenerics
parameter_list|()
block|{
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map1
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Number
argument_list|>
name|map2
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|map3
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Object
argument_list|>
name|map4
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|>
name|map5
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Integer
argument_list|>
name|map6
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|map7
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Number
argument_list|>
name|map8
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map9
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|?
extends|extends
name|Number
argument_list|,
name|?
extends|extends
name|Number
argument_list|>
name|map0
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|,
name|Double
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|,
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Double
name|transformEntry
parameter_list|(
name|Number
name|key
parameter_list|,
name|Number
name|value
parameter_list|)
block|{
return|return
name|key
operator|.
name|doubleValue
argument_list|()
operator|+
name|value
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Double
argument_list|>
name|objectKeyed
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Double
argument_list|>
name|numberKeyed
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|integerKeyed
decl_stmt|;
name|numberKeyed
operator|=
name|transformEntries
argument_list|(
name|map5
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|numberKeyed
operator|=
name|transformEntries
argument_list|(
name|map6
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|integerKeyed
operator|=
name|transformEntries
argument_list|(
name|map8
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|integerKeyed
operator|=
name|transformEntries
argument_list|(
name|map9
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|?
extends|extends
name|Number
argument_list|,
name|Double
argument_list|>
name|wildcarded
init|=
name|transformEntries
argument_list|(
name|map0
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
comment|// Can't loosen the key type:
comment|// objectKeyed = transformEntries(map5, transformer);
comment|// objectKeyed = transformEntries(map6, transformer);
comment|// objectKeyed = transformEntries(map8, transformer);
comment|// objectKeyed = transformEntries(map9, transformer);
comment|// numberKeyed = transformEntries(map8, transformer);
comment|// numberKeyed = transformEntries(map9, transformer);
comment|// Can't loosen the value type:
comment|// Map<Number, Number> looseValued1 = transformEntries(map5, transformer);
comment|// Map<Number, Number> looseValued2 = transformEntries(map6, transformer);
comment|// Map<Integer, Number> looseValued3 = transformEntries(map8, transformer);
comment|// Map<Integer, Number> looseValued4 = transformEntries(map9, transformer);
comment|// Can't call with too loose a key:
comment|// transformEntries(map1, transformer);
comment|// transformEntries(map2, transformer);
comment|// transformEntries(map3, transformer);
comment|// Can't call with too loose a value:
comment|// transformEntries(map1, transformer);
comment|// transformEntries(map4, transformer);
comment|// transformEntries(map7, transformer);
block|}
DECL|method|testTransformEntriesExample ()
specifier|public
name|void
name|testTransformEntriesExample
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|options
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"verbose"
argument_list|,
literal|true
argument_list|,
literal|"sort"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|,
name|String
argument_list|>
name|flagPrefixer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
name|key
else|:
literal|"no"
operator|+
name|key
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|transformEntries
argument_list|(
name|options
argument_list|,
name|flagPrefixer
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"{verbose=verbose, sort=nosort}"
argument_list|,
name|transformed
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Logically this would accept a NavigableMap, but that won't work under GWT.
DECL|method|sortedNotNavigable ( final SortedMap<K, V> map)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sortedNotNavigable
parameter_list|(
specifier|final
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|ForwardingSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|map
return|;
block|}
block|}
return|;
block|}
DECL|method|testSortedMapTransformValues ()
specifier|public
name|void
name|testSortedMapTransformValues
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|sortedNotNavigable
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|9
argument_list|)
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|transformed
init|=
name|transformValues
argument_list|(
name|map
argument_list|,
name|SQRT_FUNCTION
argument_list|)
decl_stmt|;
comment|/*      * We'd like to sanity check that we didn't get a NavigableMap out, but we      * can't easily do so while maintaining GWT compatibility.      */
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2.0
argument_list|,
literal|"b"
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapTransformEntries ()
specifier|public
name|void
name|testSortedMapTransformEntries
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|sortedNotNavigable
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"4"
argument_list|,
literal|"b"
argument_list|,
literal|"9"
argument_list|)
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
name|concat
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|key
operator|+
name|value
return|;
block|}
block|}
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|transformEntries
argument_list|(
name|map
argument_list|,
name|concat
argument_list|)
decl_stmt|;
comment|/*      * We'd like to sanity check that we didn't get a NavigableMap out, but we      * can't easily do so while maintaining GWT compatibility.      */
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a4"
argument_list|,
literal|"b"
argument_list|,
literal|"b9"
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

