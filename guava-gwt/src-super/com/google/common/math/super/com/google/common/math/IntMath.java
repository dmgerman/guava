begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkNoOverflow
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|MathPreconditions
operator|.
name|checkNonNegative
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * A class for arithmetic on values of type {@code int}. Where possible, methods are defined and  * named analogously to their {@code BigInteger} counterparts.  *   *<p>The implementations of many methods in this class are based on material from Henry S. Warren,  * Jr.'s<i>Hacker's Delight</i>, (Addison Wesley, 2002).  *   *<p>Similar functionality for {@code long} and for {@link BigInteger} can be found in  * {@link LongMath} and {@link BigIntegerMath} respectively.  For other common operations on  * {@code int} values, see {@link com.google.common.primitives.Ints}.  *   * @author Louis Wasserman  * @since 11.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|IntMath
specifier|public
specifier|final
class|class
name|IntMath
block|{
comment|// NOTE: Whenever both tests are cheap and functional, it's faster to use&, | instead of&&, ||
comment|/**    * Returns {@code true} if {@code x} represents a power of two.    *     *<p>This differs from {@code Integer.bitCount(x) == 1}, because    * {@code Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power    * of two.    */
DECL|method|isPowerOfTwo (int x)
specifier|public
specifier|static
name|boolean
name|isPowerOfTwo
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|>
literal|0
operator|&
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
comment|/** The biggest half power of two that can fit in an unsigned int. */
DECL|field|MAX_POWER_OF_SQRT2_UNSIGNED
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|int
name|MAX_POWER_OF_SQRT2_UNSIGNED
init|=
literal|0xB504F333
decl_stmt|;
DECL|method|log10Floor (int x)
specifier|private
specifier|static
name|int
name|log10Floor
parameter_list|(
name|int
name|x
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|POWERS_OF_10
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
name|POWERS_OF_10
index|[
name|i
index|]
condition|)
block|{
return|return
name|i
operator|-
literal|1
return|;
block|}
block|}
return|return
name|POWERS_OF_10
operator|.
name|length
operator|-
literal|1
return|;
block|}
DECL|field|POWERS_OF_10
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|int
index|[]
name|POWERS_OF_10
init|=
block|{
literal|1
block|,
literal|10
block|,
literal|100
block|,
literal|1000
block|,
literal|10000
block|,
literal|100000
block|,
literal|1000000
block|,
literal|10000000
block|,
literal|100000000
block|,
literal|1000000000
block|}
decl_stmt|;
comment|// HALF_POWERS_OF_10[i] = largest int less than 10^(i + 0.5)
DECL|field|HALF_POWERS_OF_10
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|int
index|[]
name|HALF_POWERS_OF_10
init|=
block|{
literal|3
block|,
literal|31
block|,
literal|316
block|,
literal|3162
block|,
literal|31622
block|,
literal|316227
block|,
literal|3162277
block|,
literal|31622776
block|,
literal|316227766
block|,
name|Integer
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
DECL|method|sqrtFloor (int x)
specifier|private
specifier|static
name|int
name|sqrtFloor
parameter_list|(
name|int
name|x
parameter_list|)
block|{
comment|// There is no loss of precision in converting an int to a double, according to
comment|// http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.1.2
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|x
argument_list|)
return|;
block|}
comment|/**    * Returns {@code x mod m}. This differs from {@code x % m} in that it always returns a    * non-negative result.    *     *<p>For example:<pre> {@code    *     * mod(7, 4) == 3    * mod(-7, 4) == 1    * mod(-1, 4) == 3    * mod(-8, 4) == 0    * mod(8, 4) == 0}</pre>    *     * @throws ArithmeticException if {@code m<= 0}    */
DECL|method|mod (int x, int m)
specifier|public
specifier|static
name|int
name|mod
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Modulus "
operator|+
name|m
operator|+
literal|" must be> 0"
argument_list|)
throw|;
block|}
name|int
name|result
init|=
name|x
operator|%
name|m
decl_stmt|;
return|return
operator|(
name|result
operator|>=
literal|0
operator|)
condition|?
name|result
else|:
name|result
operator|+
name|m
return|;
block|}
comment|/**    * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if    * {@code a == 0&& b == 0}.    *     * @throws IllegalArgumentException if {@code a< 0} or {@code b< 0}    */
DECL|method|gcd (int a, int b)
specifier|public
specifier|static
name|int
name|gcd
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
comment|/*      * The reason we require both arguments to be>= 0 is because otherwise, what do you return on      * gcd(0, Integer.MIN_VALUE)? BigInteger.gcd would return positive 2^31, but positive 2^31      * isn't an int.      */
name|checkNonNegative
argument_list|(
literal|"a"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|checkNonNegative
argument_list|(
literal|"b"
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|// The simple Euclidean algorithm is the fastest for ints, and is easily the most readable.
while|while
condition|(
name|b
operator|!=
literal|0
condition|)
block|{
name|int
name|t
init|=
name|b
decl_stmt|;
name|b
operator|=
name|a
operator|%
name|b
expr_stmt|;
name|a
operator|=
name|t
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
comment|/**    * Returns the sum of {@code a} and {@code b}, provided it does not overflow.    *     * @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic    */
DECL|method|checkedAdd (int a, int b)
specifier|public
specifier|static
name|int
name|checkedAdd
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|long
name|result
init|=
operator|(
name|long
operator|)
name|a
operator|+
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
name|result
operator|==
operator|(
name|int
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|result
return|;
block|}
comment|/**    * Returns the difference of {@code a} and {@code b}, provided it does not overflow.    *     * @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic    */
DECL|method|checkedSubtract (int a, int b)
specifier|public
specifier|static
name|int
name|checkedSubtract
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|long
name|result
init|=
operator|(
name|long
operator|)
name|a
operator|-
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
name|result
operator|==
operator|(
name|int
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|result
return|;
block|}
comment|/**    * Returns the product of {@code a} and {@code b}, provided it does not overflow.    *     * @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic    */
DECL|method|checkedMultiply (int a, int b)
specifier|public
specifier|static
name|int
name|checkedMultiply
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|long
name|result
init|=
operator|(
name|long
operator|)
name|a
operator|*
name|b
decl_stmt|;
name|checkNoOverflow
argument_list|(
name|result
operator|==
operator|(
name|int
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|result
return|;
block|}
DECL|field|FLOOR_SQRT_MAX_INT
annotation|@
name|VisibleForTesting
specifier|static
specifier|final
name|int
name|FLOOR_SQRT_MAX_INT
init|=
literal|46340
decl_stmt|;
DECL|field|FACTORIALS
specifier|static
specifier|final
name|int
index|[]
name|FACTORIALS
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
operator|*
literal|2
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
block|,
literal|1
operator|*
literal|2
operator|*
literal|3
operator|*
literal|4
operator|*
literal|5
operator|*
literal|6
operator|*
literal|7
operator|*
literal|8
operator|*
literal|9
operator|*
literal|10
operator|*
literal|11
operator|*
literal|12
block|}
decl_stmt|;
comment|// binomial(BIGGEST_BINOMIALS[k], k) fits in an int, but not binomial(BIGGEST_BINOMIALS[k]+1,k).
DECL|field|BIGGEST_BINOMIALS
annotation|@
name|VisibleForTesting
specifier|static
name|int
index|[]
name|BIGGEST_BINOMIALS
init|=
block|{
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
block|,
literal|65536
block|,
literal|2345
block|,
literal|477
block|,
literal|193
block|,
literal|110
block|,
literal|75
block|,
literal|58
block|,
literal|49
block|,
literal|43
block|,
literal|39
block|,
literal|37
block|,
literal|35
block|,
literal|34
block|,
literal|34
block|,
literal|33
block|}
decl_stmt|;
DECL|method|IntMath ()
specifier|private
name|IntMath
parameter_list|()
block|{}
block|}
end_class

end_unit

