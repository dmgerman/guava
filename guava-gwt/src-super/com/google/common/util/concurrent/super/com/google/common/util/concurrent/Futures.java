begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Platform
operator|.
name|isInstanceOfThrowableClass
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|getUninterruptibly
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to the {@link Future} interface.  *  *<p>Many of these methods use the {@link ListenableFuture} API; consult the  * Guava User Guide article on<a href=  * "https://github.com/google/guava/wiki/ListenableFutureExplained">  * {@code ListenableFuture}</a>.  *  * @author Kevin Bourrillion  * @author Nishant Thakkar  * @author Sven Mawson  * @since 1.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Futures
specifier|public
specifier|final
class|class
name|Futures
extends|extends
name|GwtFuturesCatchingSpecialization
block|{
comment|// A note on memory visibility.
comment|// Many of the utilities in this class (transform, withFallback, withTimeout, asList, combine)
comment|// have two requirements that significantly complicate their design.
comment|// 1. Cancellation should propagate from the returned future to the input future(s).
comment|// 2. The returned futures shouldn't unnecessarily 'pin' their inputs after completion.
comment|//
comment|// A consequence of these requirements is that the delegate futures cannot be stored in
comment|// final fields.
comment|//
comment|// For simplicity the rest of this description will discuss Futures.catching since it is the
comment|// simplest instance, though very similar descriptions apply to many other classes in this file.
comment|//
comment|// In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field
comment|// 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the
comment|// 'inputFuture' field is read and where we will have to consider visibility of the write
comment|// operation in the constructor.
comment|//
comment|// 1. In the listener that performs the callback.  In this case it is fine since inputFuture is
comment|//    assigned prior to calling addListener, and addListener happens-before any invocation of the
comment|//    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible
comment|//    to the listener.
comment|//
comment|// 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine.
comment|//    There is currently nothing that enforces that the write to inputFuture in the constructor is
comment|//    visible to done().  This is because there is no happens before edge between the write and a
comment|//    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,
comment|//    it would just add an edge such that if done() observed non-null, then it would also
comment|//    definitely observe all earlier writes, but we still have no guarantee that done() would see
comment|//    the inital write (just stronger guarantees if it does).
comment|//
comment|// See: http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013800.html
comment|// For a (long) discussion about this specific issue and the general futility of life.
comment|//
comment|// For the time being we are OK with the problem discussed above since it requires a caller to
comment|// introduce a very specific kind of data-race.  And given the other operations performed by these
comment|// methods that involve volatile read/write operations, in practice there is no issue.  Also, the
comment|// way in such a visibility issue would surface is most likely as a failure of cancel() to
comment|// propagate to the input.  Cancellation propagation is fundamentally racy so this is fine.
comment|//
comment|// Future versions of the JMM may revise safe construction semantics in such a way that we can
comment|// safely publish these objects and we won't need this whole discussion.
comment|// TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs
comment|// that should resolve the issue.  This comes at the cost of adding more write barriers to the
comment|// implementations.
DECL|method|Futures ()
specifier|private
name|Futures
parameter_list|()
block|{}
DECL|class|ImmediateFuture
specifier|private
specifier|abstract
specifier|static
class|class
name|ImmediateFuture
parameter_list|<
name|V
parameter_list|>
implements|implements
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ImmediateFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor executor)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|,
literal|"Runnable was null."
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|executor
argument_list|,
literal|"Executor was null."
argument_list|)
expr_stmt|;
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// ListenableFuture's contract is that it will not throw unchecked
comment|// exceptions, so log the bad runnable and/or executor and swallow it.
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"RuntimeException while executing runnable "
operator|+
name|listener
operator|+
literal|" with executor "
operator|+
name|executor
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
specifier|abstract
name|V
name|get
parameter_list|()
throws|throws
name|ExecutionException
function_decl|;
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isCancelled ()
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isDone ()
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|class|ImmediateSuccessfulFuture
specifier|private
specifier|static
class|class
name|ImmediateSuccessfulFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ImmediateFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|NULL
specifier|static
specifier|final
name|ImmediateSuccessfulFuture
argument_list|<
name|Object
argument_list|>
name|NULL
init|=
operator|new
name|ImmediateSuccessfulFuture
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|field|value
annotation|@
name|Nullable
specifier|private
specifier|final
name|V
name|value
decl_stmt|;
DECL|method|ImmediateSuccessfulFuture (@ullable V value)
name|ImmediateSuccessfulFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|value
return|;
block|}
block|}
DECL|class|ImmediateFailedFuture
specifier|private
specifier|static
class|class
name|ImmediateFailedFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ImmediateFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|thrown
specifier|private
specifier|final
name|Throwable
name|thrown
decl_stmt|;
DECL|method|ImmediateFailedFuture (Throwable thrown)
name|ImmediateFailedFuture
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|this
operator|.
name|thrown
operator|=
name|thrown
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|ExecutionException
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|thrown
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates a {@code ListenableFuture} which has its value set immediately upon    * construction. The getters just return the value. This {@code Future} can't    * be canceled or timed out and its {@code isDone()} method always returns    * {@code true}.    */
annotation|@
name|CheckReturnValue
DECL|method|immediateFuture (@ullable V value)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// This cast is safe because null is assignable to V for all V (i.e. it is covariant)
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|typedNull
init|=
operator|(
name|ListenableFuture
operator|)
name|ImmediateSuccessfulFuture
operator|.
name|NULL
decl_stmt|;
return|return
name|typedNull
return|;
block|}
return|return
operator|new
name|ImmediateSuccessfulFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code ListenableFuture} which has an exception set immediately    * upon construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} will immediately    * throw the provided {@code Throwable} wrapped in an {@code    * ExecutionException}.    */
annotation|@
name|CheckReturnValue
DECL|method|immediateFailedFuture ( Throwable throwable)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFailedFuture
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmediateFailedFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|throwable
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code Future} whose result is taken from the given primary    * {@code input} or, if the primary input fails, from the {@code Future}    * provided by the {@code fallback}. {@link FutureFallback#create} is not    * invoked until the primary input has failed, so if the primary input    * succeeds, it is never invoked. If, during the invocation of {@code    * fallback}, an exception is thrown, this exception is used as the result of    * the output {@code Future}.    *    *<p>Below is an example of a fallback that returns a default value if an    * exception occurs:    *    *<pre>   {@code    *   ListenableFuture<Integer> fetchCounterFuture = ...;    *    *   // Falling back to a zero counter in case an exception happens when    *   // processing the RPC to fetch counters.    *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(    *       fetchCounterFuture, new FutureFallback<Integer>() {    *         public ListenableFuture<Integer> create(Throwable t) {    *           // Returning "0" as the default for the counter when the    *           // exception happens.    *           return immediateFuture(0);    *         }    *       });}</pre>    *    *<p>The fallback can also choose to propagate the original exception when    * desired:    *    *<pre>   {@code    *   ListenableFuture<Integer> fetchCounterFuture = ...;    *    *   // Falling back to a zero counter only in case the exception was a    *   // TimeoutException.    *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(    *       fetchCounterFuture, new FutureFallback<Integer>() {    *         public ListenableFuture<Integer> create(Throwable t) {    *           if (t instanceof TimeoutException) {    *             return immediateFuture(0);    *           }    *           return immediateFailedFuture(t);    *         }    *       });}</pre>    *    *<p>This overload, which does not accept an executor, uses {@code    * directExecutor}, a dangerous choice in some cases. See the discussion in    * the {@link ListenableFuture#addListener ListenableFuture.addListener}    * documentation. The documentation's warnings about "lightweight listeners"    * refer here to the work done during {@code FutureFallback.create}, not to    * any work done to complete the returned {@code Future}.    *    * @param input the primary input {@code Future}    * @param fallback the {@link FutureFallback} implementation to be called if    *     {@code input} fails    * @since 14.0    * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,    *     AsyncFunction) catchingAsync(input, Throwable.class,    *     fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code    *     Throwable.class} with the specific type you want to handle. This method    *     will be removed in Guava release 20.0.    */
annotation|@
name|Deprecated
annotation|@
name|CheckReturnValue
DECL|method|withFallback ( ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|withFallback
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|FutureFallback
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|)
block|{
return|return
name|withFallback
argument_list|(
name|input
argument_list|,
name|fallback
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code Future} whose result is taken from the given primary    * {@code input} or, if the primary input fails, from the {@code Future}    * provided by the {@code fallback}. {@link FutureFallback#create} is not    * invoked until the primary input has failed, so if the primary input    * succeeds, it is never invoked. If, during the invocation of {@code    * fallback}, an exception is thrown, this exception is used as the result of    * the output {@code Future}.    *    *<p>Below is an example of a fallback that returns a default value if an    * exception occurs:    *    *<pre>   {@code    *   ListenableFuture<Integer> fetchCounterFuture = ...;    *    *   // Falling back to a zero counter in case an exception happens when    *   // processing the RPC to fetch counters.    *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(    *       fetchCounterFuture, new FutureFallback<Integer>() {    *         public ListenableFuture<Integer> create(Throwable t) {    *           // Returning "0" as the default for the counter when the    *           // exception happens.    *           return immediateFuture(0);    *         }    *       }, directExecutor());}</pre>    *    *<p>The fallback can also choose to propagate the original exception when    * desired:    *    *<pre>   {@code    *   ListenableFuture<Integer> fetchCounterFuture = ...;    *    *   // Falling back to a zero counter only in case the exception was a    *   // TimeoutException.    *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(    *       fetchCounterFuture, new FutureFallback<Integer>() {    *         public ListenableFuture<Integer> create(Throwable t) {    *           if (t instanceof TimeoutException) {    *             return immediateFuture(0);    *           }    *           return immediateFailedFuture(t);    *         }    *       }, directExecutor());}</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is    * dangerous in some cases. See the discussion in the {@link    * ListenableFuture#addListener ListenableFuture.addListener} documentation.    * The documentation's warnings about "lightweight listeners" refer here to    * the work done during {@code FutureFallback.create}, not to any work done to    * complete the returned {@code Future}.    *    * @param input the primary input {@code Future}    * @param fallback the {@link FutureFallback} implementation to be called if    *     {@code input} fails    * @param executor the executor that runs {@code fallback} if {@code input}    *     fails    * @since 14.0    * @deprecated Use {@link #catchingAsync(ListenableFuture, Class,    *     AsyncFunction, Executor) catchingAsync(input, Throwable.class,    *     fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing    *     {@code Throwable.class} with the specific type you want to handle. This method    *     will be removed in Guava release 20.0.    */
annotation|@
name|Deprecated
annotation|@
name|CheckReturnValue
DECL|method|withFallback ( ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|withFallback
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|FutureFallback
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|asAsyncFunction
argument_list|(
name|fallback
argument_list|)
argument_list|,
name|executor
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
DECL|method|asAsyncFunction (final FutureFallback<V> fallback)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|V
argument_list|>
name|asAsyncFunction
parameter_list|(
specifier|final
name|FutureFallback
argument_list|<
name|V
argument_list|>
name|fallback
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fallback
argument_list|)
expr_stmt|;
return|return
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|checkNotNull
argument_list|(
name|fallback
operator|.
name|create
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"FutureFallback.create returned null instead of a "
operator|+
literal|"Future. Did you mean to return immediateFuture(null)?"
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|class|AbstractCatchingFuture
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractCatchingFuture
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Throwable
parameter_list|,
name|F
parameter_list|>
extends|extends
name|AbstractFuture
operator|.
name|TrustedFuture
argument_list|<
name|V
argument_list|>
implements|implements
name|Runnable
block|{
DECL|field|inputFuture
annotation|@
name|Nullable
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|inputFuture
decl_stmt|;
DECL|field|exceptionType
annotation|@
name|Nullable
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
decl_stmt|;
DECL|field|fallback
annotation|@
name|Nullable
name|F
name|fallback
decl_stmt|;
DECL|method|AbstractCatchingFuture ( ListenableFuture<? extends V> inputFuture, Class<X> exceptionType, F fallback)
name|AbstractCatchingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|inputFuture
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|F
name|fallback
parameter_list|)
block|{
name|this
operator|.
name|inputFuture
operator|=
name|checkNotNull
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
name|this
operator|.
name|exceptionType
operator|=
name|checkNotNull
argument_list|(
name|exceptionType
argument_list|)
expr_stmt|;
name|this
operator|.
name|fallback
operator|=
name|checkNotNull
argument_list|(
name|fallback
argument_list|)
expr_stmt|;
block|}
DECL|method|run ()
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|localInputFuture
init|=
name|inputFuture
decl_stmt|;
name|Class
argument_list|<
name|X
argument_list|>
name|localExceptionType
init|=
name|exceptionType
decl_stmt|;
name|F
name|localFallback
init|=
name|fallback
decl_stmt|;
if|if
condition|(
name|localInputFuture
operator|==
literal|null
operator||
name|localExceptionType
operator|==
literal|null
operator||
name|localFallback
operator|==
literal|null
operator||
name|isCancelled
argument_list|()
condition|)
block|{
return|return;
block|}
name|inputFuture
operator|=
literal|null
expr_stmt|;
name|exceptionType
operator|=
literal|null
expr_stmt|;
name|fallback
operator|=
literal|null
expr_stmt|;
name|Throwable
name|throwable
decl_stmt|;
try|try
block|{
name|set
argument_list|(
name|getUninterruptibly
argument_list|(
name|localInputFuture
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|throwable
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// this includes cancellation exception
name|throwable
operator|=
name|e
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|isInstanceOfThrowableClass
argument_list|(
name|throwable
argument_list|,
name|localExceptionType
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// verified safe by isInstance
name|X
name|castThrowable
init|=
operator|(
name|X
operator|)
name|throwable
decl_stmt|;
name|doFallback
argument_list|(
name|localFallback
argument_list|,
name|castThrowable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setException
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Template method for subtypes to actually run the fallback. */
DECL|method|doFallback (F fallback, X throwable)
specifier|abstract
name|void
name|doFallback
parameter_list|(
name|F
name|fallback
parameter_list|,
name|X
name|throwable
parameter_list|)
throws|throws
name|Exception
function_decl|;
DECL|method|done ()
annotation|@
name|Override
specifier|final
name|void
name|done
parameter_list|()
block|{
name|maybePropagateCancellation
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputFuture
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|exceptionType
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fallback
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * A {@link AbstractCatchingFuture} that delegates to an {@link AsyncFunction}    * and {@link #setFuture(ListenableFuture)} to implement {@link #doFallback}    */
DECL|class|AsyncCatchingFuture
specifier|static
specifier|final
class|class
name|AsyncCatchingFuture
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Throwable
parameter_list|>
extends|extends
name|AbstractCatchingFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
argument_list|>
block|{
DECL|method|AsyncCatchingFuture (ListenableFuture<? extends V> input, Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback)
name|AsyncCatchingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|,
name|exceptionType
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
block|}
DECL|method|doFallback ( AsyncFunction<? super X, ? extends V> fallback, X cause)
annotation|@
name|Override
name|void
name|doFallback
parameter_list|(
name|AsyncFunction
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|X
name|cause
parameter_list|)
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|replacement
init|=
name|fallback
operator|.
name|apply
argument_list|(
name|cause
argument_list|)
decl_stmt|;
name|checkNotNull
argument_list|(
name|replacement
argument_list|,
literal|"AsyncFunction.apply returned null instead of a Future. "
operator|+
literal|"Did you mean to return immediateFuture(null)?"
argument_list|)
expr_stmt|;
name|setFuture
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A {@link AbstractCatchingFuture} that delegates to a {@link Function}    * and {@link #set(Object)} to implement {@link #doFallback}    */
DECL|class|CatchingFuture
specifier|static
specifier|final
class|class
name|CatchingFuture
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Throwable
parameter_list|>
extends|extends
name|AbstractCatchingFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|,
name|Function
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
argument_list|>
block|{
DECL|method|CatchingFuture (ListenableFuture<? extends V> input, Class<X> exceptionType, Function<? super X, ? extends V> fallback)
name|CatchingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|input
parameter_list|,
name|Class
argument_list|<
name|X
argument_list|>
name|exceptionType
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|,
name|exceptionType
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
block|}
DECL|method|doFallback (Function<? super X, ? extends V> fallback, X cause)
annotation|@
name|Override
name|void
name|doFallback
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|X
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fallback
parameter_list|,
name|X
name|cause
parameter_list|)
throws|throws
name|Exception
block|{
name|V
name|replacement
init|=
name|fallback
operator|.
name|apply
argument_list|(
name|cause
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Future that delegates to another but will finish early (via a {@link    * TimeoutException} wrapped in an {@link ExecutionException}) if the    * specified duration expires.    * The delegate future is interrupted and cancelled if it times out.    */
DECL|class|TimeoutFuture
specifier|private
specifier|static
specifier|final
class|class
name|TimeoutFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractFuture
operator|.
name|TrustedFuture
argument_list|<
name|V
argument_list|>
block|{
comment|// Memory visibility of these fields.
comment|// There are two cases to consider.
comment|// 1. visibility of the writes to these fields to Fire.run
comment|//    The initial write to delegateRef is made definitely visible via the semantics of
comment|//    addListener/SES.schedule.  The later racy write in cancel() is not guaranteed to be
comment|//    observed, however that is fine since the correctness is based on the atomic state in
comment|//    our base class.
comment|//    The initial write to timer is never definitely visible to Fire.run since it is assigned
comment|//    after SES.schedule is called. Therefore Fire.run has to check for null.  However, it
comment|//    should be visible if Fire.run is called by delegate.addListener since addListener is
comment|//    called after the assignment to timer, and importantly this is the main situation in which
comment|//    we need to be able to see the write.
comment|// 2. visibility of the writes to cancel
comment|//    Since these fields are non-final that means that TimeoutFuture is not being 'safely
comment|//    published', thus a motivated caller may be able to expose the reference to another thread
comment|//    that would then call cancel() and be unable to cancel the delegate.
comment|//    There are a number of ways to solve this, none of which are very pretty, and it is
comment|//    currently believed to be a purely theoretical problem (since the other actions should
comment|//    supply sufficient write-barriers).
DECL|field|delegateRef
annotation|@
name|Nullable
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegateRef
decl_stmt|;
DECL|field|timer
annotation|@
name|Nullable
name|Future
argument_list|<
name|?
argument_list|>
name|timer
decl_stmt|;
DECL|method|TimeoutFuture (ListenableFuture<V> delegate)
name|TimeoutFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegateRef
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
comment|/** A runnable that is called when the delegate or the timer completes. */
DECL|class|Fire
specifier|private
specifier|static
specifier|final
class|class
name|Fire
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Runnable
block|{
DECL|field|timeoutFutureRef
annotation|@
name|Nullable
name|TimeoutFuture
argument_list|<
name|V
argument_list|>
name|timeoutFutureRef
decl_stmt|;
DECL|method|Fire (TimeoutFuture<V> timeoutFuture)
name|Fire
parameter_list|(
name|TimeoutFuture
argument_list|<
name|V
argument_list|>
name|timeoutFuture
parameter_list|)
block|{
name|this
operator|.
name|timeoutFutureRef
operator|=
name|timeoutFuture
expr_stmt|;
block|}
DECL|method|run ()
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// If either of these reads return null then we must be after a successful cancel
comment|// or another call to this method.
name|TimeoutFuture
argument_list|<
name|V
argument_list|>
name|timeoutFuture
init|=
name|timeoutFutureRef
decl_stmt|;
if|if
condition|(
name|timeoutFuture
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
init|=
name|timeoutFuture
operator|.
name|delegateRef
decl_stmt|;
if|if
condition|(
name|delegate
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|/*          * If we're about to complete the TimeoutFuture, we want to release our reference to it.          * Otherwise, we'll pin it (and its result) in memory until the timeout task is GCed. (The          * need to clear our reference to the TimeoutFuture is the reason we use a *static* nested          * class with a manual reference back to the "containing" class.)          *          * This has the nice-ish side effect of limiting reentrancy: run() calls          * timeoutFuture.setException() calls run(). That reentrancy would already be harmless,          * since timeoutFuture can be set (and delegate cancelled) only once. (And "set only once"          * is important for other reasons: run() can still be invoked concurrently in different          * threads, even with the above null checks.)          */
name|timeoutFutureRef
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|delegate
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|timeoutFuture
operator|.
name|setFuture
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// TODO(lukes): this stack trace is particularly useless (all it does is point at the
comment|// scheduledexecutorservice thread), consider eliminating it altogether?
name|timeoutFuture
operator|.
name|setException
argument_list|(
operator|new
name|TimeoutException
argument_list|(
literal|"Future timed out: "
operator|+
name|delegate
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|delegate
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|done ()
annotation|@
name|Override
name|void
name|done
parameter_list|()
block|{
name|maybePropagateCancellation
argument_list|(
name|delegateRef
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|?
argument_list|>
name|localTimer
init|=
name|timer
decl_stmt|;
comment|// Try to cancel the timer as an optimization
comment|// timer may be null if this call to run was by the timer task since there is no
comment|// happens-before edge between the assignment to timer and an execution of the timer task.
if|if
condition|(
name|localTimer
operator|!=
literal|null
condition|)
block|{
name|localTimer
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|delegateRef
operator|=
literal|null
expr_stmt|;
name|timer
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code AsyncFunction} to the result of the original    * {@code Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   AsyncFunction<RowKey, QueryResult> queryFunction =    *       new AsyncFunction<RowKey, QueryResult>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       transform(rowKeyFuture, queryFunction);}</pre>    *    *<p>This overload, which does not accept an executor, uses {@code    * directExecutor}, a dangerous choice in some cases. See the discussion in    * the {@link ListenableFuture#addListener ListenableFuture.addListener}    * documentation. The documentation's warnings about "lightweight listeners"    * refer here to the work done during {@code AsyncFunction.apply}, not to any    * work done to complete the returned {@code Future}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future and that of the future returned by the    * function. That is, if the returned {@code Future} is cancelled, it will    * attempt to cancel the other two, and if either of the other two is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    * @param input The future to transform    * @param function A function to transform the result of the input future    *     to the result of the output future    * @return A future that holds result of the function (if the input succeeded)    *     or the original input's failure (if not)    * @since 11.0    * @deprecated These {@code AsyncFunction} overloads of {@code transform} are    *     being renamed to {@code transformAsync}. (The {@code Function}    *     overloads are keeping the "transform" name.) This method will be removed in Guava release    *     20.0.    */
annotation|@
name|Deprecated
DECL|method|transform (ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|transformAsync
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code AsyncFunction} to the result of the original    * {@code Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   AsyncFunction<RowKey, QueryResult> queryFunction =    *       new AsyncFunction<RowKey, QueryResult>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       transform(rowKeyFuture, queryFunction, executor);}</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is    * dangerous in some cases. See the discussion in the {@link    * ListenableFuture#addListener ListenableFuture.addListener} documentation.    * The documentation's warnings about "lightweight listeners" refer here to    * the work done during {@code AsyncFunction.apply}, not to any work done to    * complete the returned {@code Future}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future and that of the future returned by the    * chain function. That is, if the returned {@code Future} is cancelled, it    * will attempt to cancel the other two, and if either of the other two is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    * @param input The future to transform    * @param function A function to transform the result of the input future    *     to the result of the output future    * @param executor Executor to run the function in.    * @return A future that holds result of the function (if the input succeeded)    *     or the original input's failure (if not)    * @since 11.0    * @deprecated These {@code AsyncFunction} overloads of {@code transform} are    *     being renamed to {@code transformAsync}. (The {@code Function}    *     overloads are keeping the "transform" name.) This method will be removed in Guava release    *     20.0.    */
annotation|@
name|Deprecated
DECL|method|transform (ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
return|return
name|transformAsync
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result    * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from    * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the    * original {@code Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   AsyncFunction<RowKey, QueryResult> queryFunction =    *       new AsyncFunction<RowKey, QueryResult>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       transformAsync(rowKeyFuture, queryFunction);}</pre>    *    *<p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous    * choice in some cases. See the discussion in the {@link ListenableFuture#addListener    * ListenableFuture.addListener} documentation. The documentation's warnings about "lightweight    * listeners" refer here to the work done during {@code AsyncFunction.apply}, not to any work done    * to complete the returned {@code Future}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the    * input future and that of the future returned by the function. That is, if the returned {@code    * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two    * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to    * cancel itself.    *    * @param input The future to transform    * @param function A function to transform the result of the input future to the result of the    *     output future    * @return A future that holds result of the function (if the input succeeded) or the original    *     input's failure (if not)    * @since 19.0 (in 11.0 as {@code transform})    */
DECL|method|transformAsync ( ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transformAsync
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|AsyncChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|output
init|=
operator|new
name|AsyncChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|output
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result    * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from    * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the    * original {@code Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);    *   AsyncFunction<RowKey, QueryResult> queryFunction =    *       new AsyncFunction<RowKey, QueryResult>() {    *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {    *           return dataService.read(rowKey);    *         }    *       };    *   ListenableFuture<QueryResult> queryFuture =    *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See    * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}    * documentation. The documentation's warnings about "lightweight listeners" refer here to the    * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned    * {@code Future}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the    * input future and that of the future returned by the chain function. That is, if the returned    * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the    * other two is cancelled, the returned {@code Future} will receive a callback in which it will    * attempt to cancel itself.    *    * @param input The future to transform    * @param function A function to transform the result of the input future to the result of the    *     output future    * @param executor Executor to run the function in.    * @return A future that holds result of the function (if the input succeeded) or the original    *     input's failure (if not)    * @since 19.0 (in 11.0 as {@code transform})    */
DECL|method|transformAsync (ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transformAsync
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|AsyncChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|output
init|=
operator|new
name|AsyncChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|output
argument_list|,
name|rejectionPropagatingExecutor
argument_list|(
name|executor
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Returns an Executor that will propagate {@link RejectedExecutionException} from the delegate    * executor to the given {@code future}.    *    *<p>Note, the returned executor can only be used once.    */
DECL|method|rejectionPropagatingExecutor ( final Executor delegate, final AbstractFuture<?> future)
specifier|private
specifier|static
name|Executor
name|rejectionPropagatingExecutor
parameter_list|(
specifier|final
name|Executor
name|delegate
parameter_list|,
specifier|final
name|AbstractFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegate
operator|==
name|directExecutor
argument_list|()
condition|)
block|{
comment|// directExecutor() cannot throw RejectedExecutionException
return|return
name|delegate
return|;
block|}
return|return
operator|new
name|Executor
argument_list|()
block|{
specifier|volatile
name|boolean
name|thrownFromDelegate
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
specifier|final
name|Runnable
name|command
parameter_list|)
block|{
try|try
block|{
name|delegate
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|thrownFromDelegate
operator|=
literal|false
expr_stmt|;
name|command
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|thrownFromDelegate
condition|)
block|{
comment|// wrap exception?
name|future
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// otherwise it must have been thrown from a transitive call and the delegate runnable
comment|// should have handled it.
block|}
block|}
block|}
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<QueryResult> queryFuture = ...;    *   Function<QueryResult, List<Row>> rowsFunction =    *       new Function<QueryResult, List<Row>>() {    *         public List<Row> apply(QueryResult queryResult) {    *           return queryResult.getRows();    *         }    *       };    *   ListenableFuture<List<Row>> rowsFuture =    *       transform(queryFuture, rowsFunction);}</pre>    *    *<p>This overload, which does not accept an executor, uses {@code    * directExecutor}, a dangerous choice in some cases. See the discussion in    * the {@link ListenableFuture#addListener ListenableFuture.addListener}    * documentation. The documentation's warnings about "lightweight listeners"    * refer here to the work done during {@code Function.apply}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future. That is, if the returned {@code Future}    * is cancelled, it will attempt to cancel the input, and if the input is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    * @param input The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the transformation.    * @since 9.0 (in 1.0 as {@code compose})    */
DECL|method|transform (ListenableFuture<I> input, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|ChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|output
init|=
operator|new
name|ChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|output
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}. Example:    *    *<pre>   {@code    *   ListenableFuture<QueryResult> queryFuture = ...;    *   Function<QueryResult, List<Row>> rowsFunction =    *       new Function<QueryResult, List<Row>>() {    *         public List<Row> apply(QueryResult queryResult) {    *           return queryResult.getRows();    *         }    *       };    *   ListenableFuture<List<Row>> rowsFuture =    *       transform(queryFuture, rowsFunction, executor);}</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is    * dangerous in some cases. See the discussion in the {@link    * ListenableFuture#addListener ListenableFuture.addListener} documentation.    * The documentation's warnings about "lightweight listeners" refer here to    * the work done during {@code Function.apply}.    *    *<p>The returned {@code Future} attempts to keep its cancellation state in    * sync with that of the input future. That is, if the returned {@code Future}    * is cancelled, it will attempt to cancel the input, and if the input is    * cancelled, the returned {@code Future} will receive a callback in which it    * will attempt to cancel itself.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    * @param input The future to transform    * @param function A Function to transform the results of the provided future    *     to the results of the returned future.    * @param executor Executor to run the function in.    * @return A future that holds result of the transformation.    * @since 9.0 (in 2.0 as {@code compose})    */
DECL|method|transform (ListenableFuture<I> input, final Function<? super I, ? extends O> function, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|transform
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|ChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|output
init|=
operator|new
name|ChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|output
argument_list|,
name|rejectionPropagatingExecutor
argument_list|(
name|executor
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * An implementation of {@code ListenableFuture} that also implements    * {@code Runnable} so that it can be used to nest ListenableFutures.    * Once the passed-in {@code ListenableFuture} is complete, it calls the    * passed-in {@code Function} to generate the result.    *    *<p>For historical reasons, this class has a special case in its exception    * handling: If the given {@code AsyncFunction} throws an {@code    * UndeclaredThrowableException}, {@code ChainingListenableFuture} unwraps it    * and uses its<i>cause</i> as the output future's exception, rather than    * using the {@code UndeclaredThrowableException} itself as it would for other    * exception types. The reason for this is that {@code Futures.transform} used    * to require a {@code Function}, whose {@code apply} method is not allowed to    * throw checked exceptions. Nowadays, {@code Futures.transform} has an    * overload that accepts an {@code AsyncFunction}, whose {@code apply} method    *<i>is</i> allowed to throw checked exception. Users who wish to throw    * checked exceptions should use that overload instead, and<a    * href="http://code.google.com/p/guava-libraries/issues/detail?id=1548">we    * should remove the {@code UndeclaredThrowableException} special case</a>.    */
DECL|class|AbstractChainingFuture
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractChainingFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|,
name|F
parameter_list|>
extends|extends
name|AbstractFuture
operator|.
name|TrustedFuture
argument_list|<
name|O
argument_list|>
implements|implements
name|Runnable
block|{
comment|// In theory, this field might not be visible to a cancel() call in certain circumstances. For
comment|// details, see the comments on the fields of TimeoutFuture.
DECL|field|inputFuture
annotation|@
name|Nullable
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
decl_stmt|;
DECL|field|function
annotation|@
name|Nullable
name|F
name|function
decl_stmt|;
DECL|method|AbstractChainingFuture (ListenableFuture<? extends I> inputFuture, F function)
name|AbstractChainingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|,
name|F
name|function
parameter_list|)
block|{
name|this
operator|.
name|inputFuture
operator|=
name|checkNotNull
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|localInputFuture
init|=
name|inputFuture
decl_stmt|;
name|F
name|localFunction
init|=
name|function
decl_stmt|;
if|if
condition|(
name|isCancelled
argument_list|()
operator||
name|localInputFuture
operator|==
literal|null
operator||
name|localFunction
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|inputFuture
operator|=
literal|null
expr_stmt|;
name|function
operator|=
literal|null
expr_stmt|;
name|I
name|sourceResult
decl_stmt|;
try|try
block|{
name|sourceResult
operator|=
name|getUninterruptibly
argument_list|(
name|localInputFuture
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
comment|// At this point, inputFuture is cancelled and outputFuture doesn't
comment|// exist, so the value of mayInterruptIfRunning is irrelevant.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|doTransform
argument_list|(
name|localFunction
argument_list|,
name|sourceResult
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// This exception is irrelevant in this thread, but useful for the
comment|// client
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Template method for subtypes to actually run the transform. */
DECL|method|doTransform (F function, I result)
specifier|abstract
name|void
name|doTransform
parameter_list|(
name|F
name|function
parameter_list|,
name|I
name|result
parameter_list|)
throws|throws
name|Exception
function_decl|;
DECL|method|done ()
annotation|@
name|Override
specifier|final
name|void
name|done
parameter_list|()
block|{
name|maybePropagateCancellation
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputFuture
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|function
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * A {@link AbstractChainingFuture} that delegates to an {@link AsyncFunction} and    * {@link #setFuture(ListenableFuture)} to implement {@link #doTransform}.    */
DECL|class|AsyncChainingFuture
specifier|private
specifier|static
specifier|final
class|class
name|AsyncChainingFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
extends|extends
name|AbstractChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
argument_list|>
block|{
DECL|method|AsyncChainingFuture (ListenableFuture<? extends I> inputFuture, AsyncFunction<? super I, ? extends O> function)
name|AsyncChainingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|,
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|inputFuture
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doTransform (AsyncFunction<? super I, ? extends O> function, I input)
name|void
name|doTransform
parameter_list|(
name|AsyncFunction
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|I
name|input
parameter_list|)
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|checkNotNull
argument_list|(
name|outputFuture
argument_list|,
literal|"AsyncFunction.apply returned null instead of a Future. "
operator|+
literal|"Did you mean to return immediateFuture(null)?"
argument_list|)
expr_stmt|;
name|setFuture
argument_list|(
name|outputFuture
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A {@link AbstractChainingFuture} that delegates to a {@link Function} and    * {@link #set(Object)} to implement {@link #doTransform}.    */
DECL|class|ChainingFuture
specifier|private
specifier|static
specifier|final
class|class
name|ChainingFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
extends|extends
name|AbstractChainingFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
argument_list|>
block|{
DECL|method|ChainingFuture (ListenableFuture<? extends I> inputFuture, Function<? super I, ? extends O> function)
name|ChainingFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|inputFuture
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doTransform (Function<? super I, ? extends O> function, I input)
name|void
name|doTransform
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|I
name|input
parameter_list|)
block|{
comment|// TODO(lukes): move the UndeclaredThrowable catch block here?
name|set
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * calling {@code get()} on the {@code Future} nested within the given {@code    * Future}, effectively chaining the futures one after the other.  Example:    *    *<pre>   {@code    *   SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();    *   ListenableFuture<String> dereferenced = dereference(nested);}</pre>    *    *<p>This call has the same cancellation and execution semantics as {@link    * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code    * Future} attempts to keep its cancellation state in sync with both the    * input {@code Future} and the nested {@code Future}.  The transformation    * is very lightweight and therefore takes place in the same thread (either    * the thread that called {@code dereference}, or the thread in which the    * dereferenced future completes).    *    * @param nested The nested future to transform.    * @return A future that holds result of the inner future.    * @since 13.0    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
annotation|@
name|CheckReturnValue
DECL|method|dereference ( ListenableFuture<? extends ListenableFuture<? extends V>> nested)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|dereference
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|nested
parameter_list|)
block|{
return|return
name|transformAsync
argument_list|(
operator|(
name|ListenableFuture
operator|)
name|nested
argument_list|,
operator|(
name|AsyncFunction
operator|)
name|DEREFERENCER
argument_list|)
return|;
block|}
comment|/**    * Helper {@code Function} for {@link #dereference}.    */
DECL|field|DEREFERENCER
specifier|private
specifier|static
specifier|final
name|AsyncFunction
argument_list|<
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
argument_list|,
name|Object
argument_list|>
name|DEREFERENCER
init|=
operator|new
name|AsyncFunction
argument_list|<
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its input futures, if all succeed. If any input fails, the    * returned future fails immediately.    *    *<p>The list of results is in the same order as the input list.    *    *<p>Canceling this future will attempt to cancel all the component futures,    * and if any of the provided futures fails or is canceled, this one is,    * too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
annotation|@
name|CheckReturnValue
DECL|method|allAsList ( ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its input futures, if all succeed. If any input fails, the    * returned future fails immediately.    *    *<p>The list of results is in the same order as the input list.    *    *<p>Canceling this future will attempt to cancel all the component futures,    * and if any of the provided futures fails or is canceled, this one is,    * too.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|CheckReturnValue
DECL|method|allAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|allAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its successful input futures. The list of results is in the    * same order as the input list, and if any of the provided futures fails or    * is canceled, its corresponding position will contain {@code null} (which is    * indistinguishable from the future having a successful value of    * {@code null}).    *    *<p>Canceling this future will attempt to cancel all the component futures.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|SafeVarargs
annotation|@
name|CheckReturnValue
DECL|method|successfulAsList ( ListenableFuture<? extends V>.... futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
modifier|...
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} whose value is a list containing the    * values of all its successful input futures. The list of results is in the    * same order as the input list, and if any of the provided futures fails or    * is canceled, its corresponding position will contain {@code null} (which is    * indistinguishable from the future having a successful value of    * {@code null}).    *    *<p>Canceling this future will attempt to cancel all the component futures.    *    * @param futures futures to combine    * @return a future that provides a list of the results of the component    *         futures    * @since 10.0    */
annotation|@
name|Beta
annotation|@
name|CheckReturnValue
DECL|method|successfulAsList ( Iterable<? extends ListenableFuture<? extends V>> futures)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|successfulAsList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
return|return
operator|new
name|ListFuture
argument_list|<
name|V
argument_list|>
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|futures
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Registers separate success and failure callbacks to be run when the {@code    * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()    * complete} or, if the computation is already complete, immediately.    *    *<p>There is no guaranteed ordering of execution of callbacks, but any    * callback added through this method is guaranteed to be called once the    * computation is complete.    *    * Example:<pre> {@code    * ListenableFuture<QueryResult> future = ...;    * addCallback(future,    *     new FutureCallback<QueryResult> {    *       public void onSuccess(QueryResult result) {    *         storeInCache(result);    *       }    *       public void onFailure(Throwable t) {    *         reportError(t);    *       }    *     });}</pre>    *    *<p>This overload, which does not accept an executor, uses {@code    * directExecutor}, a dangerous choice in some cases. See the discussion in    * the {@link ListenableFuture#addListener ListenableFuture.addListener}    * documentation.    *    *<p>For a more general interface to attach a completion listener to a    * {@code Future}, see {@link ListenableFuture#addListener addListener}.    *    * @param future The future attach the callback to.    * @param callback The callback to invoke when {@code future} is completed.    * @since 10.0    */
DECL|method|addCallback (ListenableFuture<V> future, FutureCallback<? super V> callback)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|void
name|addCallback
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|FutureCallback
argument_list|<
name|?
super|super
name|V
argument_list|>
name|callback
parameter_list|)
block|{
name|addCallback
argument_list|(
name|future
argument_list|,
name|callback
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers separate success and failure callbacks to be run when the {@code    * Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()    * complete} or, if the computation is already complete, immediately.    *    *<p>The callback is run in {@code executor}.    * There is no guaranteed ordering of execution of callbacks, but any    * callback added through this method is guaranteed to be called once the    * computation is complete.    *    * Example:<pre> {@code    * ListenableFuture<QueryResult> future = ...;    * Executor e = ...    * addCallback(future,    *     new FutureCallback<QueryResult> {    *       public void onSuccess(QueryResult result) {    *         storeInCache(result);    *       }    *       public void onFailure(Throwable t) {    *         reportError(t);    *       }    *     }, e);}</pre>    *    *<p>When selecting an executor, note that {@code directExecutor} is    * dangerous in some cases. See the discussion in the {@link    * ListenableFuture#addListener ListenableFuture.addListener} documentation.    *    *<p>For a more general interface to attach a completion listener to a    * {@code Future}, see {@link ListenableFuture#addListener addListener}.    *    * @param future The future attach the callback to.    * @param callback The callback to invoke when {@code future} is completed.    * @param executor The executor to run {@code callback} when the future    *    completes.    * @since 10.0    */
DECL|method|addCallback (final ListenableFuture<V> future, final FutureCallback<? super V> callback, Executor executor)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|void
name|addCallback
parameter_list|(
specifier|final
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
specifier|final
name|FutureCallback
argument_list|<
name|?
super|super
name|V
argument_list|>
name|callback
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|callback
argument_list|)
expr_stmt|;
name|Runnable
name|callbackListener
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
specifier|final
name|V
name|value
decl_stmt|;
try|try
block|{
comment|// TODO(user): (Before Guava release), validate that this
comment|// is the thing for IE.
name|value
operator|=
name|getUninterruptibly
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|callback
operator|.
name|onSuccess
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|future
operator|.
name|addListener
argument_list|(
name|callbackListener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/*    * Arguably we don't need a timed getUnchecked because any operation slow    * enough to require a timeout is heavyweight enough to throw a checked    * exception and therefore be inappropriate to use with getUnchecked. Further,    * it's not clear that converting the checked TimeoutException to a    * RuntimeException -- especially to an UncheckedExecutionException, since it    * wasn't thrown by the computation -- makes sense, and if we don't convert    * it, the user still has to write a try-catch block.    *    * If you think you would use this method, let us know. You might also also    * look into the Fork-Join framework:    * http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html    */
comment|/** Used for {@link #allAsList} and {@link #successfulAsList}. */
DECL|class|ListFuture
specifier|private
specifier|static
specifier|final
class|class
name|ListFuture
parameter_list|<
name|V
parameter_list|>
extends|extends
name|CollectionFuture
argument_list|<
name|V
argument_list|,
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|ListFuture (ImmutableCollection<? extends ListenableFuture<? extends V>> futures, boolean allMustSucceed)
name|ListFuture
parameter_list|(
name|ImmutableCollection
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|,
name|boolean
name|allMustSucceed
parameter_list|)
block|{
name|init
argument_list|(
operator|new
name|ListFutureRunningState
argument_list|(
name|futures
argument_list|,
name|allMustSucceed
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|ListFutureRunningState
specifier|private
specifier|final
class|class
name|ListFutureRunningState
extends|extends
name|CollectionFutureRunningState
block|{
DECL|method|ListFutureRunningState (ImmutableCollection<? extends ListenableFuture<? extends V>> futures, boolean allMustSucceed)
name|ListFutureRunningState
parameter_list|(
name|ImmutableCollection
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|V
argument_list|>
argument_list|>
name|futures
parameter_list|,
name|boolean
name|allMustSucceed
parameter_list|)
block|{
name|super
argument_list|(
name|futures
argument_list|,
name|allMustSucceed
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|combine (List<Optional<V>> values)
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|combine
parameter_list|(
name|List
argument_list|<
name|Optional
argument_list|<
name|V
argument_list|>
argument_list|>
name|values
parameter_list|)
block|{
name|List
argument_list|<
name|V
argument_list|>
name|result
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Optional
argument_list|<
name|V
argument_list|>
name|element
range|:
name|values
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|element
operator|!=
literal|null
condition|?
name|element
operator|.
name|orNull
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

