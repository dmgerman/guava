begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * This class contains static utility methods that operate on or return objects  * of type {@link Iterator}. Except as noted, each method has a corresponding  * {@link Iterable}-based method in the {@link Iterables} class.  *  *<p><i>Performance notes:</i> Unless otherwise noted, all of the iterators  * produced in this class are<i>lazy</i>, which means that they only advance  * the backing iteration when absolutely necessary.  *  *<p>See the Guava User Guide section on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Iterables">  * {@code Iterators}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Iterators
specifier|public
specifier|final
class|class
name|Iterators
block|{
DECL|method|Iterators ()
specifier|private
name|Iterators
parameter_list|()
block|{}
DECL|field|EMPTY_LIST_ITERATOR
specifier|static
specifier|final
name|UnmodifiableListIterator
argument_list|<
name|Object
argument_list|>
name|EMPTY_LIST_ITERATOR
init|=
operator|new
name|UnmodifiableListIterator
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|previous
parameter_list|()
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns the empty iterator.    *    *<p>The {@link Iterable} equivalent of this method is {@link    * ImmutableSet#of()}.    */
DECL|method|emptyIterator ()
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|emptyIterator
parameter_list|()
block|{
return|return
name|emptyListIterator
argument_list|()
return|;
block|}
comment|/**    * Returns the empty iterator.    *    *<p>The {@link Iterable} equivalent of this method is {@link    * ImmutableSet#of()}.    */
comment|// Casting to any type is safe since there are no actual elements.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyListIterator ()
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
name|emptyListIterator
parameter_list|()
block|{
return|return
operator|(
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
operator|)
name|EMPTY_LIST_ITERATOR
return|;
block|}
DECL|field|EMPTY_MODIFIABLE_ITERATOR
specifier|private
specifier|static
specifier|final
name|Iterator
argument_list|<
name|Object
argument_list|>
name|EMPTY_MODIFIABLE_ITERATOR
init|=
operator|new
name|Iterator
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns the empty {@code Iterator} that throws    * {@link IllegalStateException} instead of    * {@link UnsupportedOperationException} on a call to    * {@link Iterator#remove()}.    */
comment|// Casting to any type is safe since there are no actual elements.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|emptyModifiableIterator ()
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|emptyModifiableIterator
parameter_list|()
block|{
return|return
operator|(
name|Iterator
argument_list|<
name|T
argument_list|>
operator|)
name|EMPTY_MODIFIABLE_ITERATOR
return|;
block|}
comment|/** Returns an unmodifiable view of {@code iterator}. */
DECL|method|unmodifiableIterator ( final Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|unmodifiableIterator
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|instanceof
name|UnmodifiableIterator
condition|)
block|{
return|return
operator|(
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
return|;
block|}
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
DECL|method|unmodifiableIterator ( UnmodifiableIterator<T> iterator)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|unmodifiableIterator
parameter_list|(
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
return|;
block|}
comment|/**    * Returns the number of elements remaining in {@code iterator}. The iterator    * will be left exhausted: its {@code hasNext()} method will return    * {@code false}.    */
DECL|method|size (Iterator<?> iterator)
specifier|public
specifier|static
name|int
name|size
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns {@code true} if {@code iterator} contains {@code element}.    */
DECL|method|contains (Iterator<?> iterator, @Nullable Object element)
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iterator
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Traverses an iterator and removes every element that belongs to the    * provided collection. The iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param elementsToRemove the elements to remove    * @return {@code true} if any element was removed from {@code iterator}    */
DECL|method|removeAll ( Iterator<?> removeFrom, Collection<?> elementsToRemove)
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRemove
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|removeFrom
argument_list|,
name|Predicates
operator|.
name|in
argument_list|(
name|elementsToRemove
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Removes every element that satisfies the provided predicate from the    * iterator. The iterator will be left exhausted: its {@code hasNext()}    * method will return {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param predicate a predicate that determines whether an element should    *     be removed    * @return {@code true} if any elements were removed from the iterator    * @since 2.0    */
DECL|method|removeIf ( Iterator<T> removeFrom, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|removeIf
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|removeFrom
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|removeFrom
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|removeFrom
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
comment|/**    * Traverses an iterator and removes every element that does not belong to the    * provided collection. The iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.    *    * @param removeFrom the iterator to (potentially) remove elements from    * @param elementsToRetain the elements to retain    * @return {@code true} if any element was removed from {@code iterator}    */
DECL|method|retainAll ( Iterator<?> removeFrom, Collection<?> elementsToRetain)
specifier|public
specifier|static
name|boolean
name|retainAll
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRetain
parameter_list|)
block|{
return|return
name|removeIf
argument_list|(
name|removeFrom
argument_list|,
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
name|in
argument_list|(
name|elementsToRetain
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Determines whether two iterators contain equal elements in the same order.    * More specifically, this method returns {@code true} if {@code iterator1}    * and {@code iterator2} contain the same number of elements and every element    * of {@code iterator1} is equal to the corresponding element of    * {@code iterator2}.    *    *<p>Note that this will modify the supplied iterators, since they will have    * been advanced some number of elements forward.    */
DECL|method|elementsEqual ( Iterator<?> iterator1, Iterator<?> iterator2)
specifier|public
specifier|static
name|boolean
name|elementsEqual
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator1
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator2
parameter_list|)
block|{
while|while
condition|(
name|iterator1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|iterator2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Object
name|o1
init|=
name|iterator1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|o2
init|=
name|iterator2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Objects
operator|.
name|equal
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
operator|!
name|iterator2
operator|.
name|hasNext
argument_list|()
return|;
block|}
comment|/**    * Returns a string representation of {@code iterator}, with the format    * {@code [e1, e2, ..., en]}. The iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.    */
DECL|method|toString (Iterator<?> iterator)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|STANDARD_JOINER
operator|.
name|appendTo
argument_list|(
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
argument_list|,
name|iterator
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the single element contained in {@code iterator}.    *    * @throws NoSuchElementException if the iterator is empty    * @throws IllegalArgumentException if the iterator contains multiple    *     elements.  The state of the iterator is unspecified.    */
DECL|method|getOnlyElement (Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
name|T
name|first
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|first
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"expected one element but was:<"
operator|+
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
operator|+
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Returns the single element contained in {@code iterator}, or {@code    * defaultValue} if the iterator is empty.    *    * @throws IllegalArgumentException if the iterator contains multiple    *     elements.  The state of the iterator is unspecified.    */
annotation|@
name|Nullable
DECL|method|getOnlyElement (Iterator<? extends T> iterator, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|getOnlyElement
argument_list|(
name|iterator
argument_list|)
else|:
name|defaultValue
return|;
block|}
comment|/**    * Adds all elements in {@code iterator} to {@code collection}. The iterator    * will be left exhausted: its {@code hasNext()} method will return    * {@code false}.    *    * @return {@code true} if {@code collection} was modified as a result of this    *         operation    */
DECL|method|addAll ( Collection<T> addTo, Iterator<? extends T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|addTo
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|addTo
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|boolean
name|wasModified
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wasModified
operator||=
name|addTo
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|wasModified
return|;
block|}
comment|/**    * Returns the number of elements in the specified iterator that equal the    * specified object. The iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.    *    * @see Collections#frequency    */
DECL|method|frequency (Iterator<?> iterator, @Nullable Object element)
specifier|public
specifier|static
name|int
name|frequency
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iterator
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
name|result
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns an iterator that cycles indefinitely over the elements of {@code    * iterable}.    *    *<p>The returned iterator supports {@code remove()} if the provided iterator    * does. After {@code remove()} is called, subsequent cycles omit the removed    * element, which is no longer in {@code iterable}. The iterator's    * {@code hasNext()} method returns {@code true} until {@code iterable} is    * empty.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an    * infinite loop. You should use an explicit {@code break} or be certain that    * you will eventually remove all the elements.    */
DECL|method|cycle (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
init|=
name|emptyIterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|T
argument_list|>
name|removeFrom
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|=
name|iterable
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|removeFrom
operator|=
name|iterator
expr_stmt|;
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|removeFrom
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|removeFrom
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an iterator that cycles indefinitely over the provided elements.    *    *<p>The returned iterator supports {@code remove()}. After {@code remove()}    * is called, subsequent cycles omit the removed    * element, but {@code elements} does not change. The iterator's    * {@code hasNext()} method returns {@code true} until all of the original    * elements have been removed.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an    * infinite loop. You should use an explicit {@code break} or be certain that    * you will eventually remove all the elements.    */
DECL|method|cycle (T... elements)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
name|T
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|cycle
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines two iterators into a single iterator. The returned iterator    * iterates across the elements in {@code a}, followed by the elements in    * {@code b}. The source iterators are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding    * input iterator supports it.    *    *<p><b>Note:</b> the current implementation is not suitable for nested    * concatenated iterators, i.e. the following should be avoided when in a loop:    * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the    * resulting iterator has a cubic complexity to the depth of the nesting.    */
DECL|method|concat (Iterator<? extends T> a, Iterator<? extends T> b)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|concat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Combines three iterators into a single iterator. The returned iterator    * iterates across the elements in {@code a}, followed by the elements in    * {@code b}, followed by the elements in {@code c}. The source iterators    * are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding    * input iterator supports it.    *    *<p><b>Note:</b> the current implementation is not suitable for nested    * concatenated iterators, i.e. the following should be avoided when in a loop:    * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the    * resulting iterator has a cubic complexity to the depth of the nesting.    */
DECL|method|concat (Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|concat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Combines four iterators into a single iterator. The returned iterator    * iterates across the elements in {@code a}, followed by the elements in    * {@code b}, followed by the elements in {@code c}, followed by the elements    * in {@code d}. The source iterators are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding    * input iterator supports it.    *    *<p><b>Note:</b> the current implementation is not suitable for nested    * concatenated iterators, i.e. the following should be avoided when in a loop:    * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the    * resulting iterator has a cubic complexity to the depth of the nesting.    */
DECL|method|concat (Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c, Iterator<? extends T> d)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|,
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|d
parameter_list|)
block|{
return|return
name|concat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterators into a single iterator. The returned iterator    * iterates across the elements of each iterator in {@code inputs}. The input    * iterators are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding    * input iterator supports it.    *    *<p><b>Note:</b> the current implementation is not suitable for nested    * concatenated iterators, i.e. the following should be avoided when in a loop:    * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the    * resulting iterator has a cubic complexity to the depth of the nesting.    *    * @throws NullPointerException if any of the provided iterators is null    */
DECL|method|concat (Iterator<? extends T>.... inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
modifier|...
name|inputs
parameter_list|)
block|{
return|return
name|concat
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|inputs
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterators into a single iterator. The returned iterator    * iterates across the elements of each iterator in {@code inputs}. The input    * iterators are not polled until necessary.    *    *<p>The returned iterator supports {@code remove()} when the corresponding    * input iterator supports it. The methods of the returned iterator may throw    * {@code NullPointerException} if any of the input iterators is null.    *    *<p><b>Note:</b> the current implementation is not suitable for nested    * concatenated iterators, i.e. the following should be avoided when in a loop:    * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the    * resulting iterator has a cubic complexity to the depth of the nesting.    */
DECL|method|concat ( final Iterator<? extends Iterator<? extends T>> inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|inputs
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|inputs
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|current
init|=
name|emptyIterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|removeFrom
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
comment|// http://code.google.com/p/google-collections/issues/detail?id=151
comment|// current.hasNext() might be relatively expensive, worth minimizing.
name|boolean
name|currentHasNext
decl_stmt|;
comment|// checkNotNull eager for GWT
comment|// note: it must be here& not where 'current' is assigned,
comment|// because otherwise we'll have called inputs.next() before throwing
comment|// the first NPE, and the next time around we'll call inputs.next()
comment|// again, incorrectly moving beyond the error.
while|while
condition|(
operator|!
operator|(
name|currentHasNext
operator|=
name|checkNotNull
argument_list|(
name|current
argument_list|)
operator|.
name|hasNext
argument_list|()
operator|)
operator|&&
name|inputs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|current
operator|=
name|inputs
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|currentHasNext
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|removeFrom
operator|=
name|current
expr_stmt|;
return|return
name|current
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|removeFrom
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|removeFrom
operator|.
name|remove
argument_list|()
expr_stmt|;
name|removeFrom
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Divides an iterator into unmodifiable sublists of the given size (the final    * list may be smaller). For example, partitioning an iterator containing    * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code    * [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of    * three and two elements, all in the original order.    *    *<p>The returned lists implement {@link java.util.RandomAccess}.    *    * @param iterator the iterator to return a partitioned view of    * @param size the desired size of each partition (the last may be smaller)    * @return an iterator of immutable lists containing the elements of {@code    *     iterator} divided into partitions    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|partition ( Iterator<T> iterator, int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|partitionImpl
argument_list|(
name|iterator
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Divides an iterator into unmodifiable sublists of the given size, padding    * the final iterator with null values if necessary. For example, partitioning    * an iterator containing {@code [a, b, c, d, e]} with a partition size of 3    * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing    * two inner lists of three elements each, all in the original order.    *    *<p>The returned lists implement {@link java.util.RandomAccess}.    *    * @param iterator the iterator to return a partitioned view of    * @param size the desired size of each partition    * @return an iterator of immutable lists containing the elements of {@code    *     iterator} divided into partitions (the final iterable may have    *     trailing null elements)    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|paddedPartition ( Iterator<T> iterator, int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|paddedPartition
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|partitionImpl
argument_list|(
name|iterator
argument_list|,
name|size
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|partitionImpl ( final Iterator<T> iterator, final int size, final boolean pad)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partitionImpl
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|boolean
name|pad
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|Object
index|[]
name|array
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|count
operator|<
name|size
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|array
index|[
name|count
index|]
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|count
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|array
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// for GWT
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// we only put Ts in it
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|pad
operator|||
name|count
operator|==
name|size
operator|)
condition|?
name|list
else|:
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|count
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate.    */
DECL|method|filter ( final Iterator<T> unfiltered, final Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|T
name|computeNext
parameter_list|()
block|{
while|while
condition|(
name|unfiltered
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|element
init|=
name|unfiltered
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
name|element
return|;
block|}
block|}
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns {@code true} if one or more elements returned by {@code iterator}    * satisfy the given predicate.    */
DECL|method|any ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
comment|/**    * Returns {@code true} if every element returned by {@code iterator}    * satisfies the given predicate. If {@code iterator} is empty, {@code true}    * is returned.    */
DECL|method|all ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|all
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|element
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns the first element in {@code iterator} that satisfies the given    * predicate; use this method only when such an element is known to exist. If    * no such element is found, the iterator will be left exhausted: its {@code    * hasNext()} method will return {@code false}. If it is possible that    *<i>no</i> element will match, use {@link #tryFind} or {@link    * #find(Iterator, Predicate, Object)} instead.    *    * @throws NoSuchElementException if no element in {@code iterator} matches    *     the given predicate    */
DECL|method|find ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**    * Returns the first element in {@code iterator} that satisfies the given    * predicate. If no such element is found, {@code defaultValue} will be    * returned from this method and the iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}. Note that this can    * usually be handled more naturally using {@code    * tryFind(iterator, predicate).or(defaultValue)}.    *    * @since 7.0    */
annotation|@
name|Nullable
DECL|method|find (Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|getNext
argument_list|(
name|filter
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns an {@link Optional} containing the first element in {@code    * iterator} that satisfies the given predicate, if such an element exists. If    * no such element is found, an empty {@link Optional} will be returned from    * this method and the iterator will be left exhausted: its {@code    * hasNext()} method will return {@code false}.    *    *<p><b>Warning:</b> avoid using a {@code predicate} that matches {@code    * null}. If {@code null} is matched in {@code iterator}, a    * NullPointerException will be thrown.    *    * @since 11.0    */
DECL|method|tryFind ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|tryFind
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|filteredIterator
init|=
name|filter
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
name|filteredIterator
operator|.
name|hasNext
argument_list|()
condition|?
name|Optional
operator|.
name|of
argument_list|(
name|filteredIterator
operator|.
name|next
argument_list|()
argument_list|)
else|:
name|Optional
operator|.
expr|<
name|T
operator|>
name|absent
argument_list|()
return|;
block|}
comment|/**    * Returns the index in {@code iterator} of the first element that satisfies    * the provided {@code predicate}, or {@code -1} if the Iterator has no such    * elements.    *    *<p>More formally, returns the lowest index {@code i} such that    * {@code predicate.apply(Iterators.get(iterator, i))} returns {@code true},    * or {@code -1} if there is no such index.    *    *<p>If -1 is returned, the iterator will be left exhausted: its    * {@code hasNext()} method will return {@code false}.  Otherwise,    * the iterator will be set to the element which satisfies the    * {@code predicate}.    *    * @since 2.0    */
DECL|method|indexOf ( Iterator<T> iterator, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|indexOf
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|,
literal|"predicate"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|T
name|current
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|current
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns an iterator that applies {@code function} to each element of {@code    * fromIterator}.    *    *<p>The returned iterator supports {@code remove()} if the provided iterator    * does. After a successful {@code remove()} call, {@code fromIterator} no    * longer contains the corresponding element.    */
DECL|method|transform (final Iterator<F> fromIterator, final Function<? super F, ? extends T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|F
argument_list|>
name|fromIterator
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|TransformedIterator
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromIterator
argument_list|)
block|{
annotation|@
name|Override
name|T
name|transform
parameter_list|(
name|F
name|from
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Advances {@code iterator} {@code position + 1} times, returning the    * element at the {@code position}th position.    *    * @param position position of the element to return    * @return the element at the specified position in {@code iterator}    * @throws IndexOutOfBoundsException if {@code position} is negative or    *     greater than or equal to the number of elements remaining in    *     {@code iterator}    */
DECL|method|get (Iterator<T> iterator, int position)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|int
name|skipped
init|=
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"position ("
operator|+
name|position
operator|+
literal|") must be less than the number of elements that remained ("
operator|+
name|skipped
operator|+
literal|")"
argument_list|)
throw|;
block|}
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|checkNonnegative (int position)
specifier|static
name|void
name|checkNonnegative
parameter_list|(
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"position ("
operator|+
name|position
operator|+
literal|") must not be negative"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Advances {@code iterator} {@code position + 1} times, returning the    * element at the {@code position}th position or {@code defaultValue}    * otherwise.    *    * @param position position of the element to return    * @param defaultValue the default value to return if the iterator is empty    *     or if {@code position} is greater than the number of elements    *     remaining in {@code iterator}    * @return the element at the specified position in {@code iterator} or    *     {@code defaultValue} if {@code iterator} produces fewer than    *     {@code position + 1} elements.    * @throws IndexOutOfBoundsException if {@code position} is negative    * @since 4.0    */
annotation|@
name|Nullable
DECL|method|get (Iterator<? extends T> iterator, int position, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
name|int
name|position
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|advance
argument_list|(
name|iterator
argument_list|,
name|position
argument_list|)
expr_stmt|;
return|return
name|getNext
argument_list|(
name|iterator
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns the next element in {@code iterator} or {@code defaultValue} if    * the iterator is empty.  The {@link Iterables} analog to this method is    * {@link Iterables#getFirst}.    *    * @param defaultValue the default value to return if the iterator is empty    * @return the next element of {@code iterator} or the default value    * @since 7.0    */
annotation|@
name|Nullable
DECL|method|getNext (Iterator<? extends T> iterator, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getNext
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|iterator
operator|.
name|next
argument_list|()
else|:
name|defaultValue
return|;
block|}
comment|/**    * Advances {@code iterator} to the end, returning the last element.    *    * @return the last element of {@code iterator}    * @throws NoSuchElementException if the iterator is empty    */
DECL|method|getLast (Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|T
name|current
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|current
return|;
block|}
block|}
block|}
comment|/**    * Advances {@code iterator} to the end, returning the last element or    * {@code defaultValue} if the iterator is empty.    *    * @param defaultValue the default value to return if the iterator is empty    * @return the last element of {@code iterator}    * @since 3.0    */
annotation|@
name|Nullable
DECL|method|getLast (Iterator<? extends T> iterator, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
condition|?
name|getLast
argument_list|(
name|iterator
argument_list|)
else|:
name|defaultValue
return|;
block|}
comment|/**    * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times    * or until {@code hasNext()} returns {@code false}, whichever comes first.    *    * @return the number of elements the iterator was advanced    * @since 13.0 (since 3.0 as {@code Iterators.skip})    */
DECL|method|advance (Iterator<?> iterator, int numberToAdvance)
specifier|public
specifier|static
name|int
name|advance
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|,
name|int
name|numberToAdvance
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|numberToAdvance
operator|>=
literal|0
argument_list|,
literal|"numberToAdvance must be nonnegative"
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberToAdvance
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
comment|/**    * Creates an iterator returning the first {@code limitSize} elements of the    * given iterator. If the original iterator does not contain that many    * elements, the returned iterator will have the same behavior as the original    * iterator. The returned iterator supports {@code remove()} if the original    * iterator does.    *    * @param iterator the iterator to limit    * @param limitSize the maximum number of elements in the returned iterator    * @throws IllegalArgumentException if {@code limitSize} is negative    * @since 3.0    */
DECL|method|limit ( final Iterator<T> iterator, final int limitSize)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|limit
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
specifier|final
name|int
name|limitSize
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|limitSize
operator|>=
literal|0
argument_list|,
literal|"limit is negative"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|count
operator|<
name|limitSize
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|count
operator|++
expr_stmt|;
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of the supplied {@code iterator} that removes each element    * from the supplied {@code iterator} as it is returned.    *    *<p>The provided iterator must support {@link Iterator#remove()} or    * else the returned iterator will fail on the first call to {@code    * next}.    *    * @param iterator the iterator to remove and return elements from    * @return an iterator that removes and returns elements from the    *     supplied iterator    * @since 2.0    */
DECL|method|consumingIterator (final Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|consumingIterator
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
name|T
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|next
return|;
block|}
block|}
return|;
block|}
comment|/**    * Deletes and returns the next value from the iterator, or returns    * {@code defaultValue} if there is no such value.    */
annotation|@
name|Nullable
DECL|method|pollNext (Iterator<T> iterator)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|pollNext
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|result
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Methods only in Iterators, not in Iterables
comment|/**    * Clears the iterator using its remove method.    */
DECL|method|clear (Iterator<?> iterator)
specifier|static
name|void
name|clear
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns an iterator containing the elements of {@code array} in order. The    * returned iterator is a view of the array; subsequent changes to the array    * will be reflected in the iterator.    *    *<p><b>Note:</b> It is often preferable to represent your data using a    * collection type, for example using {@link Arrays#asList(Object[])}, making    * this method unnecessary.    *    *<p>The {@code Iterable} equivalent of this method is either {@link    * Arrays#asList(Object[])}, {@link ImmutableList#copyOf(Object[])}},    * or {@link ImmutableList#of}.    */
DECL|method|forArray (final T... array)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|forArray
parameter_list|(
specifier|final
name|T
modifier|...
name|array
parameter_list|)
block|{
return|return
name|forArray
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|array
operator|.
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Returns a list iterator containing the elements in the specified range of    * {@code array} in order, starting at the specified index.    *    *<p>The {@code Iterable} equivalent of this method is {@code    * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.    */
DECL|method|forArray ( final T[] array, final int offset, int length, int index)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableListIterator
argument_list|<
name|T
argument_list|>
name|forArray
parameter_list|(
specifier|final
name|T
index|[]
name|array
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
comment|// Technically we should give a slightly more descriptive error on overflow
name|Preconditions
operator|.
name|checkPositionIndexes
argument_list|(
name|offset
argument_list|,
name|end
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|index
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|emptyListIterator
argument_list|()
return|;
block|}
comment|/*      * We can't use call the two-arg constructor with arguments (offset, end)      * because the returned Iterator is a ListIterator that may be moved back      * past the beginning of the iteration.      */
return|return
operator|new
name|AbstractIndexedListIterator
argument_list|<
name|T
argument_list|>
argument_list|(
name|length
argument_list|,
name|index
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|array
index|[
name|offset
operator|+
name|index
index|]
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an iterator containing only {@code value}.    *    *<p>The {@link Iterable} equivalent of this method is {@link    * Collections#singleton}.    */
DECL|method|singletonIterator ( @ullable final T value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|singletonIterator
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|T
name|value
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|done
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|done
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
name|done
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
return|;
block|}
comment|/**    * Adapts an {@code Enumeration} to the {@code Iterator} interface.    *    *<p>This method has no equivalent in {@link Iterables} because viewing an    * {@code Enumeration} as an {@code Iterable} is impossible. However, the    * contents can be<i>copied</i> into a collection using {@link    * Collections#list}.    */
DECL|method|forEnumeration ( final Enumeration<T> enumeration)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|forEnumeration
parameter_list|(
specifier|final
name|Enumeration
argument_list|<
name|T
argument_list|>
name|enumeration
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|enumeration
argument_list|)
expr_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|enumeration
operator|.
name|hasMoreElements
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|enumeration
operator|.
name|nextElement
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Adapts an {@code Iterator} to the {@code Enumeration} interface.    *    *<p>The {@code Iterable} equivalent of this method is either {@link    * Collections#enumeration} (if you have a {@link Collection}), or    * {@code Iterators.asEnumeration(collection.iterator())}.    */
DECL|method|asEnumeration (final Iterator<T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Enumeration
argument_list|<
name|T
argument_list|>
name|asEnumeration
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
return|return
operator|new
name|Enumeration
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|nextElement
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Implementation of PeekingIterator that avoids peeking unless necessary.    */
DECL|class|PeekingImpl
specifier|private
specifier|static
class|class
name|PeekingImpl
parameter_list|<
name|E
parameter_list|>
implements|implements
name|PeekingIterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|iterator
specifier|private
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
decl_stmt|;
DECL|field|hasPeeked
specifier|private
name|boolean
name|hasPeeked
decl_stmt|;
DECL|field|peekedElement
specifier|private
name|E
name|peekedElement
decl_stmt|;
DECL|method|PeekingImpl (Iterator<? extends E> iterator)
specifier|public
name|PeekingImpl
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
parameter_list|)
block|{
name|this
operator|.
name|iterator
operator|=
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|hasPeeked
operator|||
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|E
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasPeeked
condition|)
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
name|E
name|result
init|=
name|peekedElement
decl_stmt|;
name|hasPeeked
operator|=
literal|false
expr_stmt|;
name|peekedElement
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
operator|!
name|hasPeeked
argument_list|,
literal|"Can't remove after you've peeked at next"
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|E
name|peek
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasPeeked
condition|)
block|{
name|peekedElement
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|hasPeeked
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|peekedElement
return|;
block|}
block|}
comment|/**    * Returns a {@code PeekingIterator} backed by the given iterator.    *    *<p>Calls to the {@code peek} method with no intervening calls to {@code    * next} do not affect the iteration, and hence return the same object each    * time. A subsequent call to {@code next} is guaranteed to return the same    * object again. For example:<pre>   {@code    *    *   PeekingIterator<String> peekingIterator =    *       Iterators.peekingIterator(Iterators.forArray("a", "b"));    *   String a1 = peekingIterator.peek(); // returns "a"    *   String a2 = peekingIterator.peek(); // also returns "a"    *   String a3 = peekingIterator.next(); // also returns "a"}</pre>    *    * Any structural changes to the underlying iteration (aside from those    * performed by the iterator's own {@link PeekingIterator#remove()} method)    * will leave the iterator in an undefined state.    *    *<p>The returned iterator does not support removal after peeking, as    * explained by {@link PeekingIterator#remove()}.    *    *<p>Note: If the given iterator is already a {@code PeekingIterator},    * it<i>might</i> be returned to the caller, although this is neither    * guaranteed to occur nor required to be consistent.  For example, this    * method<i>might</i> choose to pass through recognized implementations of    * {@code PeekingIterator} when the behavior of the implementation is    * known to meet the contract guaranteed by this method.    *    *<p>There is no {@link Iterable} equivalent to this method, so use this    * method to wrap each individual iterator as it is generated.    *    * @param iterator the backing iterator. The {@link PeekingIterator} assumes    *     ownership of this iterator, so users should cease making direct calls    *     to it after calling this method.    * @return a peeking iterator backed by that iterator. Apart from the    *     additional {@link PeekingIterator#peek()} method, this iterator behaves    *     exactly the same as {@code iterator}.    */
DECL|method|peekingIterator ( Iterator<? extends T> iterator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|peekingIterator
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
if|if
condition|(
name|iterator
operator|instanceof
name|PeekingImpl
condition|)
block|{
comment|// Safe to cast<? extends T> to<T> because PeekingImpl only uses T
comment|// covariantly (and cannot be subclassed to add non-covariant uses).
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|PeekingImpl
argument_list|<
name|T
argument_list|>
name|peeking
init|=
operator|(
name|PeekingImpl
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
decl_stmt|;
return|return
name|peeking
return|;
block|}
return|return
operator|new
name|PeekingImpl
argument_list|<
name|T
argument_list|>
argument_list|(
name|iterator
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
DECL|method|peekingIterator ( PeekingIterator<T> iterator)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|peekingIterator
parameter_list|(
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|iterator
argument_list|)
return|;
block|}
comment|/**    * Returns an iterator over the merged contents of all given    * {@code iterators}, traversing every element of the input iterators.    * Equivalent entries will not be de-duplicated.    *    *<p>Callers must ensure that the source {@code iterators} are in    * non-descending order as this method does not sort its input.    *    *<p>For any equivalent elements across all {@code iterators}, it is    * undefined which element is returned first.    *    * @since 11.0    */
annotation|@
name|Beta
DECL|method|mergeSorted ( Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
name|mergeSorted
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterators
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|comparator
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterators
argument_list|,
literal|"iterators"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|comparator
argument_list|,
literal|"comparator"
argument_list|)
expr_stmt|;
return|return
operator|new
name|MergingIterator
argument_list|<
name|T
argument_list|>
argument_list|(
name|iterators
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**    * An iterator that performs a lazy N-way merge, calculating the next value    * each time the iterator is polled. This amortizes the sorting cost over the    * iteration and requires less memory than sorting all elements at once.    *    *<p>Retrieving a single element takes approximately O(log(M)) time, where M    * is the number of iterators. (Retrieving all elements takes approximately    * O(N*log(M)) time, where N is the total number of elements.)    */
DECL|class|MergingIterator
specifier|private
specifier|static
class|class
name|MergingIterator
parameter_list|<
name|T
parameter_list|>
extends|extends
name|UnmodifiableIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|queue
specifier|final
name|Queue
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
name|queue
decl_stmt|;
DECL|method|MergingIterator (Iterable<? extends Iterator<? extends T>> iterators, final Comparator<? super T> itemComparator)
specifier|public
name|MergingIterator
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterators
parameter_list|,
specifier|final
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|itemComparator
parameter_list|)
block|{
comment|// A comparator that's used by the heap, allowing the heap
comment|// to be sorted based on the top of each iterator.
name|Comparator
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
name|heapComparator
init|=
operator|new
name|Comparator
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|o1
parameter_list|,
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|o2
parameter_list|)
block|{
return|return
name|itemComparator
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|peek
argument_list|()
argument_list|,
name|o2
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|queue
operator|=
operator|new
name|PriorityQueue
argument_list|<
name|PeekingIterator
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
literal|2
argument_list|,
name|heapComparator
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
range|:
name|iterators
control|)
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|Iterators
operator|.
name|peekingIterator
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|T
name|next
parameter_list|()
block|{
name|PeekingIterator
argument_list|<
name|T
argument_list|>
name|nextIter
init|=
name|queue
operator|.
name|remove
argument_list|()
decl_stmt|;
name|T
name|next
init|=
name|nextIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|nextIter
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
block|}
comment|/**    * Precondition tester for {@code Iterator.remove()} that throws an exception with a consistent    * error message.    */
DECL|method|checkRemove (boolean canRemove)
specifier|static
name|void
name|checkRemove
parameter_list|(
name|boolean
name|canRemove
parameter_list|)
block|{
name|checkState
argument_list|(
name|canRemove
argument_list|,
literal|"no calls to next() since the last call to remove()"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557    */
DECL|method|cast (Iterator<T> iterator)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ListIterator
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
operator|(
name|ListIterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
return|;
block|}
block|}
end_class

end_unit

