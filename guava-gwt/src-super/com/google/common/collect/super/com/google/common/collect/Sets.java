begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
operator|.
name|FilteredCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Set} instances. Also see this  * class's counterparts {@link Lists} and {@link Maps}.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @author Chris Povirk  * @since Guava release 02 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Sets
specifier|public
specifier|final
class|class
name|Sets
block|{
DECL|method|Sets ()
specifier|private
name|Sets
parameter_list|()
block|{}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements are provided to the method.    *    * @param anElement one of the elements the set should contain    * @param otherElements the rest of the elements the set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet ( E anElement, E... otherElements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|E
name|anElement
parameter_list|,
name|E
modifier|...
name|otherElements
parameter_list|)
block|{
return|return
operator|new
name|ImmutableEnumSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|anElement
argument_list|,
name|otherElements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements appear in the given collection.    *    * @param elements the elements, all of the same {@code enum} type, that the    *     set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet ( Iterable<E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
init|=
name|elements
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
if|if
condition|(
name|elements
operator|instanceof
name|EnumSet
condition|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|enumSetClone
init|=
name|EnumSet
operator|.
name|copyOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|elements
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutableEnumSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|enumSetClone
argument_list|)
return|;
block|}
name|E
name|first
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|EnumSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|first
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ImmutableEnumSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|set
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code EnumSet} instance containing the given elements.    * Unlike {@link EnumSet#copyOf(Collection)}, this method does not produce an    * exception on an empty collection, and it may be called on any iterable, not    * just a {@code Collection}.    */
DECL|method|newEnumSet (Iterable<E> iterable, Class<E> elementType)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|newEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|elementType
parameter_list|)
block|{
comment|/*      * TODO(cpovirk): noneOf() and addAll() will both throw      * NullPointerExceptions when appropriate. However, NullPointerTester will      * fail on this method because it passes in Class.class instead of an enum      * type. This means that, when iterable is null but elementType is not,      * noneOf() will throw a ClassCastException before addAll() has a chance to      * throw a NullPointerException. NullPointerTester considers this a failure.      * Ideally the test would be fixed, but it would require a special case for      * Class<E> where E extends Enum. Until that happens (if ever), leave      * checkNotNull() here. For now, contemplate the irony that checking      * elementType, the problem argument, is harmful, while checking iterable,      * the innocent bystander, is effective.      */
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|EnumSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|elementType
argument_list|)
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|iterable
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// HashSet
comment|/**    * Creates a<i>mutable</i>, empty {@code HashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSet#of()} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link    * EnumSet#noneOf} instead.    *    * @return a new, empty {@code HashSet}    */
DECL|method|newHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use an overload of {@link ImmutableSet#of()} (for varargs) or    * {@link ImmutableSet#copyOf(Object[])} (for an array) instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link    * EnumSet#of(Enum, Enum[])} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (E... elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSetWithExpectedSize
argument_list|(
name|elements
operator|.
name|length
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a {@code HashSet} instance, with a high enough "initial capacity"    * that it<i>should</i> hold {@code expectedSize} elements without growth.    * This behavior cannot be broadly guaranteed, but it is observed to be true    * for OpenJDK 1.6. It also can't be guaranteed that the method isn't    * inadvertently<i>oversizing</i> the returned set.    *    * @param expectedSize the number of elements you expect to add to the    *        returned set    * @return a new, empty {@code HashSet} with enough capacity to hold {@code    *         expectedSize} elements without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|newHashSetWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSetWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use    * {@link #newEnumSet(Iterable, Class)} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
else|:
name|newHashSet
argument_list|(
name|elements
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an    * {@link EnumSet} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSet
argument_list|()
decl_stmt|;
while|while
condition|(
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|elements
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|// LinkedHashSet
comment|/**    * Creates a<i>mutable</i>, empty {@code LinkedHashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSet#of()} instead.    *    * @return a new, empty {@code LinkedHashSet}    */
DECL|method|newLinkedHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code LinkedHashSet} instance containing the    * given elements in order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    * @param elements the elements that the set should contain, in order    * @return a new {@code LinkedHashSet} containing those elements (minus    *     duplicates)    */
DECL|method|newLinkedHashSet ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newLinkedHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|E
name|element
range|:
name|elements
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|// TreeSet
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance sorted by the    * natural sort ordering of its elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedSet#of()} instead.    *    * @return a new, empty {@code TreeSet}    */
DECL|method|newTreeSet ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code TreeSet} instance containing the given    * elements sorted by their natural ordering.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit    * comparator, this method has different behavior than    * {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with    * that comparator.    *    * @param elements the elements that the set should contain    * @return a new {@code TreeSet} containing those elements (minus duplicates)    */
DECL|method|newTreeSet ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newTreeSet
argument_list|()
decl_stmt|;
for|for
control|(
name|E
name|element
range|:
name|elements
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance with the given    * comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedSet.orderedBy(comparator).build()} instead.    *    * @param comparator the comparator to use to sort the set    * @return a new, empty {@code TreeSet}    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|newTreeSet (Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an empty {@code Set} that uses identity to determine equality. It    * compares object references, instead of calling {@code equals}, to    * determine whether a provided object matches an element in the set. For    * example, {@code contains} returns {@code false} when passed an object that    * equals a set member, but isn't the same instance. This behavior is similar    * to the way {@code IdentityHashMap} handles key lookups.    *    * @since Guava release 08    */
DECL|method|newIdentityHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newIdentityHashSet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newSetFromMap
argument_list|(
name|Maps
operator|.
expr|<
name|E
argument_list|,
name|Boolean
operator|>
name|newIdentityHashMap
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. If the collection is an {@link EnumSet}, this    * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,    * the specified collection must contain at least one element, in order to    * determine the element type. If the collection could be empty, use    * {@link #complementOf(Collection, Class)} instead of this method.    *    * @param collection the collection whose complement should be stored in the    *     enum set    * @return a new, modifiable {@code EnumSet} containing all values of the enum    *     that aren't present in the given collection    * @throws IllegalArgumentException if {@code collection} is not an    *     {@code EnumSet} instance and contains no elements    */
DECL|method|complementOf ( Collection<E> collection)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|EnumSet
condition|)
block|{
return|return
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
operator|!
name|collection
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"collection is empty; use the other version of this method"
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|E
argument_list|>
name|type
init|=
name|collection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
return|return
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. This is equivalent to    * {@link EnumSet#complementOf}, but can act on any input collection, as long    * as the elements are of enum type.    *    * @param collection the collection whose complement should be stored in the    *     {@code EnumSet}    * @param type the type of the elements in the set    * @return a new, modifiable {@code EnumSet} initially containing all the    *     values of the enum not present in the given collection    */
DECL|method|complementOf ( Collection<E> collection, Class<E> type)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
operator|(
name|collection
operator|instanceof
name|EnumSet
operator|)
condition|?
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
else|:
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|makeComplementByHand ( Collection<E> collection, Class<E> type)
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|makeComplementByHand
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|result
operator|.
name|removeAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*    * Regarding newSetForMap() and SetFromMap:    *    * Written by Doug Lea with assistance from members of JCP JSR-166    * Expert Group and released to the public domain, as explained at    * http://creativecommons.org/licenses/publicdomain    */
comment|/**    * Returns a set backed by the specified map. The resulting set displays    * the same ordering, concurrency, and performance characteristics as the    * backing map. In essence, this factory method provides a {@link Set}    * implementation corresponding to any {@link Map} implementation. There is no    * need to use this method on a {@link Map} implementation that already has a    * corresponding {@link Set} implementation (such as {@link java.util.HashMap}    * or {@link java.util.TreeMap}).    *    *<p>Each method invocation on the set returned by this method results in    * exactly one method invocation on the backing map or its {@code keySet}    * view, with one exception. The {@code addAll} method is implemented as a    * sequence of {@code put} invocations on the backing map.    *    *<p>The specified map must be empty at the time this method is invoked,    * and should not be accessed directly after this method returns. These    * conditions are ensured if the map is created empty, passed directly    * to this method, and no reference to the map is retained, as illustrated    * in the following code fragment:<pre>  {@code    *    *   Set<Object> identityHashSet = Sets.newSetFromMap(    *       new IdentityHashMap<Object, Boolean>());}</pre>    *    * This method has the same behavior as the JDK 6 method    * {@code Collections.newSetFromMap()}. The returned set is serializable if    * the backing map is.    *    * @param map the backing map    * @return the set backed by the map    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSetFromMap (Map<E, Boolean> map)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newSetFromMap
parameter_list|(
name|Map
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|SetFromMap
argument_list|<
name|E
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|class|SetFromMap
specifier|private
specifier|static
class|class
name|SetFromMap
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
implements|implements
name|Set
argument_list|<
name|E
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|m
specifier|private
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
name|m
decl_stmt|;
comment|// The backing map
DECL|field|s
specifier|private
specifier|transient
name|Set
argument_list|<
name|E
argument_list|>
name|s
decl_stmt|;
comment|// Its keySet
DECL|method|SetFromMap (Map<E, Boolean> map)
name|SetFromMap
parameter_list|(
name|Map
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
name|map
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Map is non-empty"
argument_list|)
expr_stmt|;
name|m
operator|=
name|map
expr_stmt|;
name|s
operator|=
name|map
operator|.
name|keySet
argument_list|()
expr_stmt|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|m
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|m
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|m
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|m
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|m
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|add (E e)
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|m
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
operator|==
literal|null
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|s
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|s
operator|.
name|toArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] a)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
return|return
name|s
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|s
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|this
operator|==
name|object
operator|||
name|this
operator|.
name|s
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|s
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|removeAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|s
operator|.
name|removeAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|retainAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|s
operator|.
name|retainAll
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|// addAll is the only inherited implementation
block|}
comment|/**    * An unmodifiable view of a set which may be backed by other sets; this view    * will change as the backing sets do. Contains methods to copy the data into    * a new set which will then remain stable. There is usually no reason to    * retain a reference of type {@code SetView}; typically, you either use it    * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or    * {@link #copyInto} and forget the {@code SetView} itself.    *    * @since Guava release 02 (imported from Google Collections Library)    */
DECL|class|SetView
specifier|public
specifier|abstract
specifier|static
class|class
name|SetView
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|SetView ()
specifier|private
name|SetView
parameter_list|()
block|{}
comment|// no subclasses but our own
comment|/**      * Returns an immutable copy of the current contents of this set view.      * Does not support null elements.      *      *<p><b>Warning:</b> this may have unexpected results if a backing set of      * this view uses a nonstandard notion of equivalence, for example if it is      * a {@link TreeSet} using a comparator that is inconsistent with {@link      * Object#equals(Object)}.      */
DECL|method|immutableCopy ()
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Copies the current contents of this set view into an existing set. This      * method has equivalent behavior to {@code set.addAll(this)}, assuming that      * all the sets involved are based on the same notion of equivalence.      *      * @return a reference to {@code set}, for convenience      */
comment|// Note: S should logically extend Set<? super E> but can't due to either
comment|// some javac bug or some weirdness in the spec, not sure which.
DECL|method|copyInto (S set)
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the union of two sets. The returned    * set contains all elements that are contained in either backing set.    * Iterating over the returned set iterates first over all the elements of    * {@code set1}, then over each element of {@code set2}, in order, that is not    * contained in {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based on    * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and    * the {@link Map#keySet} of an {@code IdentityHashMap} all are).    *    *<p><b>Note:</b> The returned view performs better when {@code set1} is the    * smaller of the two sets. If you have reason to believe one of your sets    * will generally be smaller than the other, pass it first.    */
DECL|method|union ( final Set<? extends E> set1, final Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|union
parameter_list|(
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2minus1
init|=
name|difference
argument_list|(
name|set2
argument_list|,
name|set1
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|set1
operator|.
name|size
argument_list|()
operator|+
name|set2minus1
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set1
operator|.
name|isEmpty
argument_list|()
operator|&&
name|set2
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|Iterators
operator|.
name|concat
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|||
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
operator|new
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|()
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the intersection of two sets. The    * returned set contains all elements that are contained by both backing sets.    * The iteration order of the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    *<p><b>Note:</b> The returned view performs slightly better when {@code    * set1} is the smaller of the two sets. If you have reason to believe one of    * your sets will generally be smaller than the other, pass it first.    * Unfortunately, since this method sets the generic type of the returned set    * based on the type of the first set passed, this could in rare cases force    * you to make a cast, for example:<pre>   {@code    *    *   Set<Object> aFewBadObjects = ...    *   Set<String> manyBadStrings = ...    *    *   // impossible for a non-String to be in the intersection    *   SuppressWarnings("unchecked")    *   Set<String> badStrings = (Set) Sets.intersection(    *       aFewBadObjects, manyBadStrings);}</pre>    *    * This is unfortunate, but should come up only very rarely.    */
DECL|method|intersection ( final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|intersection
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|inSet2
init|=
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|inSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|set1
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
operator|&&
name|set2
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the difference of two sets. The    * returned set contains all elements that are contained by {@code set1} and    * not contained by {@code set2}. {@code set2} may also contain elements not    * present in {@code set1}; these are simply ignored. The iteration order of    * the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    */
DECL|method|difference ( final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|difference
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|notInSet2
init|=
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|notInSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set2
operator|.
name|containsAll
argument_list|(
name|set1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|element
argument_list|)
operator|&&
operator|!
name|set2
operator|.
name|contains
argument_list|(
name|element
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the symmetric difference of two    * sets. The returned set contains all elements that are contained in either    * {@code set1} or {@code set2} but not in both. The iteration order of the    * returned set is undefined.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    * @since Guava release 03    */
DECL|method|symmetricDifference ( Set<? extends E> set1, Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|symmetricDifference
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
comment|// TODO(kevinb): Replace this with a more efficient implementation
return|return
name|difference
argument_list|(
name|union
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
argument_list|,
name|intersection
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate. The    * returned set is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as {@code    * removeAll()} and {@code clear()} are called on the filtered set, only    * elements that satisfy the filter will be removed from the underlying set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate    * across every element in the underlying set and determine which elements    * satisfy the filter. When a live view is<i>not</i> needed, it may be faster    * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such    * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent    * with equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    */
comment|// TODO(kevinb): how to omit that last sentence when building GWT javadoc?
DECL|method|filter ( Set<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FilteredSet
specifier|private
specifier|static
class|class
name|FilteredSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredCollection
argument_list|<
name|E
argument_list|>
implements|implements
name|Set
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredSet (Set<E> unfiltered, Predicate<? super E> predicate)
name|FilteredSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(ImmutableList.of(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C")))}</pre>    *    * returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    * The order in which these lists are returned is not guaranteed, however the    * position of an element inside a tuple always corresponds to the position of    * the set from which it came in the input list. Note that if any input set is    * empty, the Cartesian product will also be empty. If no sets at all are    * provided (an empty list), the resulting Cartesian product has one element,    * an empty list (counter-intuitive, but mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since Guava release 02    */
DECL|method|cartesianProduct ( List<? extends Set<? extends B>> sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
name|CartesianSet
argument_list|<
name|B
argument_list|>
name|cartesianSet
init|=
operator|new
name|CartesianSet
argument_list|<
name|B
argument_list|>
argument_list|(
name|sets
argument_list|)
decl_stmt|;
return|return
name|cartesianSet
operator|.
name|isEmpty
argument_list|()
condition|?
name|ImmutableSet
operator|.
expr|<
name|List
argument_list|<
name|B
argument_list|>
operator|>
name|of
argument_list|()
else|:
name|cartesianSet
return|;
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C"))}</pre>    *    * returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    * The order in which these lists are returned is not guaranteed, however the    * position of an element inside a tuple always corresponds to the position of    * the set from which it came in the input list. Note that if any input set is    * empty, the Cartesian product will also be empty. If no sets at all are    * provided, the resulting Cartesian product has one element, an empty list    * (counter-intuitive, but mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since Guava release 02    */
DECL|method|cartesianProduct ( Set<? extends B>.... sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
modifier|...
name|sets
parameter_list|)
block|{
return|return
name|cartesianProduct
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|sets
argument_list|)
argument_list|)
return|;
block|}
DECL|class|CartesianSet
specifier|private
specifier|static
class|class
name|CartesianSet
parameter_list|<
name|B
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
block|{
DECL|field|axes
specifier|final
name|ImmutableList
argument_list|<
name|Axis
argument_list|>
name|axes
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|CartesianSet (List<? extends Set<? extends B>> sets)
name|CartesianSet
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
name|long
name|dividend
init|=
literal|1
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Axis
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
name|set
range|:
name|sets
control|)
block|{
name|Axis
name|axis
init|=
operator|new
name|Axis
argument_list|(
name|set
argument_list|,
operator|(
name|int
operator|)
name|dividend
argument_list|)
decl_stmt|;
comment|// check overflow at end
name|builder
operator|.
name|add
argument_list|(
name|axis
argument_list|)
expr_stmt|;
name|dividend
operator|*=
name|axis
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|axes
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|size
operator|=
name|Ints
operator|.
name|checkedCast
argument_list|(
name|dividend
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
argument_list|()
block|{
name|int
name|index
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|size
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|B
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|Object
index|[]
name|tuple
init|=
operator|new
name|Object
index|[
name|axes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tuple
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tuple
index|[
name|i
index|]
operator|=
name|axes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getForIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// only B's are put in here
name|List
argument_list|<
name|B
argument_list|>
name|result
init|=
operator|(
name|ImmutableList
argument_list|<
name|B
argument_list|>
operator|)
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tuple
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
block|}
return|;
block|}
DECL|method|contains (Object element)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|element
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|tuple
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|element
decl_stmt|;
name|int
name|dimensions
init|=
name|axes
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|tuple
operator|.
name|size
argument_list|()
operator|!=
name|dimensions
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dimensions
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|axes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|tuple
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
if|if
condition|(
name|object
operator|instanceof
name|CartesianSet
condition|)
block|{
name|CartesianSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|CartesianSet
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|axes
operator|.
name|equals
argument_list|(
name|that
operator|.
name|axes
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
comment|// It's a weird formula, but tests prove it works.
name|int
name|adjust
init|=
name|size
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|axes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|adjust
operator|*=
literal|31
expr_stmt|;
block|}
return|return
name|axes
operator|.
name|hashCode
argument_list|()
operator|+
name|adjust
return|;
block|}
DECL|class|Axis
specifier|private
class|class
name|Axis
block|{
DECL|field|choices
specifier|final
name|ImmutableSet
argument_list|<
name|?
extends|extends
name|B
argument_list|>
name|choices
decl_stmt|;
DECL|field|choicesList
specifier|final
name|ImmutableList
argument_list|<
name|?
extends|extends
name|B
argument_list|>
name|choicesList
decl_stmt|;
DECL|field|dividend
specifier|final
name|int
name|dividend
decl_stmt|;
DECL|method|Axis (Set<? extends B> set, int dividend)
name|Axis
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
name|set
parameter_list|,
name|int
name|dividend
parameter_list|)
block|{
name|choices
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|choicesList
operator|=
name|choices
operator|.
name|asList
argument_list|()
expr_stmt|;
name|this
operator|.
name|dividend
operator|=
name|dividend
expr_stmt|;
block|}
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|choices
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getForIndex (int index)
name|B
name|getForIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|choicesList
operator|.
name|get
argument_list|(
name|index
operator|/
name|dividend
operator|%
name|size
argument_list|()
argument_list|)
return|;
block|}
DECL|method|contains (Object target)
name|boolean
name|contains
parameter_list|(
name|Object
name|target
parameter_list|)
block|{
return|return
name|choices
operator|.
name|contains
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|CartesianSet
operator|.
name|Axis
condition|)
block|{
name|CartesianSet
operator|.
name|Axis
name|that
init|=
operator|(
name|CartesianSet
operator|.
name|Axis
operator|)
name|obj
decl_stmt|;
return|return
name|this
operator|.
name|choices
operator|.
name|equals
argument_list|(
name|that
operator|.
name|choices
argument_list|)
return|;
comment|// dividends must be equal or we wouldn't have gotten this far
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Because Axis instances are not exposed, we can
comment|// opportunistically choose whatever bizarre formula happens
comment|// to make CartesianSet.hashCode() as simple as possible.
return|return
name|size
operator|/
name|choices
operator|.
name|size
argument_list|()
operator|*
name|choices
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * Returns the set of all possible subsets of {@code set}. For example,    * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},    * {1}, {2}, {1, 2}}}.    *    *<p>Elements appear in these subsets in the same iteration order as they    * appeared in the input set. The order in which these subsets appear in the    * outer set is undefined. Note that the power set of the empty set is not the    * empty set, but a one-element set containing the empty set.    *    *<p>The returned set and its constituent sets use {@code equals} to decide    * whether two elements are identical, even if the input set uses a different    * concept of equivalence.    *    *<p><i>Performance notes:</i> while the power set of a set with size {@code    * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the    * power set is constructed, the input set is merely copied. Only as the    * power set is iterated are the individual subsets created, and these subsets    * themselves occupy only a few bytes of memory regardless of their size.    *    * @param set the set of elements to construct a power set from    * @return the power set, as an immutable set of immutable sets    * @throws IllegalArgumentException if {@code set} has more than 30 unique    *     elements (causing the power set size to exceed the {@code int} range)    * @throws NullPointerException if {@code set} is or contains {@code null}    * @see<a href="http://en.wikipedia.org/wiki/Power_set">Power set article at    *      Wikipedia</a>    * @since Guava release 04    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|false
argument_list|)
DECL|method|powerSet (Set<E> set)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|powerSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|input
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|input
operator|.
name|size
argument_list|()
operator|<=
literal|30
argument_list|,
literal|"Too many elements to create power set: %s> 30"
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|PowerSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|input
argument_list|)
return|;
block|}
DECL|class|PowerSet
specifier|private
specifier|static
specifier|final
class|class
name|PowerSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|inputSet
specifier|final
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|inputSet
decl_stmt|;
DECL|field|inputList
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|inputList
decl_stmt|;
DECL|field|powerSetSize
specifier|final
name|int
name|powerSetSize
decl_stmt|;
DECL|method|PowerSet (ImmutableSet<E> input)
name|PowerSet
parameter_list|(
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|input
parameter_list|)
block|{
name|this
operator|.
name|inputSet
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|inputList
operator|=
name|input
operator|.
name|asList
argument_list|()
expr_stmt|;
name|this
operator|.
name|powerSetSize
operator|=
literal|1
operator|<<
name|input
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|powerSetSize
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIndexedListIterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
name|powerSetSize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|get
parameter_list|(
specifier|final
name|int
name|setBits
parameter_list|)
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|bitCount
argument_list|(
name|setBits
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|BitFilteredSetIterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|inputList
argument_list|,
name|setBits
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
DECL|class|BitFilteredSetIterator
specifier|private
specifier|static
specifier|final
class|class
name|BitFilteredSetIterator
parameter_list|<
name|E
parameter_list|>
extends|extends
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|input
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|input
decl_stmt|;
DECL|field|remainingSetBits
name|int
name|remainingSetBits
decl_stmt|;
DECL|method|BitFilteredSetIterator (ImmutableList<E> input, int allSetBits)
name|BitFilteredSetIterator
parameter_list|(
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|input
parameter_list|,
name|int
name|allSetBits
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|remainingSetBits
operator|=
name|allSetBits
expr_stmt|;
block|}
DECL|method|hasNext ()
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|remainingSetBits
operator|!=
literal|0
return|;
block|}
DECL|method|next ()
annotation|@
name|Override
specifier|public
name|E
name|next
parameter_list|()
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|remainingSetBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|32
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|int
name|currentElementMask
init|=
literal|1
operator|<<
name|index
decl_stmt|;
name|remainingSetBits
operator|&=
operator|~
name|currentElementMask
expr_stmt|;
return|return
name|input
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
DECL|method|contains (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|containsAll
argument_list|(
name|set
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|equals (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|PowerSet
condition|)
block|{
name|PowerSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|PowerSet
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|equals
argument_list|(
name|that
operator|.
name|inputSet
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|/*        * The sum of the sums of the hash codes in each subset is just the sum of        * each input element's hash code times the number of sets that element        * appears in. Each element appears in exactly half of the 2^n sets, so:        */
return|return
name|inputSet
operator|.
name|hashCode
argument_list|()
operator|<<
operator|(
name|inputSet
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"powerSet("
operator|+
name|inputSet
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * An implementation for {@link Set#hashCode()}.    */
DECL|method|hashCodeImpl (Set<?> s)
specifier|static
name|int
name|hashCodeImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|)
block|{
name|int
name|hashCode
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|s
control|)
block|{
name|hashCode
operator|+=
name|o
operator|!=
literal|null
condition|?
name|o
operator|.
name|hashCode
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
return|return
name|hashCode
return|;
block|}
comment|/**    * An implementation for {@link Set#equals(Object)}.    */
DECL|method|equalsImpl (Set<?> s, @Nullable Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|,
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|o
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
try|try
block|{
return|return
name|s
operator|.
name|size
argument_list|()
operator|==
name|o
operator|.
name|size
argument_list|()
operator|&&
name|s
operator|.
name|containsAll
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Creates a view of Set<B> for a Set<A>, given a bijection between A and B.    * (Modelled for now as InvertibleFunction<A, B>, can't be Converter<A, B>    * because that's not in Guava, though both designs are less than optimal).    * Note that the bijection is treated as undefined for values not in the    * given Set<A> - it doesn't have to define a true bijection for those.    *    *<p>Note that the returned Set's contains method is unsafe -    * you *must* pass an instance of B to it, since the bijection    * can only invert B's (not any Object) back to A, so we can    * then delegate the call to the original Set<A>.    */
DECL|method|transform ( Set<A> set, InvertibleFunction<A, B> bijection)
specifier|static
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
name|Set
argument_list|<
name|B
argument_list|>
name|transform
parameter_list|(
name|Set
argument_list|<
name|A
argument_list|>
name|set
parameter_list|,
name|InvertibleFunction
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bijection
parameter_list|)
block|{
return|return
operator|new
name|TransformedSet
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
argument_list|(
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|set
argument_list|,
literal|"set"
argument_list|)
argument_list|,
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|bijection
argument_list|,
literal|"bijection"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Stop-gap measure since there is no bijection related type in Guava.    */
DECL|class|InvertibleFunction
specifier|abstract
specifier|static
class|class
name|InvertibleFunction
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
implements|implements
name|Function
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
block|{
DECL|method|invert (B b)
specifier|abstract
name|A
name|invert
parameter_list|(
name|B
name|b
parameter_list|)
function_decl|;
DECL|method|inverse ()
specifier|public
name|InvertibleFunction
argument_list|<
name|B
argument_list|,
name|A
argument_list|>
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|InvertibleFunction
argument_list|<
name|B
argument_list|,
name|A
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|A
name|apply
parameter_list|(
name|B
name|b
parameter_list|)
block|{
return|return
name|InvertibleFunction
operator|.
name|this
operator|.
name|invert
argument_list|(
name|b
argument_list|)
return|;
block|}
annotation|@
name|Override
name|B
name|invert
parameter_list|(
name|A
name|a
parameter_list|)
block|{
return|return
name|InvertibleFunction
operator|.
name|this
operator|.
name|apply
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|// Not required per se, but just for good karma.
annotation|@
name|Override
specifier|public
name|InvertibleFunction
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|inverse
parameter_list|()
block|{
return|return
name|InvertibleFunction
operator|.
name|this
return|;
block|}
block|}
return|;
block|}
block|}
DECL|class|TransformedSet
specifier|private
specifier|static
class|class
name|TransformedSet
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|B
argument_list|>
block|{
DECL|field|delegate
specifier|final
name|Set
argument_list|<
name|A
argument_list|>
name|delegate
decl_stmt|;
DECL|field|bijection
specifier|final
name|InvertibleFunction
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bijection
decl_stmt|;
DECL|method|TransformedSet (Set<A> delegate, InvertibleFunction<A, B> bijection)
name|TransformedSet
parameter_list|(
name|Set
argument_list|<
name|A
argument_list|>
name|delegate
parameter_list|,
name|InvertibleFunction
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|bijection
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|bijection
operator|=
name|bijection
expr_stmt|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|B
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|delegate
operator|.
name|iterator
argument_list|()
argument_list|,
name|bijection
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, passed object *must* be B
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|B
name|b
init|=
operator|(
name|B
operator|)
name|o
decl_stmt|;
name|A
name|a
init|=
name|bijection
operator|.
name|invert
argument_list|(
name|b
argument_list|)
decl_stmt|;
comment|/*        * Mathematically, Converter<A, B> defines a bijection between ALL A's        * on ALL B's. Here we concern ourselves with a subset        * of this relation: we only want the part that is defined by a *subset*        * of all A's (defined by that Set<A> delegate), and the image        * of *that* on B (which is this set). We don't care whether        * the converter is *not* a bijection for A's that are not in Set<A>        * or B's not in this Set<B>.        *        * We only want to return true if and only f the user passes a B instance        * that is contained in precisely in the image of Set<A>.        *        * The first test is whether the inverse image of this B is indeed        * in Set<A>. But we don't know whether that B belongs in this Set<B>        * or not; if not, the converter is free to return        * anything it wants, even an element of Set<A> (and this relationship        * is not part of the Set<A><--> Set<B> bijection), and we must not        * be confused by that. So we have to do a final check to see if the        * image of that A is really equivalent to the passed B, which proves        * that the given B belongs indeed in the image of Set<A>.        */
return|return
name|delegate
operator|.
name|contains
argument_list|(
name|a
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|bijection
operator|.
name|apply
argument_list|(
name|a
argument_list|)
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|add (B b)
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|B
name|b
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|add
argument_list|(
name|bijection
operator|.
name|invert
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// unsafe, passed object *must* be B
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|o
argument_list|)
operator|&&
name|delegate
operator|.
name|remove
argument_list|(
name|bijection
operator|.
name|invert
argument_list|(
operator|(
name|B
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|delegate
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

