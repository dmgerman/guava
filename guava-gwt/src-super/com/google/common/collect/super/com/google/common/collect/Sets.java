begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
operator|.
name|FilteredCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Set} instances. Also see this  * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Sets">  * {@code Sets}</a>.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @author Chris Povirk  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Sets
specifier|public
specifier|final
class|class
name|Sets
block|{
DECL|method|Sets ()
specifier|private
name|Sets
parameter_list|()
block|{}
comment|/**    * {@link AbstractSet} substitute without the potentially-quadratic    * {@code removeAll} implementation.    */
DECL|class|ImprovedAbstractSet
specifier|abstract
specifier|static
class|class
name|ImprovedAbstractSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|removeAllImpl
argument_list|(
name|this
argument_list|,
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|super
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
comment|// GWT compatibility
block|}
block|}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements are provided to the method.    *    * @param anElement one of the elements the set should contain    * @param otherElements the rest of the elements the set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet ( E anElement, E... otherElements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|E
name|anElement
parameter_list|,
name|E
modifier|...
name|otherElements
parameter_list|)
block|{
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|anElement
argument_list|,
name|otherElements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an immutable set instance containing the given enum elements.    * Internally, the returned set will be backed by an {@link EnumSet}.    *    *<p>The iteration order of the returned set follows the enum's iteration    * order, not the order in which the elements appear in the given collection.    *    * @param elements the elements, all of the same {@code enum} type, that the    *     set should contain    * @return an immutable set containing those elements, minus duplicates    */
comment|// http://code.google.com/p/google-web-toolkit/issues/detail?id=3028
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|immutableEnumSet ( Iterable<E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|ImmutableEnumSet
condition|)
block|{
return|return
operator|(
name|ImmutableEnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|elements
return|;
block|}
elseif|else
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|elements
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|EnumSet
operator|.
name|copyOf
argument_list|(
name|collection
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|Iterator
argument_list|<
name|E
argument_list|>
name|itr
init|=
name|elements
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|enumSet
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|itr
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|enumSet
argument_list|,
name|itr
argument_list|)
expr_stmt|;
return|return
name|ImmutableEnumSet
operator|.
name|asImmutable
argument_list|(
name|enumSet
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * Returns a new {@code EnumSet} instance containing the given elements.    * Unlike {@link EnumSet#copyOf(Collection)}, this method does not produce an    * exception on an empty collection, and it may be called on any iterable, not    * just a {@code Collection}.    */
DECL|method|newEnumSet (Iterable<E> iterable, Class<E> elementType)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|newEnumSet
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|elementType
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|elementType
argument_list|)
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|iterable
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// HashSet
comment|/**    * Creates a<i>mutable</i>, empty {@code HashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSet#of()} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link    * EnumSet#noneOf} instead.    *    * @return a new, empty {@code HashSet}    */
DECL|method|newHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use an overload of {@link ImmutableSet#of()} (for varargs) or    * {@link ImmutableSet#copyOf(Object[])} (for an array) instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link    * EnumSet#of(Enum, Enum[])} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (E... elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSetWithExpectedSize
argument_list|(
name|elements
operator|.
name|length
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a {@code HashSet} instance, with a high enough "initial capacity"    * that it<i>should</i> hold {@code expectedSize} elements without growth.    * This behavior cannot be broadly guaranteed, but it is observed to be true    * for OpenJDK 1.6. It also can't be guaranteed that the method isn't    * inadvertently<i>oversizing</i> the returned set.    *    * @param expectedSize the number of elements you expect to add to the    *        returned set    * @return a new, empty {@code HashSet} with enough capacity to hold {@code    *         expectedSize} elements without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|newHashSetWithExpectedSize (int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSetWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, use    * {@link #newEnumSet(Iterable, Class)} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
return|return
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
operator|new
name|HashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
else|:
name|newHashSet
argument_list|(
name|elements
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashSet} instance containing the given    * elements in unspecified order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an    * {@link EnumSet} instead.    *    * @param elements the elements that the set should contain    * @return a new {@code HashSet} containing those elements (minus duplicates)    */
DECL|method|newHashSet (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|HashSet
argument_list|<
name|E
argument_list|>
name|newHashSet
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|HashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newHashSet
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a thread-safe set backed by a hash map. The set is backed by a    * {@link ConcurrentHashMap} instance, and thus carries the same concurrency    * guarantees.    *    *<p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be    * used as an element. The set is serializable.    *    * @return a new, empty thread-safe {@code Set}    * @since 15.0    */
DECL|method|newConcurrentHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newConcurrentHashSet
parameter_list|()
block|{
return|return
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a thread-safe set backed by a hash map and containing the given    * elements. The set is backed by a {@link ConcurrentHashMap} instance, and    * thus carries the same concurrency guarantees.    *    *<p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be    * used as an element. The set is serializable.    *    * @param elements the elements that the set should contain    * @return a new thread-safe set containing those elements (minus duplicates)    * @throws NullPointerException if {@code elements} or any of its contents is    *      null    * @since 15.0    */
DECL|method|newConcurrentHashSet ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newConcurrentHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|Set
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newConcurrentHashSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// LinkedHashSet
comment|/**    * Creates a<i>mutable</i>, empty {@code LinkedHashSet} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSet#of()} instead.    *    * @return a new, empty {@code LinkedHashSet}    */
DECL|method|newLinkedHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code LinkedHashSet} instance, with a high enough "initial    * capacity" that it<i>should</i> hold {@code expectedSize} elements without    * growth. This behavior cannot be broadly guaranteed, but it is observed to    * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't    * inadvertently<i>oversizing</i> the returned set.    *    * @param expectedSize the number of elements you expect to add to the    *        returned set    * @return a new, empty {@code LinkedHashSet} with enough capacity to hold    *         {@code expectedSize} elements without resizing    * @throws IllegalArgumentException if {@code expectedSize} is negative    * @since 11.0    */
DECL|method|newLinkedHashSetWithExpectedSize ( int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSetWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code LinkedHashSet} instance containing the    * given elements in order.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.    *    * @param elements the elements that the set should contain, in order    * @return a new {@code LinkedHashSet} containing those elements (minus    *     duplicates)    */
DECL|method|newLinkedHashSet ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|newLinkedHashSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
if|if
condition|(
name|elements
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|// TreeSet
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance sorted by the    * natural sort ordering of its elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedSet#of()} instead.    *    * @return a new, empty {@code TreeSet}    */
DECL|method|newTreeSet ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code TreeSet} instance containing the given    * elements sorted by their natural ordering.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedSet#copyOf(Iterable)} instead.    *    *<p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit    * comparator, this method has different behavior than    * {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with    * that comparator.    *    * @param elements the elements that the set should contain    * @return a new {@code TreeSet} containing those elements (minus duplicates)    */
DECL|method|newTreeSet ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|E
argument_list|>
name|set
init|=
name|newTreeSet
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeSet} instance with the given    * comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedSet.orderedBy(comparator).build()} instead.    *    * @param comparator the comparator to use to sort the set    * @return a new, empty {@code TreeSet}    * @throws NullPointerException if {@code comparator} is null    */
DECL|method|newTreeSet (Comparator<? super E> comparator)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|TreeSet
argument_list|<
name|E
argument_list|>
name|newTreeSet
parameter_list|(
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|TreeSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an empty {@code Set} that uses identity to determine equality. It    * compares object references, instead of calling {@code equals}, to    * determine whether a provided object matches an element in the set. For    * example, {@code contains} returns {@code false} when passed an object that    * equals a set member, but isn't the same instance. This behavior is similar    * to the way {@code IdentityHashMap} handles key lookups.    *    * @since 8.0    */
DECL|method|newIdentityHashSet ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newIdentityHashSet
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newSetFromMap
argument_list|(
name|Maps
operator|.
expr|<
name|E
argument_list|,
name|Boolean
operator|>
name|newIdentityHashMap
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. If the collection is an {@link EnumSet}, this    * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,    * the specified collection must contain at least one element, in order to    * determine the element type. If the collection could be empty, use    * {@link #complementOf(Collection, Class)} instead of this method.    *    * @param collection the collection whose complement should be stored in the    *     enum set    * @return a new, modifiable {@code EnumSet} containing all values of the enum    *     that aren't present in the given collection    * @throws IllegalArgumentException if {@code collection} is not an    *     {@code EnumSet} instance and contains no elements    */
DECL|method|complementOf ( Collection<E> collection)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|EnumSet
condition|)
block|{
return|return
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
name|checkArgument
argument_list|(
operator|!
name|collection
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"collection is empty; use the other version of this method"
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|E
argument_list|>
name|type
init|=
name|collection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
return|return
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumSet} consisting of all enum values that are not in    * the specified collection. This is equivalent to    * {@link EnumSet#complementOf}, but can act on any input collection, as long    * as the elements are of enum type.    *    * @param collection the collection whose complement should be stored in the    *     {@code EnumSet}    * @param type the type of the elements in the set    * @return a new, modifiable {@code EnumSet} initially containing all the    *     values of the enum not present in the given collection    */
DECL|method|complementOf ( Collection<E> collection, Class<E> type)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|complementOf
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
operator|(
name|collection
operator|instanceof
name|EnumSet
operator|)
condition|?
name|EnumSet
operator|.
name|complementOf
argument_list|(
operator|(
name|EnumSet
argument_list|<
name|E
argument_list|>
operator|)
name|collection
argument_list|)
else|:
name|makeComplementByHand
argument_list|(
name|collection
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|makeComplementByHand ( Collection<E> collection, Class<E> type)
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|EnumSet
argument_list|<
name|E
argument_list|>
name|makeComplementByHand
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|EnumSet
argument_list|<
name|E
argument_list|>
name|result
init|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|result
operator|.
name|removeAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns a set backed by the specified map. The resulting set displays    * the same ordering, concurrency, and performance characteristics as the    * backing map. In essence, this factory method provides a {@link Set}    * implementation corresponding to any {@link Map} implementation. There is no    * need to use this method on a {@link Map} implementation that already has a    * corresponding {@link Set} implementation (such as {@link java.util.HashMap}    * or {@link java.util.TreeMap}).    *    *<p>Each method invocation on the set returned by this method results in    * exactly one method invocation on the backing map or its {@code keySet}    * view, with one exception. The {@code addAll} method is implemented as a    * sequence of {@code put} invocations on the backing map.    *    *<p>The specified map must be empty at the time this method is invoked,    * and should not be accessed directly after this method returns. These    * conditions are ensured if the map is created empty, passed directly    * to this method, and no reference to the map is retained, as illustrated    * in the following code fragment:<pre>  {@code    *    *   Set<Object> identityHashSet = Sets.newSetFromMap(    *       new IdentityHashMap<Object, Boolean>());}</pre>    *    * This method has the same behavior as the JDK 6 method    * {@code Collections.newSetFromMap()}. The returned set is serializable if    * the backing map is.    *    * @param map the backing map    * @return the set backed by the map    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSetFromMap (Map<E, Boolean> map)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|newSetFromMap
parameter_list|(
name|Map
argument_list|<
name|E
argument_list|,
name|Boolean
argument_list|>
name|map
parameter_list|)
block|{
return|return
name|Platform
operator|.
name|newSetFromMap
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * An unmodifiable view of a set which may be backed by other sets; this view    * will change as the backing sets do. Contains methods to copy the data into    * a new set which will then remain stable. There is usually no reason to    * retain a reference of type {@code SetView}; typically, you either use it    * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or    * {@link #copyInto} and forget the {@code SetView} itself.    *    * @since 2.0 (imported from Google Collections Library)    */
DECL|class|SetView
specifier|public
specifier|abstract
specifier|static
class|class
name|SetView
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|SetView ()
specifier|private
name|SetView
parameter_list|()
block|{}
comment|// no subclasses but our own
comment|/**      * Returns an immutable copy of the current contents of this set view.      * Does not support null elements.      *      *<p><b>Warning:</b> this may have unexpected results if a backing set of      * this view uses a nonstandard notion of equivalence, for example if it is      * a {@link TreeSet} using a comparator that is inconsistent with {@link      * Object#equals(Object)}.      */
DECL|method|immutableCopy ()
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Copies the current contents of this set view into an existing set. This      * method has equivalent behavior to {@code set.addAll(this)}, assuming that      * all the sets involved are based on the same notion of equivalence.      *      * @return a reference to {@code set}, for convenience      */
comment|// Note: S should logically extend Set<? super E> but can't due to either
comment|// some javac bug or some weirdness in the spec, not sure which.
DECL|method|copyInto (S set)
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the union of two sets. The returned    * set contains all elements that are contained in either backing set.    * Iterating over the returned set iterates first over all the elements of    * {@code set1}, then over each element of {@code set2}, in order, that is not    * contained in {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based on    * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and    * the {@link Map#keySet} of an {@code IdentityHashMap} all are).    *    *<p><b>Note:</b> The returned view performs better when {@code set1} is the    * smaller of the two sets. If you have reason to believe one of your sets    * will generally be smaller than the other, pass it first.    *    *<p>Further, note that the current implementation is not suitable for nested    * {@code union} views, i.e. the following should be avoided when in a loop:    * {@code union = Sets.union(union, anotherSet);}, since iterating over the resulting    * set has a cubic complexity to the depth of the nesting.    */
DECL|method|union ( final Set<? extends E> set1, final Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|union
parameter_list|(
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2minus1
init|=
name|difference
argument_list|(
name|set2
argument_list|,
name|set1
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|set1
operator|.
name|size
argument_list|()
operator|+
name|set2minus1
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set1
operator|.
name|isEmpty
argument_list|()
operator|&&
name|set2
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|Iterators
operator|.
name|concat
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|set2minus1
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|||
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|S
extends|extends
name|Set
argument_list|<
name|E
argument_list|>
parameter_list|>
name|S
name|copyInto
parameter_list|(
name|S
name|set
parameter_list|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|immutableCopy
parameter_list|()
block|{
return|return
operator|new
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|()
operator|.
name|addAll
argument_list|(
name|set1
argument_list|)
operator|.
name|addAll
argument_list|(
name|set2
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the intersection of two sets. The    * returned set contains all elements that are contained by both backing sets.    * The iteration order of the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    *<p><b>Note:</b> The returned view performs slightly better when {@code    * set1} is the smaller of the two sets. If you have reason to believe one of    * your sets will generally be smaller than the other, pass it first.    * Unfortunately, since this method sets the generic type of the returned set    * based on the type of the first set passed, this could in rare cases force    * you to make a cast, for example:<pre>   {@code    *    *   Set<Object> aFewBadObjects = ...    *   Set<String> manyBadStrings = ...    *    *   // impossible for a non-String to be in the intersection    *   SuppressWarnings("unchecked")    *   Set<String> badStrings = (Set) Sets.intersection(    *       aFewBadObjects, manyBadStrings);}</pre>    *    * This is unfortunate, but should come up only very rarely.    */
DECL|method|intersection ( final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|intersection
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|inSet2
init|=
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|inSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
name|set2
operator|.
name|contains
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
return|return
name|set1
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
operator|&&
name|set2
operator|.
name|containsAll
argument_list|(
name|collection
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the difference of two sets. The    * returned set contains all elements that are contained by {@code set1} and    * not contained by {@code set2}. {@code set2} may also contain elements not    * present in {@code set1}; these are simply ignored. The iteration order of    * the returned set matches that of {@code set1}.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    */
DECL|method|difference ( final Set<E> set1, final Set<?> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|difference
parameter_list|(
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|set1
parameter_list|,
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
specifier|final
name|Predicate
argument_list|<
name|Object
argument_list|>
name|notInSet2
init|=
name|Predicates
operator|.
name|not
argument_list|(
name|Predicates
operator|.
name|in
argument_list|(
name|set2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SetView
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|set1
operator|.
name|iterator
argument_list|()
argument_list|,
name|notInSet2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|size
argument_list|(
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|set2
operator|.
name|containsAll
argument_list|(
name|set1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|element
parameter_list|)
block|{
return|return
name|set1
operator|.
name|contains
argument_list|(
name|element
argument_list|)
operator|&&
operator|!
name|set2
operator|.
name|contains
argument_list|(
name|element
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable<b>view</b> of the symmetric difference of two    * sets. The returned set contains all elements that are contained in either    * {@code set1} or {@code set2} but not in both. The iteration order of the    * returned set is undefined.    *    *<p>Results are undefined if {@code set1} and {@code set2} are sets based    * on different equivalence relations (as {@code HashSet}, {@code TreeSet},    * and the keySet of an {@code IdentityHashMap} all are).    *    * @since 3.0    */
DECL|method|symmetricDifference ( Set<? extends E> set1, Set<? extends E> set2)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SetView
argument_list|<
name|E
argument_list|>
name|symmetricDifference
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|set1
argument_list|,
literal|"set1"
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|set2
argument_list|,
literal|"set2"
argument_list|)
expr_stmt|;
comment|// TODO(kevinb): Replace this with a more efficient implementation
return|return
name|difference
argument_list|(
name|union
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
argument_list|,
name|intersection
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate. The    * returned set is a live view of {@code unfiltered}; changes to one affect    * the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as {@code    * removeAll()} and {@code clear()} are called on the filtered set, only    * elements that satisfy the filter will be removed from the underlying set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate    * across every element in the underlying set and determine which elements    * satisfy the filter. When a live view is<i>not</i> needed, it may be faster    * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such    * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent    * with equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    */
comment|// TODO(kevinb): how to omit that last sentence when building GWT javadoc?
DECL|method|filter ( Set<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|filter
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|Set
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FilteredSet
specifier|private
specifier|static
class|class
name|FilteredSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredCollection
argument_list|<
name|E
argument_list|>
implements|implements
name|Set
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredSet (Set<E> unfiltered, Predicate<? super E> predicate)
name|FilteredSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that    * satisfy a predicate. The returned set is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting set's iterator does not support {@code remove()}, but all    * other set methods are supported. When given an element that doesn't satisfy    * the predicate, the set's {@code add()} and {@code addAll()} methods throw    * an {@link IllegalArgumentException}. When methods such as    * {@code removeAll()} and {@code clear()} are called on the filtered set,    * only elements that satisfy the filter will be removed from the underlying    * set.    *    *<p>The returned set isn't threadsafe or serializable, even if    * {@code unfiltered} is.    *    *<p>Many of the filtered set's methods, such as {@code size()}, iterate across    * every element in the underlying set and determine which elements satisfy    * the filter. When a live view is<i>not</i> needed, it may be faster to copy    * {@code Iterables.filter(unfiltered, predicate)} and use the copy.    *    *<p><b>Warning:</b> {@code predicate} must be<i>consistent with equals</i>,    * as documented at {@link Predicate#apply}. Do not provide a predicate such as    * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with    * equals. (See {@link Iterables#filter(Iterable, Class)} for related    * functionality.)    *    * @since 11.0    */
DECL|method|filter ( SortedSet<E> unfiltered, Predicate<? super E> predicate)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Platform
operator|.
name|setsFilterSortedSet
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|filterSortedIgnoreNavigable ( SortedSet<E> unfiltered, Predicate<? super E> predicate)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|SortedSet
argument_list|<
name|E
argument_list|>
name|filterSortedIgnoreNavigable
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|unfiltered
operator|instanceof
name|FilteredSet
condition|)
block|{
comment|// Support clear(), removeAll(), and retainAll() when filtering a filtered
comment|// collection.
name|FilteredSet
argument_list|<
name|E
argument_list|>
name|filtered
init|=
operator|(
name|FilteredSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
name|Predicate
argument_list|<
name|E
argument_list|>
name|combinedPredicate
init|=
name|Predicates
operator|.
expr|<
name|E
operator|>
name|and
argument_list|(
name|filtered
operator|.
name|predicate
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|filtered
operator|.
name|unfiltered
argument_list|,
name|combinedPredicate
argument_list|)
return|;
block|}
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FilteredSortedSet
specifier|private
specifier|static
class|class
name|FilteredSortedSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|FilteredSet
argument_list|<
name|E
argument_list|>
implements|implements
name|SortedSet
argument_list|<
name|E
argument_list|>
block|{
DECL|method|FilteredSortedSet (SortedSet<E> unfiltered, Predicate<? super E> predicate)
name|FilteredSortedSet
parameter_list|(
name|SortedSet
argument_list|<
name|E
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|comparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|subSet
argument_list|(
name|fromElement
argument_list|,
name|toElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|headSet
argument_list|(
name|toElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
return|return
operator|new
name|FilteredSortedSet
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
operator|)
operator|.
name|tailSet
argument_list|(
name|fromElement
argument_list|)
argument_list|,
name|predicate
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
return|return
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|E
argument_list|>
name|sortedUnfiltered
init|=
operator|(
name|SortedSet
argument_list|<
name|E
argument_list|>
operator|)
name|unfiltered
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|E
name|element
init|=
name|sortedUnfiltered
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
name|element
return|;
block|}
name|sortedUnfiltered
operator|=
name|sortedUnfiltered
operator|.
name|headSet
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(ImmutableList.of(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C")))}</pre>    *    * returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    * The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : sets.get(0)) {    *     for (B b1 : sets.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    * Note that if any input set is empty, the Cartesian product will also be    * empty. If no sets at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since 2.0    */
DECL|method|cartesianProduct ( List<? extends Set<? extends B>> sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
return|return
name|CartesianSet
operator|.
name|create
argument_list|(
name|sets
argument_list|)
return|;
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given sets in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the sets. For example:<pre>   {@code    *    *   Sets.cartesianProduct(    *       ImmutableSet.of(1, 2),    *       ImmutableSet.of("A", "B", "C"))}</pre>    *    * returns a set containing six lists:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    * The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : sets.get(0)) {    *     for (B b1 : sets.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    * Note that if any input set is empty, the Cartesian product will also be    * empty. If no sets at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of sets of size    * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian set is constructed, the    * input sets are merely copied. Only as the resulting set is iterated are the    * individual lists created, and these are not retained after iteration.    *    * @param sets the sets to choose elements from, in the order that    *     the elements chosen from those sets should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable set containing immutable    *     lists    * @throws NullPointerException if {@code sets}, any one of the {@code sets},    *     or any element of a provided set is null    * @since 2.0    */
DECL|method|cartesianProduct ( Set<? extends B>.... sets)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
name|cartesianProduct
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|B
argument_list|>
modifier|...
name|sets
parameter_list|)
block|{
return|return
name|cartesianProduct
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|sets
argument_list|)
argument_list|)
return|;
block|}
DECL|class|CartesianSet
specifier|private
specifier|static
specifier|final
class|class
name|CartesianSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
implements|implements
name|Set
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|axes
specifier|private
specifier|transient
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|transient
specifier|final
name|CartesianList
argument_list|<
name|E
argument_list|>
name|delegate
decl_stmt|;
DECL|method|create (List<? extends Set<? extends E>> sets)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|create
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
argument_list|>
name|sets
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axesBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
name|sets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|set
range|:
name|sets
control|)
block|{
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|copy
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
name|axesBuilder
operator|.
name|add
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
init|=
name|axesBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|listAxes
init|=
operator|new
name|ImmutableList
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|axes
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|axes
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|asList
argument_list|()
return|;
block|}
annotation|@
name|Override
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|CartesianSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|axes
argument_list|,
operator|new
name|CartesianList
argument_list|<
name|E
argument_list|>
argument_list|(
name|listAxes
argument_list|)
argument_list|)
return|;
block|}
DECL|method|CartesianSet ( ImmutableList<ImmutableSet<E>> axes, CartesianList<E> delegate)
specifier|private
name|CartesianSet
parameter_list|(
name|ImmutableList
argument_list|<
name|ImmutableSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|axes
parameter_list|,
name|CartesianList
argument_list|<
name|E
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|axes
operator|=
name|axes
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Collection
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
if|if
condition|(
name|object
operator|instanceof
name|CartesianSet
condition|)
block|{
name|CartesianSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|CartesianSet
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|axes
operator|.
name|equals
argument_list|(
name|that
operator|.
name|axes
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Warning: this is broken if size() == 0, so it is critical that we
comment|// substitute an empty ImmutableSet to the user in place of this
comment|// It's a weird formula, but tests prove it works.
name|int
name|adjust
init|=
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|axes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|adjust
operator|*=
literal|31
expr_stmt|;
name|adjust
operator|=
operator|~
operator|~
name|adjust
expr_stmt|;
comment|// in GWT, we have to deal with integer overflow carefully
block|}
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|E
argument_list|>
name|axis
range|:
name|axes
control|)
block|{
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|size
argument_list|()
operator|/
name|axis
operator|.
name|size
argument_list|()
operator|*
name|axis
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|hash
operator|=
operator|~
operator|~
name|hash
expr_stmt|;
block|}
name|hash
operator|+=
name|adjust
expr_stmt|;
return|return
operator|~
operator|~
name|hash
return|;
block|}
block|}
comment|/**    * Returns the set of all possible subsets of {@code set}. For example,    * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},    * {1}, {2}, {1, 2}}}.    *    *<p>Elements appear in these subsets in the same iteration order as they    * appeared in the input set. The order in which these subsets appear in the    * outer set is undefined. Note that the power set of the empty set is not the    * empty set, but a one-element set containing the empty set.    *    *<p>The returned set and its constituent sets use {@code equals} to decide    * whether two elements are identical, even if the input set uses a different    * concept of equivalence.    *    *<p><i>Performance notes:</i> while the power set of a set with size {@code    * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the    * power set is constructed, the input set is merely copied. Only as the    * power set is iterated are the individual subsets created, and these subsets    * themselves occupy only a few bytes of memory regardless of their size.    *    * @param set the set of elements to construct a power set from    * @return the power set, as an immutable set of immutable sets    * @throws IllegalArgumentException if {@code set} has more than 30 unique    *     elements (causing the power set size to exceed the {@code int} range)    * @throws NullPointerException if {@code set} is or contains {@code null}    * @see<a href="http://en.wikipedia.org/wiki/Power_set">Power set article at    *      Wikipedia</a>    * @since 4.0    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|false
argument_list|)
DECL|method|powerSet (Set<E> set)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|powerSet
parameter_list|(
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|input
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|checkArgument
argument_list|(
name|input
operator|.
name|size
argument_list|()
operator|<=
literal|30
argument_list|,
literal|"Too many elements to create power set: %s> 30"
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|PowerSet
argument_list|<
name|E
argument_list|>
argument_list|(
name|input
argument_list|)
return|;
block|}
DECL|class|PowerSet
specifier|private
specifier|static
specifier|final
class|class
name|PowerSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
block|{
DECL|field|inputSet
specifier|final
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|inputSet
decl_stmt|;
DECL|field|inputList
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|inputList
decl_stmt|;
DECL|field|powerSetSize
specifier|final
name|int
name|powerSetSize
decl_stmt|;
DECL|method|PowerSet (ImmutableSet<E> input)
name|PowerSet
parameter_list|(
name|ImmutableSet
argument_list|<
name|E
argument_list|>
name|input
parameter_list|)
block|{
name|this
operator|.
name|inputSet
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|inputList
operator|=
name|input
operator|.
name|asList
argument_list|()
expr_stmt|;
name|this
operator|.
name|powerSetSize
operator|=
literal|1
operator|<<
name|input
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|powerSetSize
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIndexedListIterator
argument_list|<
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
name|powerSetSize
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|E
argument_list|>
name|get
parameter_list|(
specifier|final
name|int
name|setBits
parameter_list|)
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|bitCount
argument_list|(
name|setBits
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|BitFilteredSetIterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|inputList
argument_list|,
name|setBits
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
DECL|class|BitFilteredSetIterator
specifier|private
specifier|static
specifier|final
class|class
name|BitFilteredSetIterator
parameter_list|<
name|E
parameter_list|>
extends|extends
name|UnmodifiableIterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|input
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|input
decl_stmt|;
DECL|field|remainingSetBits
name|int
name|remainingSetBits
decl_stmt|;
DECL|method|BitFilteredSetIterator (ImmutableList<E> input, int allSetBits)
name|BitFilteredSetIterator
parameter_list|(
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|input
parameter_list|,
name|int
name|allSetBits
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|remainingSetBits
operator|=
name|allSetBits
expr_stmt|;
block|}
DECL|method|hasNext ()
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|remainingSetBits
operator|!=
literal|0
return|;
block|}
DECL|method|next ()
annotation|@
name|Override
specifier|public
name|E
name|next
parameter_list|()
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|remainingSetBits
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|32
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|int
name|currentElementMask
init|=
literal|1
operator|<<
name|index
decl_stmt|;
name|remainingSetBits
operator|&=
operator|~
name|currentElementMask
expr_stmt|;
return|return
name|input
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
DECL|method|contains (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|containsAll
argument_list|(
name|set
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|equals (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|PowerSet
condition|)
block|{
name|PowerSet
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|PowerSet
argument_list|<
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|inputSet
operator|.
name|equals
argument_list|(
name|that
operator|.
name|inputSet
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|/*        * The sum of the sums of the hash codes in each subset is just the sum of        * each input element's hash code times the number of sets that element        * appears in. Each element appears in exactly half of the 2^n sets, so:        */
return|return
name|inputSet
operator|.
name|hashCode
argument_list|()
operator|<<
operator|(
name|inputSet
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"powerSet("
operator|+
name|inputSet
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * An implementation for {@link Set#hashCode()}.    */
DECL|method|hashCodeImpl (Set<?> s)
specifier|static
name|int
name|hashCodeImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|)
block|{
name|int
name|hashCode
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|s
control|)
block|{
name|hashCode
operator|+=
name|o
operator|!=
literal|null
condition|?
name|o
operator|.
name|hashCode
argument_list|()
else|:
literal|0
expr_stmt|;
name|hashCode
operator|=
operator|~
operator|~
name|hashCode
expr_stmt|;
comment|// Needed to deal with unusual integer overflow in GWT.
block|}
return|return
name|hashCode
return|;
block|}
comment|/**    * An implementation for {@link Set#equals(Object)}.    */
DECL|method|equalsImpl (Set<?> s, @Nullable Object object)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|s
parameter_list|,
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Set
condition|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|o
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
try|try
block|{
return|return
name|s
operator|.
name|size
argument_list|()
operator|==
name|o
operator|.
name|size
argument_list|()
operator|&&
name|s
operator|.
name|containsAll
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove each element in an iterable from a set.    */
DECL|method|removeAllImpl (Set<?> set, Iterator<?> iterator)
specifier|static
name|boolean
name|removeAllImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|set
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|changed
operator||=
name|set
operator|.
name|remove
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
DECL|method|removeAllImpl (Set<?> set, Collection<?> collection)
specifier|static
name|boolean
name|removeAllImpl
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|set
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// for GWT
if|if
condition|(
name|collection
operator|instanceof
name|Multiset
condition|)
block|{
name|collection
operator|=
operator|(
operator|(
name|Multiset
argument_list|<
name|?
argument_list|>
operator|)
name|collection
operator|)
operator|.
name|elementSet
argument_list|()
expr_stmt|;
block|}
comment|/*      * AbstractSet.removeAll(List) has quadratic behavior if the list size      * is just less than the set's size.  We augment the test by      * assuming that sets have fast contains() performance, and other      * collections don't.  See      * http://code.google.com/p/guava-libraries/issues/detail?id=1013      */
if|if
condition|(
name|collection
operator|instanceof
name|Set
operator|&&
name|collection
operator|.
name|size
argument_list|()
operator|>
name|set
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|Iterators
operator|.
name|removeAll
argument_list|(
name|set
operator|.
name|iterator
argument_list|()
argument_list|,
name|collection
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|removeAllImpl
argument_list|(
name|set
argument_list|,
name|collection
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

