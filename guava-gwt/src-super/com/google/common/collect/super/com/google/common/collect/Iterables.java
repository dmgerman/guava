begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * This class contains static utility methods that operate on or return objects  * of type {@code Iterable}. Except as noted, each method has a corresponding  * {@link Iterator}-based method in the {@link Iterators} class.  *  *<p><i>Performance notes:</i> Unless otherwise noted, all of the iterables  * produced in this class are<i>lazy</i>, which means that their iterators  * only advance the backing iteration when absolutely necessary.  *  * @author Kevin Bourrillion  * @author Jared Levy  * @since Guava release 02 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Iterables
specifier|public
specifier|final
class|class
name|Iterables
block|{
DECL|method|Iterables ()
specifier|private
name|Iterables
parameter_list|()
block|{}
comment|/** Returns an unmodifiable view of {@code iterable}. */
DECL|method|unmodifiableIterable (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|unmodifiableIterable
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|unmodifiableIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// no equals and hashCode; it would break the contract!
block|}
return|;
block|}
comment|/**    * Returns the number of elements in {@code iterable}.    */
DECL|method|size (Iterable<?> iterable)
specifier|public
specifier|static
name|int
name|size
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|size
argument_list|()
else|:
name|Iterators
operator|.
name|size
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if {@code iterable} contains {@code element}; that is,    * any object for which {@code equals(element)} is true.    */
DECL|method|contains (Iterable<?> iterable, @Nullable Object element)
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
decl_stmt|;
try|try
block|{
return|return
name|collection
operator|.
name|contains
argument_list|(
name|element
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that belongs to the provided    * collection.    *    *<p>This method calls {@link Collection#removeAll} if {@code iterable} is a    * collection, and {@link Iterators#removeAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRemove the elements to remove    * @return {@code true} if any element was removed from {@code iterable}    */
DECL|method|removeAll ( Iterable<?> removeFrom, Collection<?> elementsToRemove)
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRemove
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|removeAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRemove
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|removeAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRemove
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that does not belong to the    * provided collection.    *    *<p>This method calls {@link Collection#retainAll} if {@code iterable} is a    * collection, and {@link Iterators#retainAll} otherwise.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param elementsToRetain the elements to retain    * @return {@code true} if any element was removed from {@code iterable}    */
DECL|method|retainAll ( Iterable<?> removeFrom, Collection<?> elementsToRetain)
specifier|public
specifier|static
name|boolean
name|retainAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|removeFrom
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|elementsToRetain
parameter_list|)
block|{
return|return
operator|(
name|removeFrom
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|removeFrom
operator|)
operator|.
name|retainAll
argument_list|(
name|checkNotNull
argument_list|(
name|elementsToRetain
argument_list|)
argument_list|)
else|:
name|Iterators
operator|.
name|retainAll
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|elementsToRetain
argument_list|)
return|;
block|}
comment|/**    * Removes, from an iterable, every element that satisfies the provided    * predicate.    *    * @param removeFrom the iterable to (potentially) remove elements from    * @param predicate a predicate that determines whether an element should    *     be removed    * @return {@code true} if any elements were removed from the iterable    *    * @throws UnsupportedOperationException if the iterable does not support    *     {@code remove()}.    * @since Guava release 02    */
DECL|method|removeIf ( Iterable<T> removeFrom, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|removeIf
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|removeFrom
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|removeFrom
operator|instanceof
name|RandomAccess
operator|&&
name|removeFrom
operator|instanceof
name|List
condition|)
block|{
return|return
name|removeIfFromRandomAccessList
argument_list|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|removeFrom
argument_list|,
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|removeIf
argument_list|(
name|removeFrom
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|method|removeIfFromRandomAccessList ( List<T> list, Predicate<? super T> predicate)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|removeIfFromRandomAccessList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// Note: Not all random access lists support set() so we need to deal with
comment|// those that don't and attempt the slower remove() based solution.
name|int
name|from
init|=
literal|0
decl_stmt|;
name|int
name|to
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|from
operator|++
control|)
block|{
name|T
name|element
init|=
name|list
operator|.
name|get
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
try|try
block|{
name|list
operator|.
name|set
argument_list|(
name|to
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|slowRemoveIfForRemainingElements
argument_list|(
name|list
argument_list|,
name|predicate
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|to
operator|++
expr_stmt|;
block|}
block|}
comment|// Clear the tail of any remaining items
name|list
operator|.
name|subList
argument_list|(
name|to
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|from
operator|!=
name|to
return|;
block|}
DECL|method|slowRemoveIfForRemainingElements (List<T> list, Predicate<? super T> predicate, int to, int from)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|slowRemoveIfForRemainingElements
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|// Here we know that:
comment|// * (to< from) and that both are valid indices.
comment|// * Everything with (index< to) should be kept.
comment|// * Everything with (to<= index< from) should be removed.
comment|// * The element with (index == from) should be kept.
comment|// * Everything with (index> from) has not been checked yet.
comment|// Check from the end of the list backwards (minimize expected cost of
comment|// moving elements when remove() is called). Stop before 'from' because
comment|// we already know that should be kept.
for|for
control|(
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|n
operator|>
name|from
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|// And now remove everything in the range [to, from) (going backwards).
for|for
control|(
name|int
name|n
init|=
name|from
operator|-
literal|1
init|;
name|n
operator|>=
name|to
condition|;
name|n
operator|--
control|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determines whether two iterables contain equal elements in the same order.    * More specifically, this method returns {@code true} if {@code iterable1}    * and {@code iterable2} contain the same number of elements and every element    * of {@code iterable1} is equal to the corresponding element of    * {@code iterable2}.    */
DECL|method|elementsEqual ( Iterable<?> iterable1, Iterable<?> iterable2)
specifier|public
specifier|static
name|boolean
name|elementsEqual
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable1
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable2
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|elementsEqual
argument_list|(
name|iterable1
operator|.
name|iterator
argument_list|()
argument_list|,
name|iterable2
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a string representation of {@code iterable}, with the format    * {@code [e1, e2, ..., en]}.    */
DECL|method|toString (Iterable<?> iterable)
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|toString
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the single element contained in {@code iterable}.    *    * @throws NoSuchElementException if the iterable is empty    * @throws IllegalArgumentException if the iterable contains multiple    *     elements    */
DECL|method|getOnlyElement (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the single element contained in {@code iterable}, or {@code    * defaultValue} if the iterable is empty.    *    * @throws IllegalArgumentException if the iterator contains multiple    *     elements    */
DECL|method|getOnlyElement ( Iterable<T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getOnlyElement
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getOnlyElement
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Copies an iterable's elements into an array.    *    * @param iterable the iterable to copy    * @return a newly-allocated array into which all the elements of the iterable    *     have been copied    */
DECL|method|toArray (Iterable<?> iterable)
specifier|static
name|Object
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
name|toCollection
argument_list|(
name|iterable
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
comment|/**    * Converts an iterable into a collection. If the iterable is already a    * collection, it is returned. Otherwise, an {@link java.util.ArrayList} is    * created with the contents of the iterable in the same iteration order.    */
DECL|method|toCollection (Iterable<E> iterable)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|toCollection
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|iterable
operator|instanceof
name|Collection
operator|)
condition|?
operator|(
name|Collection
argument_list|<
name|E
argument_list|>
operator|)
name|iterable
else|:
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Adds all elements in {@code iterable} to {@code collection}.    *    * @return {@code true} if {@code collection} was modified as a result of this    *     operation.    */
DECL|method|addAll ( Collection<T> addTo, Iterable<? extends T> elementsToAdd)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|addTo
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|elementsToAdd
parameter_list|)
block|{
if|if
condition|(
name|elementsToAdd
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
init|=
name|Collections2
operator|.
name|cast
argument_list|(
name|elementsToAdd
argument_list|)
decl_stmt|;
return|return
name|addTo
operator|.
name|addAll
argument_list|(
name|c
argument_list|)
return|;
block|}
return|return
name|Iterators
operator|.
name|addAll
argument_list|(
name|addTo
argument_list|,
name|elementsToAdd
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the number of elements in the specified iterable that equal the    * specified object. This implementation avoids a full iteration when the    * iterable is a {@link Multiset} or {@link Set}.    *    * @see Collections#frequency    */
DECL|method|frequency (Iterable<?> iterable, @Nullable Object element)
specifier|public
specifier|static
name|int
name|frequency
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Multiset
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Multiset
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|iterable
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|contains
argument_list|(
name|element
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
name|Iterators
operator|.
name|frequency
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|element
argument_list|)
return|;
block|}
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the elements of    * {@code iterable}.    *    *<p>That iterator supports {@code remove()} if {@code iterable.iterator()}    * does. After {@code remove()} is called, subsequent cycles omit the removed    * element, which is no longer in {@code iterable}. The iterator's    * {@code hasNext()} method returns {@code true} until {@code iterable} is    * empty.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an    * infinite loop. You should use an explicit {@code break} or be certain that    * you will eventually remove all the elements.    *    *<p>To cycle over the iterable {@code n} times, use the following:    * {@code Iterables.concat(Collections.nCopies(n, iterable))}    */
DECL|method|cycle (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|cycle
argument_list|(
name|iterable
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|toString
argument_list|()
operator|+
literal|" (cycled)"
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an iterable whose iterators cycle indefinitely over the provided    * elements.    *    *<p>After {@code remove} is invoked on a generated iterator, the removed    * element will no longer appear in either that iterator or any other iterator    * created from the same source iterable. That is, this method behaves exactly    * as {@code Iterables.cycle(Lists.newArrayList(elements))}. The iterator's    * {@code hasNext} method returns {@code true} until all of the original    * elements have been removed.    *    *<p><b>Warning:</b> Typical uses of the resulting iterator may produce an    * infinite loop. You should use an explicit {@code break} or be certain that    * you will eventually remove all the elements.    *    *<p>To cycle over the elements {@code n} times, use the following:    * {@code Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}    */
DECL|method|cycle (T... elements)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|cycle
parameter_list|(
name|T
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|cycle
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines two iterables into a single iterable. The returned iterable has an    * iterator that traverses the elements in {@code a}, followed by the elements    * in {@code b}. The source iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the    * corresponding input iterator supports it.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|concat ( Iterable<? extends T> a, Iterable<? extends T> b)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines three iterables into a single iterable. The returned iterable has    * an iterator that traverses the elements in {@code a}, followed by the    * elements in {@code b}, followed by the elements in {@code c}. The source    * iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the    * corresponding input iterator supports it.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|concat (Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines four iterables into a single iterable. The returned iterable has    * an iterator that traverses the elements in {@code a}, followed by the    * elements in {@code b}, followed by the elements in {@code c}, followed by    * the elements in {@code d}. The source iterators are not polled until    * necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the    * corresponding input iterator supports it.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|concat (Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c, Iterable<? extends T> d)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|d
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable    * has an iterator that traverses the elements of each iterable in    * {@code inputs}. The input iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the    * corresponding input iterator supports it.    *    * @throws NullPointerException if any of the provided iterables is null    */
DECL|method|concat (Iterable<? extends T>.... inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
modifier|...
name|inputs
parameter_list|)
block|{
return|return
name|concat
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|inputs
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Combines multiple iterables into a single iterable. The returned iterable    * has an iterator that traverses the elements of each iterable in    * {@code inputs}. The input iterators are not polled until necessary.    *    *<p>The returned iterable's iterator supports {@code remove()} when the    * corresponding input iterator supports it. The methods of the returned    * iterable may throw {@code NullPointerException} if any of the input    * iterators is null.    */
DECL|method|concat ( final Iterable<? extends Iterable<? extends T>> inputs)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|concat
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|inputs
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|inputs
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|concat
argument_list|(
name|iterators
argument_list|(
name|inputs
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an iterator over the iterators of the given iterables.    */
DECL|method|iterators ( Iterable<? extends Iterable<? extends T>> iterables)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|UnmodifiableIterator
argument_list|<
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterators
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterables
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|iterableIterator
init|=
name|iterables
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterableIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|iterableIterator
operator|.
name|next
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
empty_stmt|;
block|}
comment|/**    * Divides an iterable into unmodifiable sublists of the given size (the final    * iterable may be smaller). For example, partitioning an iterable containing    * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code    * [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of    * three and two elements, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link    * Iterator#remove()} method. The returned lists implement {@link    * RandomAccess}, whether or not the input list does.    *    *<p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link    * Lists#partition(List, int)} instead.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition (the last may be smaller)    * @return an iterable of unmodifiable lists containing the elements of {@code    *     iterable} divided into partitions    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|partition ( final Iterable<T> iterable, final int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|partition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Divides an iterable into unmodifiable sublists of the given size, padding    * the final iterable with null values if necessary. For example, partitioning    * an iterable containing {@code [a, b, c, d, e]} with a partition size of 3    * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing    * two inner lists of three elements each, all in the original order.    *    *<p>Iterators returned by the returned iterable do not support the {@link    * Iterator#remove()} method.    *    * @param iterable the iterable to return a partitioned view of    * @param size the desired size of each partition    * @return an iterable of unmodifiable lists containing the elements of {@code    *     iterable} divided into partitions (the final iterable may have    *     trailing null elements)    * @throws IllegalArgumentException if {@code size} is nonpositive    */
DECL|method|paddedPartition ( final Iterable<T> iterable, final int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|paddedPartition
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|paddedPartition
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the elements of {@code unfiltered} that satisfy a predicate. The    * resulting iterable's iterator does not support {@code remove()}.    */
DECL|method|filter ( final Iterable<T> unfiltered, final Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns {@code true} if one or more elements in {@code iterable} satisfy    * the predicate.    */
DECL|method|any ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|any
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if every element in {@code iterable} satisfies the    * predicate. If {@code iterable} is empty, {@code true} is returned.    */
DECL|method|all ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|all
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|all
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the first element in {@code iterable} that satisfies the given    * predicate.    *    * @throws NoSuchElementException if no element in {@code iterable} matches    *     the given predicate    */
DECL|method|find (Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the first element in {@code iterable} that satisfies the given    * predicate, or {@code defaultValue} if none found.    *    * @since Guava release 07    */
DECL|method|find (Iterable<T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|find
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns the index in {@code iterable} of the first element that satisfies    * the provided {@code predicate}, or {@code -1} if the Iterable has no such    * elements.    *    *<p>More formally, returns the lowest index {@code i} such that    * {@code predicate.apply(Iterables.get(iterable, i))} returns {@code true},    * or {@code -1} if there is no such index.    *    * @since Guava release 02    */
DECL|method|indexOf ( Iterable<T> iterable, Predicate<? super T> predicate)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|indexOf
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|indexOf
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns an iterable that applies {@code function} to each element of {@code    * fromIterable}.    *    *<p>The returned iterable's iterator supports {@code remove()} if the    * provided iterator does. After a successful {@code remove()} call,    * {@code fromIterable} no longer contains the corresponding element.    */
DECL|method|transform (final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|F
argument_list|>
name|fromIterable
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|fromIterable
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromIterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the element at the specified position in an iterable.    *    * @param position position of the element to return    * @return the element at the specified position in {@code iterable}    * @throws IndexOutOfBoundsException if {@code position} is negative or    *     greater than or equal to the size of {@code iterable}    */
DECL|method|get (Iterable<T> iterable, int position)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
return|return
operator|(
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
operator|)
operator|.
name|get
argument_list|(
name|position
argument_list|)
return|;
block|}
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
comment|// Can check both ends
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
name|Preconditions
operator|.
name|checkElementIndex
argument_list|(
name|position
argument_list|,
name|collection
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Can only check the lower end
name|checkNonnegativeIndex
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
return|return
name|Iterators
operator|.
name|get
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|position
argument_list|)
return|;
block|}
DECL|method|checkNonnegativeIndex (int position)
specifier|private
specifier|static
name|void
name|checkNonnegativeIndex
parameter_list|(
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"position cannot be negative: "
operator|+
name|position
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the element at the specified position in an iterable or a default    * value otherwise.    *    * @param position position of the element to return    * @param defaultValue the default value to return if {@code position} is    *     greater than or equal to the size of the iterable    * @return the element at the specified position in {@code iterable} or    *     {@code defaultValue} if {@code iterable} contains fewer than    *     {@code position + 1} elements.    * @throws IndexOutOfBoundsException if {@code position} is negative    * @since Guava release 04    */
DECL|method|get (Iterable<T> iterable, int position, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|int
name|position
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkNonnegativeIndex
argument_list|(
name|position
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|get
argument_list|(
name|iterable
argument_list|,
name|position
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
name|defaultValue
return|;
block|}
block|}
comment|/**    * Returns the first element in {@code iterable} or {@code defaultValue} if    * the iterable is empty.  The {@link Iterators} analog to this method is    * {@link Iterators#getNext}.    *    * @param defaultValue the default value to return if the iterable is empty    * @return the first element of {@code iterable} or the default value    * @since Guava release 07    */
DECL|method|getFirst (Iterable<T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getFirst
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|getNext
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Returns the last element of {@code iterable}.    *    * @return the last element of {@code iterable}    * @throws NoSuchElementException if the iterable is empty    */
DECL|method|getLast (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
comment|// TODO(kevinb): Support a concurrently modified collection?
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|getLastInNonemptyList
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/*      * TODO(kevinb): consider whether this "optimization" is worthwhile. Users      * with SortedSets tend to know they are SortedSets and probably would not      * call this method.      */
if|if
condition|(
name|iterable
operator|instanceof
name|SortedSet
condition|)
block|{
name|SortedSet
argument_list|<
name|T
argument_list|>
name|sortedSet
init|=
operator|(
name|SortedSet
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|sortedSet
operator|.
name|last
argument_list|()
return|;
block|}
return|return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the last element of {@code iterable} or {@code defaultValue} if    * the iterable is empty.    *    * @param defaultValue the value to return if {@code iterable} is empty    * @return the last element of {@code iterable} or the default value    * @since Guava release 03    */
DECL|method|getLast (Iterable<T> iterable, @Nullable T defaultValue)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLast
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|T
name|defaultValue
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
block|}
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|getLastInNonemptyList
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/*      * TODO(kevinb): consider whether this "optimization" is worthwhile. Users      * with SortedSets tend to know they are SortedSets and probably would not      * call this method.      */
if|if
condition|(
name|iterable
operator|instanceof
name|SortedSet
condition|)
block|{
name|SortedSet
argument_list|<
name|T
argument_list|>
name|sortedSet
init|=
operator|(
name|SortedSet
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
name|sortedSet
operator|.
name|last
argument_list|()
return|;
block|}
return|return
name|Iterators
operator|.
name|getLast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
DECL|method|getLastInNonemptyList (List<T> list)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getLastInNonemptyList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Returns a view of {@code iterable} that skips its first    * {@code numberToSkip} elements. If {@code iterable} contains fewer than    * {@code numberToSkip} elements, the returned iterable skips all of its    * elements.    *    *<p>Modifications to the underlying {@link Iterable} before a call to    * {@code iterator()} are reflected in the returned iterator. That is, the    * iterator skips the first {@code numberToSkip} elements that exist when the    * {@code Iterator} is created, not when {@code skip()} is called.    *    *<p>The returned iterable's iterator supports {@code remove()} if the    * iterator of the underlying iterable supports it. Note that it is    *<i>not</i> possible to delete the last skipped element by immediately    * calling {@code remove()} on that iterator, as the {@code Iterator}    * contract states that a call to {@code remove()} before a call to    * {@code next()} will throw an {@link IllegalStateException}.    *    * @since Guava release 03    */
DECL|method|skip (final Iterable<T> iterable, final int numberToSkip)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|skip
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|numberToSkip
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|numberToSkip
operator|>=
literal|0
argument_list|,
literal|"number to skip cannot be negative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
decl_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// TODO(kevinb): Support a concurrently modified collection?
return|return
operator|(
name|numberToSkip
operator|>=
name|list
operator|.
name|size
argument_list|()
operator|)
condition|?
name|Iterators
operator|.
expr|<
name|T
operator|>
name|emptyIterator
argument_list|()
else|:
name|list
operator|.
name|subList
argument_list|(
name|numberToSkip
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|skip
argument_list|(
name|iterator
argument_list|,
name|numberToSkip
argument_list|)
expr_stmt|;
comment|/*          * We can't just return the iterator because an immediate call to its          * remove() method would remove one of the skipped elements instead of          * throwing an IllegalStateException.          */
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|atStart
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
try|try
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
finally|finally
block|{
name|atStart
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|atStart
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Creates an iterable with the first {@code limitSize} elements of the given    * iterable. If the original iterable does not contain that many elements, the    * returned iterator will have the same behavior as the original iterable. The    * returned iterable's iterator supports {@code remove()} if the original    * iterator does.    *    * @param iterable the iterable to limit    * @param limitSize the maximum number of elements in the returned iterator    * @throws IllegalArgumentException if {@code limitSize} is negative    * @since Guava release 03    */
DECL|method|limit ( final Iterable<T> iterable, final int limitSize)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|limit
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|int
name|limitSize
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|limitSize
operator|>=
literal|0
argument_list|,
literal|"limit is negative"
argument_list|)
expr_stmt|;
return|return
operator|new
name|IterableWithToString
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|limit
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|limitSize
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a view of the supplied iterable that wraps each generated    * {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.    *    *<p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will    * get entries from {@link Queue#remove()} since {@link Queue}'s iteration    * order is undefined.  Calling {@link Iterator#hasNext()} on a generated    * iterator from the returned iterable may cause an item to be immediately    * dequeued for return on a subsequent call to {@link Iterator#next()}.    *    * @param iterable the iterable to wrap    * @return a view of the supplied iterable that wraps each generated iterator    *     through {@link Iterators#consumingIterator(Iterator)}; for queues,    *     an iterable that generates iterators that return and consume the    *     queue's elements in queue order    *    * @see Iterators#consumingIterator(Iterator)    * @since Guava release 02    */
DECL|method|consumingIterable (final Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|consumingIterable
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Queue
condition|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ConsumingQueueIterator
argument_list|<
name|T
argument_list|>
argument_list|(
operator|(
name|Queue
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
argument_list|)
return|;
block|}
block|}
return|;
block|}
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
return|return
operator|new
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|consumingIterator
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|class|ConsumingQueueIterator
specifier|private
specifier|static
class|class
name|ConsumingQueueIterator
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|queue
specifier|private
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
decl_stmt|;
DECL|method|ConsumingQueueIterator (Queue<T> queue)
specifier|private
name|ConsumingQueueIterator
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
DECL|method|computeNext ()
annotation|@
name|Override
specifier|public
name|T
name|computeNext
parameter_list|()
block|{
try|try
block|{
return|return
name|queue
operator|.
name|remove
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
block|}
comment|// Methods only in Iterables, not in Iterators
comment|/**    * Adapts a list to an iterable with reversed iteration order. It is    * especially useful in foreach-style loops:<pre>   {@code    *    *   List<String> mylist = ...    *   for (String str : Iterables.reverse(mylist)) {    *     ...    *   }}</pre>    *    * There is no corresponding method in {@link Iterators}, since {@link    * Iterable#iterator} can simply be invoked on the result of calling this    * method.    *    * @return an iterable with the same elements as the list, in reverse    *    * @deprecated use {@link Lists#reverse(List)} or {@link    *     ImmutableList#reverse()}.<b>This method is scheduled for deletion in    *     July 2012.</b>    */
annotation|@
name|Deprecated
DECL|method|reverse (final List<T> list)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|reverse
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**    * Determines if the given iterable contains no elements.    *    *<p>There is no precise {@link Iterator} equivalent to this method, since    * one can only ask an iterator whether it has any elements<i>remaining</i>    * (which one does using {@link Iterator#hasNext}).    *    * @return {@code true} if the iterable contains no elements    */
DECL|method|isEmpty (Iterable<T> iterable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|isEmpty
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|!
name|iterable
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
return|;
block|}
comment|// Non-public
comment|/**    * Removes the specified element from the specified iterable.    *    *<p>This method iterates over the iterable, checking each element returned    * by the iterator in turn to see if it equals the object {@code o}. If they    * are equal, it is removed from the iterable with the iterator's    * {@code remove} method. At most one element is removed, even if the iterable    * contains multiple members that equal {@code o}.    *    *<p><b>Warning:</b> Do not use this method for a collection, such as a    * {@link HashSet}, that has a fast {@code remove} method.    *    * @param iterable the iterable from which to remove    * @param o an element to remove from the collection    * @return {@code true} if the iterable changed as a result    * @throws UnsupportedOperationException if the iterator does not support the    *     {@code remove} method and the iterable contains the object    */
DECL|method|remove (Iterable<?> iterable, @Nullable Object o)
specifier|static
name|boolean
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|i
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|,
name|o
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|class|IterableWithToString
specifier|abstract
specifier|static
class|class
name|IterableWithToString
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Iterable
argument_list|<
name|E
argument_list|>
block|{
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|toString
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

