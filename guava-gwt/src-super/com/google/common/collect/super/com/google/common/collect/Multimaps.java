begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
operator|.
name|MapJoiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Provides static methods acting on or generating a {@code Multimap}.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Multimaps">  * {@code Multimaps}</a>.  *  * @author Jared Levy  * @author Robert Konigsberg  * @author Mike Bostock  * @author Louis Wasserman  * @since 2.0 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Multimaps
specifier|public
specifier|final
class|class
name|Multimaps
block|{
DECL|method|Multimaps ()
specifier|private
name|Multimaps
parameter_list|()
block|{}
comment|/**    * Creates a new {@code Multimap} backed by {@code map}, whose internal value    * collections are generated by {@code factory}.    *    *<b>Warning: do not use</b> this method when the collections returned by    * {@code factory} implement either {@link List} or {@code Set}! Use the more    * specific method {@link #newListMultimap}, {@link #newSetMultimap} or {@link    * #newSortedSetMultimap} instead, to avoid very surprising behavior from    * {@link Multimap#equals}.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * collections generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},    * {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},    * {@link TreeMultimap#create()}, and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the collections returned by {@code factory}. Those objects should not be    * manually updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty collections that will each hold all    *     values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newMultimap (Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomMultimap
specifier|private
specifier|static
class|class
name|CustomMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMapBasedMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomMultimap (Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory)
name|CustomMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
comment|// can't use Serialization writeMultimap and populateMultimap methods since
comment|// there's no way to generate the empty backing map.
block|}
comment|/**    * Creates a new {@code ListMultimap} that uses the provided map and factory.    * It can generate a multimap based on arbitrary {@link Map} and {@link List}    * classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. The multimap's {@code get}, {@code    * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}    * lists if the factory does. However, the multimap's {@code get} method    * returns instances of a different class than does {@code factory.get()}.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * lists generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedListMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}    * won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the lists returned by {@code factory}. Those objects should not be manually    * updated, they should be empty when provided, and they should not use soft,    * weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty lists that will each hold all values    *     for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newListMultimap ( Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newListMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomListMultimap
specifier|private
specifier|static
class|class
name|CustomListMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomListMultimap (Map<K, Collection<V>> map, Supplier<? extends List<V>> factory)
name|CustomListMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * Creates a new {@code SetMultimap} that uses the provided map and factory.    * It can generate a multimap based on arbitrary {@link Map} and {@link Set}    * classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * sets generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedSetMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},    * {@link TreeMultimap#create()}, and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the sets returned by {@code factory}. Those objects should not be manually    * updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty sets that will each hold all values    *     for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomSetMultimap
specifier|private
specifier|static
class|class
name|CustomSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomSetMultimap (Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory)
name|CustomSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * Creates a new {@code SortedSetMultimap} that uses the provided map and    * factory. It can generate a multimap based on arbitrary {@link Map} and    * {@link SortedSet} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * sets generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedSortedSetMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link TreeMultimap#create()} and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the sets returned by {@code factory}. Those objects should not be manually    * updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty sorted sets that will each hold    *     all values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSortedSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSortedSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomSortedSetMultimap
specifier|private
specifier|static
class|class
name|CustomSortedSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|field|valueComparator
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
decl_stmt|;
DECL|method|CustomSortedSetMultimap (Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
name|CustomSortedSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|valueComparator
operator|=
name|factory
operator|.
name|get
argument_list|()
operator|.
name|comparator
argument_list|()
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|SortedSet
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|valueComparator ()
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|valueComparator
return|;
block|}
block|}
comment|/**    * Copies each key-value mapping in {@code source} into {@code dest}, with    * its key and value reversed.    *    *<p>If {@code source} is an {@link ImmutableMultimap}, consider using    * {@link ImmutableMultimap#inverse} instead.    *    * @param source any multimap    * @param dest the multimap to copy into; usually empty    * @return {@code dest}    */
DECL|method|invertFrom ( Multimap<? extends V, ? extends K> source, M dest)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|M
extends|extends
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
parameter_list|>
name|M
name|invertFrom
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|source
parameter_list|,
name|M
name|dest
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|entry
range|:
name|source
operator|.
name|entries
argument_list|()
control|)
block|{
name|dest
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) multimap backed by the specified    * multimap. In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing multimap is accomplished through the    * returned multimap.    *    *<p>It is imperative that the user manually synchronize on the returned    * multimap when accessing any of its collection views:<pre>   {@code    *    *   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(    *       HashMultimap.<K, V>create());    *   ...    *   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block    *   ...    *   synchronized (multimap) {  // Synchronizing on multimap, not values!    *     Iterator<V> i = values.iterator(); // Must be in synchronized block    *     while (i.hasNext()) {    *       foo(i.next());    *     }    *   }}</pre>    *    * Failure to follow this advice may result in non-deterministic behavior.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that aren't    * synchronized.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped in a synchronized view    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedMultimap ( Multimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedMultimap
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|multimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified multimap. Query operations on    * the returned multimap "read through" to the specified multimap, and    * attempts to modify the returned multimap, either directly or through the    * multimap's views, result in an {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableMultimap ( Multimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMultimap
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
return|return
operator|new
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
DECL|method|unmodifiableMultimap ( ImmutableMultimap<K, V> delegate)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMultimap
parameter_list|(
name|ImmutableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
DECL|class|UnmodifiableMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|delegate
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|entries
specifier|transient
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|field|keys
specifier|transient
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
decl_stmt|;
DECL|field|keySet
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|field|values
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|field|map
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
decl_stmt|;
DECL|method|UnmodifiableMultimap (final Multimap<K, V> delegate)
name|UnmodifiableMultimap
parameter_list|(
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|asMap ()
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|map
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|unmodifiableMap
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|delegate
operator|.
name|asMap
argument_list|()
argument_list|)
decl_stmt|;
name|map
operator|=
name|result
operator|=
operator|new
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableMap
return|;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|unmodifiableAsMapEntries
argument_list|(
name|unmodifiableMap
operator|.
name|entrySet
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|unmodifiableMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|collection
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|unmodifiableValueCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMapValues
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|asMapValues
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|asMapValues
operator|=
operator|new
name|UnmodifiableAsMapValues
argument_list|<
name|V
argument_list|>
argument_list|(
name|unmodifiableMap
operator|.
name|values
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|entries ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entries
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|entries
operator|=
name|result
operator|=
name|unmodifiableEntries
argument_list|(
name|delegate
operator|.
name|entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|delegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|keys ()
annotation|@
name|Override
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
name|Multiset
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keys
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keys
operator|=
name|result
operator|=
name|Multisets
operator|.
name|unmodifiableMultiset
argument_list|(
name|delegate
operator|.
name|keys
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keySet
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|boolean
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll (K key, Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|boolean
name|putAll
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|remove (Object key, Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableAsMapValues
specifier|private
specifier|static
class|class
name|UnmodifiableAsMapValues
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|field|delegate
specifier|final
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableAsMapValues (Collection<Collection<V>> delegate)
name|UnmodifiableAsMapValues
parameter_list|(
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|delegate
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|standardToArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|standardToArray
argument_list|(
name|array
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|standardContains
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|standardContainsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
DECL|class|UnmodifiableListMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableListMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableListMultimap (ListMultimap<K, V> delegate)
name|UnmodifiableListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableSetMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSetMultimap (SetMultimap<K, V> delegate)
name|UnmodifiableSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
comment|/*        * Note that this doesn't return a SortedSet when delegate is a        * SortedSetMultiset, unlike (SortedSet<V>) super.get().        */
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|entries ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
name|delegate
argument_list|()
operator|.
name|entries
argument_list|()
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableSortedSetMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableSortedSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSortedSetMultimap (SortedSetMultimap<K, V> delegate)
name|UnmodifiableSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|valueComparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|delegate
argument_list|()
operator|.
name|valueComparator
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the    * specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedSetMultimap ( SetMultimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|setMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code SetMultimap}. Query    * operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableSetMultimap ( SetMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableSetMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableSetMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
return|return
operator|new
name|UnmodifiableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
DECL|method|unmodifiableSetMultimap ( ImmutableSetMultimap<K, V> delegate)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSetMultimap
parameter_list|(
name|ImmutableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by    * the specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|synchronizedSortedSetMultimap (SortedSetMultimap<K, V> multimap)
name|synchronizedSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|sortedSetMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.    * Query operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableSortedSetMultimap ( SortedSetMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableSortedSetMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
return|return
operator|new
name|UnmodifiableSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the    * specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedListMultimap ( ListMultimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|listMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code ListMultimap}. Query    * operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableListMultimap ( ListMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|UnmodifiableListMultimap
operator|||
name|delegate
operator|instanceof
name|ImmutableListMultimap
condition|)
block|{
return|return
name|delegate
return|;
block|}
return|return
operator|new
name|UnmodifiableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Simply returns its argument.    *    * @deprecated no need to use this    * @since 10.0    */
DECL|method|unmodifiableListMultimap ( ImmutableListMultimap<K, V> delegate)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableListMultimap
parameter_list|(
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified collection, preserving the    * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and    * {@code Collection}, in that order of preference.    *    * @param collection the collection for which to return an unmodifiable view    * @return an unmodifiable view of the collection    */
DECL|method|unmodifiableValueCollection ( Collection<V> collection)
specifier|private
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Collection
argument_list|<
name|V
argument_list|>
name|unmodifiableValueCollection
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified multimap {@code asMap} entry.    * The {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}, and the collection returned by {@code    * getValue} is also an unmodifiable (type-preserving) view. This also has the    * side-effect of redefining equals to comply with the Map.Entry contract, and    * to avoid a possible nefarious implementation of equals.    *    * @param entry the entry for which to return an unmodifiable view    * @return an unmodifiable view of the entry    */
DECL|method|unmodifiableAsMapEntry ( final Map.Entry<K, Collection<V>> entry)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|unmodifiableAsMapEntry
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|getValue
parameter_list|()
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified collection of entries. The    * {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}. If the specified collection is a {@code    * Set}, the returned collection is also a {@code Set}.    *    * @param entries the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
DECL|method|unmodifiableEntries ( Collection<Entry<K, V>> entries)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|entries
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
operator|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
operator|)
name|entries
argument_list|)
return|;
block|}
return|return
operator|new
name|Maps
operator|.
name|UnmodifiableEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|entries
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified set of {@code asMap} entries.    * The {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}, as do any operations that attempt to modify    * the returned collection.    *    * @param asMapEntries the {@code asMap} entries for which to return an    *     unmodifiable view    * @return an unmodifiable view of the collection entries    */
DECL|method|unmodifiableAsMapEntries ( Set<Entry<K, Collection<V>>> asMapEntries)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|unmodifiableAsMapEntries
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|asMapEntries
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableAsMapEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|asMapEntries
argument_list|)
argument_list|)
return|;
block|}
comment|/** @see Multimaps#unmodifiableAsMapEntries */
DECL|class|UnmodifiableAsMapEntries
specifier|static
class|class
name|UnmodifiableAsMapEntries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|field|delegate
specifier|private
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableAsMapEntries (Set<Entry<K, Collection<V>>> delegate)
name|UnmodifiableAsMapEntries
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|delegate
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|ForwardingIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|iterator
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableAsMapEntry
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|standardToArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|standardToArray
argument_list|(
name|array
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|containsEntryImpl
argument_list|(
name|delegate
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|standardContainsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|standardEquals
argument_list|(
name|object
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a multimap view of the specified map. The multimap is backed by the    * map, so changes to the map are reflected in the multimap, and vice versa.    * If the map is modified while an iteration over one of the multimap's    * collection views is in progress (except through the iterator's own {@code    * remove} operation, or through the {@code setValue} operation on a map entry    * returned by the iterator), the results of the iteration are undefined.    *    *<p>The multimap supports mapping removal, which removes the corresponding    * mapping from the map. It does not support any operations which might add    * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.    *    *<p>The returned multimap will be serializable if the specified map is    * serializable.    *    * @param map the backing map for the returned multimap view    */
DECL|method|forMap (Map<K, V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|forMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|MapMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/** @see Multimaps#forMap */
DECL|class|MapMultimap
specifier|private
specifier|static
class|class
name|MapMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|map
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|asMap
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
decl_stmt|;
DECL|method|MapMultimap (Map<K, V> map)
name|MapMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsValue (Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|containsEntry (Object key, Object value)
specifier|public
name|boolean
name|containsEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (final K key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
operator|new
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
name|int
name|i
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|i
operator|++
expr_stmt|;
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|put (K key, V value)
specifier|public
name|boolean
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (K key, Iterable<? extends V> values)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|replaceValues (K key, Iterable<? extends V> values)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|remove (Object key, Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|remove
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Object key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|values
init|=
operator|new
name|HashSet
argument_list|<
name|V
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|values
return|;
block|}
name|values
operator|.
name|add
argument_list|(
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|map
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|keys ()
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|Multimaps
operator|.
name|Keys
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|entries ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|asMap ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|asMap
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|asMap
operator|=
name|result
operator|=
operator|new
name|AsMap
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Multimap
condition|)
block|{
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|size
argument_list|()
operator|==
name|that
operator|.
name|size
argument_list|()
operator|&&
name|asMap
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|asMap
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|map
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|field|JOINER
specifier|private
specifier|static
specifier|final
name|MapJoiner
name|JOINER
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|"], "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"=["
argument_list|)
operator|.
name|useForNull
argument_list|(
literal|"null"
argument_list|)
decl_stmt|;
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"{}"
return|;
block|}
name|StringBuilder
name|builder
init|=
name|Collections2
operator|.
name|newStringBuilderForCollection
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
decl_stmt|;
name|JOINER
operator|.
name|appendTo
argument_list|(
name|builder
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|append
argument_list|(
literal|"]}"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @see MapMultimap#asMap */
DECL|class|AsMapEntries
class|class
name|AsMapEntries
extends|extends
name|Sets
operator|.
name|ImprovedAbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|K
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|transform
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|getValue
parameter_list|()
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
operator|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|containsEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|set
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
operator|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|remove
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|set
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** @see MapMultimap#asMap */
DECL|class|AsMap
class|class
name|AsMap
extends|extends
name|Maps
operator|.
name|ImprovedAbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|createEntrySet ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|AsMapEntries
argument_list|()
return|;
block|}
comment|// The following methods are included for performance.
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|MapMultimap
operator|.
name|this
operator|.
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
decl_stmt|;
return|return
name|collection
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|collection
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|removeAll
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|collection
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|collection
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7845222491160860175L
decl_stmt|;
block|}
comment|/**    * Returns a view of a multimap where each value is transformed by a function.    * All other properties of the multimap, such as iteration order, are left    * intact. For example, the code:<pre>   {@code    *    * Multimap<String, Integer> multimap =    *     ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);    * Function<Integer, String> square = new Function<Integer, String>() {    *     public String apply(Integer in) {    *       return Integer.toString(in * in);    *     }    * };    * Multimap<String, String> transformed =    *     Multimaps.transformValues(multimap, square);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=[4, 16], b=[9, 9], c=[6]}}.    *    *<p>Changes in the underlying multimap are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys, and    * even null values provided that the function is capable of accepting null    * input.  The transformed multimap might contain null values, if the function    * sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the    * underlying multimap is.  The {@code equals} and {@code hashCode} methods    * of the returned multimap are meaningless, since there is not a definition    * of {@code equals} or {@code hashCode} for general collections, and    * {@code get()} will return a general {@code Collection} as opposed to a    * {@code List} or a {@code Set}.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned multimap to be a view, but it means that the function will    * be applied many times for bulk operations like    * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to    * perform well, {@code function} should be fast. To avoid lazy evaluation    * when the returned multimap doesn't need to be a view, copy the returned    * multimap into a new multimap of your choosing.    *    * @since 7.0    */
DECL|method|transformValues ( Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|transformEntries
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a multimap whose values are derived from the original    * multimap's entries. In contrast to {@link #transformValues}, this method's    * entry-transformation logic may depend on the key as well as the value.    *    *<p>All other properties of the transformed multimap, such as iteration    * order, are left intact. For example, the code:<pre>   {@code    *    *   SetMultimap<String, Integer> multimap =    *       ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);    *   EntryTransformer<String, Integer, String> transformer =    *       new EntryTransformer<String, Integer, String>() {    *         public String transformEntry(String key, Integer value) {    *            return (value>= 0) ? key : "no" + key;    *         }    *       };    *   Multimap<String, String> transformed =    *       Multimaps.transformEntries(multimap, transformer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=[a, a], b=[nob]}}.    *    *<p>Changes in the underlying multimap are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys and    * null values provided that the transformer is capable of accepting null    * inputs. The transformed multimap might contain null values if the    * transformer sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the    * underlying multimap is.  The {@code equals} and {@code hashCode} methods    * of the returned multimap are meaningless, since there is not a definition    * of {@code equals} or {@code hashCode} for general collections, and    * {@code get()} will return a general {@code Collection} as opposed to a    * {@code List} or a {@code Set}.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned multimap to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Multimap#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the    * returned multimap doesn't need to be a view, copy the returned multimap    * into a new multimap of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed multimap.    *    * @since 7.0    */
DECL|method|transformEntries ( Multimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|class|ValueFunction
specifier|static
specifier|final
class|class
name|ValueFunction
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
implements|implements
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|key
specifier|private
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|transformer
specifier|private
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
decl_stmt|;
DECL|method|ValueFunction (K key, EntryTransformer<? super K, ? super V1, V2> transformer)
name|ValueFunction
parameter_list|(
name|K
name|key
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|apply (@ullable V1 value)
specifier|public
name|V2
name|apply
parameter_list|(
annotation|@
name|Nullable
name|V1
name|value
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
DECL|class|TransformedEntriesMultimap
specifier|private
specifier|static
class|class
name|TransformedEntriesMultimap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromMultimap
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
decl_stmt|;
DECL|field|transformer
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
decl_stmt|;
DECL|method|TransformedEntriesMultimap (Multimap<K, V1> fromMultimap, final EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesMultimap
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
parameter_list|,
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|fromMultimap
operator|=
name|checkNotNull
argument_list|(
name|fromMultimap
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|transform (K key, Collection<V1> values)
name|Collection
argument_list|<
name|V2
argument_list|>
name|transform
parameter_list|(
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|values
parameter_list|)
block|{
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
name|function
init|=
operator|new
name|ValueFunction
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|key
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|instanceof
name|List
condition|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
operator|(
name|List
argument_list|<
name|V1
argument_list|>
operator|)
name|values
argument_list|,
name|function
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|values
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|createAsMap ()
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V2
argument_list|>
argument_list|>
name|createAsMap
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|transformEntries
argument_list|(
name|fromMultimap
operator|.
name|asMap
argument_list|()
argument_list|,
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|value
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMultimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containsEntry (Object key, Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|containsEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Collection
argument_list|<
name|V2
argument_list|>
name|values
init|=
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
decl_stmt|;
return|return
name|values
operator|.
name|contains
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMultimap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|containsValue (Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|entryIterator ()
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|fromMultimap
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|apply
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V2
name|getValue
parameter_list|()
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|get (final K key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|fromMultimap
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|keys ()
annotation|@
name|Override
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|keys
argument_list|()
return|;
block|}
DECL|method|put (K key, V2 value)
annotation|@
name|Override
specifier|public
name|boolean
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V2
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll (K key, Iterable<? extends V2> values)
annotation|@
name|Override
specifier|public
name|boolean
name|putAll
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll ( Multimap<? extends K, ? extends V2> multimap)
annotation|@
name|Override
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V2
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object key, Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
operator|.
name|remove
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMultimap
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V2> values)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V2
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromMultimap
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|createValues ()
name|Collection
argument_list|<
name|V2
argument_list|>
name|createValues
parameter_list|()
block|{
return|return
name|Collections2
operator|.
name|transform
argument_list|(
name|fromMultimap
operator|.
name|entries
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a view of a {@code ListMultimap} where each value is transformed by    * a function. All other properties of the multimap, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   ListMultimap<String, Integer> multimap    *        = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,    *       sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.    *    *<p>Changes in the underlying multimap are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys, and    * even null values provided that the function is capable of accepting null    * input.  The transformed multimap might contain null values, if the function    * sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the    * underlying multimap is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned multimap to be a view, but it means that the function will    * be applied many times for bulk operations like    * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to    * perform well, {@code function} should be fast. To avoid lazy evaluation    * when the returned multimap doesn't need to be a view, copy the returned    * multimap into a new multimap of your choosing.    *    * @since 7.0    */
DECL|method|transformValues ( ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|transformEntries
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a {@code ListMultimap} whose values are derived from the    * original multimap's entries. In contrast to    * {@link #transformValues(ListMultimap, Function)}, this method's    * entry-transformation logic may depend on the key as well as the value.    *    *<p>All other properties of the transformed multimap, such as iteration    * order, are left intact. For example, the code:<pre>   {@code    *    *   Multimap<String, Integer> multimap =    *       ImmutableMultimap.of("a", 1, "a", 4, "b", 6);    *   EntryTransformer<String, Integer, String> transformer =    *       new EntryTransformer<String, Integer, String>() {    *         public String transformEntry(String key, Integer value) {    *           return key + value;    *         }    *       };    *   Multimap<String, String> transformed =    *       Multimaps.transformEntries(multimap, transformer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {"a"=["a1", "a4"], "b"=["b6"]}}.    *    *<p>Changes in the underlying multimap are reflected in this view.    * Conversely, this view supports removal operations, and these are reflected    * in the underlying multimap.    *    *<p>It's acceptable for the underlying multimap to contain null keys and    * null values provided that the transformer is capable of accepting null    * inputs. The transformed multimap might contain null values if the    * transformer sometimes gives a null result.    *    *<p>The returned multimap is not thread-safe or serializable, even if the    * underlying multimap is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned multimap to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Multimap#containsValue} and {@link Object#toString}. For this to perform    * well, {@code transformer} should be fast. To avoid lazy evaluation when the    * returned multimap doesn't need to be a view, copy the returned multimap    * into a new multimap of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed multimap.    *    * @since 7.0    */
DECL|method|transformEntries ( ListMultimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
DECL|class|TransformedEntriesListMultimap
specifier|private
specifier|static
specifier|final
class|class
name|TransformedEntriesListMultimap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|TransformedEntriesMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
implements|implements
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|method|TransformedEntriesListMultimap (ListMultimap<K, V1> fromMultimap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMultimap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|super
argument_list|(
name|fromMultimap
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|transform (final K key, Collection<V1> values)
annotation|@
name|Override
name|List
argument_list|<
name|V2
argument_list|>
name|transform
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
name|Collection
argument_list|<
name|V1
argument_list|>
name|values
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
operator|(
name|List
argument_list|<
name|V1
argument_list|>
operator|)
name|values
argument_list|,
operator|new
name|Function
argument_list|<
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V2
name|apply
parameter_list|(
name|V1
name|value
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|key
argument_list|,
name|fromMultimap
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|transform
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMultimap
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|replaceValues ( K key, Iterable<? extends V2> values)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V2
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Creates an index {@code ImmutableListMultimap} that contains the results of    * applying a specified function to each item in an {@code Iterable} of    * values. Each value will be stored as a value in the resulting multimap,    * yielding a multimap with the same size as the input iterable. The key used    * to store that value in the multimap will be the result of calling the    * function on that value. The resulting multimap is created as an immutable    * snapshot. In the returned multimap, keys appear in the order they are first    * encountered, and the values corresponding to each key appear in the same    * order as they are encountered.    *    *<p>For example,<pre>   {@code    *    *   List<String> badGuys =    *       Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");    *   Function<String, Integer> stringLengthFunction = ...;    *   Multimap<Integer, String> index =    *       Multimaps.index(badGuys, stringLengthFunction);    *   System.out.println(index);}</pre>    *    * prints<pre>   {@code    *    *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>    *    * The returned multimap is serializable if its keys and values are all    * serializable.    *    * @param values the values to use when constructing the {@code    *     ImmutableListMultimap}    * @param keyFunction the function used to produce the key for each value    * @return {@code ImmutableListMultimap} mapping the result of evaluating the    *     function {@code keyFunction} on each value in the input collection to    *     that value    * @throws NullPointerException if any of the following cases is true:    *<ul>    *<li>{@code values} is null    *<li>{@code keyFunction} is null    *<li>An element in {@code values} is null    *<li>{@code keyFunction} returns {@code null} for any element of {@code    *         values}    *</ul>    */
DECL|method|index ( Iterable<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|index
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
return|return
name|index
argument_list|(
name|values
operator|.
name|iterator
argument_list|()
argument_list|,
name|keyFunction
argument_list|)
return|;
block|}
comment|/**    * Creates an index {@code ImmutableListMultimap} that contains the results of    * applying a specified function to each item in an {@code Iterator} of    * values. Each value will be stored as a value in the resulting multimap,    * yielding a multimap with the same size as the input iterator. The key used    * to store that value in the multimap will be the result of calling the    * function on that value. The resulting multimap is created as an immutable    * snapshot. In the returned multimap, keys appear in the order they are first    * encountered, and the values corresponding to each key appear in the same    * order as they are encountered.    *    *<p>For example,<pre>   {@code    *    *   List<String> badGuys =    *       Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");    *   Function<String, Integer> stringLengthFunction = ...;    *   Multimap<Integer, String> index =    *       Multimaps.index(badGuys.iterator(), stringLengthFunction);    *   System.out.println(index);}</pre>    *    * prints<pre>   {@code    *    *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>    *    * The returned multimap is serializable if its keys and values are all    * serializable.    *    * @param values the values to use when constructing the {@code    *     ImmutableListMultimap}    * @param keyFunction the function used to produce the key for each value    * @return {@code ImmutableListMultimap} mapping the result of evaluating the    *     function {@code keyFunction} on each value in the input collection to    *     that value    * @throws NullPointerException if any of the following cases is true:    *<ul>    *<li>{@code values} is null    *<li>{@code keyFunction} is null    *<li>An element in {@code values} is null    *<li>{@code keyFunction} returns {@code null} for any element of {@code    *         values}    *</ul>    * @since 10.0    */
DECL|method|index ( Iterator<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|index
parameter_list|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|V
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|checkNotNull
argument_list|(
name|value
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
DECL|class|Keys
specifier|static
class|class
name|Keys
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMultiset
argument_list|<
name|K
argument_list|>
block|{
DECL|field|multimap
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
decl_stmt|;
DECL|method|Keys (Multimap<K, V> multimap)
name|Keys
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
name|this
operator|.
name|multimap
operator|=
name|multimap
expr_stmt|;
block|}
DECL|method|entryIterator ()
annotation|@
name|Override
name|Iterator
argument_list|<
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
block|{
return|return
operator|new
name|TransformedIterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|,
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
name|transform
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|backingEntry
parameter_list|)
block|{
return|return
operator|new
name|Multisets
operator|.
name|AbstractEntry
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getElement
parameter_list|()
block|{
return|return
name|backingEntry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCount
parameter_list|()
block|{
return|return
name|backingEntry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
DECL|method|distinctElements ()
annotation|@
name|Override
name|int
name|distinctElements
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|createEntrySet ()
annotation|@
name|Override
name|Set
argument_list|<
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|KeysEntrySet
argument_list|()
return|;
block|}
DECL|class|KeysEntrySet
class|class
name|KeysEntrySet
extends|extends
name|Multisets
operator|.
name|EntrySet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|multiset ()
annotation|@
name|Override
name|Multiset
argument_list|<
name|K
argument_list|>
name|multiset
parameter_list|()
block|{
return|return
name|Keys
operator|.
name|this
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Multiset
operator|.
name|Entry
argument_list|<
name|K
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|distinctElements
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Multiset
operator|.
name|Entry
condition|)
block|{
name|Multiset
operator|.
name|Entry
argument_list|<
name|?
argument_list|>
name|entry
init|=
operator|(
name|Multiset
operator|.
name|Entry
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|collection
operator|!=
literal|null
operator|&&
name|collection
operator|.
name|size
argument_list|()
operator|==
name|entry
operator|.
name|getCount
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|remove (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Multiset
operator|.
name|Entry
condition|)
block|{
name|Multiset
operator|.
name|Entry
argument_list|<
name|?
argument_list|>
name|entry
init|=
operator|(
name|Multiset
operator|.
name|Entry
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|collection
operator|!=
literal|null
operator|&&
name|collection
operator|.
name|size
argument_list|()
operator|==
name|entry
operator|.
name|getCount
argument_list|()
condition|)
block|{
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|method|contains (@ullable Object element)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
return|return
name|multimap
operator|.
name|containsKey
argument_list|(
name|element
argument_list|)
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|keyIterator
argument_list|(
name|multimap
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|count (@ullable Object element)
annotation|@
name|Override
specifier|public
name|int
name|count
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
argument_list|,
name|element
argument_list|)
decl_stmt|;
return|return
operator|(
name|values
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|values
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|remove (@ullable Object element, int occurrences)
annotation|@
name|Override
specifier|public
name|int
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|element
parameter_list|,
name|int
name|occurrences
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|occurrences
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|occurrences
operator|==
literal|0
condition|)
block|{
return|return
name|count
argument_list|(
name|element
argument_list|)
return|;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|Maps
operator|.
name|safeGet
argument_list|(
name|multimap
operator|.
name|asMap
argument_list|()
argument_list|,
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|oldCount
init|=
name|values
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|occurrences
operator|>=
name|oldCount
condition|)
block|{
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
init|=
name|values
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|occurrences
condition|;
name|i
operator|++
control|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|oldCount
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|elementSet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|elementSet
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|keySet
argument_list|()
return|;
block|}
block|}
DECL|class|Values
specifier|static
class|class
name|Values
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|field|multimap
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
decl_stmt|;
DECL|method|Values (Multimap<K, V> multimap)
name|Values
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
name|this
operator|.
name|multimap
operator|=
name|multimap
expr_stmt|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|valueIterator
argument_list|(
name|multimap
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|multimap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
return|return
name|multimap
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A skeleton implementation of {@link Multimap#entries()}.    */
DECL|class|Entries
specifier|static
specifier|abstract
class|class
name|Entries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|multimap ()
specifier|abstract
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|()
function_decl|;
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|multimap
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|multimap
argument_list|()
operator|.
name|containsEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|remove (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|multimap
argument_list|()
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A skeleton implementation of {@link SetMultimap#entries()}.    */
DECL|class|EntrySet
specifier|static
specifier|abstract
class|class
name|EntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Entries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|equals (@ullable Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|obj
parameter_list|)
block|{
return|return
name|Sets
operator|.
name|equalsImpl
argument_list|(
name|this
argument_list|,
name|obj
argument_list|)
return|;
block|}
block|}
comment|/**    * A skeleton implementation of {@link Multimap#asMap()}.    */
DECL|class|AsMap
specifier|static
specifier|abstract
class|class
name|AsMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Maps
operator|.
name|ImprovedAbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|multimap ()
specifier|abstract
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|()
function_decl|;
DECL|method|size ()
annotation|@
name|Override
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
DECL|method|entryIterator ()
specifier|abstract
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entryIterator
parameter_list|()
function_decl|;
DECL|method|createEntrySet ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|EntrySet
argument_list|()
return|;
block|}
DECL|method|removeValuesForKey (Object key)
name|void
name|removeValuesForKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|multimap
argument_list|()
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
DECL|class|EntrySet
class|class
name|EntrySet
extends|extends
name|Maps
operator|.
name|EntrySet
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|map ()
annotation|@
name|Override
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|()
block|{
return|return
name|AsMap
operator|.
name|this
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entryIterator
argument_list|()
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|removeValuesForKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|multimap
argument_list|()
operator|.
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|multimap
argument_list|()
operator|.
name|removeAll
argument_list|(
name|key
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|multimap
argument_list|()
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|multimap
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|multimap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|multimap
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Support removal operations when filtering a filtered multimap. Since a    * filtered multimap has iterators that don't support remove, passing one to    * the FilteredEntryMultimap constructor would lead to a multimap whose removal    * operations would fail. This method combines the predicates to avoid that    * problem.    */
DECL|method|filterFiltered (FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|FilteredMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|multimap
operator|.
name|entryPredicate
argument_list|()
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|multimap
operator|.
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|// TODO(jlevy): Create methods that filter a SetMultimap or SortedSetMultimap.
block|}
end_class

end_unit

