begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkElementIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndexes
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkNonnegative
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CollectPreconditions
operator|.
name|checkRemove
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
operator|.
name|IntMath
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSequentialList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckReturnValue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link List} instances. Also see this  * class's counterparts {@link Sets}, {@link Maps} and {@link Queues}.  *  *<p>See the Guava User Guide article on<a href=  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Lists">  * {@code Lists}</a>.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Louis Wasserman  * @since 2.0  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Lists
specifier|public
specifier|final
class|class
name|Lists
block|{
DECL|method|Lists ()
specifier|private
name|Lists
parameter_list|()
block|{}
comment|// ArrayList
comment|/**    * Creates a<i>mutable</i>, empty {@code ArrayList} instance (for Java 6 and    * earlier).    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableList#of()} instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and    * should be treated as deprecated. Instead, use the {@code ArrayList}    * {@linkplain ArrayList#ArrayList() constructor} directly, taking advantage    * of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements.    *    *<p><b>Note:</b> essentially the only reason to use this method is when you    * will need to add or remove elements later. Otherwise, for non-null elements    * use {@link ImmutableList#of()} (for varargs) or {@link    * ImmutableList#copyOf(Object[])} (for an array) instead. If any elements    * might be null, or you need support for {@link List#set(int, Object)}, use    * {@link Arrays#asList}.    *    *<p>Note that even when you do need the ability to add or remove, this method    * provides only a tiny bit of syntactic sugar for {@code newArrayList(}{@link    * Arrays#asList asList}{@code (...))}, or for creating an empty list then    * calling {@link Collections#addAll}. This method is not actually very useful    * and will likely be deprecated in the future.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (E... elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|E
modifier|...
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
comment|// for GWT
comment|// Avoid integer overflow when a large array is passed in
name|int
name|capacity
init|=
name|computeArrayListCapacity
argument_list|(
name|elements
operator|.
name|length
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|capacity
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|list
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|computeArrayListCapacity (int arraySize)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|computeArrayListCapacity
parameter_list|(
name|int
name|arraySize
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|arraySize
argument_list|,
literal|"arraySize"
argument_list|)
expr_stmt|;
comment|// TODO(kevinb): Figure out the right behavior, and document it
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
literal|5L
operator|+
name|arraySize
operator|+
operator|(
name|arraySize
operator|/
literal|10
operator|)
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements; a very thin shortcut for creating an empty list then calling    * {@link Iterables#addAll}.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change    * {@code elements} to be a {@link FluentIterable} and call    * {@code elements.toList()}.)    *    *<p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link    * Collection}, you don't need this method. Use the {@code ArrayList}    * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking    * advantage of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|elements
argument_list|)
expr_stmt|;
comment|// for GWT
comment|// Let ArrayList's sizing logic work, if possible
return|return
operator|(
name|elements
operator|instanceof
name|Collection
operator|)
condition|?
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|Collections2
operator|.
name|cast
argument_list|(
name|elements
argument_list|)
argument_list|)
else|:
name|newArrayList
argument_list|(
name|elements
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code ArrayList} instance containing the given    * elements; a very thin shortcut for creating an empty list and then calling    * {@link Iterators#addAll}.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayList (Iterator<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayList
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|Iterators
operator|.
name|addAll
argument_list|(
name|list
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Creates an {@code ArrayList} instance backed by an array with the specified    * initial size; simply delegates to {@link ArrayList#ArrayList(int)}.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and    * should be treated as deprecated. Instead, use {@code new }{@link    * ArrayList#ArrayList(int) ArrayList}{@code<>(int)} directly, taking    * advantage of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    * (Unlike here, there is no risk of overload ambiguity, since the {@code    * ArrayList} constructors very wisely did not accept varargs.)    *    * @param initialArraySize the exact size of the initial backing array for    *     the returned array list ({@code ArrayList} documentation calls this    *     value the "capacity")    * @return a new, empty {@code ArrayList} which is guaranteed not to resize    *     itself unless its size reaches {@code initialArraySize + 1}    * @throws IllegalArgumentException if {@code initialArraySize} is negative    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayListWithCapacity ( int initialArraySize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayListWithCapacity
parameter_list|(
name|int
name|initialArraySize
parameter_list|)
block|{
name|checkNonnegative
argument_list|(
name|initialArraySize
argument_list|,
literal|"initialArraySize"
argument_list|)
expr_stmt|;
comment|// for GWT.
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|initialArraySize
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code ArrayList} instance to hold {@code estimatedSize}    * elements,<i>plus</i> an unspecified amount of padding; you almost    * certainly mean to call {@link #newArrayListWithCapacity} (see that method    * for further advice on usage).    *    *<p><b>Note:</b> This method will soon be deprecated. Even in the rare case    * that you do want some amount of padding, it's best if you choose your    * desired amount explicitly.    *    * @param estimatedSize an estimate of the eventual {@link List#size()} of    *     the new list    * @return a new, empty {@code ArrayList}, sized appropriately to hold the    *     estimated number of elements    * @throws IllegalArgumentException if {@code estimatedSize} is negative    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newArrayListWithExpectedSize ( int estimatedSize)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|newArrayListWithExpectedSize
parameter_list|(
name|int
name|estimatedSize
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|computeArrayListCapacity
argument_list|(
name|estimatedSize
argument_list|)
argument_list|)
return|;
block|}
comment|// LinkedList
comment|/**    * Creates a<i>mutable</i>, empty {@code LinkedList} instance (for Java 6 and    * earlier).    *    *<p><b>Note:</b> if you won't be adding any elements to the list, use {@link    * ImmutableList#of()} instead.    *    *<p><b>Performance note:</b> {@link ArrayList} and {@link    * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in    * certain rare and specific situations. Unless you have spent a lot of time    * benchmarking your specific needs, use one of those instead.    *    *<p><b>Note for Java 7 and later:</b> this method is now unnecessary and    * should be treated as deprecated. Instead, use the {@code LinkedList}    * {@linkplain LinkedList#LinkedList() constructor} directly, taking advantage    * of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newLinkedList ()
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedList
argument_list|<
name|E
argument_list|>
name|newLinkedList
parameter_list|()
block|{
return|return
operator|new
name|LinkedList
argument_list|<
name|E
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code LinkedList} instance containing the given    * elements; a very thin shortcut for creating an empty list then calling    * {@link Iterables#addAll}.    *    *<p><b>Note:</b> if mutability is not required and the elements are    * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change    * {@code elements} to be a {@link FluentIterable} and call    * {@code elements.toList()}.)    *    *<p><b>Performance note:</b> {@link ArrayList} and {@link    * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in    * certain rare and specific situations. Unless you have spent a lot of time    * benchmarking your specific needs, use one of those instead.    *    *<p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link    * Collection}, you don't need this method. Use the {@code LinkedList}    * {@linkplain LinkedList#LinkedList(Collection) constructor} directly, taking    * advantage of the new<a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.    */
annotation|@
name|GwtCompatible
argument_list|(
name|serializable
operator|=
literal|true
argument_list|)
DECL|method|newLinkedList ( Iterable<? extends E> elements)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|LinkedList
argument_list|<
name|E
argument_list|>
name|newLinkedList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|E
argument_list|>
name|list
init|=
name|newLinkedList
argument_list|()
decl_stmt|;
name|Iterables
operator|.
name|addAll
argument_list|(
name|list
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns an unmodifiable list containing the specified first element and    * backed by the specified array of additional elements. Changes to the {@code    * rest} array will be reflected in the returned list. Unlike {@link    * Arrays#asList}, the returned list is unmodifiable.    *    *<p>This is useful when a varargs method needs to use a signature such as    * {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload    * ambiguity or to enforce a minimum argument count.    *    *<p>The returned list is serializable and implements {@link RandomAccess}.    *    * @param first the first element    * @param rest an array of additional elements, possibly empty    * @return an unmodifiable list containing the specified elements    */
DECL|method|asList (@ullable E first, E[] rest)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|asList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
return|return
operator|new
name|OnePlusArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|first
argument_list|,
name|rest
argument_list|)
return|;
block|}
comment|/** @see Lists#asList(Object, Object[]) */
DECL|class|OnePlusArrayList
specifier|private
specifier|static
class|class
name|OnePlusArrayList
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
implements|implements
name|Serializable
implements|,
name|RandomAccess
block|{
DECL|field|first
specifier|final
name|E
name|first
decl_stmt|;
DECL|field|rest
specifier|final
name|E
index|[]
name|rest
decl_stmt|;
DECL|method|OnePlusArrayList (@ullable E first, E[] rest)
name|OnePlusArrayList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
name|this
operator|.
name|rest
operator|=
name|checkNotNull
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rest
operator|.
name|length
operator|+
literal|1
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|// check explicitly so the IOOBE will have the right message
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|index
operator|==
literal|0
operator|)
condition|?
name|first
else|:
name|rest
index|[
name|index
operator|-
literal|1
index|]
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns an unmodifiable list containing the specified first and second    * element, and backed by the specified array of additional elements. Changes    * to the {@code rest} array will be reflected in the returned list. Unlike    * {@link Arrays#asList}, the returned list is unmodifiable.    *    *<p>This is useful when a varargs method needs to use a signature such as    * {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid    * overload ambiguity or to enforce a minimum argument count.    *    *<p>The returned list is serializable and implements {@link RandomAccess}.    *    * @param first the first element    * @param second the second element    * @param rest an array of additional elements, possibly empty    * @return an unmodifiable list containing the specified elements    */
DECL|method|asList ( @ullable E first, @Nullable E second, E[] rest)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|asList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
annotation|@
name|Nullable
name|E
name|second
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
return|return
operator|new
name|TwoPlusArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|rest
argument_list|)
return|;
block|}
comment|/** @see Lists#asList(Object, Object, Object[]) */
DECL|class|TwoPlusArrayList
specifier|private
specifier|static
class|class
name|TwoPlusArrayList
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
implements|implements
name|Serializable
implements|,
name|RandomAccess
block|{
DECL|field|first
specifier|final
name|E
name|first
decl_stmt|;
DECL|field|second
specifier|final
name|E
name|second
decl_stmt|;
DECL|field|rest
specifier|final
name|E
index|[]
name|rest
decl_stmt|;
DECL|method|TwoPlusArrayList (@ullable E first, @Nullable E second, E[] rest)
name|TwoPlusArrayList
parameter_list|(
annotation|@
name|Nullable
name|E
name|first
parameter_list|,
annotation|@
name|Nullable
name|E
name|second
parameter_list|,
name|E
index|[]
name|rest
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
name|this
operator|.
name|second
operator|=
name|second
expr_stmt|;
name|this
operator|.
name|rest
operator|=
name|checkNotNull
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rest
operator|.
name|length
operator|+
literal|2
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
return|return
name|first
return|;
case|case
literal|1
case|:
return|return
name|second
return|;
default|default:
comment|// check explicitly so the IOOBE will have the right message
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rest
index|[
name|index
operator|-
literal|2
index|]
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given lists in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the lists. For example:<pre>   {@code    *    *   Lists.cartesianProduct(ImmutableList.of(    *       ImmutableList.of(1, 2),    *       ImmutableList.of("A", "B", "C")))}</pre>    *    *<p>returns a list containing six lists in the following order:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    *<p>The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : lists.get(0)) {    *     for (B b1 : lists.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    *<p>Note that if any input list is empty, the Cartesian product will also be    * empty. If no lists at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of lists of size    * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian product is constructed, the    * input lists are merely copied. Only as the resulting list is iterated are    * the individual lists created, and these are not retained after iteration.    *    * @param lists the lists to choose elements from, in the order that    *     the elements chosen from those lists should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable list containing immutable    *     lists    * @throws IllegalArgumentException if the size of the cartesian product would    *     be greater than {@link Integer#MAX_VALUE}    * @throws NullPointerException if {@code lists}, any one of the {@code lists},    *     or any element of a provided list is null    */
specifier|static
parameter_list|<
name|B
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
DECL|method|cartesianProduct (List<? extends List<? extends B>> lists)
name|cartesianProduct
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|?
extends|extends
name|B
argument_list|>
argument_list|>
name|lists
parameter_list|)
block|{
return|return
name|CartesianList
operator|.
name|create
argument_list|(
name|lists
argument_list|)
return|;
block|}
comment|/**    * Returns every possible list that can be formed by choosing one element    * from each of the given lists in order; the "n-ary    *<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian    * product</a>" of the lists. For example:<pre>   {@code    *    *   Lists.cartesianProduct(ImmutableList.of(    *       ImmutableList.of(1, 2),    *       ImmutableList.of("A", "B", "C")))}</pre>    *    *<p>returns a list containing six lists in the following order:    *    *<ul>    *<li>{@code ImmutableList.of(1, "A")}    *<li>{@code ImmutableList.of(1, "B")}    *<li>{@code ImmutableList.of(1, "C")}    *<li>{@code ImmutableList.of(2, "A")}    *<li>{@code ImmutableList.of(2, "B")}    *<li>{@code ImmutableList.of(2, "C")}    *</ul>    *    *<p>The result is guaranteed to be in the "traditional", lexicographical    * order for Cartesian products that you would get from nesting for loops:    *<pre>   {@code    *    *   for (B b0 : lists.get(0)) {    *     for (B b1 : lists.get(1)) {    *       ...    *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);    *       // operate on tuple    *     }    *   }}</pre>    *    *<p>Note that if any input list is empty, the Cartesian product will also be    * empty. If no lists at all are provided (an empty list), the resulting    * Cartesian product has one element, an empty list (counter-intuitive, but    * mathematically consistent).    *    *<p><i>Performance notes:</i> while the cartesian product of lists of size    * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory    * consumption is much smaller. When the cartesian product is constructed, the    * input lists are merely copied. Only as the resulting list is iterated are    * the individual lists created, and these are not retained after iteration.    *    * @param lists the lists to choose elements from, in the order that    *     the elements chosen from those lists should appear in the resulting    *     lists    * @param<B> any common base class shared by all axes (often just {@link    *     Object})    * @return the Cartesian product, as an immutable list containing immutable    *     lists    * @throws IllegalArgumentException if the size of the cartesian product would    *     be greater than {@link Integer#MAX_VALUE}    * @throws NullPointerException if {@code lists}, any one of the    *     {@code lists}, or any element of a provided list is null    */
specifier|static
parameter_list|<
name|B
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|B
argument_list|>
argument_list|>
DECL|method|cartesianProduct (List<? extends B>.... lists)
name|cartesianProduct
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|B
argument_list|>
modifier|...
name|lists
parameter_list|)
block|{
return|return
name|cartesianProduct
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|lists
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a list that applies {@code function} to each element of {@code    * fromList}. The returned list is a transformed view of {@code fromList};    * changes to {@code fromList} will be reflected in the returned list and vice    * versa.    *    *<p>Since functions are not reversible, the transform is one-way and new    * items cannot be stored in the returned list. The {@code add},    * {@code addAll} and {@code set} methods are unsupported in the returned    * list.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned list to be a view, but it means that the function will be    * applied many times for bulk operations like {@link List#contains} and    * {@link List#hashCode}. For this to perform well, {@code function} should be    * fast. To avoid lazy evaluation when the returned list doesn't need to be a    * view, copy the returned list into a new list of your choosing.    *    *<p>If {@code fromList} implements {@link RandomAccess}, so will the    * returned list. The returned list is threadsafe if the supplied list and    * function are.    *    *<p>If only a {@code Collection} or {@code Iterable} input is available, use    * {@link Collections2#transform} or {@link Iterables#transform}.    *    *<p><b>Note:</b> serializing the returned list is implemented by serializing    * {@code fromList}, its contents, and {@code function} --<i>not</i> by    * serializing the transformed values. This can lead to surprising behavior,    * so serializing the returned list is<b>not recommended</b>. Instead,    * copy the list using {@link ImmutableList#copyOf(Collection)} (for example),    * then serialize the copy. Other methods similar to this do not implement    * serialization at all for this reason.    */
annotation|@
name|CheckReturnValue
DECL|method|transform ( List<F> fromList, Function<? super F, ? extends T> function)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|(
name|fromList
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|TransformingRandomAccessList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
argument_list|,
name|function
argument_list|)
else|:
operator|new
name|TransformingSequentialList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**    * Implementation of a sequential transforming list.    *    * @see Lists#transform    */
DECL|class|TransformingSequentialList
specifier|private
specifier|static
class|class
name|TransformingSequentialList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractSequentialList
argument_list|<
name|T
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|fromList
specifier|final
name|List
argument_list|<
name|F
argument_list|>
name|fromList
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformingSequentialList ( List<F> fromList, Function<? super F, ? extends T> function)
name|TransformingSequentialList
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromList
operator|=
name|checkNotNull
argument_list|(
name|fromList
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
comment|/**      * The default implementation inherited is based on iteration and removal of      * each element which can be overkill. That's why we forward this call      * directly to the backing list.      */
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|listIterator (final int index)
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|TransformedListIterator
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|T
name|transform
parameter_list|(
name|F
name|from
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Implementation of a transforming random access list. We try to make as many    * of these methods pass-through to the source list as possible so that the    * performance characteristics of the source list and transformed list are    * similar.    *    * @see Lists#transform    */
DECL|class|TransformingRandomAccessList
specifier|private
specifier|static
class|class
name|TransformingRandomAccessList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
implements|,
name|Serializable
block|{
DECL|field|fromList
specifier|final
name|List
argument_list|<
name|F
argument_list|>
name|fromList
decl_stmt|;
DECL|field|function
specifier|final
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
DECL|method|TransformingRandomAccessList ( List<F> fromList, Function<? super F, ? extends T> function)
name|TransformingRandomAccessList
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|fromList
operator|=
name|checkNotNull
argument_list|(
name|fromList
argument_list|)
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|fromList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|listIterator
argument_list|()
return|;
block|}
DECL|method|listIterator (int index)
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|TransformedListIterator
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
argument_list|(
name|fromList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|T
name|transform
parameter_list|(
name|F
name|from
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|T
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|fromList
operator|.
name|remove
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,    * each of the same size (the final list may be smaller). For example,    * partitioning a list containing {@code [a, b, c, d, e]} with a partition    * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing    * two inner lists of three and two elements, all in the original order.    *    *<p>The outer list is unmodifiable, but reflects the latest state of the    * source list. The inner lists are sublist views of the original list,    * produced on demand using {@link List#subList(int, int)}, and are subject    * to all the usual caveats about modification as explained in that API.    *    * @param list the list to return consecutive sublists of    * @param size the desired size of each sublist (the last may be    *     smaller)    * @return a list of consecutive sublists    * @throws IllegalArgumentException if {@code partitionSize} is nonpositive    */
DECL|method|partition (List<T> list, int size)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|partition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|instanceof
name|RandomAccess
operator|)
condition|?
operator|new
name|RandomAccessPartition
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
else|:
operator|new
name|Partition
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
return|;
block|}
DECL|class|Partition
specifier|private
specifier|static
class|class
name|Partition
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|list
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|Partition (List<T> list, int size)
name|Partition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|start
init|=
name|index
operator|*
name|size
decl_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|start
operator|+
name|size
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|IntMath
operator|.
name|divide
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|size
argument_list|,
name|RoundingMode
operator|.
name|CEILING
argument_list|)
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|list
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
DECL|class|RandomAccessPartition
specifier|private
specifier|static
class|class
name|RandomAccessPartition
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Partition
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessPartition (List<T> list, int size)
name|RandomAccessPartition
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|list
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a view of the specified string as an immutable list of {@code    * Character} values.    *    * @since 7.0    */
DECL|method|charactersOf (String string)
annotation|@
name|Beta
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|Character
argument_list|>
name|charactersOf
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
operator|new
name|StringAsImmutableList
argument_list|(
name|checkNotNull
argument_list|(
name|string
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// serialized using ImmutableList serialization
DECL|class|StringAsImmutableList
specifier|private
specifier|static
specifier|final
class|class
name|StringAsImmutableList
extends|extends
name|ImmutableList
argument_list|<
name|Character
argument_list|>
block|{
DECL|field|string
specifier|private
specifier|final
name|String
name|string
decl_stmt|;
DECL|method|StringAsImmutableList (String string)
name|StringAsImmutableList
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
block|}
DECL|method|indexOf (@ullable Object object)
annotation|@
name|Override
specifier|public
name|int
name|indexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
operator|(
name|object
operator|instanceof
name|Character
operator|)
condition|?
name|string
operator|.
name|indexOf
argument_list|(
operator|(
name|Character
operator|)
name|object
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|lastIndexOf (@ullable Object object)
annotation|@
name|Override
specifier|public
name|int
name|lastIndexOf
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
operator|(
name|object
operator|instanceof
name|Character
operator|)
condition|?
name|string
operator|.
name|lastIndexOf
argument_list|(
operator|(
name|Character
operator|)
name|object
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
DECL|method|subList ( int fromIndex, int toIndex)
annotation|@
name|Override
specifier|public
name|ImmutableList
argument_list|<
name|Character
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|checkPositionIndexes
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// for GWT
return|return
name|charactersOf
argument_list|(
name|string
operator|.
name|substring
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
argument_list|)
return|;
block|}
DECL|method|isPartialView ()
annotation|@
name|Override
name|boolean
name|isPartialView
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|Character
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// for GWT
return|return
name|string
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|string
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns a view of the specified {@code CharSequence} as a {@code    * List<Character>}, viewing {@code sequence} as a sequence of Unicode code    * units. The view does not support any modification operations, but reflects    * any changes to the underlying character sequence.    *    * @param sequence the character sequence to view as a {@code List} of    *        characters    * @return an {@code List<Character>} view of the character sequence    * @since 7.0    */
DECL|method|charactersOf (CharSequence sequence)
annotation|@
name|Beta
specifier|public
specifier|static
name|List
argument_list|<
name|Character
argument_list|>
name|charactersOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|new
name|CharSequenceAsList
argument_list|(
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
argument_list|)
return|;
block|}
DECL|class|CharSequenceAsList
specifier|private
specifier|static
specifier|final
class|class
name|CharSequenceAsList
extends|extends
name|AbstractList
argument_list|<
name|Character
argument_list|>
block|{
DECL|field|sequence
specifier|private
specifier|final
name|CharSequence
name|sequence
decl_stmt|;
DECL|method|CharSequenceAsList (CharSequence sequence)
name|CharSequenceAsList
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|this
operator|.
name|sequence
operator|=
name|sequence
expr_stmt|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|Character
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// for GWT
return|return
name|sequence
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns a reversed view of the specified list. For example, {@code    * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,    * 2, 1}. The returned list is backed by this list, so changes in the returned    * list are reflected in this list, and vice-versa. The returned list supports    * all of the optional list operations supported by this list.    *    *<p>The returned list is random-access if the specified list is random    * access.    *    * @since 7.0    */
annotation|@
name|CheckReturnValue
DECL|method|reverse (List<T> list)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|reverse
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|ImmutableList
condition|)
block|{
return|return
operator|(
operator|(
name|ImmutableList
argument_list|<
name|T
argument_list|>
operator|)
name|list
operator|)
operator|.
name|reverse
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|list
operator|instanceof
name|ReverseList
condition|)
block|{
return|return
operator|(
operator|(
name|ReverseList
argument_list|<
name|T
argument_list|>
operator|)
name|list
operator|)
operator|.
name|getForwardList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|new
name|RandomAccessReverseList
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReverseList
argument_list|<
name|T
argument_list|>
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
DECL|class|ReverseList
specifier|private
specifier|static
class|class
name|ReverseList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
block|{
DECL|field|forwardList
specifier|private
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
decl_stmt|;
DECL|method|ReverseList (List<T> forwardList)
name|ReverseList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
parameter_list|)
block|{
name|this
operator|.
name|forwardList
operator|=
name|checkNotNull
argument_list|(
name|forwardList
argument_list|)
expr_stmt|;
block|}
DECL|method|getForwardList ()
name|List
argument_list|<
name|T
argument_list|>
name|getForwardList
parameter_list|()
block|{
return|return
name|forwardList
return|;
block|}
DECL|method|reverseIndex (int index)
specifier|private
name|int
name|reverseIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkElementIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|-
literal|1
operator|)
operator|-
name|index
return|;
block|}
DECL|method|reversePosition (int index)
specifier|private
name|int
name|reversePosition
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkPositionIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
operator|-
name|index
return|;
block|}
DECL|method|add (int index, @Nullable T element)
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|Nullable
name|T
name|element
parameter_list|)
block|{
name|forwardList
operator|.
name|add
argument_list|(
name|reversePosition
argument_list|(
name|index
argument_list|)
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|forwardList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|T
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|remove
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeRange (int fromIndex, int toIndex)
annotation|@
name|Override
specifier|protected
name|void
name|removeRange
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|set (int index, @Nullable T element)
annotation|@
name|Override
specifier|public
name|T
name|set
parameter_list|(
name|int
name|index
parameter_list|,
annotation|@
name|Nullable
name|T
name|element
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|set
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|,
name|element
argument_list|)
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|forwardList
operator|.
name|get
argument_list|(
name|reverseIndex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|forwardList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|subList (int fromIndex, int toIndex)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|checkPositionIndexes
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reverse
argument_list|(
name|forwardList
operator|.
name|subList
argument_list|(
name|reversePosition
argument_list|(
name|toIndex
argument_list|)
argument_list|,
name|reversePosition
argument_list|(
name|fromIndex
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|listIterator
argument_list|()
return|;
block|}
DECL|method|listIterator (int index)
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|start
init|=
name|reversePosition
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|ListIterator
argument_list|<
name|T
argument_list|>
name|forwardIterator
init|=
name|forwardList
operator|.
name|listIterator
argument_list|(
name|start
argument_list|)
decl_stmt|;
return|return
operator|new
name|ListIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|boolean
name|canRemoveOrSet
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|T
name|e
parameter_list|)
block|{
name|forwardIterator
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|previous
argument_list|()
expr_stmt|;
name|canRemoveOrSet
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|forwardIterator
operator|.
name|hasPrevious
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|forwardIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|canRemoveOrSet
operator|=
literal|true
expr_stmt|;
return|return
name|forwardIterator
operator|.
name|previous
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|reversePosition
argument_list|(
name|forwardIterator
operator|.
name|nextIndex
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|previous
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasPrevious
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|canRemoveOrSet
operator|=
literal|true
expr_stmt|;
return|return
name|forwardIterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|nextIndex
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkRemove
argument_list|(
name|canRemoveOrSet
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|canRemoveOrSet
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|T
name|e
parameter_list|)
block|{
name|checkState
argument_list|(
name|canRemoveOrSet
argument_list|)
expr_stmt|;
name|forwardIterator
operator|.
name|set
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
DECL|class|RandomAccessReverseList
specifier|private
specifier|static
class|class
name|RandomAccessReverseList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ReverseList
argument_list|<
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessReverseList (List<T> forwardList)
name|RandomAccessReverseList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|forwardList
parameter_list|)
block|{
name|super
argument_list|(
name|forwardList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * An implementation of {@link List#hashCode()}.    */
DECL|method|hashCodeImpl (List<?> list)
specifier|static
name|int
name|hashCodeImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|)
block|{
comment|// TODO(user): worth optimizing for RandomAccess?
name|int
name|hashCode
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|list
control|)
block|{
name|hashCode
operator|=
literal|31
operator|*
name|hashCode
operator|+
operator|(
name|o
operator|==
literal|null
condition|?
literal|0
else|:
name|o
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|hashCode
operator|=
operator|~
operator|~
name|hashCode
expr_stmt|;
comment|// needed to deal with GWT integer overflow
block|}
return|return
name|hashCode
return|;
block|}
comment|/**    * An implementation of {@link List#equals(Object)}.    */
DECL|method|equalsImpl (List<?> thisList, @Nullable Object other)
specifier|static
name|boolean
name|equalsImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|thisList
parameter_list|,
annotation|@
name|Nullable
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
name|checkNotNull
argument_list|(
name|thisList
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|List
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|?
argument_list|>
name|otherList
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|other
decl_stmt|;
name|int
name|size
init|=
name|thisList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|otherList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|thisList
operator|instanceof
name|RandomAccess
operator|&&
name|otherList
operator|instanceof
name|RandomAccess
condition|)
block|{
comment|// avoid allocation and use the faster loop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Objects
operator|.
name|equal
argument_list|(
name|thisList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|otherList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|Iterators
operator|.
name|elementsEqual
argument_list|(
name|thisList
operator|.
name|iterator
argument_list|()
argument_list|,
name|otherList
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * An implementation of {@link List#addAll(int, Collection)}.    */
DECL|method|addAllImpl ( List<E> list, int index, Iterable<? extends E> elements)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|addAllImpl
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|elements
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|elements
control|)
block|{
name|listIterator
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
comment|/**    * An implementation of {@link List#indexOf(Object)}.    */
DECL|method|indexOfImpl (List<?> list, @Nullable Object element)
specifier|static
name|int
name|indexOfImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
name|indexOfRandomAccess
argument_list|(
name|list
argument_list|,
name|element
argument_list|)
return|;
block|}
else|else
block|{
name|ListIterator
argument_list|<
name|?
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|listIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|element
argument_list|,
name|listIterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|listIterator
operator|.
name|previousIndex
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
DECL|method|indexOfRandomAccess (List<?> list, @Nullable Object element)
specifier|private
specifier|static
name|int
name|indexOfRandomAccess
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
name|int
name|size
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * An implementation of {@link List#lastIndexOf(Object)}.    */
DECL|method|lastIndexOfImpl (List<?> list, @Nullable Object element)
specifier|static
name|int
name|lastIndexOfImpl
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
name|lastIndexOfRandomAccess
argument_list|(
name|list
argument_list|,
name|element
argument_list|)
return|;
block|}
else|else
block|{
name|ListIterator
argument_list|<
name|?
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|listIterator
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|element
argument_list|,
name|listIterator
operator|.
name|previous
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|listIterator
operator|.
name|nextIndex
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
DECL|method|lastIndexOfRandomAccess (List<?> list, @Nullable Object element)
specifier|private
specifier|static
name|int
name|lastIndexOfRandomAccess
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
annotation|@
name|Nullable
name|Object
name|element
parameter_list|)
block|{
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns an implementation of {@link List#listIterator(int)}.    */
DECL|method|listIteratorImpl (List<E> list, int index)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIteratorImpl
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * An implementation of {@link List#subList(int, int)}.    */
DECL|method|subListImpl ( final List<E> list, int fromIndex, int toIndex)
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|subListImpl
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|List
argument_list|<
name|E
argument_list|>
name|wrapper
decl_stmt|;
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
name|wrapper
operator|=
operator|new
name|RandomAccessListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
expr_stmt|;
block|}
else|else
block|{
name|wrapper
operator|=
operator|new
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
expr_stmt|;
block|}
return|return
name|wrapper
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
return|;
block|}
DECL|class|AbstractListWrapper
specifier|private
specifier|static
class|class
name|AbstractListWrapper
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|E
argument_list|>
block|{
DECL|field|backingList
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|backingList
decl_stmt|;
DECL|method|AbstractListWrapper (List<E> backingList)
name|AbstractListWrapper
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|backingList
parameter_list|)
block|{
name|this
operator|.
name|backingList
operator|=
name|checkNotNull
argument_list|(
name|backingList
argument_list|)
expr_stmt|;
block|}
DECL|method|add (int index, E element)
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
name|backingList
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
DECL|method|addAll (int index, Collection<? extends E> c)
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|addAll
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
return|;
block|}
DECL|method|get (int index)
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|remove (int index)
annotation|@
name|Override
specifier|public
name|E
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|remove
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|set (int index, E element)
annotation|@
name|Override
specifier|public
name|E
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|backingList
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|backingList
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|class|RandomAccessListWrapper
specifier|private
specifier|static
class|class
name|RandomAccessListWrapper
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractListWrapper
argument_list|<
name|E
argument_list|>
implements|implements
name|RandomAccess
block|{
DECL|method|RandomAccessListWrapper (List<E> backingList)
name|RandomAccessListWrapper
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|backingList
parameter_list|)
block|{
name|super
argument_list|(
name|backingList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557    */
DECL|method|cast (Iterable<T> iterable)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
return|return
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
block|}
end_class

end_unit

