begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
operator|.
name|MapJoiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Provides static methods acting on or generating a {@code Multimap}.  *  * @author Jared Levy  * @author Robert Konigsberg  * @author Mike Bostock  * @since 2 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Multimaps
specifier|public
specifier|final
class|class
name|Multimaps
block|{
DECL|method|Multimaps ()
specifier|private
name|Multimaps
parameter_list|()
block|{}
comment|/**    * Creates a new {@code Multimap} that uses the provided map and factory. It    * can generate a multimap based on arbitrary {@link Map} and    * {@link Collection} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * collections generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},    * {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},    * {@link TreeMultimap#create()}, and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the collections returned by {@code factory}. Those objects should not be    * manually updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty collections that will each hold all    *     values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newMultimap (Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomMultimap
specifier|private
specifier|static
class|class
name|CustomMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomMultimap (Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory)
name|CustomMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
comment|// can't use Serialization writeMultimap and populateMultimap methods since
comment|// there's no way to generate the empty backing map.
block|}
comment|/**    * Creates a new {@code ListMultimap} that uses the provided map and factory.    * It can generate a multimap based on arbitrary {@link Map} and {@link List}    * classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. The multimap's {@code get}, {@code    * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}    * lists if the factory does. However, the multimap's {@code get} method    * returns instances of a different class than does {@code factory.get()}.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * lists generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedListMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}    * won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the lists returned by {@code factory}. Those objects should not be manually    * updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty lists that will each hold all values    *     for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newListMultimap ( Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newListMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomListMultimap
specifier|private
specifier|static
class|class
name|CustomListMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomListMultimap (Map<K, Collection<V>> map, Supplier<? extends List<V>> factory)
name|CustomListMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * Creates a new {@code SetMultimap} that uses the provided map and factory.    * It can generate a multimap based on arbitrary {@link Map} and {@link Set}    * classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * sets generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedSetMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},    * {@link TreeMultimap#create()}, and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the sets returned by {@code factory}. Those objects should not be manually    * updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty sets that will each hold all values    *     for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomSetMultimap
specifier|private
specifier|static
class|class
name|CustomSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|method|CustomSetMultimap (Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory)
name|CustomSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|Set
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * Creates a new {@code SortedSetMultimap} that uses the provided map and    * factory. It can generate a multimap based on arbitrary {@link Map} and    * {@link SortedSet} classes.    *    *<p>The {@code factory}-generated and {@code map} classes determine the    * multimap iteration order. They also specify the behavior of the    * {@code equals}, {@code hashCode}, and {@code toString} methods for the    * multimap and its returned views. However, the multimap's {@code get}    * method returns instances of a different class than {@code factory.get()}    * does.    *    *<p>The multimap is serializable if {@code map}, {@code factory}, the    * sets generated by {@code factory}, and the multimap contents are all    * serializable.    *    *<p>The multimap is not threadsafe when any concurrent operations update the    * multimap, even if {@code map} and the instances generated by    * {@code factory} are. Concurrent read operations will work correctly. To    * allow concurrent update operations, wrap the multimap with a call to    * {@link #synchronizedSortedSetMultimap}.    *    *<p>Call this method only when the simpler methods    * {@link TreeMultimap#create()} and    * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.    *    *<p>Note: the multimap assumes complete ownership over of {@code map} and    * the sets returned by {@code factory}. Those objects should not be manually    * updated and they should not use soft, weak, or phantom references.    *    * @param map place to store the mapping from each key to its corresponding    *     values    * @param factory supplier of new, empty sorted sets that will each hold    *     all values for a given key    * @throws IllegalArgumentException if {@code map} is not empty    */
DECL|method|newSortedSetMultimap ( Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSortedSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
return|return
operator|new
name|CustomSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|factory
argument_list|)
return|;
block|}
DECL|class|CustomSortedSetMultimap
specifier|private
specifier|static
class|class
name|CustomSortedSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|factory
specifier|transient
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
decl_stmt|;
DECL|field|valueComparator
specifier|transient
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
decl_stmt|;
DECL|method|CustomSortedSetMultimap (Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory)
name|CustomSortedSetMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|SortedSet
argument_list|<
name|V
argument_list|>
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|checkNotNull
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|valueComparator
operator|=
name|factory
operator|.
name|get
argument_list|()
operator|.
name|comparator
argument_list|()
expr_stmt|;
block|}
DECL|method|createCollection ()
annotation|@
name|Override
specifier|protected
name|SortedSet
argument_list|<
name|V
argument_list|>
name|createCollection
parameter_list|()
block|{
return|return
name|factory
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|valueComparator ()
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|valueComparator
return|;
block|}
block|}
comment|/**    * Copies each key-value mapping in {@code source} into {@code dest}, with    * its key and value reversed.    *    * @param source any multimap    * @param dest the multimap to copy into; usually empty    * @return {@code dest}    */
DECL|method|invertFrom ( Multimap<? extends V, ? extends K> source, M dest)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|M
extends|extends
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
parameter_list|>
name|M
name|invertFrom
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|source
parameter_list|,
name|M
name|dest
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|V
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|entry
range|:
name|source
operator|.
name|entries
argument_list|()
control|)
block|{
name|dest
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) multimap backed by the specified    * multimap. In order to guarantee serial access, it is critical that    *<b>all</b> access to the backing multimap is accomplished through the    * returned multimap.    *    *<p>It is imperative that the user manually synchronize on the returned    * multimap when accessing any of its collection views:<pre>  {@code    *    *  Multimap<K, V> m = Multimaps.synchronizedMultimap(    *      HashMultimap.<K, V>create());    *  ...    *  Set<K> s = m.keySet();  // Needn't be in synchronized block    *  ...    *  synchronized (m) {  // Synchronizing on m, not s!    *    Iterator<K> i = s.iterator(); // Must be in synchronized block    *    while (i.hasNext()) {    *      foo(i.next());    *    }    *  }}</pre>    *    * Failure to follow this advice may result in non-deterministic behavior.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that aren't    * synchronized.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped in a synchronized view    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedMultimap ( Multimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedMultimap
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|multimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified multimap. Query operations on    * the returned multimap "read through" to the specified multimap, and    * attempts to modify the returned multimap, either directly or through the    * multimap's views, result in an {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableMultimap ( Multimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMultimap
parameter_list|(
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
DECL|class|UnmodifiableMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|delegate
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|entries
specifier|transient
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|field|keys
specifier|transient
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
decl_stmt|;
DECL|field|keySet
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|field|values
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|field|map
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|map
decl_stmt|;
DECL|method|UnmodifiableMultimap (final Multimap<K, V> delegate)
name|UnmodifiableMultimap
parameter_list|(
specifier|final
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Multimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|asMap ()
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|map
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|unmodifiableMap
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|delegate
operator|.
name|asMap
argument_list|()
argument_list|)
decl_stmt|;
name|map
operator|=
name|result
operator|=
operator|new
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableMap
return|;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|unmodifiableAsMapEntries
argument_list|(
name|unmodifiableMap
operator|.
name|entrySet
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|unmodifiableMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|collection
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|unmodifiableValueCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMapValues
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|asMapValues
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|asMapValues
operator|=
operator|new
name|UnmodifiableAsMapValues
argument_list|<
name|V
argument_list|>
argument_list|(
name|unmodifiableMap
operator|.
name|values
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|entries ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entries
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|entries
operator|=
name|result
operator|=
name|unmodifiableEntries
argument_list|(
name|delegate
operator|.
name|entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|delegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|keys ()
annotation|@
name|Override
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
name|Multiset
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keys
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keys
operator|=
name|result
operator|=
name|Multisets
operator|.
name|unmodifiableMultiset
argument_list|(
name|delegate
operator|.
name|keys
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|keySet
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|boolean
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll (K key, @SuppressWarnings(R) Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|boolean
name|putAll
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|remove (Object key, Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues (K key, @SuppressWarnings(R) Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|result
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableAsMapValues
specifier|private
specifier|static
class|class
name|UnmodifiableAsMapValues
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|field|delegate
specifier|final
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableAsMapValues (Collection<Collection<V>> delegate)
name|UnmodifiableAsMapValues
parameter_list|(
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|delegate
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|,
name|array
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|iterator
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|containsAll
argument_list|(
name|this
argument_list|,
name|c
argument_list|)
return|;
block|}
block|}
DECL|class|UnmodifiableListMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableListMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableListMultimap (ListMultimap<K, V> delegate)
name|UnmodifiableListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, @SuppressWarnings(R) Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableSetMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSetMultimap (SetMultimap<K, V> delegate)
name|UnmodifiableSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
comment|/*        * Note that this doesn't return a SortedSet when delegate is a        * SortedSetMultiset, unlike (SortedSet<V>) super.get().        */
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|entries ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
name|delegate
argument_list|()
operator|.
name|entries
argument_list|()
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, @SuppressWarnings(R) Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnmodifiableSortedSetMultimap
specifier|private
specifier|static
class|class
name|UnmodifiableSortedSetMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|UnmodifiableSortedSetMultimap (SortedSetMultimap<K, V> delegate)
name|UnmodifiableSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|public
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
operator|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|super
operator|.
name|delegate
argument_list|()
return|;
block|}
DECL|method|get (K key)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
name|delegate
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues ( K key, @SuppressWarnings(R) Iterable<? extends V> values)
annotation|@
name|Override
specifier|public
name|SortedSet
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|valueComparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valueComparator
parameter_list|()
block|{
return|return
name|delegate
argument_list|()
operator|.
name|valueComparator
argument_list|()
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the    * specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedSetMultimap ( SetMultimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|setMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code SetMultimap}. Query    * operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableSetMultimap ( SetMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSetMultimap
parameter_list|(
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by    * the specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
DECL|method|synchronizedSortedSetMultimap (SortedSetMultimap<K, V> multimap)
name|synchronizedSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|sortedSetMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.    * Query operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableSortedSetMultimap ( SortedSetMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableSortedSetMultimap
parameter_list|(
name|SortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableSortedSetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the    * specified multimap.    *    *<p>You must follow the warnings described in {@link #synchronizedMultimap}.    *    * @param multimap the multimap to be wrapped    * @return a synchronized view of the specified multimap    */
DECL|method|synchronizedListMultimap ( ListMultimap<K, V> multimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|listMultimap
argument_list|(
name|multimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified {@code ListMultimap}. Query    * operations on the returned multimap "read through" to the specified    * multimap, and attempts to modify the returned multimap, either directly or    * through the multimap's views, result in an    * {@code UnsupportedOperationException}.    *    *<p>Note that the generated multimap's {@link Multimap#removeAll} and    * {@link Multimap#replaceValues} methods return collections that are    * modifiable.    *    *<p>The returned multimap will be serializable if the specified multimap is    * serializable.    *    * @param delegate the multimap for which an unmodifiable view is to be    *     returned    * @return an unmodifiable view of the specified multimap    */
DECL|method|unmodifiableListMultimap ( ListMultimap<K, V> delegate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableListMultimap
parameter_list|(
name|ListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified collection, preserving the    * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and    * {@code Collection}, in that order of preference.    *    * @param collection the collection for which to return an unmodifiable view    * @return an unmodifiable view of the collection    */
DECL|method|unmodifiableValueCollection ( Collection<V> collection)
specifier|private
specifier|static
parameter_list|<
name|V
parameter_list|>
name|Collection
argument_list|<
name|V
argument_list|>
name|unmodifiableValueCollection
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|instanceof
name|SortedSet
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedSet
argument_list|(
operator|(
name|SortedSet
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|(
name|Set
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
argument_list|<
name|V
argument_list|>
operator|)
name|collection
argument_list|)
return|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|collection
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified multimap {@code asMap} entry.    * The {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}, and the collection returned by {@code    * getValue} is also an unmodifiable (type-preserving) view. This also has the    * side-effect of redefining equals to comply with the Map.Entry contract, and    * to avoid a possible nefarious implementation of equals.    *    * @param entry the entry for which to return an unmodifiable view    * @return an unmodifiable view of the entry    */
DECL|method|unmodifiableAsMapEntry ( final Map.Entry<K, Collection<V>> entry)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|unmodifiableAsMapEntry
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|getValue
parameter_list|()
block|{
return|return
name|unmodifiableValueCollection
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified collection of entries. The    * {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}. If the specified collection is a {@code    * Set}, the returned collection is also a {@code Set}.    *    * @param entries the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
DECL|method|unmodifiableEntries ( Collection<Entry<K, V>> entries)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|entries
operator|instanceof
name|Set
condition|)
block|{
return|return
name|Maps
operator|.
name|unmodifiableEntrySet
argument_list|(
operator|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
operator|)
name|entries
argument_list|)
return|;
block|}
return|return
operator|new
name|Maps
operator|.
name|UnmodifiableEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|entries
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified set of {@code asMap} entries.    * The {@link Entry#setValue} operation throws an {@link    * UnsupportedOperationException}, as do any operations that attempt to modify    * the returned collection.    *    * @param asMapEntries the {@code asMap} entries for which to return an    *     unmodifiable view    * @return an unmodifiable view of the collection entries    */
DECL|method|unmodifiableAsMapEntries ( Set<Entry<K, Collection<V>>> asMapEntries)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|unmodifiableAsMapEntries
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|asMapEntries
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableAsMapEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|asMapEntries
argument_list|)
argument_list|)
return|;
block|}
comment|/** @see Multimaps#unmodifiableAsMapEntries */
DECL|class|UnmodifiableAsMapEntries
specifier|static
class|class
name|UnmodifiableAsMapEntries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|field|delegate
specifier|private
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
decl_stmt|;
DECL|method|UnmodifiableAsMapEntries (Set<Entry<K, Collection<V>>> delegate)
name|UnmodifiableAsMapEntries
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|delegate
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|ForwardingIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|iterator
return|;
block|}
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableAsMapEntry
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|,
name|array
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Maps
operator|.
name|containsEntryImpl
argument_list|(
name|delegate
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|containsAll
argument_list|(
name|this
argument_list|,
name|c
argument_list|)
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|setEquals
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a multimap view of the specified map. The multimap is backed by the    * map, so changes to the map are reflected in the multimap, and vice versa.    * If the map is modified while an iteration over one of the multimap's    * collection views is in progress (except through the iterator's own {@code    * remove} operation, or through the {@code setValue} operation on a map entry    * returned by the iterator), the results of the iteration are undefined.    *    *<p>The multimap supports mapping removal, which removes the corresponding    * mapping from the map. It does not support any operations which might add    * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.    *    *<p>The returned multimap will be serializable if the specified map is    * serializable.    *    * @param map the backing map for the returned multimap view    */
DECL|method|forMap (Map<K, V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|forMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|MapMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/** @see Multimaps#forMap */
DECL|class|MapMultimap
specifier|private
specifier|static
class|class
name|MapMultimap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|SetMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|map
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|asMap
specifier|transient
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
decl_stmt|;
DECL|method|MapMultimap (Map<K, V> map)
name|MapMultimap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|containsValue (Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|containsEntry (Object key, Object value)
specifier|public
name|boolean
name|containsEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|contains
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|get (final K key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
specifier|final
name|K
name|key
parameter_list|)
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|public
name|V
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|i
operator|++
expr_stmt|;
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
block|}
return|;
block|}
DECL|method|put (K key, V value)
specifier|public
name|boolean
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll (K key, Iterable<? extends V> values)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|putAll (Multimap<? extends K, ? extends V> multimap)
specifier|public
name|boolean
name|putAll
parameter_list|(
name|Multimap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|multimap
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|replaceValues (K key, Iterable<? extends V> values)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|replaceValues
parameter_list|(
name|K
name|key
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|values
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|remove (Object key, Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|remove
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|removeAll (Object key)
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|removeAll
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|values
init|=
operator|new
name|HashSet
argument_list|<
name|V
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|values
return|;
block|}
name|values
operator|.
name|add
argument_list|(
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|map
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|keys ()
specifier|public
name|Multiset
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
name|Multisets
operator|.
name|forSet
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|entries ()
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|()
block|{
return|return
name|map
operator|.
name|entrySet
argument_list|()
return|;
block|}
DECL|method|asMap ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|asMap
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|result
init|=
name|asMap
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|asMap
operator|=
name|result
operator|=
operator|new
name|AsMap
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|Multimap
condition|)
block|{
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Multimap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|size
argument_list|()
operator|==
name|that
operator|.
name|size
argument_list|()
operator|&&
name|asMap
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|asMap
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|map
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|field|joiner
specifier|private
specifier|static
specifier|final
name|MapJoiner
name|joiner
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|"], "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"=["
argument_list|)
operator|.
name|useForNull
argument_list|(
literal|"null"
argument_list|)
decl_stmt|;
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|map
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"{}"
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|map
operator|.
name|size
argument_list|()
operator|*
literal|16
argument_list|)
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
decl_stmt|;
name|joiner
operator|.
name|appendTo
argument_list|(
name|builder
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|append
argument_list|(
literal|"]}"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @see MapMultimap#asMap */
DECL|class|AsMapEntries
class|class
name|AsMapEntries
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
block|{
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|K
argument_list|>
name|keys
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|keys
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
name|next
parameter_list|()
block|{
specifier|final
name|K
name|key
init|=
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|getValue
parameter_list|()
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|keys
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
operator|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|containsEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|set
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Set
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|?
argument_list|>
name|set
init|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
operator|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|remove
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|set
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** @see MapMultimap#asMap */
DECL|class|AsMap
class|class
name|AsMap
extends|extends
name|Maps
operator|.
name|ImprovedAbstractMap
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
block|{
DECL|method|createEntrySet ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|Collection
argument_list|<
name|V
argument_list|>
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
block|{
return|return
operator|new
name|AsMapEntries
argument_list|()
return|;
block|}
comment|// The following methods are included for performance.
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|MapMultimap
operator|.
name|this
operator|.
name|get
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
decl_stmt|;
return|return
name|collection
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|collection
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|collection
init|=
name|removeAll
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|collection
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|collection
return|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7845222491160860175L
decl_stmt|;
block|}
comment|/**    * Creates an index {@code ImmutableMultimap} that contains the results of    * applying a specified function to each item in an {@code Iterable} of    * values. Each value will be stored as a value in the resulting multimap,    * yielding a multimap with the same size as the input iterable. The key used    * to store that value in the multimap will be the result of calling the    * function on that value. The resulting multimap is created as an immutable    * snapshot, it does<em>not</em> reflect subsequent changes on the input    * iterable.    *    *<p>For example,<pre class="code">  {@code    *    *  List<String> badGuys    *      = Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");    *  Function<String, Integer> stringLengthFunction = ...;    *  Multimap<Integer, String> index    *      = Multimaps.index(badGuys, stringLengthFunction);    *  System.out.println(index);}</pre>    *    * prints<pre class="code">  {@code    *    *  {4=[Inky], 5=[Pinky, Pinky, Clyde], 6=[Blinky]}}</pre>    *    *<p>The returned multimap is serializable if its keys and values are all    * serializable.    *    * @param values the values to use when constructing the {@code    *     ImmutableMultimap}    * @param keyFunction the function used to produce the key for each value    * @return {@code ImmutableMultimap} mapping the result of evaluating the    *     function {@code keyFunction} on each value in the input collection to    *     that value    * @throws NullPointerException if any of the following cases is true:<ul>    *<li> {@code values} is null    *<li> {@code keyFunction} is null    *<li> An element in {@code values} is null    *<li> {@code keyFunction} returns null for any element of {@code values}    *</ul>    */
DECL|method|index ( Iterable<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableListMultimap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|index
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|V
name|value
range|:
name|values
control|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
end_class

end_unit

