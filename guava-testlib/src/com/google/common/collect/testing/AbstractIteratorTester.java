begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect.testing
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
package|;
end_package

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|AssertionFailedError
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/**  * Most of the logic for {@link IteratorTester} and {@link ListIteratorTester}.  *  * @param<E> the type of element returned by the iterator  * @param<I> the type of the iterator ({@link Iterator} or  *     {@link ListIterator})  *  * @author Kevin Bourrillion  * @author Chris Povirk  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|AbstractIteratorTester
specifier|abstract
class|class
name|AbstractIteratorTester
parameter_list|<
name|E
parameter_list|,
name|I
extends|extends
name|Iterator
parameter_list|<
name|E
parameter_list|>
parameter_list|>
block|{
DECL|field|stimuli
specifier|private
name|Stimulus
argument_list|<
name|E
argument_list|,
name|?
super|super
name|I
argument_list|>
index|[]
name|stimuli
decl_stmt|;
DECL|field|elementsToInsert
specifier|private
specifier|final
name|Iterator
argument_list|<
name|E
argument_list|>
name|elementsToInsert
decl_stmt|;
DECL|field|features
specifier|private
specifier|final
name|Set
argument_list|<
name|IteratorFeature
argument_list|>
name|features
decl_stmt|;
DECL|field|expectedElements
specifier|private
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|expectedElements
decl_stmt|;
DECL|field|startIndex
specifier|private
specifier|final
name|int
name|startIndex
decl_stmt|;
DECL|field|knownOrder
specifier|private
specifier|final
name|KnownOrder
name|knownOrder
decl_stmt|;
comment|/**    * Meta-exception thrown by {@link AbstractIteratorTester.MultiExceptionListIterator} instead of    * throwing any particular exception type.    */
DECL|class|PermittedMetaException
specifier|private
specifier|abstract
specifier|static
class|class
name|PermittedMetaException
extends|extends
name|RuntimeException
block|{
DECL|field|UOE_OR_ISE
specifier|static
specifier|final
name|PermittedMetaException
name|UOE_OR_ISE
init|=
operator|new
name|PermittedMetaException
argument_list|(
literal|"UnsupportedOperationException or IllegalStateException"
argument_list|)
block|{
annotation|@
name|Override
name|boolean
name|isPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
return|return
name|exception
operator|instanceof
name|UnsupportedOperationException
operator|||
name|exception
operator|instanceof
name|IllegalStateException
return|;
block|}
block|}
decl_stmt|;
DECL|field|UOE
specifier|static
specifier|final
name|PermittedMetaException
name|UOE
init|=
operator|new
name|PermittedMetaException
argument_list|(
literal|"UnsupportedOperationException"
argument_list|)
block|{
annotation|@
name|Override
name|boolean
name|isPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
return|return
name|exception
operator|instanceof
name|UnsupportedOperationException
return|;
block|}
block|}
decl_stmt|;
DECL|field|ISE
specifier|static
specifier|final
name|PermittedMetaException
name|ISE
init|=
operator|new
name|PermittedMetaException
argument_list|(
literal|"IllegalStateException"
argument_list|)
block|{
annotation|@
name|Override
name|boolean
name|isPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
return|return
name|exception
operator|instanceof
name|IllegalStateException
return|;
block|}
block|}
decl_stmt|;
DECL|field|NSEE
specifier|static
specifier|final
name|PermittedMetaException
name|NSEE
init|=
operator|new
name|PermittedMetaException
argument_list|(
literal|"NoSuchElementException"
argument_list|)
block|{
annotation|@
name|Override
name|boolean
name|isPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
return|return
name|exception
operator|instanceof
name|NoSuchElementException
return|;
block|}
block|}
decl_stmt|;
DECL|method|PermittedMetaException (String message)
specifier|private
name|PermittedMetaException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
DECL|method|isPermitted (RuntimeException exception)
specifier|abstract
name|boolean
name|isPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
function_decl|;
DECL|method|assertPermitted (RuntimeException exception)
name|void
name|assertPermitted
parameter_list|(
name|RuntimeException
name|exception
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isPermitted
argument_list|(
name|exception
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Exception "
operator|+
name|exception
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" was thrown; expected "
operator|+
name|getMessage
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|fail
argument_list|(
name|exception
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
DECL|class|UnknownElementException
specifier|private
specifier|static
specifier|final
class|class
name|UnknownElementException
extends|extends
name|RuntimeException
block|{
DECL|method|UnknownElementException (Collection<?> expected, Object actual)
specifier|private
name|UnknownElementException
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|expected
parameter_list|,
name|Object
name|actual
parameter_list|)
block|{
name|super
argument_list|(
literal|"Returned value '"
operator|+
name|actual
operator|+
literal|"' not found. Remaining elements: "
operator|+
name|expected
argument_list|)
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Quasi-implementation of {@link ListIterator} that works from a list of    * elements and a set of features to support (from the enclosing    * {@link AbstractIteratorTester} instance). Instead of throwing exceptions    * like {@link NoSuchElementException} at the appropriate times, it throws    * {@link PermittedMetaException} instances, which wrap a set of all    * exceptions that the iterator could throw during the invocation of that    * method. This is necessary because, e.g., a call to    * {@code iterator().remove()} of an unmodifiable list could throw either    * {@link IllegalStateException} or {@link UnsupportedOperationException}.    * Note that iterator implementations should always throw one of the    * exceptions in a {@code PermittedExceptions} instance, since    * {@code PermittedExceptions} is thrown only when a method call is invalid.    *    *<p>This class is accessible but not supported in GWT as it references    * {@link PermittedMetaException}.    */
DECL|class|MultiExceptionListIterator
specifier|protected
specifier|final
class|class
name|MultiExceptionListIterator
implements|implements
name|ListIterator
argument_list|<
name|E
argument_list|>
block|{
comment|// TODO: track seen elements when order isn't guaranteed
comment|// TODO: verify contents afterward
comment|// TODO: something shiny and new instead of Stack
comment|// TODO: test whether null is supported (create a Feature)
comment|/**      * The elements to be returned by future calls to {@code next()}, with the      * first at the top of the stack.      */
DECL|field|nextElements
specifier|final
name|Stack
argument_list|<
name|E
argument_list|>
name|nextElements
init|=
operator|new
name|Stack
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The elements to be returned by future calls to {@code previous()}, with      * the first at the top of the stack.      */
DECL|field|previousElements
specifier|final
name|Stack
argument_list|<
name|E
argument_list|>
name|previousElements
init|=
operator|new
name|Stack
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * {@link #nextElements} if {@code next()} was called more recently then      * {@code previous}, {@link #previousElements} if the reverse is true, or --      * overriding both of these -- {@code null} if {@code remove()} or      * {@code add()} has been called more recently than either. We use this to      * determine which stack to pop from on a call to {@code remove()} (or to      * pop from and push to on a call to {@code set()}.      */
DECL|field|stackWithLastReturnedElementAtTop
name|Stack
argument_list|<
name|E
argument_list|>
name|stackWithLastReturnedElementAtTop
init|=
literal|null
decl_stmt|;
DECL|method|MultiExceptionListIterator (List<E> expectedElements)
name|MultiExceptionListIterator
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|expectedElements
parameter_list|)
block|{
name|Helpers
operator|.
name|addAll
argument_list|(
name|nextElements
argument_list|,
name|Helpers
operator|.
name|reverse
argument_list|(
name|expectedElements
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startIndex
condition|;
name|i
operator|++
control|)
block|{
name|previousElements
operator|.
name|push
argument_list|(
name|nextElements
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|add (E e)
specifier|public
name|void
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|features
operator|.
name|contains
argument_list|(
name|IteratorFeature
operator|.
name|SUPPORTS_ADD
argument_list|)
condition|)
block|{
throw|throw
name|PermittedMetaException
operator|.
name|UOE
throw|;
block|}
name|previousElements
operator|.
name|push
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|nextElements
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasPrevious ()
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
operator|!
name|previousElements
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|E
name|next
parameter_list|()
block|{
return|return
name|transferElement
argument_list|(
name|nextElements
argument_list|,
name|previousElements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|nextIndex ()
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|previousElements
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|previous ()
specifier|public
name|E
name|previous
parameter_list|()
block|{
return|return
name|transferElement
argument_list|(
name|previousElements
argument_list|,
name|nextElements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|previousIndex ()
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|nextIndex
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|throwIfInvalid
argument_list|(
name|IteratorFeature
operator|.
name|SUPPORTS_REMOVE
argument_list|)
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|set (E e)
specifier|public
name|void
name|set
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|throwIfInvalid
argument_list|(
name|IteratorFeature
operator|.
name|SUPPORTS_SET
argument_list|)
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|.
name|push
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**      * Moves the given element from its current position in      * {@link #nextElements} to the top of the stack so that it is returned by      * the next call to {@link Iterator#next()}. If the element is not in      * {@link #nextElements}, this method throws an      * {@link UnknownElementException}.      *      *<p>This method is used when testing iterators without a known ordering.      * We poll the target iterator's next element and pass it to the reference      * iterator through this method so it can return the same element. This      * enables the assertion to pass and the reference iterator to properly      * update its state.      */
DECL|method|promoteToNext (E e)
name|void
name|promoteToNext
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|nextElements
operator|.
name|remove
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|nextElements
operator|.
name|push
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnknownElementException
argument_list|(
name|nextElements
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|transferElement (Stack<E> source, Stack<E> destination)
specifier|private
name|E
name|transferElement
parameter_list|(
name|Stack
argument_list|<
name|E
argument_list|>
name|source
parameter_list|,
name|Stack
argument_list|<
name|E
argument_list|>
name|destination
parameter_list|)
block|{
if|if
condition|(
name|source
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|PermittedMetaException
operator|.
name|NSEE
throw|;
block|}
name|destination
operator|.
name|push
argument_list|(
name|source
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|stackWithLastReturnedElementAtTop
operator|=
name|destination
expr_stmt|;
return|return
name|destination
operator|.
name|peek
argument_list|()
return|;
block|}
DECL|method|throwIfInvalid (IteratorFeature methodFeature)
specifier|private
name|void
name|throwIfInvalid
parameter_list|(
name|IteratorFeature
name|methodFeature
parameter_list|)
block|{
if|if
condition|(
operator|!
name|features
operator|.
name|contains
argument_list|(
name|methodFeature
argument_list|)
condition|)
block|{
if|if
condition|(
name|stackWithLastReturnedElementAtTop
operator|==
literal|null
condition|)
block|{
throw|throw
name|PermittedMetaException
operator|.
name|UOE_OR_ISE
throw|;
block|}
else|else
block|{
throw|throw
name|PermittedMetaException
operator|.
name|UOE
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|stackWithLastReturnedElementAtTop
operator|==
literal|null
condition|)
block|{
throw|throw
name|PermittedMetaException
operator|.
name|ISE
throw|;
block|}
block|}
DECL|method|getElements ()
specifier|private
name|List
argument_list|<
name|E
argument_list|>
name|getElements
parameter_list|()
block|{
name|List
argument_list|<
name|E
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|addAll
argument_list|(
name|elements
argument_list|,
name|previousElements
argument_list|)
expr_stmt|;
name|Helpers
operator|.
name|addAll
argument_list|(
name|elements
argument_list|,
name|Helpers
operator|.
name|reverse
argument_list|(
name|nextElements
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|elements
return|;
block|}
block|}
DECL|enum|KnownOrder
specifier|public
enum|enum
name|KnownOrder
block|{
DECL|enumConstant|KNOWN_ORDER
name|KNOWN_ORDER
block|,
DECL|enumConstant|UNKNOWN_ORDER
name|UNKNOWN_ORDER
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// creating array of generic class Stimulus
DECL|method|AbstractIteratorTester ( int steps, Iterable<E> elementsToInsertIterable, Iterable<? extends IteratorFeature> features, Iterable<E> expectedElements, KnownOrder knownOrder, int startIndex)
name|AbstractIteratorTester
parameter_list|(
name|int
name|steps
parameter_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
name|elementsToInsertIterable
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|IteratorFeature
argument_list|>
name|features
parameter_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
name|expectedElements
parameter_list|,
name|KnownOrder
name|knownOrder
parameter_list|,
name|int
name|startIndex
parameter_list|)
block|{
comment|// periodically we should manually try (steps * 3 / 2) here; all tests but
comment|// one should still pass (testVerifyGetsCalled()).
name|stimuli
operator|=
operator|new
name|Stimulus
index|[
name|steps
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|elementsToInsertIterable
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|elementsToInsert
operator|=
name|Helpers
operator|.
name|cycle
argument_list|(
name|elementsToInsertIterable
argument_list|)
expr_stmt|;
name|this
operator|.
name|features
operator|=
name|Helpers
operator|.
name|copyToSet
argument_list|(
name|features
argument_list|)
expr_stmt|;
name|this
operator|.
name|expectedElements
operator|=
name|Helpers
operator|.
name|copyToList
argument_list|(
name|expectedElements
argument_list|)
expr_stmt|;
name|this
operator|.
name|knownOrder
operator|=
name|knownOrder
expr_stmt|;
name|this
operator|.
name|startIndex
operator|=
name|startIndex
expr_stmt|;
block|}
comment|/**    * I'd like to make this a parameter to the constructor, but I can't because    * the stimulus instances refer to {@code this}.    */
DECL|method|getStimulusValues ()
specifier|protected
specifier|abstract
name|Iterable
argument_list|<
name|?
extends|extends
name|Stimulus
argument_list|<
name|E
argument_list|,
name|?
super|super
name|I
argument_list|>
argument_list|>
name|getStimulusValues
parameter_list|()
function_decl|;
comment|/**    * Returns a new target iterator each time it's called. This is the iterator    * you are trying to test. This must return an Iterator that returns the    * expected elements passed to the constructor in the given order. Warning: it    * is not enough to simply pull multiple iterators from the same source    * Iterable, unless that Iterator is unmodifiable.    */
DECL|method|newTargetIterator ()
specifier|protected
specifier|abstract
name|I
name|newTargetIterator
parameter_list|()
function_decl|;
comment|/**    * Override this to verify anything after running a list of Stimuli.    *    *<p>For example, verify that calls to remove() actually removed    * the correct elements.    *    * @param elements the expected elements passed to the constructor, as mutated    *     by {@code remove()}, {@code set()}, and {@code add()} calls    */
DECL|method|verify (List<E> elements)
specifier|protected
name|void
name|verify
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|)
block|{}
comment|/**    * Executes the test.    */
DECL|method|test ()
specifier|public
specifier|final
name|void
name|test
parameter_list|()
block|{
try|try
block|{
name|recurse
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|stimuli
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|recurse (int level)
specifier|private
name|void
name|recurse
parameter_list|(
name|int
name|level
parameter_list|)
block|{
comment|// We're going to reuse the stimuli array 3^steps times by overwriting it
comment|// in a recursive loop.  Sneaky.
if|if
condition|(
name|level
operator|==
name|stimuli
operator|.
name|length
condition|)
block|{
comment|// We've filled the array.
name|compareResultsForThisListOfStimuli
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Keep recursing to fill the array.
for|for
control|(
name|Stimulus
argument_list|<
name|E
argument_list|,
name|?
super|super
name|I
argument_list|>
name|stimulus
range|:
name|getStimulusValues
argument_list|()
control|)
block|{
name|stimuli
index|[
name|level
index|]
operator|=
name|stimulus
expr_stmt|;
name|recurse
argument_list|(
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|compareResultsForThisListOfStimuli ()
specifier|private
name|void
name|compareResultsForThisListOfStimuli
parameter_list|()
block|{
name|int
name|removes
init|=
name|Collections
operator|.
name|frequency
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|stimuli
argument_list|)
argument_list|,
name|remove
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|features
operator|.
name|contains
argument_list|(
name|IteratorFeature
operator|.
name|SUPPORTS_REMOVE
argument_list|)
operator|&&
name|removes
operator|>
literal|1
operator|)
operator|||
operator|(
name|stimuli
operator|.
name|length
operator|>=
literal|5
operator|&&
name|removes
operator|>
literal|2
operator|)
condition|)
block|{
comment|// removes are the most expensive thing to test, since they often throw exceptions with stack
comment|// traces, so we test them a bit less aggressively
return|return;
block|}
name|MultiExceptionListIterator
name|reference
init|=
operator|new
name|MultiExceptionListIterator
argument_list|(
name|expectedElements
argument_list|)
decl_stmt|;
name|I
name|target
init|=
name|newTargetIterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stimuli
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|stimuli
index|[
name|i
index|]
operator|.
name|executeAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|reference
operator|.
name|getElements
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|cause
parameter_list|)
block|{
name|Helpers
operator|.
name|fail
argument_list|(
name|cause
argument_list|,
literal|"failed with stimuli "
operator|+
name|subListCopy
argument_list|(
name|stimuli
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|subListCopy (Object[] source, int size)
specifier|private
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|subListCopy
parameter_list|(
name|Object
index|[]
name|source
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|final
name|Object
index|[]
name|copy
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|copy
argument_list|)
return|;
block|}
DECL|interface|IteratorOperation
specifier|private
interface|interface
name|IteratorOperation
block|{
DECL|method|execute (Iterator<?> iterator)
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
function_decl|;
block|}
comment|/**    * Apply this method to both iterators and return normally only if both    * produce the same response.    *    * @see Stimulus#executeAndCompare(ListIterator, Iterator)    */
DECL|method|internalExecuteAndCompare ( T reference, T target, IteratorOperation method)
specifier|private
parameter_list|<
name|T
extends|extends
name|Iterator
argument_list|<
name|E
argument_list|>
parameter_list|>
name|void
name|internalExecuteAndCompare
parameter_list|(
name|T
name|reference
parameter_list|,
name|T
name|target
parameter_list|,
name|IteratorOperation
name|method
parameter_list|)
block|{
name|Object
name|referenceReturnValue
init|=
literal|null
decl_stmt|;
name|PermittedMetaException
name|referenceException
init|=
literal|null
decl_stmt|;
name|Object
name|targetReturnValue
init|=
literal|null
decl_stmt|;
name|RuntimeException
name|targetException
init|=
literal|null
decl_stmt|;
try|try
block|{
name|targetReturnValue
operator|=
name|method
operator|.
name|execute
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|targetException
operator|=
name|e
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|method
operator|==
name|NEXT_METHOD
operator|&&
name|targetException
operator|==
literal|null
operator|&&
name|knownOrder
operator|==
name|KnownOrder
operator|.
name|UNKNOWN_ORDER
condition|)
block|{
comment|/*          * We already know the iterator is an Iterator<E>, and now we know that          * we called next(), so the returned element must be of type E.          */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|targetReturnValueFromNext
init|=
operator|(
name|E
operator|)
name|targetReturnValue
decl_stmt|;
comment|/*          * We have an Iterator<E> and want to cast it to          * MultiExceptionListIterator. Because we're inside an          * AbstractIteratorTester<E>, that's implicitly a cast to          * AbstractIteratorTester<E>.MultiExceptionListIterator. The runtime          * won't be able to verify the AbstractIteratorTester<E> part, so it's          * an unchecked cast. We know, however, that the only possible value for          * the type parameter is<E>, since otherwise the          * MultiExceptionListIterator wouldn't be an Iterator<E>. The cast is          * safe, even though javac can't tell.          *          * Sun bug 6665356 is an additional complication. Until OpenJDK 7, javac          * doesn't recognize this kind of cast as unchecked cast. Neither does          * Eclipse 3.4. Right now, this suppression is mostly unecessary.          */
name|MultiExceptionListIterator
name|multiExceptionListIterator
init|=
operator|(
name|MultiExceptionListIterator
operator|)
name|reference
decl_stmt|;
name|multiExceptionListIterator
operator|.
name|promoteToNext
argument_list|(
name|targetReturnValueFromNext
argument_list|)
expr_stmt|;
block|}
name|referenceReturnValue
operator|=
name|method
operator|.
name|execute
argument_list|(
name|reference
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PermittedMetaException
name|e
parameter_list|)
block|{
name|referenceException
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownElementException
name|e
parameter_list|)
block|{
name|Helpers
operator|.
name|fail
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|referenceException
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|targetException
operator|!=
literal|null
condition|)
block|{
name|Helpers
operator|.
name|fail
argument_list|(
name|targetException
argument_list|,
literal|"Target threw exception when reference did not"
argument_list|)
expr_stmt|;
block|}
comment|/*        * Reference iterator returned a value, so we should expect the        * same value from the target        */
name|assertEquals
argument_list|(
name|referenceReturnValue
argument_list|,
name|targetReturnValue
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|targetException
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|(
literal|"Target failed to throw "
operator|+
name|referenceException
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reference iterator threw an exception, so we should expect an acceptable      * exception from the target.      */
name|referenceException
operator|.
name|assertPermitted
argument_list|(
name|targetException
argument_list|)
expr_stmt|;
block|}
DECL|field|REMOVE_METHOD
specifier|private
specifier|static
specifier|final
name|IteratorOperation
name|REMOVE_METHOD
init|=
operator|new
name|IteratorOperation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
DECL|field|NEXT_METHOD
specifier|private
specifier|static
specifier|final
name|IteratorOperation
name|NEXT_METHOD
init|=
operator|new
name|IteratorOperation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|PREVIOUS_METHOD
specifier|private
specifier|static
specifier|final
name|IteratorOperation
name|PREVIOUS_METHOD
init|=
operator|new
name|IteratorOperation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ListIterator
argument_list|<
name|?
argument_list|>
operator|)
name|iterator
operator|)
operator|.
name|previous
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|newAddMethod ()
specifier|private
specifier|final
name|IteratorOperation
name|newAddMethod
parameter_list|()
block|{
specifier|final
name|Object
name|toInsert
init|=
name|elementsToInsert
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|IteratorOperation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ListIterator
argument_list|<
name|Object
argument_list|>
name|rawIterator
init|=
operator|(
name|ListIterator
argument_list|<
name|Object
argument_list|>
operator|)
name|iterator
decl_stmt|;
name|rawIterator
operator|.
name|add
argument_list|(
name|toInsert
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|newSetMethod ()
specifier|private
specifier|final
name|IteratorOperation
name|newSetMethod
parameter_list|()
block|{
specifier|final
name|E
name|toInsert
init|=
name|elementsToInsert
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|IteratorOperation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|execute
parameter_list|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ListIterator
argument_list|<
name|E
argument_list|>
name|li
init|=
operator|(
name|ListIterator
argument_list|<
name|E
argument_list|>
operator|)
name|iterator
decl_stmt|;
name|li
operator|.
name|set
argument_list|(
name|toInsert
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|class|Stimulus
specifier|abstract
specifier|static
class|class
name|Stimulus
parameter_list|<
name|E
parameter_list|,
name|T
extends|extends
name|Iterator
parameter_list|<
name|E
parameter_list|>
parameter_list|>
block|{
DECL|field|toString
specifier|private
specifier|final
name|String
name|toString
decl_stmt|;
DECL|method|Stimulus (String toString)
specifier|protected
name|Stimulus
parameter_list|(
name|String
name|toString
parameter_list|)
block|{
name|this
operator|.
name|toString
operator|=
name|toString
expr_stmt|;
block|}
comment|/**      * Send this stimulus to both iterators and return normally only if both      * produce the same response.      */
DECL|method|executeAndCompare (ListIterator<E> reference, T target)
specifier|abstract
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|T
name|target
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
return|;
block|}
block|}
DECL|field|hasNext
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|hasNext
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"hasNext"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|reference
operator|.
name|hasNext
argument_list|()
argument_list|,
name|target
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|next
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|next
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"next"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|internalExecuteAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|,
name|NEXT_METHOD
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|remove
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|remove
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"remove"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|internalExecuteAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|,
name|REMOVE_METHOD
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|iteratorStimuli ()
name|List
argument_list|<
name|Stimulus
argument_list|<
name|E
argument_list|,
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|>
name|iteratorStimuli
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|hasNext
argument_list|,
name|next
argument_list|,
name|remove
argument_list|)
return|;
block|}
DECL|field|hasPrevious
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|hasPrevious
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"hasPrevious"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|reference
operator|.
name|hasPrevious
argument_list|()
argument_list|,
name|target
operator|.
name|hasPrevious
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|nextIndex
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|nextIndex
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"nextIndex"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|reference
operator|.
name|nextIndex
argument_list|()
argument_list|,
name|target
operator|.
name|nextIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|previousIndex
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|previousIndex
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"previousIndex"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|reference
operator|.
name|previousIndex
argument_list|()
argument_list|,
name|target
operator|.
name|previousIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|previous
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|previous
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"previous"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|internalExecuteAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|,
name|PREVIOUS_METHOD
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|add
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|add
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"add"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|internalExecuteAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|,
name|newAddMethod
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|set
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|(
literal|"set"
argument_list|)
block|{
annotation|@
name|Override
name|void
name|executeAndCompare
parameter_list|(
name|ListIterator
argument_list|<
name|E
argument_list|>
name|reference
parameter_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
name|target
parameter_list|)
block|{
name|internalExecuteAndCompare
argument_list|(
name|reference
argument_list|,
name|target
argument_list|,
name|newSetMethod
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|listIteratorStimuli ()
name|List
argument_list|<
name|Stimulus
argument_list|<
name|E
argument_list|,
name|ListIterator
argument_list|<
name|E
argument_list|>
argument_list|>
argument_list|>
name|listIteratorStimuli
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|hasPrevious
argument_list|,
name|nextIndex
argument_list|,
name|previousIndex
argument_list|,
name|previous
argument_list|,
name|add
argument_list|,
name|set
argument_list|)
return|;
block|}
block|}
end_class

end_unit

