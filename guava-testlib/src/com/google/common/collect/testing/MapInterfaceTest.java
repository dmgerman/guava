begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect.testing
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singleton
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Tests representing the contract of {@link Map}. Concrete subclasses of this  * base class test conformance of concrete {@link Map} subclasses to that  * contract.  *  * TODO: Descriptive assertion messages, with hints as to probable  * fixes.  * TODO: Add another constructor parameter indicating whether the  * class under test is ordered, and check the order if so.  * TODO: Refactor to share code with SetTestBuilder&c.  *  * @param<K> the type of keys used by the maps under test  * @param<V> the type of mapped values used the maps under test  *  * @author George van den Driessche  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|MapInterfaceTest
specifier|public
specifier|abstract
class|class
name|MapInterfaceTest
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|TestCase
block|{
comment|/** A key type that is not assignable to any classes but Object. */
DECL|class|IncompatibleKeyType
specifier|private
specifier|static
specifier|final
class|class
name|IncompatibleKeyType
block|{
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IncompatibleKeyType"
return|;
block|}
block|}
DECL|field|supportsPut
specifier|protected
specifier|final
name|boolean
name|supportsPut
decl_stmt|;
DECL|field|supportsRemove
specifier|protected
specifier|final
name|boolean
name|supportsRemove
decl_stmt|;
DECL|field|supportsClear
specifier|protected
specifier|final
name|boolean
name|supportsClear
decl_stmt|;
DECL|field|allowsNullKeys
specifier|protected
specifier|final
name|boolean
name|allowsNullKeys
decl_stmt|;
DECL|field|allowsNullValues
specifier|protected
specifier|final
name|boolean
name|allowsNullValues
decl_stmt|;
DECL|field|supportsIteratorRemove
specifier|protected
specifier|final
name|boolean
name|supportsIteratorRemove
decl_stmt|;
comment|/**    * Creates a new, empty instance of the class under test.    *    * @return a new, empty map instance.    * @throws UnsupportedOperationException if it's not possible to make an    * empty instance of the class under test.    */
DECL|method|makeEmptyMap ()
specifier|protected
specifier|abstract
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeEmptyMap
parameter_list|()
throws|throws
name|UnsupportedOperationException
function_decl|;
comment|/**    * Creates a new, non-empty instance of the class under test.    *    * @return a new, non-empty map instance.    * @throws UnsupportedOperationException if it's not possible to make a    * non-empty instance of the class under test.    */
DECL|method|makePopulatedMap ()
specifier|protected
specifier|abstract
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makePopulatedMap
parameter_list|()
throws|throws
name|UnsupportedOperationException
function_decl|;
comment|/**    * Creates a new key that is not expected to be found    * in {@link #makePopulatedMap()}.    *    * @return a key.    * @throws UnsupportedOperationException if it's not possible to make a key    * that will not be found in the map.    */
DECL|method|getKeyNotInPopulatedMap ()
specifier|protected
specifier|abstract
name|K
name|getKeyNotInPopulatedMap
parameter_list|()
throws|throws
name|UnsupportedOperationException
function_decl|;
comment|/**    * Creates a new value that is not expected to be found    * in {@link #makePopulatedMap()}.    *    * @return a value.    * @throws UnsupportedOperationException if it's not possible to make a value    * that will not be found in the map.    */
DECL|method|getValueNotInPopulatedMap ()
specifier|protected
specifier|abstract
name|V
name|getValueNotInPopulatedMap
parameter_list|()
throws|throws
name|UnsupportedOperationException
function_decl|;
comment|/**    * Constructor that assigns {@code supportsIteratorRemove} the same value as    * {@code supportsRemove}.    */
DECL|method|MapInterfaceTest ( boolean allowsNullKeys, boolean allowsNullValues, boolean supportsPut, boolean supportsRemove, boolean supportsClear)
specifier|protected
name|MapInterfaceTest
parameter_list|(
name|boolean
name|allowsNullKeys
parameter_list|,
name|boolean
name|allowsNullValues
parameter_list|,
name|boolean
name|supportsPut
parameter_list|,
name|boolean
name|supportsRemove
parameter_list|,
name|boolean
name|supportsClear
parameter_list|)
block|{
name|this
argument_list|(
name|allowsNullKeys
argument_list|,
name|allowsNullValues
argument_list|,
name|supportsPut
argument_list|,
name|supportsRemove
argument_list|,
name|supportsClear
argument_list|,
name|supportsRemove
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor with an explicit {@code supportsIteratorRemove} parameter.    */
DECL|method|MapInterfaceTest ( boolean allowsNullKeys, boolean allowsNullValues, boolean supportsPut, boolean supportsRemove, boolean supportsClear, boolean supportsIteratorRemove)
specifier|protected
name|MapInterfaceTest
parameter_list|(
name|boolean
name|allowsNullKeys
parameter_list|,
name|boolean
name|allowsNullValues
parameter_list|,
name|boolean
name|supportsPut
parameter_list|,
name|boolean
name|supportsRemove
parameter_list|,
name|boolean
name|supportsClear
parameter_list|,
name|boolean
name|supportsIteratorRemove
parameter_list|)
block|{
name|this
operator|.
name|supportsPut
operator|=
name|supportsPut
expr_stmt|;
name|this
operator|.
name|supportsRemove
operator|=
name|supportsRemove
expr_stmt|;
name|this
operator|.
name|supportsClear
operator|=
name|supportsClear
expr_stmt|;
name|this
operator|.
name|allowsNullKeys
operator|=
name|allowsNullKeys
expr_stmt|;
name|this
operator|.
name|allowsNullValues
operator|=
name|allowsNullValues
expr_stmt|;
name|this
operator|.
name|supportsIteratorRemove
operator|=
name|supportsIteratorRemove
expr_stmt|;
block|}
comment|/**    * Used by tests that require a map, but don't care whether it's    * populated or not.    *    * @return a new map instance.    */
DECL|method|makeEitherMap ()
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeEitherMap
parameter_list|()
block|{
try|try
block|{
return|return
name|makePopulatedMap
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return
name|makeEmptyMap
argument_list|()
return|;
block|}
block|}
DECL|method|supportsValuesHashCode (Map<K, V> map)
specifier|protected
specifier|final
name|boolean
name|supportsValuesHashCode
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
comment|// get the first non-null value
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|V
name|value
range|:
name|values
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|value
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Checks all the properties that should always hold of a map. Also calls    * {@link #assertMoreInvariants} to check invariants that are peculiar to    * specific implementations.    *    * @see #assertMoreInvariants    * @param map the map to check.    */
DECL|method|assertInvariants (Map<K, V> map)
specifier|protected
specifier|final
name|void
name|assertInvariants
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|keySet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|keySet
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|keySet
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|!
name|keySet
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|keySet
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|expectedKeySetHash
init|=
literal|0
decl_stmt|;
for|for
control|(
name|K
name|key
range|:
name|keySet
control|)
block|{
name|V
name|value
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|expectedKeySetHash
operator|+=
name|key
operator|!=
literal|null
condition|?
name|key
operator|.
name|hashCode
argument_list|()
else|:
literal|0
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|valueCollection
operator|.
name|contains
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|valueCollection
operator|.
name|containsAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|mapEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|allowsNullKeys
operator|||
operator|(
name|key
operator|!=
literal|null
operator|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedKeySetHash
argument_list|,
name|keySet
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|valueCollection
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueCollection
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|valueCollection
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|!
name|valueCollection
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|valueCollection
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|V
name|value
range|:
name|valueCollection
control|)
block|{
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|allowsNullValues
operator|||
operator|(
name|value
operator|!=
literal|null
operator|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|entrySet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|entrySet
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|entrySet
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|!
name|entrySet
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|supportsValuesHashCode
init|=
name|supportsValuesHashCode
argument_list|(
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsValuesHashCode
condition|)
block|{
name|int
name|expectedEntrySetHash
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|entrySet
control|)
block|{
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|expectedHash
init|=
operator|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|)
operator|^
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedHash
argument_list|,
name|entry
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|expectedEntrySetHash
operator|+=
name|expectedHash
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedEntrySetHash
argument_list|,
name|entrySet
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|containsAll
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|entrySet
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|equals
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|entrySet
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Object
index|[]
name|entrySetToArray1
init|=
name|entrySet
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|entrySetToArray1
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|entrySetToArray1
argument_list|)
operator|.
name|containsAll
argument_list|(
name|entrySet
argument_list|)
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[]
name|entrySetToArray2
init|=
operator|new
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|map
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|entrySetToArray2
index|[
name|map
operator|.
name|size
argument_list|()
index|]
operator|=
name|mapEntry
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|entrySetToArray2
argument_list|,
name|entrySet
operator|.
name|toArray
argument_list|(
name|entrySetToArray2
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|entrySetToArray2
index|[
name|map
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|entrySetToArray2
argument_list|)
operator|.
name|containsAll
argument_list|(
name|entrySet
argument_list|)
argument_list|)
expr_stmt|;
name|Object
index|[]
name|valuesToArray1
init|=
name|valueCollection
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|valuesToArray1
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|valuesToArray1
argument_list|)
operator|.
name|containsAll
argument_list|(
name|valueCollection
argument_list|)
argument_list|)
expr_stmt|;
name|Object
index|[]
name|valuesToArray2
init|=
operator|new
name|Object
index|[
name|map
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|valuesToArray2
index|[
name|map
operator|.
name|size
argument_list|()
index|]
operator|=
literal|"foo"
expr_stmt|;
name|assertSame
argument_list|(
name|valuesToArray2
argument_list|,
name|valueCollection
operator|.
name|toArray
argument_list|(
name|valuesToArray2
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|valuesToArray2
index|[
name|map
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|valuesToArray2
argument_list|)
operator|.
name|containsAll
argument_list|(
name|valueCollection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportsValuesHashCode
condition|)
block|{
name|int
name|expectedHash
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|entrySet
control|)
block|{
name|expectedHash
operator|+=
name|entry
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedHash
argument_list|,
name|map
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertMoreInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**    * Override this to check invariants which should hold true for a particular    * implementation, but which are not generally applicable to every instance    * of Map.    *    * @param map the map whose additional invariants to check.    */
DECL|method|assertMoreInvariants (Map<K, V> map)
specifier|protected
name|void
name|assertMoreInvariants
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{}
DECL|method|testClear ()
specifier|public
name|void
name|testClear
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|supportsClear
condition|)
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testContainsKey ()
specifier|public
name|void
name|testContainsKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|unmappedKey
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|unmappedKey
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|unmappedKey
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
operator|new
name|IncompatibleKeyType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|tolerated
parameter_list|)
block|{     }
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowsNullKeys
condition|)
block|{
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|optional
parameter_list|)
block|{       }
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testContainsValue ()
specifier|public
name|void
name|testContainsValue
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertFalse
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|unmappedValue
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|map
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowsNullValues
condition|)
block|{
name|map
operator|.
name|containsValue
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|optional
parameter_list|)
block|{       }
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySet ()
specifier|public
name|void
name|testEntrySet
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entrySet
operator|=
name|map
operator|.
name|entrySet
argument_list|()
expr_stmt|;
specifier|final
name|K
name|unmappedKey
decl_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedKey
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|entrySet
control|)
block|{
name|assertFalse
argument_list|(
name|unmappedKey
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|unmappedValue
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testEntrySetForEmptyMap ()
specifier|public
name|void
name|testEntrySetForEmptyMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetContainsEntryIncompatibleKey ()
specifier|public
name|void
name|testEntrySetContainsEntryIncompatibleKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entrySet
operator|=
name|map
operator|.
name|entrySet
argument_list|()
expr_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Entry
argument_list|<
name|IncompatibleKeyType
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
operator|new
name|IncompatibleKeyType
argument_list|()
argument_list|,
name|unmappedValue
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|tolerated
parameter_list|)
block|{     }
block|}
DECL|method|testEntrySetContainsEntryNullKeyPresent ()
specifier|public
name|void
name|testEntrySetContainsEntryNullKeyPresent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|allowsNullKeys
operator|||
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entrySet
operator|=
name|map
operator|.
name|entrySet
argument_list|()
expr_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|unmappedValue
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
literal|null
argument_list|,
name|unmappedValue
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|mapEntry
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetContainsEntryNullKeyMissing ()
specifier|public
name|void
name|testEntrySetContainsEntryNullKeyMissing
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entrySet
operator|=
name|map
operator|.
name|entrySet
argument_list|()
expr_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
literal|null
argument_list|,
name|unmappedValue
argument_list|)
decl_stmt|;
try|try
block|{
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|allowsNullKeys
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|mapEntry
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|allowsNullKeys
operator|&&
name|allowsNullValues
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testEntrySetIteratorRemove ()
specifier|public
name|void
name|testEntrySetIteratorRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|entrySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsIteratorRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entryCopy
init|=
name|Helpers
operator|.
name|mapEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Use "entryCopy" instead of "entry" because "entry" might be invalidated after
comment|// iterator.remove().
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entryCopy
argument_list|)
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemove ()
specifier|public
name|void
name|testEntrySetRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|remove
argument_list|(
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveMissingKey ()
specifier|public
name|void
name|testEntrySetRemoveMissingKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|key
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
name|key
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
name|key
argument_list|,
name|getValueNotInPopulatedMap
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|optional
parameter_list|)
block|{       }
block|}
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveDifferentValue ()
specifier|public
name|void
name|testEntrySetRemoveDifferentValue
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
name|key
argument_list|,
name|getValueNotInPopulatedMap
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|optional
parameter_list|)
block|{       }
block|}
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveNullKeyPresent ()
specifier|public
name|void
name|testEntrySetRemoveNullKeyPresent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|allowsNullKeys
operator|||
operator|!
name|supportsPut
operator|||
operator|!
name|supportsRemove
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entrySet
operator|=
name|map
operator|.
name|entrySet
argument_list|()
expr_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|unmappedValue
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|unmappedValue
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
literal|null
argument_list|,
name|unmappedValue
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveNullKeyMissing ()
specifier|public
name|void
name|testEntrySetRemoveNullKeyMissing
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|mapEntry
argument_list|(
literal|null
argument_list|,
name|getValueNotInPopulatedMap
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|allowsNullKeys
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|optional
parameter_list|)
block|{       }
block|}
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveAll ()
specifier|public
name|void
name|testEntrySetRemoveAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entryToRemove
init|=
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entriesToRemove
init|=
name|singleton
argument_list|(
name|entryToRemove
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
comment|// We use a copy of "entryToRemove" in the assertion because "entryToRemove" might be
comment|// invalidated and have undefined behavior after entrySet.removeAll(entriesToRemove),
comment|// for example entryToRemove.getValue() might be null.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entryToRemoveCopy
init|=
name|Helpers
operator|.
name|mapEntry
argument_list|(
name|entryToRemove
operator|.
name|getKey
argument_list|()
argument_list|,
name|entryToRemove
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|removeAll
argument_list|(
name|entriesToRemove
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|didRemove
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
name|entriesToRemove
operator|.
name|size
argument_list|()
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Use "entryToRemoveCopy" instead of "entryToRemove" because it might be invalidated and
comment|// have undefined behavior after entrySet.removeAll(entriesToRemove),
name|assertFalse
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entryToRemoveCopy
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|removeAll
argument_list|(
name|entriesToRemove
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRemoveAllNullFromEmpty ()
specifier|public
name|void
name|testEntrySetRemoveAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|entrySet
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException or NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRetainAll ()
specifier|public
name|void
name|testEntrySetRetainAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entriesToRetain
init|=
name|singleton
argument_list|(
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|boolean
name|shouldRemove
init|=
operator|(
name|entrySet
operator|.
name|size
argument_list|()
operator|>
name|entriesToRetain
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|didRemove
init|=
name|entrySet
operator|.
name|retainAll
argument_list|(
name|entriesToRetain
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|shouldRemove
argument_list|,
name|didRemove
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|entriesToRetain
operator|.
name|size
argument_list|()
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|entriesToRetain
control|)
block|{
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|retainAll
argument_list|(
name|entriesToRetain
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetRetainAllNullFromEmpty ()
specifier|public
name|void
name|testEntrySetRetainAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|entrySet
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Returning successfully is not ideal, but tolerated.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We have to tolerate a successful return (Sun bug 4802647)
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetClear ()
specifier|public
name|void
name|testEntrySetClear
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsClear
condition|)
block|{
name|entrySet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|entrySet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetAddAndAddAll ()
specifier|public
name|void
name|testEntrySetAddAndAddAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entryToAdd
init|=
name|mapEntry
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|entrySet
operator|.
name|add
argument_list|(
name|entryToAdd
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException or NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
name|entrySet
operator|.
name|addAll
argument_list|(
name|singleton
argument_list|(
name|entryToAdd
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException or NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetSetValue ()
specifier|public
name|void
name|testEntrySetSetValue
parameter_list|()
block|{
comment|// TODO: Investigate the extent to which, in practice, maps that support
comment|// put() also support Entry.setValue().
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|V
name|valueToSet
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|valueToSet
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|V
name|oldValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|V
name|returnedValue
init|=
name|entry
operator|.
name|setValue
argument_list|(
name|valueToSet
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|returnedValue
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|mapEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|valueToSet
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueToSet
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEntrySetSetValueSameValue ()
specifier|public
name|void
name|testEntrySetSetValueSameValue
parameter_list|()
block|{
comment|// TODO: Investigate the extent to which, in practice, maps that support
comment|// put() also support Entry.setValue().
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|entrySet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|V
name|oldValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|V
name|returnedValue
init|=
name|entry
operator|.
name|setValue
argument_list|(
name|oldValue
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|returnedValue
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|entrySet
operator|.
name|contains
argument_list|(
name|mapEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|oldValue
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEqualsForEqualMap ()
specifier|public
name|void
name|testEqualsForEqualMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertEquals
argument_list|(
name|map
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|makePopulatedMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//no-inspection ObjectEqualsNull
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testEqualsForLargerMap ()
specifier|public
name|void
name|testEqualsForLargerMap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|largerMap
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|largerMap
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|largerMap
operator|.
name|put
argument_list|(
name|getKeyNotInPopulatedMap
argument_list|()
argument_list|,
name|getValueNotInPopulatedMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
name|largerMap
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testEqualsForSmallerMap ()
specifier|public
name|void
name|testEqualsForSmallerMap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsRemove
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|smallerMap
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|smallerMap
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|smallerMap
operator|.
name|remove
argument_list|(
name|smallerMap
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
name|smallerMap
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testEqualsForEmptyMap ()
specifier|public
name|void
name|testEqualsForEmptyMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertEquals
argument_list|(
name|map
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|makeEmptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
name|Collections
operator|.
name|emptySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//noinspection ObjectEqualsNull
name|assertFalse
argument_list|(
name|map
operator|.
name|equals
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGet ()
specifier|public
name|void
name|testGet
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|K
name|unmappedKey
init|=
literal|null
decl_stmt|;
try|try
block|{
name|unmappedKey
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|unmappedKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetForEmptyMap ()
specifier|public
name|void
name|testGetForEmptyMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
name|K
name|unmappedKey
init|=
literal|null
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
name|unmappedKey
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|unmappedKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetNull ()
specifier|public
name|void
name|testGetNull
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|allowsNullKeys
condition|)
block|{
if|if
condition|(
name|allowsNullValues
condition|)
block|{
comment|// TODO: decide what to test here.
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|optional
parameter_list|)
block|{       }
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashCode ()
specifier|public
name|void
name|testHashCode
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashCodeForEmptyMap ()
specifier|public
name|void
name|testHashCodeForEmptyMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutNewKey ()
specifier|public
name|void
name|testPutNewKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
specifier|final
name|V
name|valueToPut
decl_stmt|;
try|try
block|{
name|keyToPut
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
name|valueToPut
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|supportsPut
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|V
name|oldValue
init|=
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|valueToPut
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|valueToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|+
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutExistingKey ()
specifier|public
name|void
name|testPutExistingKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
specifier|final
name|V
name|valueToPut
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|valueToPut
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|keyToPut
operator|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|supportsPut
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueToPut
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|valueToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutNullKey ()
specifier|public
name|void
name|testPutNullKey
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
specifier|final
name|V
name|valueToPut
decl_stmt|;
try|try
block|{
name|valueToPut
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|allowsNullKeys
condition|)
block|{
specifier|final
name|V
name|oldValue
init|=
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|V
name|returnedValue
init|=
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|valueToPut
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|returnedValue
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueToPut
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|valueToPut
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|valueToPut
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected RuntimeException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutNullValue ()
specifier|public
name|void
name|testPutNullValue
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
try|try
block|{
name|keyToPut
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|allowsNullValues
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|V
name|oldValue
init|=
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
decl_stmt|;
specifier|final
name|V
name|returnedValue
init|=
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|returnedValue
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|+
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected RuntimeException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutNullValueForExistingKey ()
specifier|public
name|void
name|testPutNullValueForExistingKey
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsPut
condition|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|keyToPut
operator|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|allowsNullValues
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|V
name|oldValue
init|=
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
decl_stmt|;
specifier|final
name|V
name|returnedValue
init|=
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|oldValue
argument_list|,
name|returnedValue
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|put
argument_list|(
name|keyToPut
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected RuntimeException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutAllNewKey ()
specifier|public
name|void
name|testPutAllNewKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|makeEitherMap
argument_list|()
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
specifier|final
name|V
name|valueToPut
decl_stmt|;
try|try
block|{
name|keyToPut
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
name|valueToPut
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapToPut
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsPut
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|map
operator|.
name|putAll
argument_list|(
name|mapToPut
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueToPut
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|valueToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|+
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|putAll
argument_list|(
name|mapToPut
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testPutAllExistingKey ()
specifier|public
name|void
name|testPutAllExistingKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|keyToPut
decl_stmt|;
specifier|final
name|V
name|valueToPut
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|valueToPut
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|keyToPut
operator|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapToPut
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|keyToPut
argument_list|,
name|valueToPut
argument_list|)
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsPut
condition|)
block|{
name|map
operator|.
name|putAll
argument_list|(
name|mapToPut
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valueToPut
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToPut
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsValue
argument_list|(
name|valueToPut
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|putAll
argument_list|(
name|mapToPut
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemove ()
specifier|public
name|void
name|testRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|keyToRemove
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|keyToRemove
operator|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|V
name|expectedValue
init|=
name|map
operator|.
name|get
argument_list|(
name|keyToRemove
argument_list|)
decl_stmt|;
name|V
name|oldValue
init|=
name|map
operator|.
name|remove
argument_list|(
name|keyToRemove
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedValue
argument_list|,
name|oldValue
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|keyToRemove
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|remove
argument_list|(
name|keyToRemove
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testRemoveMissingKey ()
specifier|public
name|void
name|testRemoveMissingKey
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|K
name|keyToRemove
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
name|keyToRemove
operator|=
name|getKeyNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|remove
argument_list|(
name|keyToRemove
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|map
operator|.
name|remove
argument_list|(
name|keyToRemove
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testSize ()
specifier|public
name|void
name|testSize
parameter_list|()
block|{
name|assertInvariants
argument_list|(
name|makeEitherMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetRemove ()
specifier|public
name|void
name|testKeySetRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keys
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|keys
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|keys
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|keys
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetRemoveAll ()
specifier|public
name|void
name|testKeySetRemoveAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keys
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|keys
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|keys
operator|.
name|removeAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|keys
operator|.
name|removeAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetRetainAll ()
specifier|public
name|void
name|testKeySetRetainAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keys
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|K
name|key
init|=
name|keys
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|keys
operator|.
name|retainAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|keys
operator|.
name|retainAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetClear ()
specifier|public
name|void
name|testKeySetClear
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsClear
condition|)
block|{
name|keySet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|keySet
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|keySet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetRemoveAllNullFromEmpty ()
specifier|public
name|void
name|testKeySetRemoveAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|keySet
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|keySet
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException or NullPointerException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeySetRetainAllNullFromEmpty ()
specifier|public
name|void
name|testKeySetRetainAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
init|=
name|map
operator|.
name|keySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|keySet
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Returning successfully is not ideal, but tolerated.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|keySet
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We have to tolerate a successful return (Sun bug 4802647)
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValues ()
specifier|public
name|void
name|testValues
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|valueCollection
operator|=
name|map
operator|.
name|values
argument_list|()
expr_stmt|;
specifier|final
name|V
name|unmappedValue
decl_stmt|;
try|try
block|{
name|unmappedValue
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
for|for
control|(
name|V
name|value
range|:
name|valueCollection
control|)
block|{
name|assertFalse
argument_list|(
name|unmappedValue
operator|.
name|equals
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testValuesIteratorRemove ()
specifier|public
name|void
name|testValuesIteratorRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
init|=
name|valueCollection
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsIteratorRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// (We can't assert that the values collection no longer contains the
comment|// removed value, because the underlying map can have multiple mappings
comment|// to the same value.)
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
try|try
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRemove ()
specifier|public
name|void
name|testValuesRemove
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|valueCollection
operator|.
name|remove
argument_list|(
name|valueCollection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|initialSize
operator|-
literal|1
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// (We can't assert that the values collection no longer contains the
comment|// removed value, because the underlying map can have multiple mappings
comment|// to the same value.)
block|}
else|else
block|{
try|try
block|{
name|valueCollection
operator|.
name|remove
argument_list|(
name|valueCollection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRemoveMissing ()
specifier|public
name|void
name|testValuesRemoveMissing
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|final
name|V
name|valueToRemove
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEitherMap
argument_list|()
expr_stmt|;
name|valueToRemove
operator|=
name|getValueNotInPopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
name|int
name|initialSize
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|assertFalse
argument_list|(
name|valueCollection
operator|.
name|remove
argument_list|(
name|valueToRemove
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|assertFalse
argument_list|(
name|valueCollection
operator|.
name|remove
argument_list|(
name|valueToRemove
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Tolerated.
block|}
block|}
name|assertEquals
argument_list|(
name|initialSize
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRemoveAll ()
specifier|public
name|void
name|testValuesRemoveAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|V
argument_list|>
name|valuesToRemove
init|=
name|singleton
argument_list|(
name|valueCollection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|valueCollection
operator|.
name|removeAll
argument_list|(
name|valuesToRemove
argument_list|)
expr_stmt|;
for|for
control|(
name|V
name|value
range|:
name|valuesToRemove
control|)
block|{
name|assertFalse
argument_list|(
name|valueCollection
operator|.
name|contains
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|V
name|value
range|:
name|valueCollection
control|)
block|{
name|assertFalse
argument_list|(
name|valuesToRemove
operator|.
name|contains
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|valueCollection
operator|.
name|removeAll
argument_list|(
name|valuesToRemove
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRemoveAllNullFromEmpty ()
specifier|public
name|void
name|testValuesRemoveAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|values
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Returning successfully is not ideal, but tolerated.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|values
operator|.
name|removeAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We have to tolerate a successful return (Sun bug 4802647)
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRetainAll ()
specifier|public
name|void
name|testValuesRetainAll
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|V
argument_list|>
name|valuesToRetain
init|=
name|singleton
argument_list|(
name|valueCollection
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
name|valueCollection
operator|.
name|retainAll
argument_list|(
name|valuesToRetain
argument_list|)
expr_stmt|;
for|for
control|(
name|V
name|value
range|:
name|valuesToRetain
control|)
block|{
name|assertTrue
argument_list|(
name|valueCollection
operator|.
name|contains
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|V
name|value
range|:
name|valueCollection
control|)
block|{
name|assertTrue
argument_list|(
name|valuesToRetain
operator|.
name|contains
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|valueCollection
operator|.
name|retainAll
argument_list|(
name|valuesToRetain
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesRetainAllNullFromEmpty ()
specifier|public
name|void
name|testValuesRetainAllNullFromEmpty
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makeEmptyMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|values
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsRemove
condition|)
block|{
try|try
block|{
name|values
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Returning successfully is not ideal, but tolerated.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
else|else
block|{
try|try
block|{
name|values
operator|.
name|retainAll
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We have to tolerate a successful return (Sun bug 4802647)
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testValuesClear ()
specifier|public
name|void
name|testValuesClear
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
try|try
block|{
name|map
operator|=
name|makePopulatedMap
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|V
argument_list|>
name|valueCollection
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportsClear
condition|)
block|{
name|valueCollection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|valueCollection
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|valueCollection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected UnsupportedOperationException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
name|assertInvariants
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|mapEntry (K key, V value)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|singletonMap
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
block|}
end_class

end_unit

