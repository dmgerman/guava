begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.testing
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
operator|.
name|throwIfUnchecked
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MutableClassToInstanceMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Invokable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|Reflection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|reflect
operator|.
name|TypeToken
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
operator|.
name|Visibility
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|RelationshipTester
operator|.
name|Item
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|RelationshipTester
operator|.
name|ItemReporter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|AssertionFailedError
import|;
end_import

begin_comment
comment|/**  * Tester that runs automated sanity tests for any given class. A typical use case is to test static  * factory classes like:<pre>  * interface Book {...}  * public class Books {  *   public static Book hardcover(String title) {...}  *   public static Book paperback(String title) {...}  * }  *</pre>  *<p>And all the created {@code Book} instances can be tested with:<pre>  * new ClassSanityTester()  *     .forAllPublicStaticMethods(Books.class)  *     .thatReturn(Book.class)  *     .testEquals(); // or testNulls(), testSerializable() etc.  *</pre>  *  * @author Ben Yu  * @since 14.0  */
end_comment

begin_class
annotation|@
name|Beta
annotation|@
name|GwtIncompatible
DECL|class|ClassSanityTester
specifier|public
specifier|final
class|class
name|ClassSanityTester
block|{
DECL|field|BY_METHOD_NAME
specifier|private
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|BY_METHOD_NAME
init|=
operator|new
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|left
parameter_list|,
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
DECL|field|BY_PARAMETERS
specifier|private
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|BY_PARAMETERS
init|=
operator|new
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|left
parameter_list|,
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|usingToString
argument_list|()
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getParameters
argument_list|()
argument_list|,
name|right
operator|.
name|getParameters
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
DECL|field|BY_NUMBER_OF_PARAMETERS
specifier|private
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|BY_NUMBER_OF_PARAMETERS
init|=
operator|new
name|Ordering
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|left
parameter_list|,
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|Ints
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|right
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
DECL|field|defaultValues
specifier|private
specifier|final
name|MutableClassToInstanceMap
argument_list|<
name|Object
argument_list|>
name|defaultValues
init|=
name|MutableClassToInstanceMap
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|distinctValues
specifier|private
specifier|final
name|ListMultimap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Object
argument_list|>
name|distinctValues
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|nullPointerTester
specifier|private
specifier|final
name|NullPointerTester
name|nullPointerTester
init|=
operator|new
name|NullPointerTester
argument_list|()
decl_stmt|;
DECL|method|ClassSanityTester ()
specifier|public
name|ClassSanityTester
parameter_list|()
block|{
comment|// TODO(benyu): bake these into ArbitraryInstances.
name|setDefault
argument_list|(
name|byte
operator|.
name|class
argument_list|,
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Byte
operator|.
name|class
argument_list|,
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|short
operator|.
name|class
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Short
operator|.
name|class
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Long
operator|.
name|class
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|1F
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Float
operator|.
name|class
argument_list|,
literal|1F
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Double
operator|.
name|class
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|Class
operator|.
name|class
argument_list|,
name|Class
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the default value for {@code type}. The default value isn't used in testing {@link    * Object#equals} because more than one sample instances are needed for testing inequality.    * To set distinct values for equality testing, use {@link #setDistinctValues} instead.    */
DECL|method|setDefault (Class<T> type, T value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ClassSanityTester
name|setDefault
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|T
name|value
parameter_list|)
block|{
name|nullPointerTester
operator|.
name|setDefault
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|defaultValues
operator|.
name|putInstance
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Sets distinct values for {@code type}, so that when a class {@code Foo} is tested for {@link    * Object#equals} and {@link Object#hashCode}, and its construction requires a parameter of {@code    * type}, the distinct values of {@code type} can be passed as parameters to create {@code Foo}    * instances that are unequal.    *    *<p>Calling {@code setDistinctValues(type, v1, v2)} also sets the default value for {@code type}    * that's used for {@link #testNulls}.    *    *<p>Only necessary for types where {@link ClassSanityTester} doesn't already know how to create    * distinct values.    *    * @return this tester instance    * @since 17.0    */
DECL|method|setDistinctValues (Class<T> type, T value1, T value2)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ClassSanityTester
name|setDistinctValues
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|T
name|value1
parameter_list|,
name|T
name|value2
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|value2
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
operator|!
name|Objects
operator|.
name|equal
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
argument_list|,
literal|"Duplicate value provided."
argument_list|)
expr_stmt|;
name|distinctValues
operator|.
name|replaceValues
argument_list|(
name|type
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
argument_list|)
expr_stmt|;
name|setDefault
argument_list|(
name|type
argument_list|,
name|value1
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Tests that {@code cls} properly checks null on all constructor and method parameters that    * aren't annotated with {@link Nullable}. In details:    *<ul>    *<li>All non-private static methods are checked such that passing null for any parameter that's    *     not annotated with {@link javax.annotation.Nullable} should throw {@link    *     NullPointerException}.    *<li>If there is any non-private constructor or non-private static factory method declared by    *     {@code cls}, all non-private instance methods will be checked too using the instance    *     created by invoking the constructor or static factory method.    *<li>If there is any non-private constructor or non-private static factory method declared by    *     {@code cls}:    *<ul>    *<li>Test will fail if default value for a parameter cannot be determined.    *<li>Test will fail if the factory method returns null so testing instance methods is    *         impossible.    *<li>Test will fail if the constructor or factory method throws exception.    *</ul>    *<li>If there is no non-private constructor or non-private static factory method declared by    *     {@code cls}, instance methods are skipped for nulls test.    *<li>Nulls test is not performed on method return values unless the method is a non-private    *     static factory method whose return type is {@code cls} or {@code cls}'s subtype.    *</ul>    */
DECL|method|testNulls (Class<?> cls)
specifier|public
name|void
name|testNulls
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
block|{
try|try
block|{
name|doTestNulls
argument_list|(
name|cls
argument_list|,
name|Visibility
operator|.
name|PACKAGE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|doTestNulls (Class<?> cls, Visibility visibility)
name|void
name|doTestNulls
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|,
name|Visibility
name|visibility
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|IllegalAccessException
throws|,
name|InvocationTargetException
throws|,
name|FactoryMethodReturnsNullException
block|{
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|cls
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|nullPointerTester
operator|.
name|testConstructors
argument_list|(
name|cls
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
block|}
name|nullPointerTester
operator|.
name|testStaticMethods
argument_list|(
name|cls
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasInstanceMethodToTestNulls
argument_list|(
name|cls
argument_list|,
name|visibility
argument_list|)
condition|)
block|{
name|Object
name|instance
init|=
name|instantiate
argument_list|(
name|cls
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
name|nullPointerTester
operator|.
name|testInstanceMethods
argument_list|(
name|instance
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|hasInstanceMethodToTestNulls (Class<?> c, Visibility visibility)
specifier|private
name|boolean
name|hasInstanceMethodToTestNulls
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|c
parameter_list|,
name|Visibility
name|visibility
parameter_list|)
block|{
for|for
control|(
name|Method
name|method
range|:
name|nullPointerTester
operator|.
name|getInstanceMethodsToTest
argument_list|(
name|c
argument_list|,
name|visibility
argument_list|)
control|)
block|{
for|for
control|(
name|Parameter
name|param
range|:
name|Invokable
operator|.
name|from
argument_list|(
name|method
argument_list|)
operator|.
name|getParameters
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|NullPointerTester
operator|.
name|isPrimitiveOrNullable
argument_list|(
name|param
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Tests the {@link Object#equals} and {@link Object#hashCode} of {@code cls}. In details:    *<ul>    *<li>The non-private constructor or non-private static factory method with the most parameters    *     is used to construct the sample instances. In case of tie, the candidate constructors or    *     factories are tried one after another until one can be used to construct sample instances.    *<li>For the constructor or static factory method used to construct instances, it's checked that    *     when equal parameters are passed, the result instance should also be equal; and vice versa.    *<li>If a non-private constructor or non-private static factory method exists:<ul>    *<li>Test will fail if default value for a parameter cannot be determined.    *<li>Test will fail if the factory method returns null so testing instance methods is    *         impossible.    *<li>Test will fail if the constructor or factory method throws exception.    *</ul>    *<li>If there is no non-private constructor or non-private static factory method declared by    *     {@code cls}, no test is performed.    *<li>Equality test is not performed on method return values unless the method is a non-private    *     static factory method whose return type is {@code cls} or {@code cls}'s subtype.    *<li>Inequality check is not performed against state mutation methods such as {@link List#add},    *     or functional update methods such as {@link com.google.common.base.Joiner#skipNulls}.    *</ul>    *    *<p>Note that constructors taking a builder object cannot be tested effectively because    * semantics of builder can be arbitrarily complex. Still, a factory class can be created in the    * test to facilitate equality testing. For example:<pre>    * public class FooTest {    *    *   private static class FooFactoryForTest {    *     public static Foo create(String a, String b, int c, boolean d) {    *       return Foo.builder()    *           .setA(a)    *           .setB(b)    *           .setC(c)    *           .setD(d)    *           .build();    *     }    *   }    *    *   public void testEquals() {    *     new ClassSanityTester()    *       .forAllPublicStaticMethods(FooFactoryForTest.class)    *       .thatReturn(Foo.class)    *       .testEquals();    *   }    * }    *</pre>    *<p>It will test that Foo objects created by the {@code create(a, b, c, d)} factory method with    * equal parameters are equal and vice versa, thus indirectly tests the builder equality.    */
DECL|method|testEquals (Class<?> cls)
specifier|public
name|void
name|testEquals
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
block|{
try|try
block|{
name|doTestEquals
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|doTestEquals (Class<?> cls)
name|void
name|doTestEquals
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|ParameterHasNoDistinctValueException
throws|,
name|IllegalAccessException
throws|,
name|InvocationTargetException
throws|,
name|FactoryMethodReturnsNullException
block|{
if|if
condition|(
name|cls
operator|.
name|isEnum
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|?
extends|extends
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|factories
init|=
name|Lists
operator|.
name|reverse
argument_list|(
name|getFactories
argument_list|(
name|TypeToken
operator|.
name|of
argument_list|(
name|cls
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|factories
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|numberOfParameters
init|=
name|factories
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ParameterNotInstantiableException
argument_list|>
name|paramErrors
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ParameterHasNoDistinctValueException
argument_list|>
name|distinctValueErrors
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|InvocationTargetException
argument_list|>
name|instantiationExceptions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FactoryMethodReturnsNullException
argument_list|>
name|nullErrors
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Try factories with the greatest number of parameters.
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|factories
control|)
block|{
if|if
condition|(
name|factory
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|numberOfParameters
condition|)
block|{
try|try
block|{
name|testEqualsUsing
argument_list|(
name|factory
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ParameterNotInstantiableException
name|e
parameter_list|)
block|{
name|paramErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParameterHasNoDistinctValueException
name|e
parameter_list|)
block|{
name|distinctValueErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|instantiationExceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FactoryMethodReturnsNullException
name|e
parameter_list|)
block|{
name|nullErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|throwFirst
argument_list|(
name|paramErrors
argument_list|)
expr_stmt|;
name|throwFirst
argument_list|(
name|distinctValueErrors
argument_list|)
expr_stmt|;
name|throwFirst
argument_list|(
name|instantiationExceptions
argument_list|)
expr_stmt|;
name|throwFirst
argument_list|(
name|nullErrors
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiates {@code cls} by invoking one of its non-private constructors or non-private static    * factory methods with the parameters automatically provided using dummy values.    *    * @return The instantiated instance, or {@code null} if the class has no non-private constructor    *         or factory method to be constructed.    */
DECL|method|instantiate (Class<T> cls)
annotation|@
name|Nullable
argument_list|<
name|T
argument_list|>
name|T
name|instantiate
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|IllegalAccessException
throws|,
name|InvocationTargetException
throws|,
name|FactoryMethodReturnsNullException
block|{
if|if
condition|(
name|cls
operator|.
name|isEnum
argument_list|()
condition|)
block|{
name|T
index|[]
name|constants
init|=
name|cls
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|constants
operator|.
name|length
operator|>
literal|0
condition|)
block|{
return|return
name|constants
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|TypeToken
argument_list|<
name|T
argument_list|>
name|type
init|=
name|TypeToken
operator|.
name|of
argument_list|(
name|cls
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ParameterNotInstantiableException
argument_list|>
name|paramErrors
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|InvocationTargetException
argument_list|>
name|instantiationExceptions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FactoryMethodReturnsNullException
argument_list|>
name|nullErrors
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|factory
range|:
name|getFactories
argument_list|(
name|type
argument_list|)
control|)
block|{
name|T
name|instance
decl_stmt|;
try|try
block|{
name|instance
operator|=
name|instantiate
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParameterNotInstantiableException
name|e
parameter_list|)
block|{
name|paramErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|instantiationExceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
name|nullErrors
operator|.
name|add
argument_list|(
operator|new
name|FactoryMethodReturnsNullException
argument_list|(
name|factory
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|instance
return|;
block|}
block|}
name|throwFirst
argument_list|(
name|paramErrors
argument_list|)
expr_stmt|;
name|throwFirst
argument_list|(
name|instantiationExceptions
argument_list|)
expr_stmt|;
name|throwFirst
argument_list|(
name|nullErrors
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Returns an object responsible for performing sanity tests against the return values    * of all public static methods declared by {@code cls}, excluding superclasses.    */
DECL|method|forAllPublicStaticMethods (Class<?> cls)
specifier|public
name|FactoryMethodReturnValueTester
name|forAllPublicStaticMethods
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|cls
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|invokable
init|=
name|Invokable
operator|.
name|from
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|invokable
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|invokable
operator|.
name|isPublic
argument_list|()
operator|&&
name|invokable
operator|.
name|isStatic
argument_list|()
operator|&&
operator|!
name|invokable
operator|.
name|isSynthetic
argument_list|()
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|invokable
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|FactoryMethodReturnValueTester
argument_list|(
name|cls
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
literal|"public static methods"
argument_list|)
return|;
block|}
comment|/** Runs sanity tests against return values of static factory methods declared by a class. */
DECL|class|FactoryMethodReturnValueTester
specifier|public
specifier|final
class|class
name|FactoryMethodReturnValueTester
block|{
DECL|field|packagesToTest
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|packagesToTest
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
DECL|field|declaringClass
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|declaringClass
decl_stmt|;
DECL|field|factories
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|factories
decl_stmt|;
DECL|field|factoryMethodsDescription
specifier|private
specifier|final
name|String
name|factoryMethodsDescription
decl_stmt|;
DECL|field|returnTypeToTest
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|returnTypeToTest
init|=
name|Object
operator|.
name|class
decl_stmt|;
DECL|method|FactoryMethodReturnValueTester ( Class<?> declaringClass, ImmutableList<Invokable<?, ?>> factories, String factoryMethodsDescription)
specifier|private
name|FactoryMethodReturnValueTester
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|declaringClass
parameter_list|,
name|ImmutableList
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|factories
parameter_list|,
name|String
name|factoryMethodsDescription
parameter_list|)
block|{
name|this
operator|.
name|declaringClass
operator|=
name|declaringClass
expr_stmt|;
name|this
operator|.
name|factories
operator|=
name|factories
expr_stmt|;
name|this
operator|.
name|factoryMethodsDescription
operator|=
name|factoryMethodsDescription
expr_stmt|;
name|packagesToTest
operator|.
name|add
argument_list|(
name|Reflection
operator|.
name|getPackageName
argument_list|(
name|declaringClass
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Specifies that only the methods that are declared to return {@code returnType} or its subtype      * are tested.      *      * @return this tester object      */
DECL|method|thatReturn (Class<?> returnType)
specifier|public
name|FactoryMethodReturnValueTester
name|thatReturn
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|returnType
parameter_list|)
block|{
name|this
operator|.
name|returnTypeToTest
operator|=
name|returnType
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Tests null checks against the instance methods of the return values, if any.      *      *<p>Test fails if default value cannot be determined for a constructor or factory method      * parameter, or if the constructor or factory method throws exception.      *      * @return this tester      */
DECL|method|testNulls ()
specifier|public
name|FactoryMethodReturnValueTester
name|testNulls
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|getFactoriesToTest
argument_list|()
control|)
block|{
name|Object
name|instance
init|=
name|instantiate
argument_list|(
name|factory
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
operator|&&
name|packagesToTest
operator|.
name|contains
argument_list|(
name|Reflection
operator|.
name|getPackageName
argument_list|(
name|instance
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
try|try
block|{
name|nullPointerTester
operator|.
name|testAllPublicInstanceMethods
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Null check failed on return value of "
operator|+
name|factory
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Tests {@link Object#equals} and {@link Object#hashCode} against the return values of the      * static methods, by asserting that when equal parameters are passed to the same static method,      * the return value should also be equal; and vice versa.      *      *<p>Test fails if default value cannot be determined for a constructor or factory method      * parameter, or if the constructor or factory method throws exception.      *      * @return this tester      */
DECL|method|testEquals ()
specifier|public
name|FactoryMethodReturnValueTester
name|testEquals
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|getFactoriesToTest
argument_list|()
control|)
block|{
try|try
block|{
name|testEqualsUsing
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FactoryMethodReturnsNullException
name|e
parameter_list|)
block|{
comment|// If the factory returns null, we just skip it.
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Runs serialization test on the return values of the static methods.      *      *<p>Test fails if default value cannot be determined for a constructor or factory method      * parameter, or if the constructor or factory method throws exception.      *      * @return this tester      */
DECL|method|testSerializable ()
specifier|public
name|FactoryMethodReturnValueTester
name|testSerializable
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|getFactoriesToTest
argument_list|()
control|)
block|{
name|Object
name|instance
init|=
name|instantiate
argument_list|(
name|factory
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|SerializableTester
operator|.
name|reserialize
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Serialization failed on return value of "
operator|+
name|factory
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Runs equals and serialization test on the return values.      *      *<p>Test fails if default value cannot be determined for a constructor or factory method      * parameter, or if the constructor or factory method throws exception.      *      * @return this tester      */
DECL|method|testEqualsAndSerializable ()
specifier|public
name|FactoryMethodReturnValueTester
name|testEqualsAndSerializable
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|getFactoriesToTest
argument_list|()
control|)
block|{
try|try
block|{
name|testEqualsUsing
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FactoryMethodReturnsNullException
name|e
parameter_list|)
block|{
comment|// If the factory returns null, we just skip it.
block|}
name|Object
name|instance
init|=
name|instantiate
argument_list|(
name|factory
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|SerializableTester
operator|.
name|reserializeAndAssert
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Serialization failed on return value of "
operator|+
name|factory
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|e
parameter_list|)
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Return value of "
operator|+
name|factory
operator|+
literal|" reserialized to an unequal value"
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
block|}
return|return
name|this
return|;
block|}
DECL|method|getFactoriesToTest ()
specifier|private
name|ImmutableList
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|getFactoriesToTest
parameter_list|()
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|factories
control|)
block|{
if|if
condition|(
name|returnTypeToTest
operator|.
name|isAssignableFrom
argument_list|(
name|factory
operator|.
name|getReturnType
argument_list|()
operator|.
name|getRawType
argument_list|()
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
block|}
name|ImmutableList
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|factoriesToTest
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"No "
operator|+
name|factoryMethodsDescription
operator|+
literal|" that return "
operator|+
name|returnTypeToTest
operator|.
name|getName
argument_list|()
operator|+
literal|" or subtype are found in "
operator|+
name|declaringClass
operator|+
literal|"."
argument_list|,
name|factoriesToTest
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|factoriesToTest
return|;
block|}
block|}
comment|/**    * Instantiates using {@code factory}. If {@code factory} is annotated with {@link Nullable} and    * returns null, null will be returned.    *    * @throws ParameterNotInstantiableException if the static methods cannot be invoked because    *         the default value of a parameter cannot be determined.    * @throws IllegalAccessException if the class isn't public or is nested inside a non-public    *         class, preventing its methods from being accessible.    * @throws InvocationTargetException if a static method threw exception.    */
DECL|method|instantiate (Invokable<?, ? extends T> factory)
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|instantiate
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|factory
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
return|return
name|invoke
argument_list|(
name|factory
argument_list|,
name|getDummyArguments
argument_list|(
name|factory
argument_list|)
argument_list|)
return|;
block|}
DECL|method|testEqualsUsing (final Invokable<?, ?> factory)
specifier|private
name|void
name|testEqualsUsing
parameter_list|(
specifier|final
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|ParameterHasNoDistinctValueException
throws|,
name|IllegalAccessException
throws|,
name|InvocationTargetException
throws|,
name|FactoryMethodReturnsNullException
block|{
name|List
argument_list|<
name|Parameter
argument_list|>
name|params
init|=
name|factory
operator|.
name|getParameters
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FreshValueGenerator
argument_list|>
name|argGenerators
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|params
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|args
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|params
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Parameter
name|param
range|:
name|params
control|)
block|{
name|FreshValueGenerator
name|generator
init|=
name|newFreshValueGenerator
argument_list|()
decl_stmt|;
name|argGenerators
operator|.
name|add
argument_list|(
name|generator
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|generateDummyArg
argument_list|(
name|param
argument_list|,
name|generator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Object
name|instance
init|=
name|createInstance
argument_list|(
name|factory
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|equalArgs
init|=
name|generateEqualFactoryArguments
argument_list|(
name|factory
argument_list|,
name|params
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// Each group is a List of items, each item has a list of factory args.
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|>
name|argGroups
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|argGroups
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|args
argument_list|,
name|equalArgs
argument_list|)
argument_list|)
expr_stmt|;
name|EqualsTester
name|tester
init|=
operator|new
name|EqualsTester
argument_list|(
operator|new
name|ItemReporter
argument_list|()
block|{
annotation|@
name|Override
name|String
name|reportItem
parameter_list|(
name|Item
argument_list|<
name|?
argument_list|>
name|item
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|factoryArgs
init|=
name|argGroups
operator|.
name|get
argument_list|(
name|item
operator|.
name|groupNumber
argument_list|)
operator|.
name|get
argument_list|(
name|item
operator|.
name|itemNumber
argument_list|)
decl_stmt|;
return|return
name|factory
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|useForNull
argument_list|(
literal|"null"
argument_list|)
operator|.
name|join
argument_list|(
name|factoryArgs
argument_list|)
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|tester
operator|.
name|addEqualityGroup
argument_list|(
name|instance
argument_list|,
name|createInstance
argument_list|(
name|factory
argument_list|,
name|equalArgs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|newArgs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|Object
name|newArg
init|=
name|argGenerators
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|generateFresh
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newArg
operator|==
literal|null
operator|||
name|Objects
operator|.
name|equal
argument_list|(
name|args
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|newArg
argument_list|)
condition|)
block|{
if|if
condition|(
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getRawType
argument_list|()
operator|.
name|isEnum
argument_list|()
condition|)
block|{
continue|continue;
comment|// Nothing better we can do if it's single-value enum
block|}
throw|throw
operator|new
name|ParameterHasNoDistinctValueException
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
throw|;
block|}
name|newArgs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newArg
argument_list|)
expr_stmt|;
name|tester
operator|.
name|addEqualityGroup
argument_list|(
name|createInstance
argument_list|(
name|factory
argument_list|,
name|newArgs
argument_list|)
argument_list|)
expr_stmt|;
name|argGroups
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|newArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns dummy factory arguments that are equal to {@code args} but may be different instances,    * to be used to construct a second instance of the same equality group.    */
DECL|method|generateEqualFactoryArguments ( Invokable<?, ?> factory, List<Parameter> params, List<Object> args)
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|generateEqualFactoryArguments
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
parameter_list|,
name|List
argument_list|<
name|Parameter
argument_list|>
name|params
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|args
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
throws|,
name|FactoryMethodReturnsNullException
throws|,
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|equalArgs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|args
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Parameter
name|param
init|=
name|params
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|arg
init|=
name|args
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Use new fresh value generator because 'args' were populated with new fresh generator each.
comment|// Two newFreshValueGenerator() instances should normally generate equal value sequence.
name|Object
name|shouldBeEqualArg
init|=
name|generateDummyArg
argument_list|(
name|param
argument_list|,
name|newFreshValueGenerator
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|shouldBeEqualArg
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|arg
argument_list|,
name|shouldBeEqualArg
argument_list|)
operator|&&
name|hashCodeInsensitiveToArgReference
argument_list|(
name|factory
argument_list|,
name|args
argument_list|,
name|i
argument_list|,
name|shouldBeEqualArg
argument_list|)
operator|&&
name|hashCodeInsensitiveToArgReference
argument_list|(
name|factory
argument_list|,
name|args
argument_list|,
name|i
argument_list|,
name|generateDummyArg
argument_list|(
name|param
argument_list|,
name|newFreshValueGenerator
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// If the implementation uses identityHashCode(), referential equality is
comment|// probably intended. So no point in using an equal-but-different factory argument.
comment|// We check twice to avoid confusion caused by accidental hash collision.
name|equalArgs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|shouldBeEqualArg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|equalArgs
return|;
block|}
DECL|method|hashCodeInsensitiveToArgReference ( Invokable<?, ?> factory, List<Object> args, int i, Object alternateArg)
specifier|private
specifier|static
name|boolean
name|hashCodeInsensitiveToArgReference
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|args
parameter_list|,
name|int
name|i
parameter_list|,
name|Object
name|alternateArg
parameter_list|)
throws|throws
name|FactoryMethodReturnsNullException
throws|,
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|tentativeArgs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tentativeArgs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|alternateArg
argument_list|)
expr_stmt|;
return|return
name|createInstance
argument_list|(
name|factory
argument_list|,
name|tentativeArgs
argument_list|)
operator|.
name|hashCode
argument_list|()
operator|==
name|createInstance
argument_list|(
name|factory
argument_list|,
name|args
argument_list|)
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// distinctValues is a type-safe class-values mapping, but we don't have a type-safe data
comment|// structure to hold the mappings.
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|newFreshValueGenerator ()
specifier|private
name|FreshValueGenerator
name|newFreshValueGenerator
parameter_list|()
block|{
name|FreshValueGenerator
name|generator
init|=
operator|new
name|FreshValueGenerator
argument_list|()
block|{
annotation|@
name|Override
name|Object
name|interfaceMethodCalled
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|interfaceType
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|getDummyValue
argument_list|(
name|TypeToken
operator|.
name|of
argument_list|(
name|interfaceType
argument_list|)
operator|.
name|method
argument_list|(
name|method
argument_list|)
operator|.
name|getReturnType
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
argument_list|>
name|entry
range|:
name|distinctValues
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|generator
operator|.
name|addSampleInstances
argument_list|(
operator|(
name|Class
operator|)
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|generator
return|;
block|}
DECL|method|generateDummyArg (Parameter param, FreshValueGenerator generator)
annotation|@
name|Nullable
specifier|private
specifier|static
name|Object
name|generateDummyArg
parameter_list|(
name|Parameter
name|param
parameter_list|,
name|FreshValueGenerator
name|generator
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
block|{
if|if
condition|(
name|param
operator|.
name|isAnnotationPresent
argument_list|(
name|Nullable
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|arg
init|=
name|generator
operator|.
name|generateFresh
argument_list|(
name|param
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ParameterNotInstantiableException
argument_list|(
name|param
argument_list|)
throw|;
block|}
return|return
name|arg
return|;
block|}
DECL|method|throwFirst (List<X> exceptions)
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|>
name|void
name|throwFirst
parameter_list|(
name|List
argument_list|<
name|X
argument_list|>
name|exceptions
parameter_list|)
throws|throws
name|X
block|{
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|exceptions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
throw|;
block|}
block|}
comment|/** Factories with the least number of parameters are listed first. */
DECL|method|getFactories (TypeToken<T> type)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ImmutableList
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|getFactories
parameter_list|(
name|TypeToken
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|List
argument_list|<
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|factories
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|type
operator|.
name|getRawType
argument_list|()
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|invokable
init|=
name|type
operator|.
name|method
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|invokable
operator|.
name|isPrivate
argument_list|()
operator|&&
operator|!
name|invokable
operator|.
name|isSynthetic
argument_list|()
operator|&&
name|invokable
operator|.
name|isStatic
argument_list|()
operator|&&
name|type
operator|.
name|isSupertypeOf
argument_list|(
name|invokable
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// guarded by isAssignableFrom()
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|factory
init|=
operator|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
operator|)
name|invokable
decl_stmt|;
name|factories
operator|.
name|add
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|type
operator|.
name|getRawType
argument_list|()
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
range|:
name|type
operator|.
name|getRawType
argument_list|()
operator|.
name|getDeclaredConstructors
argument_list|()
control|)
block|{
name|Invokable
argument_list|<
name|T
argument_list|,
name|T
argument_list|>
name|invokable
init|=
name|type
operator|.
name|constructor
argument_list|(
name|constructor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|invokable
operator|.
name|isPrivate
argument_list|()
operator|&&
operator|!
name|invokable
operator|.
name|isSynthetic
argument_list|()
condition|)
block|{
name|factories
operator|.
name|add
argument_list|(
name|invokable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
range|:
name|factories
control|)
block|{
name|factory
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Sorts methods/constructors with least number of parameters first since it's likely easier to
comment|// fill dummy parameter values for them. Ties are broken by name then by the string form of the
comment|// parameter list.
return|return
name|BY_NUMBER_OF_PARAMETERS
operator|.
name|compound
argument_list|(
name|BY_METHOD_NAME
argument_list|)
operator|.
name|compound
argument_list|(
name|BY_PARAMETERS
argument_list|)
operator|.
name|immutableSortedCopy
argument_list|(
name|factories
argument_list|)
return|;
block|}
DECL|method|getDummyArguments (Invokable<?, ?> invokable)
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|getDummyArguments
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|invokable
parameter_list|)
throws|throws
name|ParameterNotInstantiableException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|args
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Parameter
name|param
range|:
name|invokable
operator|.
name|getParameters
argument_list|()
control|)
block|{
if|if
condition|(
name|param
operator|.
name|isAnnotationPresent
argument_list|(
name|Nullable
operator|.
name|class
argument_list|)
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Object
name|defaultValue
init|=
name|getDummyValue
argument_list|(
name|param
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ParameterNotInstantiableException
argument_list|(
name|param
argument_list|)
throw|;
block|}
name|args
operator|.
name|add
argument_list|(
name|defaultValue
argument_list|)
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
DECL|method|getDummyValue (TypeToken<T> type)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|getDummyValue
parameter_list|(
name|TypeToken
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|Class
argument_list|<
name|?
super|super
name|T
argument_list|>
name|rawType
init|=
name|type
operator|.
name|getRawType
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Assume all default values are generics safe.
name|T
name|defaultValue
init|=
operator|(
name|T
operator|)
name|defaultValues
operator|.
name|getInstance
argument_list|(
name|rawType
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValue
operator|!=
literal|null
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// ArbitraryInstances always returns generics-safe dummies.
name|T
name|value
init|=
operator|(
name|T
operator|)
name|ArbitraryInstances
operator|.
name|get
argument_list|(
name|rawType
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
if|if
condition|(
name|rawType
operator|.
name|isInterface
argument_list|()
condition|)
block|{
return|return
operator|new
name|SerializableDummyProxy
argument_list|(
name|this
argument_list|)
operator|.
name|newProxy
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|createInstance (Invokable<?, ? extends T> factory, List<?> args)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|createInstance
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|factory
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|args
parameter_list|)
throws|throws
name|FactoryMethodReturnsNullException
throws|,
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
name|T
name|instance
init|=
name|invoke
argument_list|(
name|factory
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FactoryMethodReturnsNullException
argument_list|(
name|factory
argument_list|)
throw|;
block|}
return|return
name|instance
return|;
block|}
DECL|method|invoke (Invokable<?, ? extends T> factory, List<?> args)
annotation|@
name|Nullable
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|invoke
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|factory
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|args
parameter_list|)
throws|throws
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
name|T
name|returnValue
init|=
name|factory
operator|.
name|invoke
argument_list|(
literal|null
argument_list|,
name|args
operator|.
name|toArray
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnValue
operator|==
literal|null
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|factory
operator|+
literal|" returns null but it's not annotated with @Nullable"
argument_list|,
name|factory
operator|.
name|isAnnotationPresent
argument_list|(
name|Nullable
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|returnValue
return|;
block|}
comment|/**    * Thrown if the test tries to invoke a constructor or static factory method but failed because    * the dummy value of a constructor or method parameter is unknown.    */
DECL|class|ParameterNotInstantiableException
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|ParameterNotInstantiableException
extends|extends
name|Exception
block|{
DECL|method|ParameterNotInstantiableException (Parameter parameter)
specifier|public
name|ParameterNotInstantiableException
parameter_list|(
name|Parameter
name|parameter
parameter_list|)
block|{
name|super
argument_list|(
literal|"Cannot determine value for parameter "
operator|+
name|parameter
operator|+
literal|" of "
operator|+
name|parameter
operator|.
name|getDeclaringInvokable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Thrown if the test fails to generate two distinct non-null values of a constructor or factory    * parameter in order to test {@link Object#equals} and {@link Object#hashCode} of the declaring    * class.    */
DECL|class|ParameterHasNoDistinctValueException
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|ParameterHasNoDistinctValueException
extends|extends
name|Exception
block|{
DECL|method|ParameterHasNoDistinctValueException (Parameter parameter)
name|ParameterHasNoDistinctValueException
parameter_list|(
name|Parameter
name|parameter
parameter_list|)
block|{
name|super
argument_list|(
literal|"Cannot generate distinct value for parameter "
operator|+
name|parameter
operator|+
literal|" of "
operator|+
name|parameter
operator|.
name|getDeclaringInvokable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Thrown if the test tries to invoke a static factory method to test instance methods but the    * factory returned null.    */
DECL|class|FactoryMethodReturnsNullException
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|FactoryMethodReturnsNullException
extends|extends
name|Exception
block|{
DECL|method|FactoryMethodReturnsNullException (Invokable<?, ?> factory)
specifier|public
name|FactoryMethodReturnsNullException
parameter_list|(
name|Invokable
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|factory
operator|+
literal|" returns null and cannot be used to test instance methods."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SerializableDummyProxy
specifier|private
specifier|static
specifier|final
class|class
name|SerializableDummyProxy
extends|extends
name|DummyProxy
implements|implements
name|Serializable
block|{
DECL|field|tester
specifier|private
specifier|final
specifier|transient
name|ClassSanityTester
name|tester
decl_stmt|;
DECL|method|SerializableDummyProxy (ClassSanityTester tester)
name|SerializableDummyProxy
parameter_list|(
name|ClassSanityTester
name|tester
parameter_list|)
block|{
name|this
operator|.
name|tester
operator|=
name|tester
expr_stmt|;
block|}
DECL|method|dummyReturnValue (TypeToken<R> returnType)
annotation|@
name|Override
argument_list|<
name|R
argument_list|>
name|R
name|dummyReturnValue
parameter_list|(
name|TypeToken
argument_list|<
name|R
argument_list|>
name|returnType
parameter_list|)
block|{
return|return
name|tester
operator|.
name|getDummyValue
argument_list|(
name|returnType
argument_list|)
return|;
block|}
DECL|method|equals (Object obj)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|instanceof
name|SerializableDummyProxy
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
end_class

end_unit

