begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A framework for concurrent hash map implementations. The  * CustomConcurrentHashMap class itself is not extensible and does not contain  * any methods. Use {@link Builder} to create a custom concurrent hash map  * instance. Client libraries implement {@link Strategy}, and this class  * provides the surrounding concurrent data structure which implements {@link  * ConcurrentMap}. Additionally supports implementing maps where {@link  * Map#get} atomically computes values on demand (see {@link  * Builder#buildComputingMap(CustomConcurrentHashMap.ComputingStrategy,  * Function)}).  *  *<p>The resulting hash table supports full concurrency of retrievals and  * adjustable expected concurrency for updates. Even though all operations are  * thread-safe, retrieval operations do<i>not</i> entail locking,  * and there is<i>not</i> any support for locking the entire table  * in a way that prevents all access.  *  *<p>Retrieval operations (including {@link Map#get}) generally do not  * block, so may overlap with update operations (including  * {@link Map#put} and {@link Map#remove}). Retrievals reflect the results  * of the most recently<i>completed</i> update operations holding  * upon their onset. For aggregate operations such as {@link Map#putAll}  * and {@link Map#clear}, concurrent retrievals may reflect insertion or  * removal of only some entries. Similarly, iterators return elements  * reflecting the state of the hash table at some point at or since the  * creation of the iterator. They do<i>not</i> throw  * {@link java.util.ConcurrentModificationException}. However, iterators can  * only be used by one thread at a time.  *  *<p>The resulting {@link ConcurrentMap} and its views and iterators implement  * all of the<i>optional</i> methods of the {@link java.util.Map} and {@link  * java.util.Iterator} interfaces. Partially reclaimed entries are never  * exposed through the views or iterators.  *  *<p>For example, the following strategy emulates the behavior of  * {@link java.util.concurrent.ConcurrentHashMap}:  *  *<pre> {@code  * class ConcurrentHashMapStrategy<K, V>  *     implements CustomConcurrentHashMap.Strategy<K, V,  *     InternalEntry<K, V>>, Serializable {  *   public InternalEntry<K, V> newEntry(K key, int hash,  *       InternalEntry<K, V> next) {  *     return new InternalEntry<K, V>(key, hash, null, next);  *   }  *   public InternalEntry<K, V> copyEntry(K key,  *       InternalEntry<K, V> original, InternalEntry<K, V> next) {  *     return new InternalEntry<K, V>(key, original.hash, original.value, next);  *   }  *   public void setValue(InternalEntry<K, V> entry, V value) {  *     entry.value = value;  *   }  *   public V getValue(InternalEntry<K, V> entry) { return entry.value; }  *   public boolean equalKeys(K a, Object b) { return a.equals(b); }  *   public boolean equalValues(V a, Object b) { return a.equals(b); }  *   public int hashKey(Object key) { return key.hashCode(); }  *   public K getKey(InternalEntry<K, V> entry) { return entry.key; }  *   public InternalEntry<K, V> getNext(InternalEntry<K, V> entry) {  *     return entry.next;  *   }  *   public int getHash(InternalEntry<K, V> entry) { return entry.hash; }  *   public void setInternals(CustomConcurrentHashMap.Internals<K, V,  *       InternalEntry<K, V>> internals) {} // ignored  * }  *  * class InternalEntry<K, V> {  *   final K key;  *   final int hash;  *   volatile V value;  *   final InternalEntry<K, V> next;  *   InternalEntry(K key, int hash, V value, InternalEntry<K, V> next) {  *     this.key = key;  *     this.hash = hash;  *     this.value = value;  *     this.next = next;  *   }  * }  * }</pre>  *  * To create a {@link java.util.concurrent.ConcurrentMap} using the strategy  * above:  *  *<pre>{@code  *   ConcurrentMap<K, V> map = new CustomConcurrentHashMap.Builder()  *       .build(new ConcurrentHashMapStrategy<K, V>());  * }</pre>  *  * @author Bob Lee  * @author Doug Lea  */
end_comment

begin_class
DECL|class|CustomConcurrentHashMap
specifier|final
class|class
name|CustomConcurrentHashMap
block|{
comment|/** Prevents instantiation. */
DECL|method|CustomConcurrentHashMap ()
specifier|private
name|CustomConcurrentHashMap
parameter_list|()
block|{}
comment|/**    * Builds a custom concurrent hash map.    */
DECL|class|Builder
specifier|static
specifier|final
class|class
name|Builder
block|{
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
DECL|field|UNSET_INITIAL_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|UNSET_INITIAL_CAPACITY
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|UNSET_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|UNSET_CONCURRENCY_LEVEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|initialCapacity
name|int
name|initialCapacity
init|=
name|UNSET_INITIAL_CAPACITY
decl_stmt|;
DECL|field|concurrencyLevel
name|int
name|concurrencyLevel
init|=
name|UNSET_CONCURRENCY_LEVEL
decl_stmt|;
comment|/**      * Sets a custom initial capacity (defaults to 16). Resizing this or any      * other kind of hash table is a relatively slow operation, so, when      * possible, it is a good idea to provide estimates of expected table      * sizes.      *      * @throws IllegalArgumentException if initialCapacity< 0      */
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|Builder
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|initialCapacity
operator|!=
name|UNSET_INITIAL_CAPACITY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"initial capacity was already set to "
operator|+
name|this
operator|.
name|initialCapacity
argument_list|)
throw|;
block|}
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Guides the allowed concurrency among update operations. Used as a      * hint for internal sizing. The table is internally partitioned to try to      * permit the indicated number of concurrent updates without contention.      * Because placement in hash tables is essentially random, the actual      * concurrency will vary. Ideally, you should choose a value to accommodate      * as many threads as will ever concurrently modify the table. Using a      * significantly higher value than you need can waste space and time,      * and a significantly lower value can lead to thread contention. But      * overestimates and underestimates within an order of magnitude do      * not usually have much noticeable impact. A value of one is      * appropriate when it is known that only one thread will modify and      * all others will only read. Defaults to {@literal 16}.      *      * @throws IllegalArgumentException if concurrencyLevel< 0      */
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|Builder
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|concurrencyLevel
operator|!=
name|UNSET_CONCURRENCY_LEVEL
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"concurrency level was already set to "
operator|+
name|this
operator|.
name|concurrencyLevel
argument_list|)
throw|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Creates a new concurrent hash map backed by the given strategy.      *      * @param strategy used to implement and manipulate the entries      *      * @param<K> the type of keys to be stored in the returned map      * @param<V> the type of values to be stored in the returned map      * @param<E> the type of internal entry to be stored in the returned map      *      * @throws NullPointerException if strategy is null      */
DECL|method|buildMap (Strategy<K, V, E> strategy)
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|buildMap
parameter_list|(
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
parameter_list|)
block|{
if|if
condition|(
name|strategy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"strategy"
argument_list|)
throw|;
block|}
return|return
operator|new
name|Impl
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
argument_list|(
name|strategy
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link ConcurrentMap}, backed by the given strategy, that      * supports atomic, on-demand computation of values. {@link Map#get}      * returns the value corresponding to the given key, atomically computes      * it using the computer function passed to this builder, or waits for      * another thread to compute the value if necessary. Only one value will      * be computed for each key at a given time.      *      *<p>If an entry's value has not finished computing yet, query methods      * besides {@link java.util.Map#get} return immediately as if an entry      * doesn't exist. In other words, an entry isn't externally visible until      * the value's computation completes.      *      *<p>{@link Map#get} in the returned map implementation throws:      *<ul>      *<li>{@link NullPointerException} if the key is null or the      *  computer returns null</li>      *<li>or {@link ComputationException} wrapping an exception thrown by the      *  computation</li>      *</ul>      *      *<p><b>Note:</b> Callers of {@code get()}<i>must</i> ensure that the key      *  argument is of type {@code K}. {@code Map.get()} takes {@code Object},      *  so the key type is not checked at compile time. Passing an object of      *  a type other than {@code K} can result in that object being unsafely      *  passed to the computer function as type {@code K} not to mention the      *  unsafe key being stored in the map.      *      * @param strategy used to implement and manipulate the entries      * @param computer used to compute values for keys      *      * @param<K> the type of keys to be stored in the returned map      * @param<V> the type of values to be stored in the returned map      * @param<E> the type of internal entry to be stored in the returned map      *      * @throws NullPointerException if strategy or computer is null      */
DECL|method|buildComputingMap ( ComputingStrategy<K, V, E> strategy, Function<? super K, ? extends V> computer)
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|buildComputingMap
parameter_list|(
name|ComputingStrategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
parameter_list|)
block|{
if|if
condition|(
name|strategy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"strategy"
argument_list|)
throw|;
block|}
if|if
condition|(
name|computer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"computer"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ComputingImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
argument_list|(
name|strategy
argument_list|,
name|this
argument_list|,
name|computer
argument_list|)
return|;
block|}
DECL|method|getInitialCapacity ()
name|int
name|getInitialCapacity
parameter_list|()
block|{
return|return
operator|(
name|initialCapacity
operator|==
name|UNSET_INITIAL_CAPACITY
operator|)
condition|?
name|DEFAULT_INITIAL_CAPACITY
else|:
name|initialCapacity
return|;
block|}
DECL|method|getConcurrencyLevel ()
name|int
name|getConcurrencyLevel
parameter_list|()
block|{
return|return
operator|(
name|concurrencyLevel
operator|==
name|UNSET_CONCURRENCY_LEVEL
operator|)
condition|?
name|DEFAULT_CONCURRENCY_LEVEL
else|:
name|concurrencyLevel
return|;
block|}
block|}
comment|/**    * Implements behavior specific to the client's concurrent hash map    * implementation. Used by the framework to create new entries and perform    * operations on them.    *    *<p>Method parameters are never null unless otherwise specified.    *    *<h3>Partially Reclaimed Entries</h3>    *    *<p>This class does<i>not</i> allow {@code null} to be used as a key.    * Setting values to null is not permitted, but entries may have null keys    * or values for various reasons. For example, the key or value may have    * been garbage collected or reclaimed through other means.    * CustomConcurrentHashMap treats entries with null keys and values as    * "partially reclaimed" and ignores them for the most part. Entries may    * enter a partially reclaimed state but they must not leave it. Partially    * reclaimed entries will not be copied over during table expansions, for    * example. Strategy implementations should proactively remove partially    * reclaimed entries so that {@link Map#isEmpty} and {@link Map#size()}    * return up-to-date results.    *    * @param<K> the type of keys to be stored in the returned map    * @param<V> the type of values to be stored in the returned map    * @param<E> internal entry type, not directly exposed to clients in map    *  views    */
DECL|interface|Strategy
specifier|public
interface|interface
name|Strategy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
block|{
comment|/**      * Constructs a new entry for the given key with a pointer to the given      * next entry.      *      *<p>This method may return different entry implementations      * depending upon whether next is null or not. For example, if next is      * null (as will often be the case), this factory might use an entry      * class that doesn't waste memory on an unnecessary field.      *      * @param key for this entry      * @param hash of key returned by {@link #hashKey}      * @param next entry (used when implementing a hash bucket as a linked      *  list, for example), possibly null      * @return a new entry      */
DECL|method|newEntry (K key, int hash, E next)
specifier|abstract
name|E
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|E
name|next
parameter_list|)
function_decl|;
comment|/**      * Creates a copy of the given entry pointing to the given next entry.      * Copies the value and any other implementation-specific state from      * {@code original} to the returned entry. For example,      * CustomConcurrentHashMap might use this method when removing other      * entries or expanding the internal table.      *      * @param key for {@code original} as well as the returned entry.      *  Explicitly provided here to prevent reclamation of the key at an      *  inopportune time in implementations that don't otherwise keep      *  a strong reference to the key.      * @param original entry from which the value and other      *  implementation-specific state should be copied      * @param newNext the next entry the new entry should point to, possibly      *  null      */
DECL|method|copyEntry (K key, E original, E newNext)
name|E
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|E
name|original
parameter_list|,
name|E
name|newNext
parameter_list|)
function_decl|;
comment|/**      * Sets the value of an entry using volatile semantics. Values are set      * synchronously on a per-entry basis.      *      * @param entry to set the value on      * @param value to set      */
DECL|method|setValue (E entry, V value)
name|void
name|setValue
parameter_list|(
name|E
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Gets the value of an entry using volatile semantics.      *      * @param entry to get the value from      */
DECL|method|getValue (E entry)
name|V
name|getValue
parameter_list|(
name|E
name|entry
parameter_list|)
function_decl|;
comment|/**      * Returns true if the two given keys are equal, false otherwise. Neither      * key will be null.      *      * @param a key from inside the map      * @param b key passed from caller, not necesarily of type K      *      * @see Object#equals the same contractual obligations apply here      */
DECL|method|equalKeys (K a, Object b)
name|boolean
name|equalKeys
parameter_list|(
name|K
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
function_decl|;
comment|/**      * Returns true if the two given values are equal, false otherwise. Neither      * value will be null.      *      * @param a value from inside the map      * @param b value passed from caller, not necesarily of type V      *      * @see Object#equals the same contractual obligations apply here      */
DECL|method|equalValues (V a, Object b)
name|boolean
name|equalValues
parameter_list|(
name|V
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
function_decl|;
comment|/**      * Returns a hash code for the given key.      *      * @see Object#hashCode the same contractual obligations apply here      */
DECL|method|hashKey (Object key)
name|int
name|hashKey
parameter_list|(
name|Object
name|key
parameter_list|)
function_decl|;
comment|/**      * Gets the key for the given entry. This may return null (for example,      * if the key was reclaimed by the garbage collector).      *      * @param entry to get key from      * @return key from the given entry      */
DECL|method|getKey (E entry)
name|K
name|getKey
parameter_list|(
name|E
name|entry
parameter_list|)
function_decl|;
comment|/**      * Gets the next entry relative to the given entry, the exact same entry      * that was provided to {@link Strategy#newEntry} when the given entry was      * created.      *      * @return the next entry or null if null was passed to      *  {@link Strategy#newEntry}      */
DECL|method|getNext (E entry)
name|E
name|getNext
parameter_list|(
name|E
name|entry
parameter_list|)
function_decl|;
comment|/**      * Returns the hash code that was passed to {@link Strategy#newEntry})      * when the given entry was created.      */
DECL|method|getHash (E entry)
name|int
name|getHash
parameter_list|(
name|E
name|entry
parameter_list|)
function_decl|;
comment|// TODO:
comment|//    /**
comment|//     * Notifies the strategy that an entry has been removed from the map.
comment|//     *
comment|//     * @param entry that was recently removed
comment|//     */
comment|//    void remove(E entry);
comment|/**      * Provides an API for interacting directly with the map's internal      * entries to this strategy. Invoked once when the map is created.      * Strategies that don't need access to the map's internal entries      * can simply ignore the argument.      *      * @param internals of the map, enables direct interaction with the      *  internal entries      */
DECL|method|setInternals (Internals<K, V, E> internals)
name|void
name|setInternals
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|internals
parameter_list|)
function_decl|;
block|}
comment|/**    * Provides access to a map's internal entries.    */
DECL|interface|Internals
specifier|public
interface|interface
name|Internals
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
block|{
comment|// TODO:
comment|//    /**
comment|//     * Returns a set view of the internal entries.
comment|//     */
comment|//    Set<E> entrySet();
comment|/**      * Returns the internal entry corresponding to the given key from the map.      *      * @param key to retrieve entry for      *      * @throws NullPointerException if key is null      */
DECL|method|getEntry (K key)
name|E
name|getEntry
parameter_list|(
name|K
name|key
parameter_list|)
function_decl|;
comment|/**      * Removes the given entry from the map if the value of the entry in the      * map matches the given value.      *      * @param entry to remove      * @param value entry must have for the removal to succeed      *      * @throws NullPointerException if entry is null      */
DECL|method|removeEntry (E entry, @Nullable V value)
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Removes the given entry from the map.      *      * @param entry to remove      *      * @throws NullPointerException if entry is null      */
DECL|method|removeEntry (E entry)
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|)
function_decl|;
block|}
comment|/**    * Extends {@link Strategy} to add support for computing values on-demand.    * Implementations should typically intialize the entry's value to a    * placeholder value in {@link #newEntry(Object, int, Object)} so that    * {@link #waitForValue(Object)} can tell the difference between a    * pre-intialized value and an in-progress computation. {@link    * #copyEntry(Object, Object, Object)} must detect and handle the case where    * an entry is copied in the middle of a computation. Implementations can    * throw {@link UnsupportedOperationException} in {@link #setValue(Object,    * Object)} if they wish to prevent users from setting values directly.    *    * @see Builder#buildComputingMap(CustomConcurrentHashMap.ComputingStrategy,    *     Function)    */
DECL|interface|ComputingStrategy
specifier|public
interface|interface
name|ComputingStrategy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
extends|extends
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
comment|/**      * Computes a value for the given key and stores it in the given entry.      * Called as a result of {@link Map#get}. If this method throws an      * exception, CustomConcurrentHashMap will remove the entry and retry      * the computation on subsequent requests.      *      * @param entry that was created      * @param computer passed to {@link Builder#buildMap}      *      * @throws ComputationException if the computation threw an exception      * @throws NullPointerException if the computer returned null      *      * @return the computed value      */
DECL|method|compute (K key, E entry, Function<? super K, ? extends V> computer)
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|,
name|E
name|entry
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
parameter_list|)
function_decl|;
comment|/**      * Gets a value from an entry waiting for the value to be set by {@link      * #compute} if necessary. Returns null if a value isn't available at      * which point CustomConcurrentHashMap tries to compute a new value.      *      * @param entry to return value from      * @return stored value or null if the value isn't available      *      * @throws InterruptedException if the thread was interrupted while      *  waiting      */
DECL|method|waitForValue (E entry)
name|V
name|waitForValue
parameter_list|(
name|E
name|entry
parameter_list|)
throws|throws
name|InterruptedException
function_decl|;
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends    * against poor quality hash functions. This is critical when the    * concurrent hash map uses power-of-two length hash tables, that otherwise    * encounter collisions for hash codes that do not differ in lower or upper    * bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|private
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/** The concurrent hash map implementation. */
DECL|class|Impl
specifier|static
class|class
name|Impl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*      * The basic strategy is to subdivide the table among Segments,      * each of which itself is a concurrently readable hash table.      */
comment|/* ---------------- Constants -------------- */
comment|/**      * The maximum capacity, used if a higher value is implicitly specified by      * either of the constructors with arguments.  MUST be a power of two<=      * 1<<30 to ensure that entries are indexable using ints.      */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**      * The maximum number of segments to allow; used to bound constructor      * arguments.      */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/**      * Number of unsynchronized retries in size and containsValue methods before      * resorting to locking. This is used to avoid unbounded retries if tables      * undergo continuous modification which would make it impossible to obtain      * an accurate result.      */
DECL|field|RETRIES_BEFORE_LOCK
specifier|static
specifier|final
name|int
name|RETRIES_BEFORE_LOCK
init|=
literal|2
decl_stmt|;
comment|/* ---------------- Fields -------------- */
comment|/**      * The strategy used to implement this map.      */
DECL|field|strategy
specifier|final
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
decl_stmt|;
comment|/**      * Mask value for indexing into segments. The upper bits of a key's hash      * code are used to choose the segment.      */
DECL|field|segmentMask
specifier|final
name|int
name|segmentMask
decl_stmt|;
comment|/**      * Shift value for indexing within segments. Helps prevent entries that      * end up in the same segment from also ending up in the same bucket.      */
DECL|field|segmentShift
specifier|final
name|int
name|segmentShift
decl_stmt|;
comment|/**      * The segments, each of which is a specialized hash table      */
DECL|field|segments
specifier|final
name|Segment
index|[]
name|segments
decl_stmt|;
comment|/**      * Creates a new, empty map with the specified strategy, initial capacity,      * load factor and concurrency level.      */
DECL|method|Impl (Strategy<K, V, E> strategy, Builder builder)
name|Impl
parameter_list|(
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
parameter_list|,
name|Builder
name|builder
parameter_list|)
block|{
name|int
name|concurrencyLevel
init|=
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
decl_stmt|;
name|int
name|initialCapacity
init|=
name|builder
operator|.
name|getInitialCapacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|concurrencyLevel
operator|>
name|MAX_SEGMENTS
condition|)
block|{
name|concurrencyLevel
operator|=
name|MAX_SEGMENTS
expr_stmt|;
block|}
comment|// Find power-of-two sizes best matching arguments
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|initialCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|(
name|segmentSize
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|strategy
operator|=
name|strategy
expr_stmt|;
name|strategy
operator|.
name|setInternals
argument_list|(
operator|new
name|InternalsImpl
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|hash (Object key)
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|strategy
operator|.
name|hashKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|class|InternalsImpl
class|class
name|InternalsImpl
implements|implements
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|method|getEntry (K key)
specifier|public
name|E
name|getEntry
parameter_list|(
name|K
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|removeEntry (E entry, V value)
specifier|public
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"entry"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|strategy
operator|.
name|getHash
argument_list|(
name|entry
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|removeEntry (E entry)
specifier|public
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"entry"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|strategy
operator|.
name|getHash
argument_list|(
name|entry
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
name|Segment
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
comment|// Note: This is the only way I could figure out how to create
comment|// a segment array (the compile has a tough time with arrays of
comment|// inner classes of generic types apparently). Safe because we're
comment|// restricting what can go in the array and no one has an
comment|// unrestricted reference.
return|return
operator|(
name|Segment
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|Segment
operator|.
name|class
argument_list|,
name|ssize
argument_list|)
return|;
block|}
comment|/* ---------------- Small Utilities -------------- */
comment|/**      * Returns the segment that should be used for key with given hash      *      * @param hash the hash code for the key      * @return the segment      */
DECL|method|segmentFor (int hash)
name|Segment
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
comment|/* ---------------- Inner Classes -------------- */
comment|/**      * Segments are specialized versions of hash tables.  This subclasses from      * ReentrantLock opportunistically, just to simplify some locking and avoid      * separate construction.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|final
class|class
name|Segment
extends|extends
name|ReentrantLock
block|{
comment|/*        * Segments maintain a table of entry lists that are ALWAYS        * kept in a consistent state, so can be read without locking.        * Next fields of nodes are immutable (final).  All list        * additions are performed at the front of each bin. This        * makes it easy to check changes, and also fast to traverse.        * When nodes would otherwise be changed, new nodes are        * created to replace them. This works well for hash tables        * since the bin lists tend to be short. (The average length        * is less than two for the default load factor threshold.)        *        * Read operations can thus proceed without locking, but rely        * on selected uses of volatiles to ensure that completed        * write operations performed by other threads are        * noticed. For most purposes, the "count" field, tracking the        * number of elements, serves as that volatile variable        * ensuring visibility.  This is convenient because this field        * needs to be read in many read operations anyway:        *        *   - All (unsynchronized) read operations must first read the        *     "count" field, and should not look at table entries if        *     it is 0.        *        *   - All (synchronized) write operations should write to        *     the "count" field after structurally changing any bin.        *     The operations must not take any action that could even        *     momentarily cause a concurrent read operation to see        *     inconsistent data. This is made easier by the nature of        *     the read operations in Map. For example, no operation        *     can reveal that the table has grown but the threshold        *     has not yet been updated, so there are no atomicity        *     requirements for this with respect to reads.        *        * As a guide, all critical volatile reads and writes to the        * count field are marked in code comments.        */
comment|/**        * The number of elements in this segment's region.        */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**        * Number of updates that alter the size of the table. This is used        * during bulk-read methods to make sure they see a consistent snapshot:        * If modCounts change during a traversal of segments computing size or        * checking containsValue, then we might have an inconsistent view of        * state so (usually) must retry.        */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**        * The table is expanded when its size exceeds this threshold. (The        * value of this field is always {@code (int)(capacity * loadFactor)}.)        */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**        * The per-segment table.        */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
decl_stmt|;
DECL|method|Segment (int initialCapacity)
name|Segment
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|setTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
comment|/**        * Sets table to new HashEntry array. Call only while holding lock or in        * constructor.        */
DECL|method|setTable (AtomicReferenceArray<E> newTable)
name|void
name|setTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
comment|/**        * Returns properly casted first entry of bin for given hash.        */
DECL|method|getFirst (int hash)
name|E
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|/* Specialized implementations of map methods */
DECL|method|getEntry (Object key, int hash)
specifier|public
name|E
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|E
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|s
operator|.
name|equalKeys
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|E
name|entry
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|strategy
operator|.
name|getValue
argument_list|(
name|entry
argument_list|)
return|;
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|E
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|s
operator|.
name|equalKeys
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|// Return true only if this entry has a value.
return|return
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
operator|!=
literal|null
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|E
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|V
name|entryValue
init|=
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should skip it.
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|s
operator|.
name|equalValues
argument_list|(
name|entryValue
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|E
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalKeys
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|s
operator|.
name|equalValues
argument_list|(
name|entryValue
argument_list|,
name|oldValue
argument_list|)
condition|)
block|{
name|s
operator|.
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|E
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalKeys
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|s
operator|.
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|count
init|=
name|this
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|count
operator|++
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalKeys
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyIfAbsent
operator|&&
name|entryValue
operator|!=
literal|null
condition|)
block|{
return|return
name|entryValue
return|;
block|}
name|s
operator|.
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|E
name|newEntry
init|=
name|s
operator|.
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|s
operator|.
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**        * Expands the table if possible.        */
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*          * Reclassify nodes in each list to new Map.  Because we are          * using power-of-two expansion, the elements from each bin          * must either stay at same index, or move with a power of two          * offset. We eliminate unnecessary node creation by catching          * cases where old nodes can be reused because their next          * fields won't change. Statistically, at the default          * threshold, only about one-sixth of them need cloning when          * a table doubles. The nodes they replace will be garbage          * collectable as soon as they are no longer referenced by any          * reader thread that may be in the midst of traversing table          * right now.          */
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
name|oldIndex
operator|++
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|//  proceed. So we cannot yet null out each bin.
name|E
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|E
name|next
init|=
name|s
operator|.
name|getNext
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|int
name|headIndex
init|=
name|s
operator|.
name|getHash
argument_list|(
name|head
argument_list|)
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|E
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|E
name|last
init|=
name|next
init|;
name|last
operator|!=
literal|null
condition|;
name|last
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|last
argument_list|)
control|)
block|{
name|int
name|newIndex
init|=
name|s
operator|.
name|getHash
argument_list|(
name|last
argument_list|)
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|last
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|E
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|key
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|int
name|newIndex
init|=
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|&
name|newMask
decl_stmt|;
name|E
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|s
operator|.
name|copyEntry
argument_list|(
name|key
argument_list|,
name|e
argument_list|,
name|newNext
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Key was reclaimed. Skip entry.
block|}
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
block|}
DECL|method|remove (Object key, int hash)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|count
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalKeys
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|strategy
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// All entries following removed node can stay
comment|// in list, but all preceding ones need to be
comment|// cloned.
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|p
init|=
name|first
init|;
name|p
operator|!=
name|e
condition|;
name|p
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|p
argument_list|)
control|)
block|{
name|K
name|pKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pKey
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|s
operator|.
name|copyEntry
argument_list|(
name|pKey
argument_list|,
name|p
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Key was reclaimed. Skip entry.
block|}
block|}
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|count
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
name|K
name|entryKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalKeys
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|strategy
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|entryValue
operator|||
operator|(
name|value
operator|!=
literal|null
operator|&&
name|entryValue
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalValues
argument_list|(
name|entryValue
argument_list|,
name|value
argument_list|)
operator|)
condition|)
block|{
comment|// All entries following removed node can stay
comment|// in list, but all preceding ones need to be
comment|// cloned.
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|p
init|=
name|first
init|;
name|p
operator|!=
name|e
condition|;
name|p
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|p
argument_list|)
control|)
block|{
name|K
name|pKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pKey
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|s
operator|.
name|copyEntry
argument_list|(
name|pKey
argument_list|,
name|p
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Key was reclaimed. Skip entry.
block|}
block|}
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeEntry (E entry, int hash, V value)
specifier|public
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|count
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entry
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|s
operator|.
name|getValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
name|value
operator|||
operator|(
name|value
operator|!=
literal|null
operator|&&
name|s
operator|.
name|equalValues
argument_list|(
name|entryValue
argument_list|,
name|value
argument_list|)
operator|)
condition|)
block|{
comment|// All entries following removed node can stay
comment|// in list, but all preceding ones need to be
comment|// cloned.
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|p
init|=
name|first
init|;
name|p
operator|!=
name|e
condition|;
name|p
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|p
argument_list|)
control|)
block|{
name|K
name|pKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pKey
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|s
operator|.
name|copyEntry
argument_list|(
name|pKey
argument_list|,
name|p
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Key was reclaimed. Skip entry.
block|}
block|}
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeEntry (E entry, int hash)
specifier|public
name|boolean
name|removeEntry
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|count
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getHash
argument_list|(
name|e
argument_list|)
operator|==
name|hash
operator|&&
name|entry
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|// All entries following removed node can stay
comment|// in list, but all preceding ones need to be
comment|// cloned.
operator|++
name|modCount
expr_stmt|;
name|E
name|newFirst
init|=
name|s
operator|.
name|getNext
argument_list|(
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|p
init|=
name|first
init|;
name|p
operator|!=
name|e
condition|;
name|p
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|p
argument_list|)
control|)
block|{
name|K
name|pKey
init|=
name|s
operator|.
name|getKey
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pKey
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|s
operator|.
name|copyEntry
argument_list|(
name|pKey
argument_list|,
name|p
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Key was reclaimed. Skip entry.
block|}
block|}
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* ---------------- Public operations -------------- */
comment|/**      * Returns {@code true} if this map contains no key-value mappings.      *      * @return {@code true} if this map contains no key-value mappings      */
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
specifier|final
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
comment|/*        * We keep track of per-segment modCounts to avoid ABA        * problems in which an element in one segment was added and        * in another removed during traversal, in which case the        * table was never actually empty at any point. Note the        * similar use of modCounts in the size() and containsValue()        * methods, which are the only other methods also susceptible        * to ABA problems.        */
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
block|}
comment|// If mcsum happens to be zero, then we know we got a snapshot
comment|// before any modifications at all were made.  This is
comment|// probably common enough to bother tracking.
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
operator|||
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns the number of key-value mappings in this map.  If the map      * contains more than {@code Integer.MAX_VALUE} elements, returns      * {@code Integer.MAX_VALUE}.      *      * @return the number of key-value mappings in this map      */
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
specifier|final
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|long
name|check
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times to get accurate count. On failure due to
comment|// continuous async changes in table, resort to locking.
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|check
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|check
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|check
operator|=
operator|-
literal|1
expr_stmt|;
comment|// force retry
break|break;
block|}
block|}
block|}
if|if
condition|(
name|check
operator|==
name|sum
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|check
operator|!=
name|sum
condition|)
block|{
comment|// Resort to locking all segments
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|sum
operator|+=
name|segment
operator|.
name|count
expr_stmt|;
block|}
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|sum
return|;
block|}
block|}
comment|/**      * Returns the value to which the specified key is mapped, or {@code null}      * if this map contains no mapping for the key.      *      *<p>More formally, if this map contains a mapping from a key {@code k} to      * a value {@code v} such that {@code key.equals(k)}, then this method      * returns {@code v}; otherwise it returns {@code null}.  (There can be at      * most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Tests if the specified object is a key in this table.      *      * @param key possible key      * @return {@code true} if and only if the specified object is a key in      *         this table, as determined by the {@code equals} method;      *         {@code false} otherwise.      * @throws NullPointerException if the specified key is null      */
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if this map maps one or more keys to the specified      * value. Note: This method requires a full internal traversal of the hash      * table, and so is much slower than method {@code containsKey}.      *      * @param value value whose presence in this map is to be tested      * @return {@code true} if this map maps one or more keys to the specified      *         value      * @throws NullPointerException if the specified value is null      */
DECL|method|containsValue (Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"value"
argument_list|)
throw|;
block|}
comment|// See explanation of modCount use above
specifier|final
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times without locking
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
name|int
name|c
init|=
name|segments
index|[
name|i
index|]
operator|.
name|count
decl_stmt|;
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|boolean
name|cleanSweep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
name|int
name|c
init|=
name|segments
index|[
name|i
index|]
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|cleanSweep
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|cleanSweep
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Resort to locking all segments
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|segment
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
comment|/**      * Maps the specified key to the specified value in this table. Neither the      * key nor the value can be null.      *      *<p> The value can be retrieved by calling the {@code get} method with a      * key that is equal to the original key.      *      * @param key   key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @return the previous value associated with {@code key}, or {@code null}      *         if there was no mapping for {@code key}      * @throws NullPointerException if the specified key or value is null      */
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"value"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key, or      *         {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"value"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one. These      * mappings replace any mappings that this map had for any of the keys      * currently in the specified map.      *      * @param m mappings to be stored in this map      */
DECL|method|putAll (Map<? extends K, ? extends V> m)
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes the key (and its corresponding value) from this map. This method      * does nothing if the key is not in the map.      *      * @param key the key that needs to be removed      * @return the previous value associated with {@code key}, or {@code null}      *         if there was no mapping for {@code key}      * @throws NullPointerException if the specified key is null      */
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if the specified key is null      */
DECL|method|remove (Object key, Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if any of the arguments are null      */
DECL|method|replace (K key, V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"oldValue"
argument_list|)
throw|;
block|}
if|if
condition|(
name|newValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"newValue"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key, or      *         {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"value"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
comment|/**      * Returns a {@link java.util.Set} view of the keys contained in this map.      * The set is backed by the map, so changes to the map are reflected in the      * set, and vice-versa. The set supports element removal, which removes the      * corresponding mapping from this map, via the {@code Iterator.remove},      * {@code Set.remove}, {@code removeAll}, {@code retainAll}, and      * {@code clear} operations. It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException}, and      * guarantees to traverse elements as they existed upon construction of the      * iterator, and may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      */
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
comment|/**      * Returns a {@link java.util.Collection} view of the values contained in      * this map. The collection is backed by the map, so changes to the map are      * reflected in the collection, and vice-versa. The collection supports      * element removal, which removes the corresponding mapping from this map,      * via the {@code Iterator.remove}, {@code Collection.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear} operations. It      * does not support the {@code add} or {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException}, and      * guarantees to traverse elements as they existed upon construction of the      * iterator, and may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      */
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
comment|/**      * Returns a {@link java.util.Set} view of the mappings contained in this      * map. The set is backed by the map, so changes to the map are reflected in      * the set, and vice-versa. The set supports element removal, which removes      * the corresponding mapping from the map, via the {@code Iterator.remove},      * {@code Set.remove}, {@code removeAll}, {@code retainAll}, and      * {@code clear} operations. It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException}, and      * guarantees to traverse elements as they existed upon construction of the      * iterator, and may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      */
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|/* ---------------- Iterator Support -------------- */
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|E
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|hasMoreElements ()
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|Segment
name|seg
init|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
decl_stmt|;
if|if
condition|(
name|seg
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|seg
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**        * Finds the next entry in the current chain. Returns true if an entry        * was found.        */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|nextEntry
argument_list|)
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|s
operator|.
name|getNext
argument_list|(
name|nextEntry
argument_list|)
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**        * Finds the next entry in the current table. Returns true if an entry        * was found.        */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**        * Advances to the given entry. Returns true if the entry was valid,        * false if it should be skipped.        */
DECL|method|advanceTo (E entry)
name|boolean
name|advanceTo
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|s
init|=
name|Impl
operator|.
name|this
operator|.
name|strategy
decl_stmt|;
name|K
name|key
init|=
name|s
operator|.
name|getKey
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|V
name|value
init|=
name|s
operator|.
name|getValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip partially reclaimed entry.
return|return
literal|false
return|;
block|}
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|lastReturned
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|Impl
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**      * Custom Entry class used by EntryIterator.next(), that relays setValue      * changes to the underlying map.      */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|value
name|V
name|value
decl_stmt|;
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getKey ()
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue ()
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/**        * Set our entry's value and write through to the map. The value to        * return is somewhat arbitrary here. Since a WriteThroughEntry does not        * necessarily track asynchronous changes, the most recent "previous"        * value could be different from what we return (or could even have been        * removed in which case the put will re-establish). We do not and        * cannot guarantee more.        */
DECL|method|setValue (V value)
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|V
name|oldValue
init|=
name|Impl
operator|.
name|this
operator|.
name|put
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|oldValue
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Impl
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Impl
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|Impl
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|strategy
operator|.
name|equalValues
argument_list|(
name|v
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|Impl
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|Impl
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Impl
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* ---------------- Serialization Support -------------- */
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
DECL|method|writeObject (java.io.ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|segments
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// concurrencyLevel
name|out
operator|.
name|writeObject
argument_list|(
name|strategy
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// terminate entries
block|}
comment|/**      * Fields used during deserialization. We use a nested class so we don't      * load them until we need them. We need to use reflection to set final      * fields outside of the constructor.      */
DECL|class|Fields
specifier|static
class|class
name|Fields
block|{
DECL|field|segmentShift
specifier|static
specifier|final
name|Field
name|segmentShift
init|=
name|findField
argument_list|(
literal|"segmentShift"
argument_list|)
decl_stmt|;
DECL|field|segmentMask
specifier|static
specifier|final
name|Field
name|segmentMask
init|=
name|findField
argument_list|(
literal|"segmentMask"
argument_list|)
decl_stmt|;
DECL|field|segments
specifier|static
specifier|final
name|Field
name|segments
init|=
name|findField
argument_list|(
literal|"segments"
argument_list|)
decl_stmt|;
DECL|field|strategy
specifier|static
specifier|final
name|Field
name|strategy
init|=
name|findField
argument_list|(
literal|"strategy"
argument_list|)
decl_stmt|;
DECL|method|findField (String name)
specifier|static
name|Field
name|findField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|Field
name|f
init|=
name|Impl
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readObject (java.io.ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
try|try
block|{
name|int
name|initialCapacity
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|concurrencyLevel
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
init|=
operator|(
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|concurrencyLevel
operator|>
name|MAX_SEGMENTS
condition|)
block|{
name|concurrencyLevel
operator|=
name|MAX_SEGMENTS
expr_stmt|;
block|}
comment|// Find power-of-two sizes best matching arguments
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|Fields
operator|.
name|segmentShift
operator|.
name|set
argument_list|(
name|this
argument_list|,
literal|32
operator|-
name|segmentShift
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|segmentMask
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|segmentCount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|segments
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|initialCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|(
name|segmentSize
argument_list|)
expr_stmt|;
block|}
name|Fields
operator|.
name|strategy
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
break|break;
comment|// terminator
block|}
name|V
name|value
init|=
operator|(
name|V
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|ComputingImpl
specifier|static
class|class
name|ComputingImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
extends|extends
name|Impl
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|computingStrategy
specifier|final
name|ComputingStrategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|computingStrategy
decl_stmt|;
DECL|field|computer
specifier|final
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
decl_stmt|;
comment|/**      * Creates a new, empty map with the specified strategy, initial capacity,      * load factor and concurrency level.      */
DECL|method|ComputingImpl (ComputingStrategy<K, V, E> strategy, Builder builder, Function<? super K, ? extends V> computer)
name|ComputingImpl
parameter_list|(
name|ComputingStrategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|E
argument_list|>
name|strategy
parameter_list|,
name|Builder
name|builder
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
parameter_list|)
block|{
name|super
argument_list|(
name|strategy
argument_list|,
name|builder
argument_list|)
expr_stmt|;
name|this
operator|.
name|computingStrategy
operator|=
name|strategy
expr_stmt|;
name|this
operator|.
name|computer
operator|=
name|computer
expr_stmt|;
block|}
DECL|method|get (Object k)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
comment|/*        * This cast isn't safe, but we can rely on the fact that K is almost        * always passed to Map.get(), and tools like IDEs and Findbugs can        * catch situations where this isn't the case.        *        * The alternative is to add an overloaded method, but the chances of        * a user calling get() instead of the new API and the risks inherent        * in adding a new API outweigh this little hole.        */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|key
init|=
operator|(
name|K
operator|)
name|k
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"key"
argument_list|)
throw|;
block|}
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Segment
name|segment
init|=
name|segmentFor
argument_list|(
name|hash
argument_list|)
decl_stmt|;
name|outer
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|E
name|entry
init|=
name|segment
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|boolean
name|created
init|=
literal|false
decl_stmt|;
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Try again--an entry could have materialized in the interim.
name|entry
operator|=
name|segment
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
comment|// Create a new entry.
name|created
operator|=
literal|true
expr_stmt|;
name|int
name|count
init|=
name|segment
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|count
operator|++
operator|>
name|segment
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|segment
operator|.
name|expand
argument_list|()
expr_stmt|;
block|}
name|AtomicReferenceArray
argument_list|<
name|E
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|E
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
operator|++
name|segment
operator|.
name|modCount
expr_stmt|;
name|entry
operator|=
name|computingStrategy
operator|.
name|newEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|segment
operator|.
name|count
operator|=
name|count
expr_stmt|;
comment|// write-volatile
block|}
block|}
finally|finally
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|created
condition|)
block|{
comment|// This thread solely created the entry.
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|V
name|value
init|=
name|computingStrategy
operator|.
name|compute
argument_list|(
name|key
argument_list|,
name|entry
argument_list|,
name|computer
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"compute() returned null unexpectedly"
argument_list|)
throw|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|value
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|segment
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// The entry already exists. Wait for the computation.
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|V
name|value
init|=
name|computingStrategy
operator|.
name|waitForValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// Purge entry and try again.
name|segment
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
expr_stmt|;
continue|continue
name|outer
continue|;
block|}
return|return
name|value
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * A basic, no-frills implementation of {@code Strategy} using {@link    * SimpleInternalEntry}. Intended to be subclassed to provide customized    * behavior. For example, the following creates a map that uses byte arrays as    * keys:<pre>   {@code    *    *   return new CustomConcurrentHashMap.Builder().buildMap(    *       new SimpleStrategy<byte[], V>() {    *         public int hashKey(Object key) {    *           return Arrays.hashCode((byte[]) key);    *         }    *         public boolean equalKeys(byte[] a, Object b) {    *           return Arrays.equals(a, (byte[]) b);    *         }    *       });}</pre>    *    * With nothing overridden, it yields map behavior equivalent to that of    * {@link ConcurrentHashMap}.    */
DECL|class|SimpleStrategy
specifier|static
class|class
name|SimpleStrategy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Strategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|newEntry ( K key, int hash, SimpleInternalEntry<K, V> next)
specifier|public
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
literal|null
argument_list|,
name|next
argument_list|)
return|;
block|}
DECL|method|copyEntry (K key, SimpleInternalEntry<K, V> original, SimpleInternalEntry<K, V> next)
specifier|public
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|original
operator|.
name|hash
argument_list|,
name|original
operator|.
name|value
argument_list|,
name|next
argument_list|)
return|;
block|}
DECL|method|setValue (SimpleInternalEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|entry
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getValue (SimpleInternalEntry<K, V> entry)
specifier|public
name|V
name|getValue
parameter_list|(
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|value
return|;
block|}
DECL|method|equalKeys (K a, Object b)
specifier|public
name|boolean
name|equalKeys
parameter_list|(
name|K
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|equalValues (V a, Object b)
specifier|public
name|boolean
name|equalValues
parameter_list|(
name|V
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|hashKey (Object key)
specifier|public
name|int
name|hashKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|key
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|getKey (SimpleInternalEntry<K, V> entry)
specifier|public
name|K
name|getKey
parameter_list|(
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|key
return|;
block|}
DECL|method|getNext (SimpleInternalEntry<K, V> entry)
specifier|public
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|(
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|next
return|;
block|}
DECL|method|getHash (SimpleInternalEntry<K, V> entry)
specifier|public
name|int
name|getHash
parameter_list|(
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|hash
return|;
block|}
DECL|method|setInternals ( Internals<K, V, SimpleInternalEntry<K, V>> internals)
specifier|public
name|void
name|setInternals
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|)
block|{
comment|// ignore?
block|}
block|}
comment|/**    * A basic, no-frills entry class used by {@link SimpleInternalEntry}.    */
DECL|class|SimpleInternalEntry
specifier|static
class|class
name|SimpleInternalEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|value
specifier|volatile
name|V
name|value
decl_stmt|;
DECL|method|SimpleInternalEntry ( K key, int hash, @Nullable V value, SimpleInternalEntry<K, V> next)
name|SimpleInternalEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
name|SimpleInternalEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

