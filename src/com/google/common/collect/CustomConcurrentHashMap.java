begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableReferenceQueue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableSoftReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableWeakReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|concurrent
operator|.
name|GuardedBy
import|;
end_import

begin_comment
comment|/**  * The concurrent hash map implementation built by {@link MapMaker}.  *  * This implementation is heavily derived from revision 1.96 of  *<a href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.  *   * @author Bob Lee  * @author Doug Lea ({@code ConcurrentHashMap})  */
end_comment

begin_class
DECL|class|CustomConcurrentHashMap
class|class
name|CustomConcurrentHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*    * TODO: Select a permanent name for this class. The name matters because    * we expose it in the serialized state and will be stuck w/ it forever.    */
comment|/*    * The basic strategy is to subdivide the table among Segments,    * each of which itself is a concurrently readable hash table.    */
comment|/* ---------------- Constants -------------- */
comment|/**    * The maximum capacity, used if a higher value is implicitly specified by    * either of the constructors with arguments.  MUST be a power of two<=    * 1<<30 to ensure that entries are indexable using ints.    */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**    * The maximum number of segments to allow; used to bound constructor    * arguments.    */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/**    * Number of unsynchronized retries in size and containsValue methods before    * resorting to locking. This is used to avoid unbounded retries if tables    * undergo continuous modification which would make it impossible to obtain    * an accurate result.    *    * TODO: Talk to Doug about the possiblity of defining size() and    * containsValue() in terms of weakly consistent iteration.    */
DECL|field|RETRIES_BEFORE_LOCK
specifier|static
specifier|final
name|int
name|RETRIES_BEFORE_LOCK
init|=
literal|2
decl_stmt|;
comment|/* ---------------- Fields -------------- */
comment|/**    * Mask value for indexing into segments. The upper bits of a key's hash    * code are used to choose the segment.    */
DECL|field|segmentMask
specifier|final
specifier|transient
name|int
name|segmentMask
decl_stmt|;
comment|/**    * Shift value for indexing within segments. Helps prevent entries that    * end up in the same segment from also ending up in the same bucket.    */
DECL|field|segmentShift
specifier|final
specifier|transient
name|int
name|segmentShift
decl_stmt|;
comment|/** The segments, each of which is a specialized hash table. */
DECL|field|segments
specifier|final
specifier|transient
name|Segment
index|[]
name|segments
decl_stmt|;
comment|/** Strategy for comparing keys. */
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
comment|/** Strategy for comparing values. */
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
comment|/** Strategy for referencing keys. */
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
comment|/** Strategy for referencing values. */
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
comment|/** How long the map retains values in ns. */
DECL|field|expirationNanos
specifier|final
name|long
name|expirationNanos
decl_stmt|;
comment|/** True if expiration is enabled. */
DECL|field|expires
specifier|final
name|boolean
name|expires
decl_stmt|;
comment|/**    * The maximum size of this map. MapMaker.UNSET_MAXIMUM_SIZE if there is no    * maximum.    */
DECL|field|maximumSize
specifier|final
name|int
name|maximumSize
decl_stmt|;
comment|/** True if size-based eviction is enabled. */
DECL|field|evicts
specifier|final
name|boolean
name|evicts
decl_stmt|;
comment|/** The concurrency level. */
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|/** Factory used to create new entries. */
DECL|field|entryFactory
specifier|final
specifier|transient
name|EntryFactory
name|entryFactory
decl_stmt|;
comment|/**    * Creates a new, empty map with the specified strategy, initial capacity    * and concurrency level.    */
DECL|method|CustomConcurrentHashMap (MapMaker builder)
name|CustomConcurrentHashMap
parameter_list|(
name|MapMaker
name|builder
parameter_list|)
block|{
name|keyStrength
operator|=
name|builder
operator|.
name|getKeyStrength
argument_list|()
expr_stmt|;
name|valueStrength
operator|=
name|builder
operator|.
name|getValueStrength
argument_list|()
expr_stmt|;
name|keyEquivalence
operator|=
name|builder
operator|.
name|getKeyEquivalence
argument_list|()
expr_stmt|;
name|valueEquivalence
operator|=
name|builder
operator|.
name|getValueEquivalence
argument_list|()
expr_stmt|;
name|expirationNanos
operator|=
name|builder
operator|.
name|getExpirationNanos
argument_list|()
expr_stmt|;
name|maximumSize
operator|=
name|builder
operator|.
name|maximumSize
expr_stmt|;
name|evicts
operator|=
name|maximumSize
operator|!=
name|MapMaker
operator|.
name|UNSET_MAXIMUM_SIZE
expr_stmt|;
name|expires
operator|=
name|expirationNanos
operator|>
literal|0
expr_stmt|;
name|entryFactory
operator|=
name|EntryFactory
operator|.
name|getFactory
argument_list|(
name|keyStrength
argument_list|,
name|expires
argument_list|,
name|evicts
argument_list|)
expr_stmt|;
name|concurrencyLevel
operator|=
name|filterConcurrencyLevel
argument_list|(
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Handle initialCapacity> maximumSize.
name|int
name|initialCapacity
init|=
name|builder
operator|.
name|getInitialCapacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|initialCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|initialCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
comment|// Find power-of-two sizes best matching arguments
name|int
name|segmentShift
init|=
literal|0
decl_stmt|;
name|int
name|segmentCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentCount
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|segmentShift
expr_stmt|;
name|segmentCount
operator|<<=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|segmentShift
operator|=
literal|32
operator|-
name|segmentShift
expr_stmt|;
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|newSegmentArray
argument_list|(
name|segmentCount
argument_list|)
expr_stmt|;
name|int
name|segmentCapacity
init|=
name|initialCapacity
operator|/
name|segmentCount
decl_stmt|;
if|if
condition|(
name|segmentCapacity
operator|*
name|segmentCount
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|segmentCapacity
expr_stmt|;
block|}
name|int
name|segmentSize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|segmentSize
operator|<
name|segmentCapacity
condition|)
block|{
name|segmentSize
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|evicts
condition|)
block|{
comment|// Ensure sum of segment max sizes = overall max size
name|int
name|maximumSegmentSize
init|=
name|maximumSize
operator|/
name|segmentCount
operator|+
literal|1
decl_stmt|;
name|int
name|remainder
init|=
name|maximumSize
operator|%
name|segmentCount
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|remainder
condition|)
block|{
name|maximumSegmentSize
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|(
name|segmentSize
argument_list|,
name|maximumSegmentSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|(
name|segmentSize
argument_list|,
name|MapMaker
operator|.
name|UNSET_MAXIMUM_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the given concurrency level or MAX_SEGMENTS if the given level    * is> MAX_SEGMENTS.    */
DECL|method|filterConcurrencyLevel (int concurrenyLevel)
specifier|static
name|int
name|filterConcurrencyLevel
parameter_list|(
name|int
name|concurrenyLevel
parameter_list|)
block|{
return|return
name|Math
operator|.
name|min
argument_list|(
name|concurrenyLevel
argument_list|,
name|MAX_SEGMENTS
argument_list|)
return|;
block|}
DECL|enum|Strength
enum|enum
name|Strength
block|{
comment|/*      * TODO: If we strongly reference the value and aren't computing, we      * needn't wrap the value. This could save ~8 bytes per entry.      */
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|equals
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
block|{
return|return
name|Equivalences
operator|.
name|identity
argument_list|()
return|;
block|}
block|}
block|;
comment|/**      * Creates a reference for the given value according to this value      * strength.      */
DECL|method|referenceValue ( ReferenceEntry<K, V> entry, V value)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Returns the default equivalence strategy used to compare and hash      * keys or values referenced at this strength. This strategy will be used      * unless the user explicitly specifies an alternate strategy.      */
DECL|method|defaultEquivalence ()
specifier|abstract
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|defaultEquivalence
parameter_list|()
function_decl|;
block|}
comment|/**    * Creates new entries.    */
DECL|enum|EntryFactory
enum|enum
name|EntryFactory
block|{
comment|// TODO: Generate all of these combos at build time.
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EXPIRABLE
name|STRONG_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EVICTABLE
name|STRONG_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG_EXPIRABLE_EVICTABLE
name|STRONG_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|StrongExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EXPIRABLE
name|SOFT_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EVICTABLE
name|SOFT_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT_EXPIRABLE_EVICTABLE
name|SOFT_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|SoftExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EXPIRABLE
name|WEAK_EXPIRABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakExpirableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EVICTABLE
name|WEAK_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|,
DECL|enumConstant|WEAK_EXPIRABLE_EVICTABLE
name|WEAK_EXPIRABLE_EVICTABLE
block|{
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|new
name|WeakExpirableEvictableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|super
operator|.
name|copyEntry
argument_list|(
name|map
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|copyExpirableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|copyEvictableEntry
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
block|;
comment|/**      * Masks used to compute indices in the following table.      */
DECL|field|EXPIRABLE_MASK
specifier|static
specifier|final
name|int
name|EXPIRABLE_MASK
init|=
literal|1
decl_stmt|;
DECL|field|EVICTABLE_MASK
specifier|static
specifier|final
name|int
name|EVICTABLE_MASK
init|=
literal|2
decl_stmt|;
comment|/**      * Look-up table for factories. First dimension is the reference type.      * The second dimension is the result of OR-ing the feature masks.      */
DECL|field|FACTORIES
specifier|static
specifier|final
name|EntryFactory
index|[]
index|[]
name|FACTORIES
init|=
block|{
block|{
name|STRONG
block|,
name|STRONG_EXPIRABLE
block|,
name|STRONG_EVICTABLE
block|,
name|STRONG_EXPIRABLE_EVICTABLE
block|}
block|,
block|{
name|SOFT
block|,
name|SOFT_EXPIRABLE
block|,
name|SOFT_EVICTABLE
block|,
name|SOFT_EXPIRABLE_EVICTABLE
block|}
block|,
block|{
name|WEAK
block|,
name|WEAK_EXPIRABLE
block|,
name|WEAK_EVICTABLE
block|,
name|WEAK_EXPIRABLE_EVICTABLE
block|}
block|}
decl_stmt|;
DECL|method|getFactory (Strength keyStrength, boolean expires, boolean evicts)
specifier|static
name|EntryFactory
name|getFactory
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|boolean
name|expires
parameter_list|,
name|boolean
name|evicts
parameter_list|)
block|{
name|int
name|flags
init|=
operator|(
name|expires
condition|?
name|EXPIRABLE_MASK
else|:
literal|0
operator|)
operator||
operator|(
name|evicts
condition|?
name|EVICTABLE_MASK
else|:
literal|0
operator|)
decl_stmt|;
return|return
name|FACTORIES
index|[
name|keyStrength
operator|.
name|ordinal
argument_list|()
index|]
index|[
name|flags
index|]
return|;
block|}
comment|/**      * Creates a new entry.      *      * @param map to create the entry for      * @param key of the entry      * @param hash of the key      * @param next entry in the same bucket      */
DECL|method|newEntry ( CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Copies an entry, assigning it a new {@code next} entry.      *      * @param original the entry to copy      * @param newNext entry in the same bucket      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyEntry ( CustomConcurrentHashMap<K, V> map, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
return|return
name|newEntry
argument_list|(
name|map
argument_list|,
name|original
operator|.
name|getKey
argument_list|()
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyExpirableEntry ( ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyExpirableEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
name|Expirable
name|originalExpirable
init|=
operator|(
name|Expirable
operator|)
name|original
decl_stmt|;
name|Expirable
name|newExpirable
init|=
operator|(
name|Expirable
operator|)
name|newEntry
decl_stmt|;
name|newExpirable
operator|.
name|setWriteTime
argument_list|(
name|originalExpirable
operator|.
name|getWriteTime
argument_list|()
argument_list|)
expr_stmt|;
name|connectExpirable
argument_list|(
name|originalExpirable
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|newExpirable
argument_list|)
expr_stmt|;
name|connectExpirable
argument_list|(
name|newExpirable
argument_list|,
name|originalExpirable
operator|.
name|getNextExpirable
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyExpirable
argument_list|(
name|originalExpirable
argument_list|)
expr_stmt|;
block|}
DECL|method|copyEvictableEntry ( ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|copyEvictableEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
name|Evictable
name|originalEvictable
init|=
operator|(
name|Evictable
operator|)
name|original
decl_stmt|;
name|Evictable
name|newEvictable
init|=
operator|(
name|Evictable
operator|)
name|newEntry
decl_stmt|;
name|newEvictable
operator|.
name|setLastUsage
argument_list|(
name|originalEvictable
operator|.
name|getLastUsage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** A reference to a value. */
DECL|interface|ValueReference
interface|interface
name|ValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value. Does not block or throw exceptions.      */
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/** Creates a copy of this reference for the given entry. */
DECL|method|copyFor (ReferenceEntry<K, V> entry)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/**      * Waits for a value that may still be computing. Unlike get(),      * this method can block (in the case of FutureValueReference) or      * throw an exception.      */
DECL|method|waitForValue ()
name|V
name|waitForValue
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
block|}
comment|/**    * Placeholder. Indicates that the value hasn't been set yet.    */
DECL|field|UNSET
specifier|static
specifier|final
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|UNSET
init|=
operator|new
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
specifier|public
name|Object
name|waitForValue
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
comment|/**    * Singleton placeholder that indicates a value is being computed.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Safe because impl never uses a parameter or returns any non-null value
DECL|method|unset ()
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unset
parameter_list|()
block|{
return|return
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|UNSET
return|;
block|}
comment|/** Wrapper class ensures that queue isn't created until it's used. */
DECL|class|QueueHolder
specifier|private
specifier|static
class|class
name|QueueHolder
block|{
DECL|field|queue
specifier|static
specifier|final
name|FinalizableReferenceQueue
name|queue
init|=
operator|new
name|FinalizableReferenceQueue
argument_list|()
decl_stmt|;
block|}
comment|/**    * An entry in a reference map.    */
DECL|interface|ReferenceEntry
interface|interface
name|ReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value reference from this entry.      */
DECL|method|getValueReference ()
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Sets the value reference for this entry.      */
DECL|method|setValueReference (ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
function_decl|;
comment|/**      * Removes this entry from the map if its value reference hasn't      * changed.  Used to clean up after values. The value reference can      * just call this method on the entry so it doesn't have to keep      * its own reference to the map.      */
DECL|method|valueReclaimed ()
name|void
name|valueReclaimed
parameter_list|()
function_decl|;
comment|/** Gets the next entry in the chain. */
DECL|method|getNext ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
function_decl|;
comment|/** Gets the entry's hash. */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/** Gets the key for this entry. */
DECL|method|getKey ()
name|K
name|getKey
parameter_list|()
function_decl|;
block|}
comment|/**    * Implemented by entries that are expirable. Expirable entries are    * maintained in a doubly-linked list. New entries are added at the tail    * of the list at write time; stale entries are expired from the head    * of the list.    */
DECL|interface|Expirable
interface|interface
name|Expirable
block|{
comment|/** Gets the entry write time in ns. */
DECL|method|getWriteTime ()
name|long
name|getWriteTime
parameter_list|()
function_decl|;
comment|/** Sets the entry write time in ns. */
DECL|method|setWriteTime (long writeTime)
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
function_decl|;
comment|/** Gets the next entry in the recency list. */
DECL|method|getNextExpirable ()
name|Expirable
name|getNextExpirable
parameter_list|()
function_decl|;
comment|/** Sets the next entry in the recency list. */
DECL|method|setNextExpirable (Expirable next)
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
function_decl|;
comment|/** Gets the previous entry in the recency list. */
DECL|method|getPreviousExpirable ()
name|Expirable
name|getPreviousExpirable
parameter_list|()
function_decl|;
comment|/** Sets the previous entry in the recency list. */
DECL|method|setPreviousExpirable (Expirable previous)
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
function_decl|;
block|}
DECL|enum|NullExpirable
specifier|private
enum|enum
name|NullExpirable
implements|implements
name|Expirable
block|{
DECL|enumConstant|INSTANCE
name|INSTANCE
block|;
annotation|@
name|Override
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{}
block|}
comment|/** Implemented by entries that support eviction. */
DECL|interface|Evictable
interface|interface
name|Evictable
block|{
comment|/** Sets the last usage timestamp. */
DECL|method|setLastUsage (int timestamp)
name|void
name|setLastUsage
parameter_list|(
name|int
name|timestamp
parameter_list|)
function_decl|;
comment|/** Gets the last usage timestamp. */
DECL|method|getLastUsage ()
name|int
name|getLastUsage
parameter_list|()
function_decl|;
block|}
comment|/*    * Note: All of this duplicate code sucks, but it saves a lot of memory.    * If only Java had mixins! To maintain this code, make a change for    * the strong reference type. Then, cut and paste, and replace "Strong"    * with "Soft" or "Weak" within the pasted text. The primary difference    * is that strong entries store the key reference directly while soft    * and weak entries delegate to their respective superclasses.    *    * TODO: Generate this code.    */
comment|/**    * Used for strongly-referenced keys.    */
DECL|class|StrongEntry
specifier|private
specifier|static
class|class
name|StrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|method|StrongEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|StrongEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|map
specifier|final
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|map
operator|.
name|reclaimValue
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|StrongExpirableEntry
specifier|private
specifier|static
class|class
name|StrongExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
block|{
DECL|method|StrongExpirableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|StrongExpirableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|StrongEvictableEntry
specifier|private
specifier|static
class|class
name|StrongEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Evictable
block|{
DECL|method|StrongEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|StrongEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
DECL|class|StrongExpirableEvictableEntry
specifier|private
specifier|static
class|class
name|StrongExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
implements|,
name|Evictable
block|{
DECL|method|StrongExpirableEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|StrongExpirableEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
comment|/**    * Used for softly-referenced keys.    */
DECL|class|SoftEntry
specifier|private
specifier|static
class|class
name|SoftEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableSoftReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|SoftEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|map
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|map
specifier|final
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|map
operator|.
name|reclaimValue
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|SoftExpirableEntry
specifier|private
specifier|static
class|class
name|SoftExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
block|{
DECL|method|SoftExpirableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|SoftExpirableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|SoftEvictableEntry
specifier|private
specifier|static
class|class
name|SoftEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Evictable
block|{
DECL|method|SoftEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|SoftEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
DECL|class|SoftExpirableEvictableEntry
specifier|private
specifier|static
class|class
name|SoftExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
implements|,
name|Evictable
block|{
DECL|method|SoftExpirableEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|SoftExpirableEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
comment|/**    * Used for weakly-referenced keys.    */
DECL|class|WeakEntry
specifier|private
specifier|static
class|class
name|WeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableWeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|WeakEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|map
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|map
specifier|final
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|unset
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|map
operator|.
name|reclaimValue
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|class|WeakExpirableEntry
specifier|private
specifier|static
class|class
name|WeakExpirableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
block|{
DECL|method|WeakExpirableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|WeakExpirableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
block|}
DECL|class|WeakEvictableEntry
specifier|private
specifier|static
class|class
name|WeakEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Evictable
block|{
DECL|method|WeakEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|WeakEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
DECL|class|WeakExpirableEvictableEntry
specifier|private
specifier|static
class|class
name|WeakExpirableEvictableEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Expirable
implements|,
name|Evictable
block|{
DECL|method|WeakExpirableEvictableEntry (CustomConcurrentHashMap<K, V> map, K key, int hash, ReferenceEntry<K, V> next)
name|WeakExpirableEvictableEntry
parameter_list|(
name|CustomConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each expirable entry type.
DECL|field|writeTime
specifier|volatile
name|long
name|writeTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|getWriteTime ()
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|writeTime
return|;
block|}
DECL|method|setWriteTime (long writeTime)
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|writeTime
operator|=
name|writeTime
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|next
name|Expirable
name|next
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getNextExpirable ()
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
DECL|method|setNextExpirable (Expirable next)
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|field|previous
name|Expirable
name|previous
init|=
name|NullExpirable
operator|.
name|INSTANCE
decl_stmt|;
DECL|method|getPreviousExpirable ()
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
DECL|method|setPreviousExpirable (Expirable previous)
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
comment|// The code below is exactly the same for each evictable entry type.
DECL|field|lastUsage
specifier|volatile
name|int
name|lastUsage
decl_stmt|;
DECL|method|getLastUsage ()
specifier|public
name|int
name|getLastUsage
parameter_list|()
block|{
return|return
name|lastUsage
return|;
block|}
DECL|method|setLastUsage (int lastUsage)
specifier|public
name|void
name|setLastUsage
parameter_list|(
name|int
name|lastUsage
parameter_list|)
block|{
name|this
operator|.
name|lastUsage
operator|=
name|lastUsage
expr_stmt|;
block|}
block|}
comment|/** References a weak value. */
DECL|class|WeakValueReference
specifier|private
specifier|static
class|class
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableWeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|WeakValueReference (V referent, ReferenceEntry<K, V> entry)
name|WeakValueReference
parameter_list|(
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|entry
operator|.
name|valueReclaimed
argument_list|()
expr_stmt|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/** References a soft value. */
DECL|class|SoftValueReference
specifier|private
specifier|static
class|class
name|SoftValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableSoftReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|SoftValueReference (V referent, ReferenceEntry<K, V> entry)
name|SoftValueReference
parameter_list|(
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|entry
operator|.
name|valueReclaimed
argument_list|()
expr_stmt|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/** References a strong value. */
DECL|class|StrongValueReference
specifier|private
specifier|static
class|class
name|StrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|referent
specifier|final
name|V
name|referent
decl_stmt|;
DECL|method|StrongValueReference (V referent)
name|StrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|)
block|{
name|this
operator|.
name|referent
operator|=
name|referent
expr_stmt|;
block|}
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|referent
return|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/**    * Applies a supplemental hash function to a given hash code, which defends    * against poor quality hash functions. This is critical when the    * concurrent hash map uses power-of-two length hash tables, that otherwise    * encounter collisions for hash codes that do not differ in lower or upper    * bits.    *    * @param h hash code    */
DECL|method|rehash (int h)
specifier|private
specifier|static
name|int
name|rehash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
comment|// TODO: use Hashing/move this to Hashing?
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|/**    * Sets the value reference on an entry and notifies waiting threads.    */
DECL|method|setValueReference (ReferenceEntry<K, V> entry, ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|entry
operator|.
name|setValueReference
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|copyEntry ( ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|original
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|entryFactory
operator|.
name|copyEntry
argument_list|(
name|this
argument_list|,
name|original
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|copyFor
argument_list|(
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
DECL|method|hash (Object key)
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
comment|// TODO: can we just trust keyEquivalence to throw NPE as it promises?
comment|// (That is, if some user's Equivalence doesn't, let them get a broken map?)
name|int
name|h
init|=
name|keyEquivalence
operator|.
name|hash
argument_list|(
name|checkNotNull
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rehash
argument_list|(
name|h
argument_list|)
return|;
block|}
DECL|method|reclaimValue (ReferenceEntry<K, V> entry)
name|boolean
name|reclaimValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|reclaimValue
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|removeEntry (ReferenceEntry<K, V> entry)
name|boolean
name|removeEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|int
name|hash
init|=
name|entry
operator|.
name|getHash
argument_list|()
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|connectExpirable (Expirable previous, Expirable next)
specifier|static
name|void
name|connectExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|,
name|Expirable
name|next
parameter_list|)
block|{
name|previous
operator|.
name|setNextExpirable
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPreviousExpirable
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|nullifyExpirable (Expirable nulled)
specifier|static
name|void
name|nullifyExpirable
parameter_list|(
name|Expirable
name|nulled
parameter_list|)
block|{
name|nulled
operator|.
name|setNextExpirable
argument_list|(
name|NullExpirable
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|nulled
operator|.
name|setPreviousExpirable
argument_list|(
name|NullExpirable
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the given entry has expired.    */
DECL|method|isExpired (ReferenceEntry<K, V> entry)
name|boolean
name|isExpired
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|isExpired
argument_list|(
operator|(
name|Expirable
operator|)
name|entry
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns true if the given entry has expired.    */
DECL|method|isExpired (Expirable expirable, long now)
name|boolean
name|isExpired
parameter_list|(
name|Expirable
name|expirable
parameter_list|,
name|long
name|now
parameter_list|)
block|{
comment|// Avoid overflow.
return|return
name|now
operator|-
name|expirable
operator|.
name|getWriteTime
argument_list|()
operator|>
name|expirationNanos
return|;
block|}
comment|/**    * Gets the value from an entry. Returns null if the value is null (i.e.    * reclaimed or not computed yet) or if the entry is expired. If    * you already called expireEntries() you can just check the value for    * null and skip the expiration check.    */
DECL|method|getUnexpiredValue (ReferenceEntry<K, V> e)
name|V
name|getUnexpiredValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|V
name|value
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|expires
operator|&&
name|isExpired
argument_list|(
name|e
argument_list|)
operator|)
condition|?
literal|null
else|:
name|value
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newSegmentArray (int ssize)
specifier|final
name|Segment
index|[]
name|newSegmentArray
parameter_list|(
name|int
name|ssize
parameter_list|)
block|{
comment|// Note: This is the only way I could figure out how to create
comment|// a segment array (the compiler has a tough time with arrays of
comment|// inner classes of generic types apparently). Safe because we're
comment|// restricting what can go in the array and no one has an
comment|// unrestricted reference.
return|return
operator|(
name|Segment
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|Segment
operator|.
name|class
argument_list|,
name|ssize
argument_list|)
return|;
block|}
comment|/* ---------------- Small Utilities -------------- */
comment|/**    * Returns the segment that should be used for a key with the given hash.    *    * @param hash the hash code for the key    * @return the segment    */
DECL|method|segmentFor (int hash)
name|Segment
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// TODO: Lazily create segments.
return|return
name|segments
index|[
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
index|]
return|;
block|}
comment|/* ---------------- Inner Classes -------------- */
comment|/**    * Segments are specialized versions of hash tables.  This subclass inherits    * from ReentrantLock opportunistically, just to simplify some locking and    * avoid separate construction.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// This class is never serialized.
DECL|class|Segment
specifier|final
class|class
name|Segment
extends|extends
name|ReentrantLock
block|{
comment|/*      * TODO: Consider copying variables (like evicts) from outer class into      * this class. It will require more memory but will reduce indirection.      */
comment|/*      * Segments maintain a table of entry lists that are ALWAYS      * kept in a consistent state, so can be read without locking.      * Next fields of nodes are immutable (final).  All list      * additions are performed at the front of each bin. This      * makes it easy to check changes, and also fast to traverse.      * When nodes would otherwise be changed, new nodes are      * created to replace them. This works well for hash tables      * since the bin lists tend to be short. (The average length      * is less than two.)      *      * Read operations can thus proceed without locking, but rely      * on selected uses of volatiles to ensure that completed      * write operations performed by other threads are      * noticed. For most purposes, the "count" field, tracking the      * number of elements, serves as that volatile variable      * ensuring visibility.  This is convenient because this field      * needs to be read in many read operations anyway:      *      *   - All (unsynchronized) read operations must first read the      *     "count" field, and should not look at table entries if      *     it is 0.      *      *   - All (synchronized) write operations should write to      *     the "count" field after structurally changing any bin.      *     The operations must not take any action that could even      *     momentarily cause a concurrent read operation to see      *     inconsistent data. This is made easier by the nature of      *     the read operations in Map. For example, no operation      *     can reveal that the table has grown but the threshold      *     has not yet been updated, so there are no atomicity      *     requirements for this with respect to reads.      *      * As a guide, all critical volatile reads and writes to the      * count field are marked in code comments.      */
comment|/**      * The number of elements in this segment's region.      */
DECL|field|count
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**      * Number of updates that alter the size of the table. This is used      * during bulk-read methods to make sure they see a consistent snapshot:      * If modCounts change during a traversal of segments computing size or      * checking containsValue, then we might have an inconsistent view of      * state so (usually) must retry.      */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**      * The table is expanded when its size exceeds this threshold. (The      * value of this field is always {@code (int)(capacity * 0.75)}.)      */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**      * The per-segment table.      */
DECL|field|table
specifier|volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
decl_stmt|;
comment|/**      * The maximum size of this map. MapMaker.UNSET_MAXIMUM_SIZE if there is no      * maximum.      */
DECL|field|maxSegmentSize
specifier|final
name|int
name|maxSegmentSize
decl_stmt|;
comment|/** The head of the expiration queue. */
DECL|field|expirationHead
specifier|final
name|Expirable
name|expirationHead
init|=
operator|new
name|Expirable
argument_list|()
block|{
specifier|public
name|long
name|getWriteTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
specifier|public
name|void
name|setWriteTime
parameter_list|(
name|long
name|writeTime
parameter_list|)
block|{}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
name|Expirable
name|next
init|=
name|this
decl_stmt|;
specifier|public
name|Expirable
name|getNextExpirable
parameter_list|()
block|{
return|return
name|next
return|;
block|}
specifier|public
name|void
name|setNextExpirable
parameter_list|(
name|Expirable
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
name|Expirable
name|previous
init|=
name|this
decl_stmt|;
specifier|public
name|Expirable
name|getPreviousExpirable
parameter_list|()
block|{
return|return
name|previous
return|;
block|}
specifier|public
name|void
name|setPreviousExpirable
parameter_list|(
name|Expirable
name|previous
parameter_list|)
block|{
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|method|Segment (int initialCapacity, int maxSegmentSize)
name|Segment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|int
name|maxSegmentSize
parameter_list|)
block|{
name|setTable
argument_list|(
name|newEntryArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxSegmentSize
operator|=
name|maxSegmentSize
expr_stmt|;
block|}
comment|/**      * Sets a new value of an entry. Adds newly created entries at the end      * of the expiration queue.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
comment|// if expires
DECL|method|setValue (ReferenceEntry<K, V> entry, V value, boolean inserted)
name|void
name|setValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|inserted
parameter_list|)
block|{
comment|// TODO: explore other expiration strategies (e.g. on insertion)
if|if
condition|(
name|expires
condition|)
block|{
name|Expirable
name|expirable
init|=
operator|(
name|Expirable
operator|)
name|entry
decl_stmt|;
name|addExpirable
argument_list|(
name|expirable
argument_list|)
expr_stmt|;
block|}
name|setValueReference
argument_list|(
name|entry
argument_list|,
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|addExpirable (Expirable added)
name|void
name|addExpirable
parameter_list|(
name|Expirable
name|added
parameter_list|)
block|{
name|connectExpirable
argument_list|(
name|added
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|added
operator|.
name|getNextExpirable
argument_list|()
argument_list|)
expr_stmt|;
name|added
operator|.
name|setWriteTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
name|connectExpirable
argument_list|(
name|expirationHead
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|added
argument_list|)
expr_stmt|;
name|connectExpirable
argument_list|(
name|added
argument_list|,
name|expirationHead
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|removeExpirable (Expirable removed)
name|void
name|removeExpirable
parameter_list|(
name|Expirable
name|removed
parameter_list|)
block|{
name|connectExpirable
argument_list|(
name|removed
operator|.
name|getPreviousExpirable
argument_list|()
argument_list|,
name|removed
operator|.
name|getNextExpirable
argument_list|()
argument_list|)
expr_stmt|;
name|nullifyExpirable
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes expired entries.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|expireEntries ()
name|void
name|expireEntries
parameter_list|()
block|{
name|Expirable
name|expirable
init|=
name|expirationHead
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
if|if
condition|(
name|expirable
operator|==
name|expirationHead
condition|)
block|{
comment|// There's no point in calling nanoTime() if we have no entries to
comment|// expire.
return|return;
block|}
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
while|while
condition|(
name|expirable
operator|!=
name|expirationHead
operator|&&
name|isExpired
argument_list|(
name|expirable
argument_list|,
name|now
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
operator|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|expirable
decl_stmt|;
name|removeEntry
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getHash
argument_list|()
argument_list|)
expr_stmt|;
comment|// removeEntry should have called removeExpirable, but let's be sure
name|removeExpirable
argument_list|(
name|expirable
argument_list|)
expr_stmt|;
name|expirable
operator|=
name|expirationHead
operator|.
name|getNextExpirable
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|newEntryArray (int size)
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newEntryArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|size
argument_list|)
return|;
block|}
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|clearExpirationQueue ()
name|void
name|clearExpirationQueue
parameter_list|()
block|{
name|Expirable
name|expirable
init|=
name|expirationHead
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
while|while
condition|(
name|expirable
operator|!=
name|expirationHead
condition|)
block|{
name|Expirable
name|next
init|=
name|expirable
operator|.
name|getNextExpirable
argument_list|()
decl_stmt|;
name|nullifyExpirable
argument_list|(
name|expirable
argument_list|)
expr_stmt|;
name|expirable
operator|=
name|next
expr_stmt|;
block|}
name|expirationHead
operator|.
name|setNextExpirable
argument_list|(
name|expirationHead
argument_list|)
expr_stmt|;
name|expirationHead
operator|.
name|setPreviousExpirable
argument_list|(
name|expirationHead
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets table to new HashEntry array.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|setTable (AtomicReferenceArray<ReferenceEntry<K, V>> newTable)
name|void
name|setTable
parameter_list|(
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
comment|// 0.75
name|this
operator|.
name|table
operator|=
name|newTable
expr_stmt|;
block|}
comment|/**      * Returns first entry of bin for given hash.      */
DECL|method|getFirst (int hash)
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
comment|// read this volatile field only once
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
return|return
name|table
operator|.
name|get
argument_list|(
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
comment|/* Specialized implementations of map methods */
DECL|method|getEntry (Object key, int hash)
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|expires
operator|&&
name|isExpired
argument_list|(
name|e
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
name|e
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|get (Object key, int hash)
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|getEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|containsKey (Object key, int hash)
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|!=
name|hash
condition|)
block|{
continue|continue;
block|}
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryKey
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
name|getUnexpiredValue
argument_list|(
name|e
argument_list|)
operator|!=
literal|null
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsValue (Object value)
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|length
init|=
name|table
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|V
name|entryValue
init|=
name|getUnexpiredValue
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|entryValue
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|replace (K key, int hash, V oldValue, V newValue)
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|expires
condition|)
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|entryValue
argument_list|,
name|oldValue
argument_list|)
condition|)
block|{
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace (K key, int hash, V newValue)
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|expires
condition|)
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|setValue
argument_list|(
name|e
argument_list|,
name|newValue
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put (K key, int hash, V value, boolean onlyIfAbsent)
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|expires
condition|)
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newCount
operator|>
name|this
operator|.
name|threshold
condition|)
block|{
comment|// ensure capacity
name|expand
argument_list|()
expr_stmt|;
block|}
comment|// getFirst, but remember the index
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Look for an existing entry.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|key
argument_list|,
name|entryKey
argument_list|)
condition|)
block|{
comment|// We found an existing entry.
comment|// If the value disappeared, this entry is partially collected,
comment|// and we should pretend like it doesn't exist.
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|boolean
name|absent
init|=
name|entryValue
operator|==
literal|null
decl_stmt|;
if|if
condition|(
name|onlyIfAbsent
operator|&&
operator|!
name|absent
condition|)
block|{
return|return
name|entryValue
return|;
block|}
name|setValue
argument_list|(
name|e
argument_list|,
name|value
argument_list|,
name|absent
argument_list|)
expr_stmt|;
return|return
name|entryValue
return|;
block|}
block|}
comment|// Create a new entry.
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|entryFactory
operator|.
name|newEntry
argument_list|(
name|CustomConcurrentHashMap
operator|.
name|this
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|setValue
argument_list|(
name|newEntry
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Expands the table if possible.      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|expand ()
name|void
name|expand
parameter_list|()
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return;
block|}
comment|/*        * Reclassify nodes in each list to new Map.  Because we are        * using power-of-two expansion, the elements from each bin        * must either stay at same index, or move with a power of two        * offset. We eliminate unnecessary node creation by catching        * cases where old nodes can be reused because their next        * fields won't change. Statistically, at the default        * threshold, only about one-sixth of them need cloning when        * a table doubles. The nodes they replace will be garbage        * collectable as soon as they are no longer referenced by any        * reader thread that may be in the midst of traversing table        * right now.        */
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|newTable
init|=
name|newEntryArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
name|newTable
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|int
name|newMask
init|=
name|newTable
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|oldIndex
init|=
literal|0
init|;
name|oldIndex
operator|<
name|oldCapacity
condition|;
operator|++
name|oldIndex
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
init|=
name|oldTable
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|head
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|int
name|headIndex
init|=
name|head
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
operator|.
name|set
argument_list|(
name|headIndex
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the consecutive sequence of nodes with the same target
comment|// index from the end of the list. tail points to the first
comment|// entry in the reusable list.
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tail
init|=
name|head
decl_stmt|;
name|int
name|tailIndex
init|=
name|headIndex
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|next
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
if|if
condition|(
name|newIndex
operator|!=
name|tailIndex
condition|)
block|{
comment|// The index changed. We'll need to copy the previous entry.
name|tailIndex
operator|=
name|newIndex
expr_stmt|;
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
name|newTable
operator|.
name|set
argument_list|(
name|tailIndex
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|// Clone nodes leading up to the tail.
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|head
init|;
name|e
operator|!=
name|tail
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|int
name|newIndex
init|=
name|e
operator|.
name|getHash
argument_list|()
operator|&
name|newMask
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
init|=
name|newTable
operator|.
name|get
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
name|newTable
operator|.
name|set
argument_list|(
name|newIndex
argument_list|,
name|copyEntry
argument_list|(
name|e
argument_list|,
name|newNext
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Else key was reclaimed. Skip entry.
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
block|}
DECL|method|remove (Object key, int hash, boolean expire)
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|boolean
name|expire
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|expire
condition|)
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromTable
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
name|entryValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key, int hash, Object value)
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|expires
condition|)
block|{
name|expireEntries
argument_list|()
expr_stmt|;
block|}
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|entryKey
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getHash
argument_list|()
operator|==
name|hash
operator|&&
name|entryKey
operator|!=
literal|null
operator|&&
name|keyEquivalence
operator|.
name|equivalent
argument_list|(
name|entryKey
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|entryValue
operator|||
operator|(
name|value
operator|!=
literal|null
operator|&&
name|entryValue
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|entryValue
argument_list|,
name|value
argument_list|)
operator|)
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromTable
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Reclaims a value that has been collected. This is identical to      * removeEntry with the addition of a null value check, which avoids      * removing an entry that has already been reused for a new value.      */
DECL|method|reclaimValue (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|reclaimValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
comment|/*        * Used for reference cleanup. We probably don't want to expire entries        * here as it can be called over and over.        */
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|this
operator|.
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
name|V
name|entryValue
init|=
name|e
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryValue
operator|==
literal|null
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromTable
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeEntry (ReferenceEntry<K, V> entry, int hash)
name|boolean
name|removeEntry
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
comment|/*        * This is used during expiration, computation and reclamation, so        * we don't want to recursively expire entries.        */
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|newCount
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
operator|(
name|table
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|table
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|entry
condition|)
block|{
operator|++
name|modCount
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removeFromTable
argument_list|(
name|first
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|table
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
name|count
operator|=
name|newCount
expr_stmt|;
comment|// write-volatile
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Removes an entry from within a table. All entries following the removed      * node can stay, but all preceding ones need to be cloned.      *      * @param first the first entry of the table      * @param removed the entry being removed from the table      * @return the new first entry for the table      */
annotation|@
name|GuardedBy
argument_list|(
literal|"Segment.this"
argument_list|)
DECL|method|removeFromTable (ReferenceEntry<K, V> first, ReferenceEntry<K, V> removed)
specifier|private
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeFromTable
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removed
parameter_list|)
block|{
if|if
condition|(
name|expires
condition|)
block|{
name|removeExpirable
argument_list|(
operator|(
name|Expirable
operator|)
name|removed
argument_list|)
expr_stmt|;
block|}
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|removed
operator|.
name|getNext
argument_list|()
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|first
init|;
name|p
operator|!=
name|removed
condition|;
name|p
operator|=
name|p
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|pKey
init|=
name|p
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|pKey
operator|!=
literal|null
condition|)
block|{
name|newFirst
operator|=
name|copyEntry
argument_list|(
name|p
argument_list|,
name|newFirst
argument_list|)
expr_stmt|;
block|}
comment|// Else key was reclaimed. Skip entry.
block|}
return|return
name|newFirst
return|;
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|clearExpirationQueue
argument_list|()
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* ---------------- Public operations -------------- */
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
comment|/*      * We keep track of per-segment modCounts to avoid ABA      * problems in which an element in one segment was added and      * in another removed during traversal, in which case the      * table was never actually empty at any point. Note the      * similar use of modCounts in the size() and containsValue()      * methods, which are the only other methods also susceptible      * to ABA problems.      */
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
comment|// If mcsum happens to be zero, then we know we got a snapshot
comment|// before any modifications at all were made.  This is
comment|// probably common enough to bother tracking.
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
operator|||
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|long
name|check
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times to get accurate count. On failure due to
comment|// continuous async changes in table, resort to locking.
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|check
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|check
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|check
operator|=
operator|-
literal|1
expr_stmt|;
comment|// force retry
break|break;
block|}
block|}
block|}
if|if
condition|(
name|check
operator|==
name|sum
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|check
operator|!=
name|sum
condition|)
block|{
comment|// Resort to locking all segments
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|sum
operator|+=
name|segment
operator|.
name|count
expr_stmt|;
block|}
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|Ints
operator|.
name|saturatedCast
argument_list|(
name|sum
argument_list|)
return|;
block|}
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
DECL|method|containsValue (Object value)
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
comment|// TODO: document why we choose to throw over returning false?
name|checkNotNull
argument_list|(
name|value
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
comment|// See explanation of modCount use above
name|Segment
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times without locking
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
comment|// TODO: verify the importance of this crazy trick with Doug
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
name|int
name|c
init|=
name|segments
index|[
name|i
index|]
operator|.
name|count
decl_stmt|;
name|mcsum
operator|+=
operator|(
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
operator|)
expr_stmt|;
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|boolean
name|cleanSweep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
comment|// TODO: verify the importance of this crazy trick with Doug
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
name|int
name|c
init|=
name|segments
index|[
name|i
index|]
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|cleanSweep
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|cleanSweep
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Resort to locking all segments
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|segment
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|putIfAbsent (K key, V value)
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|putAll (Map<? extends K, ? extends V> m)
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|expires
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @throws NullPointerException if the specified key is null    */
DECL|method|remove (Object key, Object value)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @throws NullPointerException if any of the arguments are null    */
DECL|method|replace (K key, V oldValue, V newValue)
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    *    * @return the previous value associated with the specified key, or    *         {@code null} if there was no mapping for the key    * @throws NullPointerException if the specified key or value is null    */
DECL|method|replace (K key, V value)
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
name|segment
range|:
name|segments
control|)
block|{
name|segment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|/* ---------------- Iterator Support -------------- */
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentTable
name|AtomicReferenceArray
argument_list|<
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
decl_stmt|;
DECL|field|nextExternal
name|WriteThroughEntry
name|nextExternal
decl_stmt|;
DECL|field|lastReturned
name|WriteThroughEntry
name|lastReturned
decl_stmt|;
DECL|method|HashIterator ()
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|advance ()
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|nextExternal
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextInChain
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|Segment
name|seg
init|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
decl_stmt|;
if|if
condition|(
name|seg
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|seg
operator|.
name|table
expr_stmt|;
name|nextTableIndex
operator|=
name|currentTable
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextInTable
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Finds the next entry in the current chain. Returns true if an entry      * was found.      */
DECL|method|nextInChain ()
name|boolean
name|nextInChain
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
init|;
name|nextEntry
operator|!=
literal|null
condition|;
name|nextEntry
operator|=
name|nextEntry
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Finds the next entry in the current table. Returns true if an entry      * was found.      */
DECL|method|nextInTable ()
name|boolean
name|nextInTable
parameter_list|()
block|{
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
operator|.
name|get
argument_list|(
name|nextTableIndex
operator|--
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|advanceTo
argument_list|(
name|nextEntry
argument_list|)
operator|||
name|nextInChain
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Advances to the given entry. Returns true if the entry was valid,      * false if it should be skipped.      */
DECL|method|advanceTo (ReferenceEntry<K, V> entry)
name|boolean
name|advanceTo
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|getUnexpiredValue
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
condition|)
block|{
name|nextExternal
operator|=
operator|new
name|WriteThroughEntry
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Skip partially reclaimed entry.
return|return
literal|false
return|;
block|}
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextExternal
operator|!=
literal|null
return|;
block|}
DECL|method|nextEntry ()
name|WriteThroughEntry
name|nextEntry
parameter_list|()
block|{
if|if
condition|(
name|nextExternal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextExternal
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|lastReturned
return|;
block|}
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|lastReturned
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|lastReturned
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Custom Entry class used by EntryIterator.next(), that relays setValue    * changes to the underlying map.    */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|value
name|V
name|value
decl_stmt|;
comment|// non-null
DECL|method|WriteThroughEntry (K key, V value)
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getKey ()
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue ()
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
comment|// Cannot use key and value equivalence
if|if
condition|(
name|object
operator|instanceof
name|Entry
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|that
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|key
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Cannot use key and value equivalence
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|setValue (V newValue)
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|newValue
parameter_list|)
block|{
name|V
name|oldValue
init|=
name|put
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
comment|// only if put succeeds
return|return
name|oldValue
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|next ()
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|nextEntry
argument_list|()
return|;
block|}
block|}
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|V
name|v
init|=
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|valueEquivalence
operator|.
name|equivalent
argument_list|(
name|v
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|key
operator|!=
literal|null
operator|&&
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CustomConcurrentHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* ---------------- Serialization Support -------------- */
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2
decl_stmt|;
DECL|method|writeReplace ()
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|expirationNanos
argument_list|,
name|maximumSize
argument_list|,
name|concurrencyLevel
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve()    * doesn't get called when a circular dependency is present, so the proxy    * must be able to behave as the map itself.    */
DECL|class|AbstractSerializationProxy
specifier|abstract
specifier|static
class|class
name|AbstractSerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|keyEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
decl_stmt|;
DECL|field|valueEquivalence
specifier|final
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
decl_stmt|;
DECL|field|expirationNanos
specifier|final
name|long
name|expirationNanos
decl_stmt|;
DECL|field|maximumSize
specifier|final
name|int
name|maximumSize
decl_stmt|;
DECL|field|concurrencyLevel
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
DECL|field|delegate
specifier|transient
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|AbstractSerializationProxy (Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, long expirationNanos, int maximumSize, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|AbstractSerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|long
name|expirationNanos
parameter_list|,
name|int
name|maximumSize
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|valueStrength
expr_stmt|;
name|this
operator|.
name|keyEquivalence
operator|=
name|keyEquivalence
expr_stmt|;
name|this
operator|.
name|valueEquivalence
operator|=
name|valueEquivalence
expr_stmt|;
name|this
operator|.
name|expirationNanos
operator|=
name|expirationNanos
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|maximumSize
expr_stmt|;
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|delegate ()
specifier|protected
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
DECL|method|writeMapTo (java.io.ObjectOutputStream out)
name|void
name|writeMapTo
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|delegate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Serialize expiration times. (Wait, what??)
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
range|:
name|delegate
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// terminate entries
block|}
DECL|method|readMapMaker (ObjectInputStream in)
name|MapMaker
name|readMapMaker
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|int
name|size
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|initialCapacity
argument_list|(
name|size
argument_list|)
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|setValueStrength
argument_list|(
name|valueStrength
argument_list|)
operator|.
name|privateKeyEquivalence
argument_list|(
name|keyEquivalence
argument_list|)
operator|.
name|privateValueEquivalence
argument_list|(
name|valueEquivalence
argument_list|)
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|expirationNanos
operator|!=
literal|0
condition|)
block|{
comment|// expiration() throws an exception if you pass 0.
name|mapMaker
operator|.
name|expiration
argument_list|(
name|expirationNanos
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maximumSize
operator|!=
name|MapMaker
operator|.
name|UNSET_MAXIMUM_SIZE
condition|)
block|{
name|mapMaker
operator|.
name|maximumSize
argument_list|(
name|maximumSize
argument_list|)
expr_stmt|;
block|}
return|return
name|mapMaker
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readEntries (ObjectInputStream in)
name|void
name|readEntries
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|K
name|key
init|=
operator|(
name|K
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
break|break;
comment|// terminator
block|}
name|V
name|value
init|=
operator|(
name|V
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|delegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The actual object that gets serialized. Unfortunately, readResolve()    * doesn't get called when a circular dependency is present, so the proxy    * must be able to behave as the map itself.    */
DECL|class|SerializationProxy
specifier|private
specifier|static
class|class
name|SerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractSerializationProxy
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|method|SerializationProxy (Strength keyStrength, Strength valueStrength, Equivalence<Object> keyEquivalence, Equivalence<Object> valueEquivalence, long expirationNanos, int maximumSize, int concurrencyLevel, ConcurrentMap<K, V> delegate)
name|SerializationProxy
parameter_list|(
name|Strength
name|keyStrength
parameter_list|,
name|Strength
name|valueStrength
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|keyEquivalence
parameter_list|,
name|Equivalence
argument_list|<
name|Object
argument_list|>
name|valueEquivalence
parameter_list|,
name|long
name|expirationNanos
parameter_list|,
name|int
name|maximumSize
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|,
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|keyStrength
argument_list|,
name|valueStrength
argument_list|,
name|keyEquivalence
argument_list|,
name|valueEquivalence
argument_list|,
name|expirationNanos
argument_list|,
name|maximumSize
argument_list|,
name|concurrencyLevel
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
DECL|method|writeObject (java.io.ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|writeMapTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|MapMaker
name|mapMaker
init|=
name|readMapMaker
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|delegate
operator|=
name|mapMaker
operator|.
name|makeMap
argument_list|()
expr_stmt|;
name|readEntries
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|readResolve ()
specifier|private
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
block|}
end_class

end_unit

