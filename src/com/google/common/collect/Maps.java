begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
operator|.
name|MapJoiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link Map} instances. Also see this  * class's counterparts {@link Lists} and {@link Sets}.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Isaac Shum  * @since 2 (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|Maps
specifier|public
specifier|final
class|class
name|Maps
block|{
DECL|method|Maps ()
specifier|private
name|Maps
parameter_list|()
block|{}
comment|/**    * Creates a<i>mutable</i>, empty {@code HashMap} instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#of()} instead.    *    *<p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link    * #newEnumMap} instead.    *    * @return a new, empty {@code HashMap}    */
DECL|method|newHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|()
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a {@code HashMap} instance with enough capacity to hold the    * specified number of elements without rehashing.    *    * @param expectedSize the expected size    * @return a new, empty {@code HashMap} with enough capacity to hold {@code    *         expectedSize} elements without rehashing    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|newHashMapWithExpectedSize ( int expectedSize)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMapWithExpectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
comment|/*      * The HashMap is constructed with an initialCapacity that's greater than      * expectedSize. The larger value is necessary because HashMap resizes its      * internal array if the map size exceeds loadFactor * initialCapacity.      */
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|capacity
argument_list|(
name|expectedSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an appropriate value for the "capacity" (in reality, "minimum table    * size") parameter of a {@link HashMap} constructor, such that the resulting    * table will be between 25% and 50% full when it contains {@code    * expectedSize} entries.    *    * @throws IllegalArgumentException if {@code expectedSize} is negative    */
DECL|method|capacity (int expectedSize)
specifier|static
name|int
name|capacity
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|expectedSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|Math
operator|.
name|max
argument_list|(
name|expectedSize
operator|*
literal|2
argument_list|,
literal|16
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code HashMap} instance with the same mappings as    * the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#copyOf(Map)} instead.    *    *<p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link    * #newEnumMap} instead.    *    * @param map the mappings to be placed in the new map    * @return a new {@code HashMap} initialized with the mappings from {@code    *         map}    */
DECL|method|newHashMap ( Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}    * instance.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#of()} instead.    *    * @return a new, empty {@code LinkedHashMap}    */
DECL|method|newLinkedHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance    * with the same mappings as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableMap#copyOf(Map)} instead.    *    * @param map the mappings to be placed in the new map    * @return a new, {@code LinkedHashMap} initialized with the mappings from    *         {@code map}    */
DECL|method|newLinkedHashMap ( Map<? extends K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newLinkedHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Returns a general-purpose instance of {@code ConcurrentMap}, which supports    * all optional operations of the ConcurrentMap interface. It does not permit    * null keys or values. It is serializable.    *    *<p>This is currently accomplished by calling {@link MapMaker#makeMap()}.    *    *<p>It is preferable to use {@code MapMaker} directly (rather than through    * this method), as it presents numerous useful configuration options,    * such as the concurrency level, load factor, key/value reference types,    * and value computation.    *    * @return a new, empty {@code ConcurrentMap}    * @since 3    */
DECL|method|newConcurrentMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newConcurrentMap
parameter_list|()
block|{
return|return
operator|new
name|MapMaker
argument_list|()
operator|.
operator|<
name|K
operator|,
name|V
operator|>
name|makeMap
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the natural    * ordering of its elements.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedMap#of()} instead.    *    * @return a new, empty {@code TreeMap}    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// eclipse doesn't like the raw Comparable
DECL|method|newTreeMap ()
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Comparable
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Creates a<i>mutable</i> {@code TreeMap} instance with the same mappings as    * the specified map and using the same ordering as the specified map.    *    *<p><b>Note:</b> if mutability is not required, use {@link    * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.    *    * @param map the sorted map whose mappings are to be placed in the new map    *        and whose comparator is to be used to sort the new map    * @return a new {@code TreeMap} initialized with the mappings from {@code    *         map} and using the comparator of {@code map}    */
DECL|method|newTreeMap (SortedMap<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates a<i>mutable</i>, empty {@code TreeMap} instance using the given    * comparator.    *    *<p><b>Note:</b> if mutability is not required, use {@code    * ImmutableSortedMap.orderedBy(comparator).build()} instead.    *    * @param comparator the comparator to sort the keys with    * @return a new, empty {@code TreeMap}    */
DECL|method|newTreeMap ( @ullable Comparator<C> comparator)
specifier|public
specifier|static
parameter_list|<
name|C
parameter_list|,
name|K
extends|extends
name|C
parameter_list|,
name|V
parameter_list|>
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newTreeMap
parameter_list|(
annotation|@
name|Nullable
name|Comparator
argument_list|<
name|C
argument_list|>
name|comparator
parameter_list|)
block|{
comment|// Ideally, the extra type parameter "C" shouldn't be necessary. It is a
comment|// work-around of a compiler type inference quirk that prevents the
comment|// following code from being compiled:
comment|// Comparator<Class<?>> comparator = null;
comment|// Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);
return|return
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumMap} instance.    *    * @param type the key type for this map    * @return a new, empty {@code EnumMap}    */
DECL|method|newEnumMap (Class<K> type)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Class
argument_list|<
name|K
argument_list|>
name|type
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code EnumMap} with the same mappings as the specified map.    *    * @param map the map from which to initialize this {@code EnumMap}    * @return a new {@code EnumMap} initialized with the mappings from {@code    *         map}    * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}    *         instance and contains no mappings    */
DECL|method|newEnumMap ( Map<K, ? extends V> map)
specifier|public
specifier|static
parameter_list|<
name|K
extends|extends
name|Enum
argument_list|<
name|K
argument_list|>
parameter_list|,
name|V
parameter_list|>
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEnumMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|EnumMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates an {@code IdentityHashMap} instance.    *    * @return a new, empty {@code IdentityHashMap}    */
DECL|method|newIdentityHashMap ()
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|IdentityHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newIdentityHashMap
parameter_list|()
block|{
return|return
operator|new
name|IdentityHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * Returns a synchronized (thread-safe) bimap backed by the specified bimap.    * In order to guarantee serial access, it is critical that<b>all</b> access    * to the backing bimap is accomplished through the returned bimap.    *    *<p>It is imperative that the user manually synchronize on the returned map    * when accessing any of its collection views:<pre>   {@code    *    *   BiMap<Long, String> map = Maps.synchronizedBiMap(    *       HashBiMap.<Long, String>create());    *    ...    *   Set<Long> set = map.keySet();  // Needn't be in synchronized block    *    ...    *   synchronized (map) {  // Synchronizing on map, not set!    *     Iterator<Long> it = set.iterator(); // Must be in synchronized block    *     while (it.hasNext()) {    *       foo(it.next());    *     }    *   }}</pre>    *    * Failure to follow this advice may result in non-deterministic behavior.    *    *<p>The returned bimap will be serializable if the specified bimap is    * serializable.    *    * @param bimap the bimap to be wrapped in a synchronized view    * @return a sychronized view of the specified bimap    */
DECL|method|synchronizedBiMap (BiMap<K, V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|synchronizedBiMap
parameter_list|(
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
name|Synchronized
operator|.
name|biMap
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Computes the difference between two maps. This difference is an immutable    * snapshot of the state of the maps at the time this method is called. It    * will never change, even if the maps change at a later time.    *    *<p>Since this method uses {@code HashMap} instances internally, the keys of    * the supplied maps must be well-behaved with respect to    * {@link Object#equals} and {@link Object#hashCode}.    *    *<p><b>Note:</b>If you only need to know whether two maps have the same    * mappings, call {@code left.equals(right)} instead of this method.    *    * @param left the map to treat as the "left" map for purposes of comparison    * @param right the map to treat as the "right" map for purposes of comparison    * @return the difference between the two maps    */
DECL|method|difference ( Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|difference
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|left
parameter_list|,
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|right
parameter_list|)
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
init|=
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|right
argument_list|)
decl_stmt|;
comment|// will whittle it down
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|boolean
name|eq
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|left
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|K
name|leftKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|leftValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|right
operator|.
name|containsKey
argument_list|(
name|leftKey
argument_list|)
condition|)
block|{
name|V
name|rightValue
init|=
name|onlyOnRight
operator|.
name|remove
argument_list|(
name|leftKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
condition|)
block|{
name|onBoth
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eq
operator|=
literal|false
expr_stmt|;
name|differences
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
operator|new
name|ValueDifferenceImpl
argument_list|<
name|V
argument_list|>
argument_list|(
name|leftValue
argument_list|,
name|rightValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|eq
operator|=
literal|false
expr_stmt|;
name|onlyOnLeft
operator|.
name|put
argument_list|(
name|leftKey
argument_list|,
name|leftValue
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|areEqual
init|=
name|eq
operator|&&
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
return|return
operator|new
name|MapDifferenceImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|areEqual
argument_list|,
name|onlyOnLeft
argument_list|,
name|onlyOnRight
argument_list|,
name|onBoth
argument_list|,
name|differences
argument_list|)
return|;
block|}
DECL|class|MapDifferenceImpl
specifier|private
specifier|static
class|class
name|MapDifferenceImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|MapDifference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|areEqual
specifier|final
name|boolean
name|areEqual
decl_stmt|;
DECL|field|onlyOnLeft
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
decl_stmt|;
DECL|field|onlyOnRight
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
decl_stmt|;
DECL|field|onBoth
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
decl_stmt|;
DECL|field|differences
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
decl_stmt|;
DECL|method|MapDifferenceImpl (boolean areEqual, Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, ValueDifference<V>> differences)
name|MapDifferenceImpl
parameter_list|(
name|boolean
name|areEqual
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnLeft
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onlyOnRight
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|onBoth
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|differences
parameter_list|)
block|{
name|this
operator|.
name|areEqual
operator|=
name|areEqual
expr_stmt|;
name|this
operator|.
name|onlyOnLeft
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlyOnRight
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
name|this
operator|.
name|onBoth
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|onBoth
argument_list|)
expr_stmt|;
name|this
operator|.
name|differences
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
DECL|method|areEqual ()
specifier|public
name|boolean
name|areEqual
parameter_list|()
block|{
return|return
name|areEqual
return|;
block|}
DECL|method|entriesOnlyOnLeft ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnLeft
parameter_list|()
block|{
return|return
name|onlyOnLeft
return|;
block|}
DECL|method|entriesOnlyOnRight ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesOnlyOnRight
parameter_list|()
block|{
return|return
name|onlyOnRight
return|;
block|}
DECL|method|entriesInCommon ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entriesInCommon
parameter_list|()
block|{
return|return
name|onBoth
return|;
block|}
DECL|method|entriesDiffering ()
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|ValueDifference
argument_list|<
name|V
argument_list|>
argument_list|>
name|entriesDiffering
parameter_list|()
block|{
return|return
name|differences
return|;
block|}
DECL|method|equals (Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
condition|)
block|{
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|other
init|=
operator|(
name|MapDifference
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
operator|&&
name|entriesOnlyOnRight
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
operator|&&
name|entriesInCommon
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
operator|&&
name|entriesDiffering
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|entriesOnlyOnLeft
argument_list|()
argument_list|,
name|entriesOnlyOnRight
argument_list|()
argument_list|,
name|entriesInCommon
argument_list|()
argument_list|,
name|entriesDiffering
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|areEqual
condition|)
block|{
return|return
literal|"equal"
return|;
block|}
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"not equal"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onlyOnLeft
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on left="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnLeft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|onlyOnRight
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": only on right="
argument_list|)
operator|.
name|append
argument_list|(
name|onlyOnRight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|differences
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|": value differences="
argument_list|)
operator|.
name|append
argument_list|(
name|differences
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|ValueDifferenceImpl
specifier|static
class|class
name|ValueDifferenceImpl
parameter_list|<
name|V
parameter_list|>
implements|implements
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|V
argument_list|>
block|{
DECL|field|left
specifier|private
specifier|final
name|V
name|left
decl_stmt|;
DECL|field|right
specifier|private
specifier|final
name|V
name|right
decl_stmt|;
DECL|method|ValueDifferenceImpl (@ullable V left, @Nullable V right)
name|ValueDifferenceImpl
parameter_list|(
annotation|@
name|Nullable
name|V
name|left
parameter_list|,
annotation|@
name|Nullable
name|V
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
DECL|method|leftValue ()
specifier|public
name|V
name|leftValue
parameter_list|()
block|{
return|return
name|left
return|;
block|}
DECL|method|rightValue ()
specifier|public
name|V
name|rightValue
parameter_list|()
block|{
return|return
name|right
return|;
block|}
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|instanceof
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
name|that
init|=
operator|(
name|MapDifference
operator|.
name|ValueDifference
argument_list|<
name|?
argument_list|>
operator|)
name|object
decl_stmt|;
return|return
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|left
argument_list|,
name|that
operator|.
name|leftValue
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equal
argument_list|(
name|this
operator|.
name|right
argument_list|,
name|that
operator|.
name|rightValue
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"("
operator|+
name|left
operator|+
literal|", "
operator|+
name|right
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Returns an immutable map for which the {@link Map#values} are the given    * elements in the given order, and each key is the product of invoking a    * supplied function on its corresponding value.    *    * @param values the values to use when constructing the {@code Map}    * @param keyFunction the function used to produce the key for each value    * @return a map mapping the result of evaluating the function {@code    *         keyFunction} on each value in the input collection to that value    * @throws IllegalArgumentException if {@code keyFunction} produces the same    *         key for more than one value in the input collection    * @throws NullPointerException if any elements of {@code values} is null, or    *         if {@code keyFunction} produces {@code null} for any value    */
DECL|method|uniqueIndex ( Iterable<V> values, Function<? super V, K> keyFunction)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|uniqueIndex
parameter_list|(
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|V
argument_list|,
name|K
argument_list|>
name|keyFunction
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyFunction
argument_list|)
expr_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|V
name|value
range|:
name|values
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|keyFunction
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates an {@code ImmutableMap<String, String>} from a {@code Properties}    * instance. Properties normally derive from {@code Map<Object, Object>}, but    * they typically contain strings, which is awkward. This method lets you get    * a plain-old-{@code Map} out of a {@code Properties}.    *    * @param properties a {@code Properties} object to be converted    * @return an immutable map containing all the entries in {@code properties}    * @throws ClassCastException if any key in {@code Properties} is not a {@code    *         String}    * @throws NullPointerException if any key or value in {@code Properties} is    *         null    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.Properties"
argument_list|)
DECL|method|fromProperties ( Properties properties)
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fromProperties
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|?
argument_list|>
name|e
init|=
name|properties
operator|.
name|propertyNames
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|properties
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns an immutable map entry with the specified key and value. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.    *    *<p>The returned entry is serializable.    *    * @param key the key to be associated with the returned entry    * @param value the value to be associated with the returned entry    */
DECL|method|immutableEntry ( @ullable K key, @Nullable V value)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|immutableEntry
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|ImmutableEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified set of entries. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException},    * as do any operations that would modify the returned set.    *    * @param entrySet the entries for which to return an unmodifiable view    * @return an unmodifiable view of the entries    */
DECL|method|unmodifiableEntrySet ( Set<Entry<K, V>> entrySet)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|unmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableEntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|entrySet
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifiable view of the specified map entry. The {@link    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.    * This also has the side-effect of redefining {@code equals} to comply with    * the Entry contract, to avoid a possible nefarious implementation of equals.    *    * @param entry the entry for which to return an unmodifiable view    * @return an unmodifiable view of the entry    */
DECL|method|unmodifiableEntry (final Entry<K, V> entry)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableEntry
parameter_list|(
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/** @see Multimaps#unmodifiableEntries */
DECL|class|UnmodifiableEntries
specifier|static
class|class
name|UnmodifiableEntries
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingCollection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|entries
specifier|private
specifier|final
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|method|UnmodifiableEntries (Collection<Entry<K, V>> entries)
name|UnmodifiableEntries
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|this
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
init|=
name|super
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|ForwardingIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
name|unmodifiableEntry
argument_list|(
name|super
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
block|}
return|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|ObjectArrays
operator|.
name|toArrayImpl
argument_list|(
name|this
argument_list|,
name|array
argument_list|)
return|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|containsEntryImpl
argument_list|(
name|delegate
argument_list|()
argument_list|,
name|o
argument_list|)
return|;
block|}
DECL|method|containsAll (Collection<?> c)
annotation|@
name|Override
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|containsAll
argument_list|(
name|this
argument_list|,
name|c
argument_list|)
return|;
block|}
block|}
comment|/** @see Maps#unmodifiableEntrySet(Set) */
DECL|class|UnmodifiableEntrySet
specifier|static
class|class
name|UnmodifiableEntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|UnmodifiableEntries
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|UnmodifiableEntrySet (Set<Entry<K, V>> entries)
name|UnmodifiableEntrySet
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|super
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
comment|// See java.util.Collections.UnmodifiableEntrySet for details on attacks.
DECL|method|equals (@ullable Object object)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
annotation|@
name|Nullable
name|Object
name|object
parameter_list|)
block|{
return|return
name|Collections2
operator|.
name|setEquals
argument_list|(
name|this
argument_list|,
name|object
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|hashCodeImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns an unmodifiable view of the specified bimap. This method allows    * modules to provide users with "read-only" access to internal bimaps. Query    * operations on the returned bimap "read through" to the specified bimap, and    * attemps to modify the returned map, whether direct or via its collection    * views, result in an {@code UnsupportedOperationException}.    *    *<p>The returned bimap will be serializable if the specified bimap is    * serializable.    *    * @param bimap the bimap for which an unmodifiable view is to be returned    * @return an unmodifiable view of the specified bimap    */
DECL|method|unmodifiableBiMap ( BiMap<? extends K, ? extends V> bimap)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|bimap
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableBiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|bimap
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** @see Maps#unmodifiableBiMap(BiMap) */
DECL|class|UnmodifiableBiMap
specifier|private
specifier|static
class|class
name|UnmodifiableBiMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ForwardingMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|BiMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|unmodifiableMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unmodifiableMap
decl_stmt|;
DECL|field|delegate
specifier|final
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|field|inverse
specifier|transient
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
decl_stmt|;
DECL|field|values
specifier|transient
name|Set
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|UnmodifiableBiMap (BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse)
name|UnmodifiableBiMap
parameter_list|(
name|BiMap
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|delegate
parameter_list|,
annotation|@
name|Nullable
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|)
block|{
name|unmodifiableMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|inverse
expr_stmt|;
block|}
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|unmodifiableMap
return|;
block|}
DECL|method|forcePut (K key, V value)
specifier|public
name|V
name|forcePut
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|inverse ()
specifier|public
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|inverse
parameter_list|()
block|{
name|BiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|result
init|=
name|inverse
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|inverse
operator|=
operator|new
name|UnmodifiableBiMap
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
argument_list|(
name|delegate
operator|.
name|inverse
argument_list|()
argument_list|,
name|this
argument_list|)
else|:
name|result
return|;
block|}
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Set
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|delegate
operator|.
name|values
argument_list|()
argument_list|)
else|:
name|result
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/**    * Implements {@code Collection.contains} safely for forwarding collections of    * map entries. If {@code o} is an instance of {@code Map.Entry}, it is    * wrapped using {@link #unmodifiableEntry} to protect against a possible    * nefarious equals method.    *    *<p>Note that {@code c} is the backing (delegate) collection, rather than    * the forwarding collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object that might be contained in {@code c}    * @return {@code true} if {@code c} contains {@code o}    */
DECL|method|containsEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|containsEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|contains
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Implements {@code Collection.remove} safely for forwarding collections of    * map entries. If {@code o} is an instance of {@code Map.Entry}, it is    * wrapped using {@link #unmodifiableEntry} to protect against a possible    * nefarious equals method.    *    *<p>Note that {@code c} is backing (delegate) collection, rather than the    * forwarding collection.    *    * @param c the delegate (unwrapped) collection of map entries    * @param o the object to remove from {@code c}    * @return {@code true} if {@code c} was changed    */
DECL|method|removeEntryImpl (Collection<Entry<K, V>> c, Object o)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|removeEntryImpl
parameter_list|(
name|Collection
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|c
operator|.
name|remove
argument_list|(
name|unmodifiableEntry
argument_list|(
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a map where each value is transformed by a function. All    * other properties of the map, such as iteration order, are left intact. For    * example, the code:<pre>   {@code    *    *   Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);    *   Function<Integer, Double> sqrt =    *       new Function<Integer, Double>() {    *         public Double apply(Integer in) {    *           return Math.sqrt((int) in);    *         }    *       };    *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {a=2.0, b=3.0}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys, and even    * null values provided that the function is capable of accepting null input.    * The transformed map might contain null values, if the function sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The function is applied lazily, invoked when needed. This is necessary    * for the returned map to be a view, but it means that the function will be    * applied many times for bulk operations like {@link Map#containsValue} and    * {@code Map.toString()}. For this to perform well, {@code function} should    * be fast. To avoid lazy evaluation when the returned map doesn't need to be    * a view, copy the returned map into a new map of your choosing.    */
DECL|method|transformValues ( Map<K, V1> fromMap, final Function<? super V1, V2> function)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
specifier|public
name|V2
name|transformEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V1
name|value
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|transformEntries
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * Returns a view of a map whose values are derived from the original map's    * entries. In contrast to {@link #transformValues}, this method's    * entry-transformation logic may depend on the key as well as the value.    *    *<p>All other properties of the transformed map, such as iteration order,    * are left intact. For example, the code:<pre>   {@code    *    *   Map<String, Boolean> options =    *       ImmutableMap.of("verbose", true, "sort", false);    *   EntryTransformer<String, Boolean, String> flagPrefixer =    *       new EntryTransformer<String, Boolean, String>() {    *         public String transformEntry(String key, Boolean value) {    *           return value ? key : "no" + key;    *         }    *       };    *   Map<String, String> transformed =    *       Maps.transformEntries(options, flagPrefixer);    *   System.out.println(transformed);}</pre>    *    * ... prints {@code {verbose=verbose, sort=nosort}}.    *    *<p>Changes in the underlying map are reflected in this view. Conversely,    * this view supports removal operations, and these are reflected in the    * underlying map.    *    *<p>It's acceptable for the underlying map to contain null keys and null    * values provided that the transformer is capable of accepting null inputs.    * The transformed map might contain null values if the transformer sometimes    * gives a null result.    *    *<p>The returned map is not thread-safe or serializable, even if the    * underlying map is.    *    *<p>The transformer is applied lazily, invoked when needed. This is    * necessary for the returned map to be a view, but it means that the    * transformer will be applied many times for bulk operations like {@link    * Map#containsValue} and {@link Object#toString}. For this to perform well,    * {@code transformer} should be fast. To avoid lazy evaluation when the    * returned map doesn't need to be a view, copy the returned map into a new    * map of your choosing.    *    *<p><b>Warning:</b> This method assumes that for any instance {@code k} of    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies    * that {@code k2} is also of type {@code K}. Using an {@code    * EntryTransformer} key type for which this may not hold, such as {@code    * ArrayList}, may risk a {@code ClassCastException} when calling methods on    * the transformed map.    *    * @since 7    */
annotation|@
name|Beta
DECL|method|transformEntries ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|transformEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
return|return
operator|new
name|TransformedEntriesMap
argument_list|<
name|K
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|>
argument_list|(
name|fromMap
argument_list|,
name|transformer
argument_list|)
return|;
block|}
comment|/**    * A transformation of the value of a key-value pair, using both key and value    * as inputs. To apply the transformation to a map, use    * {@link Maps#transformEntries(Map, EntryTransformer)}.    *    * @param<K> the key type of the input and output entries    * @param<V1> the value type of the input entry    * @param<V2> the value type of the output entry    * @since 7    */
annotation|@
name|Beta
DECL|interface|EntryTransformer
specifier|public
interface|interface
name|EntryTransformer
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
block|{
DECL|method|transformEntry (@ullable K key, @Nullable V1 value)
name|V2
name|transformEntry
parameter_list|(
annotation|@
name|Nullable
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V1
name|value
parameter_list|)
function_decl|;
block|}
DECL|class|TransformedEntriesMap
specifier|static
class|class
name|TransformedEntriesMap
parameter_list|<
name|K
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
block|{
DECL|field|fromMap
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
decl_stmt|;
DECL|field|transformer
specifier|final
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
decl_stmt|;
DECL|method|TransformedEntriesMap ( Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer)
name|TransformedEntriesMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|fromMap
parameter_list|,
name|EntryTransformer
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V1
argument_list|,
name|V2
argument_list|>
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|fromMap
operator|=
name|checkNotNull
argument_list|(
name|fromMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|checkNotNull
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V2
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|V1
name|value
init|=
name|fromMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|||
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|value
argument_list|)
else|:
literal|null
return|;
block|}
comment|// safe as long as the user followed the<b>Warning</b> in the javadoc
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V2
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|fromMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|transformer
operator|.
name|transformEntry
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|,
name|fromMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|field|entrySet
name|EntrySet
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|EntrySet
name|result
init|=
name|entrySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|entrySet
operator|=
name|result
operator|=
operator|new
name|EntrySet
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|class|EntrySet
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
block|{
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|TransformedEntriesMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
argument_list|>
name|mapIterator
init|=
name|fromMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|mapIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
name|next
parameter_list|()
block|{
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V1
argument_list|>
name|entry
init|=
name|mapIterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V2
name|getValue
parameter_list|()
block|{
return|return
name|transformer
operator|.
name|transformEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|mapIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fromMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|entryKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|entryValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|V2
name|mapValue
init|=
name|TransformedEntriesMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|entryKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapValue
operator|!=
literal|null
condition|)
block|{
return|return
name|mapValue
operator|.
name|equals
argument_list|(
name|entryValue
argument_list|)
return|;
block|}
return|return
name|entryValue
operator|==
literal|null
operator|&&
name|containsKey
argument_list|(
name|entryKey
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Object
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|fromMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose keys    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. The map's {@code    * put()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException} if a key that doesn't satisfy the predicate is    * provided.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose keys satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    */
DECL|method|filterKeys ( Map<K, V> unfiltered, final Predicate<? super K> keyPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterKeys
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|keyPredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|keyPredicate
operator|.
name|apply
argument_list|(
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredKeyMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|keyPredicate
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} whose values    * satisfy a predicate. The returned map is a live view of {@code unfiltered};    * changes to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. The {@link Map#put},    * {@link Map#putAll}, and {@link Entry#setValue} methods throw an {@link    * IllegalArgumentException} if a value that doesn't satisfy the predicate is    * provided.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings whose values satisfy the    * filter will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    */
DECL|method|filterValues ( Map<K, V> unfiltered, final Predicate<? super V> valuePredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterValues
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|V
argument_list|>
name|valuePredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|valuePredicate
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|valuePredicate
operator|.
name|apply
argument_list|(
name|input
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Returns a map containing the mappings in {@code unfiltered} that satisfy a    * predicate. The returned map is a live view of {@code unfiltered}; changes    * to one affect the other.    *    *<p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code    * values()} views have iterators that don't support {@code remove()}, but all    * other methods are supported by the map and its views. The map's {@code    * put()} and {@code putAll()} methods throw an {@link    * IllegalArgumentException} if a key/value pair that doesn't satisfy the    * predicate is provided. Similarly, the map's entries have a {@link    * Entry#setValue} method that throws an {@link IllegalArgumentException} when    * the existing key and the provided value don't satisfy the predicate.    *    *<p>When methods such as {@code removeAll()} and {@code clear()} are called    * on the filtered map or its views, only mappings that satisfy the filter    * will be removed from the underlying map.    *    *<p>The returned map isn't threadsafe or serializable, even if {@code    * unfiltered} is.    *    *<p>Many of the filtered map's methods, such as {@code size()},    * iterate across every key/value mapping in the underlying map and determine    * which satisfy the filter. When a live view is<i>not</i> needed, it may be    * faster to copy the filtered map and use the copy.    */
DECL|method|filterEntries ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterEntries
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|entryPredicate
argument_list|)
expr_stmt|;
return|return
operator|(
name|unfiltered
operator|instanceof
name|AbstractFilteredMap
operator|)
condition|?
name|filterFiltered
argument_list|(
operator|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
else|:
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|checkNotNull
argument_list|(
name|unfiltered
argument_list|)
argument_list|,
name|entryPredicate
argument_list|)
return|;
block|}
comment|/**    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when    * filtering a filtered map.    */
DECL|method|filterFiltered (AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate)
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|filterFiltered
parameter_list|(
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|and
argument_list|(
name|map
operator|.
name|predicate
argument_list|,
name|entryPredicate
argument_list|)
decl_stmt|;
return|return
operator|new
name|FilteredEntryMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
operator|.
name|unfiltered
argument_list|,
name|predicate
argument_list|)
return|;
block|}
DECL|class|AbstractFilteredMap
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractFilteredMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|unfiltered
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
decl_stmt|;
DECL|field|predicate
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
decl_stmt|;
DECL|method|AbstractFilteredMap ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate)
name|AbstractFilteredMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|unfiltered
operator|=
name|unfiltered
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|apply (Object key, V value)
name|boolean
name|apply
parameter_list|(
name|Object
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
comment|// This method is called only when the key is in the map, implying that
comment|// key is a K.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|key
decl_stmt|;
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|k
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|put (K key, V value)
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unfiltered
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|putAll (Map<? extends K, ? extends V> map)
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unfiltered
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|get (Object key)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|V
name|value
init|=
name|unfiltered
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|!=
literal|null
operator|)
operator|&&
name|apply
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|)
condition|?
name|value
else|:
literal|null
return|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (Object key)
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|unfiltered
operator|.
name|remove
argument_list|(
name|key
argument_list|)
else|:
literal|null
return|;
block|}
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|values
operator|=
operator|new
name|Values
argument_list|()
else|:
name|result
return|;
block|}
DECL|class|Values
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryIterator
init|=
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|entryIterator
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|entrySet
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|o
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|removeAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|retainAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|FilteredKeyMap
specifier|private
specifier|static
class|class
name|FilteredKeyMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|keyPredicate
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
decl_stmt|;
DECL|method|FilteredKeyMap (Map<K, V> unfiltered, Predicate<? super K> keyPredicate, Predicate<Entry<K, V>> entryPredicate)
name|FilteredKeyMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|K
argument_list|>
name|keyPredicate
parameter_list|,
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|this
operator|.
name|keyPredicate
operator|=
name|keyPredicate
expr_stmt|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
else|:
name|result
return|;
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|keySet
operator|=
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|keySet
argument_list|()
argument_list|,
name|keyPredicate
argument_list|)
else|:
name|result
return|;
block|}
comment|// The cast is called only when the key is in the unfiltered map, implying
comment|// that key is a K.
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|unfiltered
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|keyPredicate
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
return|;
block|}
block|}
DECL|class|FilteredEntryMap
specifier|private
specifier|static
class|class
name|FilteredEntryMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractFilteredMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Entries in this set satisfy the predicate, but they don't validate the      * input to {@code Entry.setValue()}.      */
DECL|field|filteredEntrySet
specifier|final
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|filteredEntrySet
decl_stmt|;
DECL|method|FilteredEntryMap ( Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate)
name|FilteredEntryMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|unfiltered
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entryPredicate
parameter_list|)
block|{
name|super
argument_list|(
name|unfiltered
argument_list|,
name|entryPredicate
argument_list|)
expr_stmt|;
name|filteredEntrySet
operator|=
name|Sets
operator|.
name|filter
argument_list|(
name|unfiltered
operator|.
name|entrySet
argument_list|()
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
block|}
DECL|field|entrySet
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|class|EntrySet
specifier|private
class|class
name|EntrySet
extends|extends
name|ForwardingSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|filteredEntrySet
return|;
block|}
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|filteredEntrySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|ForwardingMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|entry
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
block|}
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
else|:
name|result
return|;
block|}
DECL|class|KeySet
specifier|private
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|filteredEntrySet
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|filteredEntrySet
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|filteredEntrySet
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|contains (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove (Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|containsKey
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|unfiltered
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|removeAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// for GWT
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Object
name|obj
range|:
name|collection
control|)
block|{
name|changed
operator||=
name|remove
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
DECL|method|retainAll (Collection<?> collection)
annotation|@
name|Override
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|collection
argument_list|)
expr_stmt|;
comment|// for GWT
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|unfiltered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collection
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
comment|// creating an ArrayList so filtering happens once
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|()
return|;
block|}
DECL|method|toArray (T[] array)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterator
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * {@code AbstractMap} extension that implements {@link #isEmpty()} as {@code    * entrySet().isEmpty()} instead of {@code size() == 0} to speed up    * implementations where {@code size()} is O(n), and it delegates the {@code    * isEmpty()} methods of its key set and value collection to this    * implementation.    */
annotation|@
name|GwtCompatible
DECL|class|ImprovedAbstractMap
specifier|abstract
specifier|static
class|class
name|ImprovedAbstractMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * Creates the entry set to be returned by {@link #entrySet()}. This method      * is invoked at most once on a given map, at the time when {@code entrySet}      * is first called.      */
DECL|method|createEntrySet ()
specifier|protected
specifier|abstract
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|createEntrySet
parameter_list|()
function_decl|;
DECL|field|entrySet
specifier|private
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|method|entrySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|result
init|=
name|entrySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|entrySet
operator|=
name|result
operator|=
name|createEntrySet
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|keySet
specifier|private
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|method|keySet ()
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|result
init|=
name|keySet
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
specifier|final
name|Set
argument_list|<
name|K
argument_list|>
name|delegate
init|=
name|super
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|keySet
operator|=
name|result
operator|=
operator|new
name|ForwardingSet
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|K
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ImprovedAbstractMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|field|values
specifier|private
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
DECL|method|values ()
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|result
init|=
name|values
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
init|=
name|super
operator|.
name|values
argument_list|()
decl_stmt|;
name|values
operator|=
name|result
operator|=
operator|new
name|ForwardingCollection
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Collection
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ImprovedAbstractMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Returns {@code true} if this map contains no key-value mappings.      *      *<p>The implementation returns {@code entrySet().isEmpty()}.      *      * @return {@code true} if this map contains no key-value mappings      */
DECL|method|isEmpty ()
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|entrySet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
DECL|field|standardJoiner
specifier|static
specifier|final
name|MapJoiner
name|standardJoiner
init|=
name|Collections2
operator|.
name|standardJoiner
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
comment|/**    * Delegates to {@link Map#get}. Returns {@code null} on {@code    * ClassCastException}.    */
DECL|method|safeGet (Map<?, V> map, Object key)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|safeGet
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code    * ClassCastException}    */
DECL|method|safeContainsKey (Map<?, ?> map, Object key)
specifier|static
name|boolean
name|safeContainsKey
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

