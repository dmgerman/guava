begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableReferenceQueue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableSoftReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|FinalizableWeakReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CustomConcurrentHashMap
operator|.
name|ComputingStrategy
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|CustomConcurrentHashMap
operator|.
name|Internals
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * A {@link ConcurrentMap} builder, providing any combination of these  * features: {@linkplain SoftReference soft} or {@linkplain WeakReference  * weak} keys, soft or weak values, timed expiration, and on-demand  * computation of values. Usage example:<pre> {@code  *  *   ConcurrentMap<Key, Graph> graphs = new MapMaker()  *       .concurrencyLevel(32)  *       .softKeys()  *       .weakValues()  *       .expiration(30, TimeUnit.MINUTES)  *       .makeComputingMap(  *           new Function<Key, Graph>() {  *             public Graph apply(Key key) {  *               return createExpensiveGraph(key);  *             }  *           });}</pre>  *  * These features are all optional; {@code new MapMaker().makeMap()}  * returns a valid concurrent map that behaves exactly like a  * {@link ConcurrentHashMap}.  *  * The returned map is implemented as a hash table with similar performance  * characteristics to {@link ConcurrentHashMap}. It supports all optional  * operations of the {@code ConcurrentMap} interface. It does not permit  * null keys or values. It is serializable; however, serializing a map that  * uses soft or weak references can give unpredictable results.  *  *<p><b>Note:</b> by default, the returned map uses equality comparisons  * (the {@link Object#equals(Object) equals} method) to determine equality  * for keys or values. However, if {@link #weakKeys()} or {@link  * #softKeys()} was specified, the map uses identity ({@code ==})  * comparisons instead for keys. Likewise, if {@link #weakValues()} or  * {@link #softValues()} was specified, the map uses identity comparisons  * for values.  *  *<p>The returned map has<i>weakly consistent iteration</i>: an iterator  * over one of the map's view collections may reflect some, all or none of  * the changes made to the map after the iterator was created.  *  *<p>An entry whose key or value is reclaimed by the garbage collector  * immediately disappears from the map. (If the default settings of strong  * keys and strong values are used, this will never happen.) The client can  * never observe a partially-reclaimed entry. Any {@link java.util.Map.Entry}  * instance retrieved from the map's {@linkplain Map#entrySet() entry set}  * is snapshot of that entry's state at the time of retrieval.  *  *<p>{@code new MapMaker().weakKeys().makeMap()} can almost always be  * used as a drop-in replacement for {@link java.util.WeakHashMap}, adding  * concurrency, asynchronous cleanup, identity-based equality for keys, and  * great flexibility.  *  * @author Bob Lee  * @author Kevin Bourrillion  * @since 2010.01.04<b>stable</b> (imported from Google Collections Library)  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|MapMaker
specifier|public
specifier|final
class|class
name|MapMaker
block|{
DECL|field|keyStrength
specifier|private
name|Strength
name|keyStrength
init|=
name|Strength
operator|.
name|STRONG
decl_stmt|;
DECL|field|valueStrength
specifier|private
name|Strength
name|valueStrength
init|=
name|Strength
operator|.
name|STRONG
decl_stmt|;
DECL|field|expirationNanos
specifier|private
name|long
name|expirationNanos
init|=
literal|0
decl_stmt|;
DECL|field|useCustomMap
specifier|private
name|boolean
name|useCustomMap
decl_stmt|;
DECL|field|builder
specifier|private
specifier|final
name|CustomConcurrentHashMap
operator|.
name|Builder
name|builder
init|=
operator|new
name|CustomConcurrentHashMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|/**    * Constructs a new {@code MapMaker} instance with default settings,    * including strong keys, strong values, and no automatic expiration.    */
DECL|method|MapMaker ()
specifier|public
name|MapMaker
parameter_list|()
block|{}
comment|/**    * Sets a custom initial capacity (defaults to 16). Resizing this or    * any other kind of hash table is a relatively slow operation, so,    * when possible, it is a good idea to provide estimates of expected    * table sizes.    *    * @throws IllegalArgumentException if {@code initialCapacity} is    *   negative    * @throws IllegalStateException if an initial capacity was already set    */
DECL|method|initialCapacity (int initialCapacity)
specifier|public
name|MapMaker
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|builder
operator|.
name|initialCapacity
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Guides the allowed concurrency among update operations. Used as a    * hint for internal sizing. The table is internally partitioned to try    * to permit the indicated number of concurrent updates without    * contention.  Because placement in hash tables is essentially random,    * the actual concurrency will vary. Ideally, you should choose a value    * to accommodate as many threads as will ever concurrently modify the    * table. Using a significantly higher value than you need can waste    * space and time, and a significantly lower value can lead to thread    * contention. But overestimates and underestimates within an order of    * magnitude do not usually have much noticeable impact. A value of one    * is appropriate when it is known that only one thread will modify and    * all others will only read. Defaults to 16.    *    * @throws IllegalArgumentException if {@code concurrencyLevel} is    *     nonpositive    * @throws IllegalStateException if a concurrency level was already set    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.util.concurrent.ConcurrentHashMap concurrencyLevel"
argument_list|)
DECL|method|concurrencyLevel (int concurrencyLevel)
specifier|public
name|MapMaker
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
name|builder
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the map should be    * wrapped in a {@link WeakReference} (by default, strong references    * are used).    *    *<p><b>Note:</b> the map will use identity ({@code ==}) comparison    * to determine equality of weak keys, which may not behave as you expect.    * For example, storing a key in the map and then attempting a lookup    * using a different but {@link Object#equals(Object) equals}-equivalent    * key will always fail.    *    * @throws IllegalStateException if the key strength was already set    * @see WeakReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
DECL|method|weakKeys ()
specifier|public
name|MapMaker
name|weakKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each key (not value) stored in the map should be    * wrapped in a {@link SoftReference} (by default, strong references    * are used).    *    *<p><b>Note:</b> the map will use identity ({@code ==}) comparison    * to determine equality of soft keys, which may not behave as you expect.    * For example, storing a key in the map and then attempting a lookup    * using a different but {@link Object#equals(Object) equals}-equivalent    * key will always fail.    *    * @throws IllegalStateException if the key strength was already set    * @see SoftReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.SoftReference"
argument_list|)
DECL|method|softKeys ()
specifier|public
name|MapMaker
name|softKeys
parameter_list|()
block|{
return|return
name|setKeyStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setKeyStrength (Strength strength)
specifier|private
name|MapMaker
name|setKeyStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
if|if
condition|(
name|keyStrength
operator|!=
name|Strength
operator|.
name|STRONG
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Key strength was already set to "
operator|+
name|keyStrength
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|keyStrength
operator|=
name|strength
expr_stmt|;
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the map should be    * wrapped in a {@link WeakReference} (by default, strong references    * are used).    *    *<p>Weak values will be garbage collected once they are weakly    * reachable. This makes them a poor candidate for caching; consider    * {@link #softValues()} instead.    *    *<p><b>Note:</b> the map will use identity ({@code ==}) comparison    * to determine equality of weak values. This will notably impact    * the behavior of {@link Map#containsValue(Object) containsValue},    * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)},    * and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}.    *    * @throws IllegalStateException if the key strength was already set    * @see WeakReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.WeakReference"
argument_list|)
DECL|method|weakValues ()
specifier|public
name|MapMaker
name|weakValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|WEAK
argument_list|)
return|;
block|}
comment|/**    * Specifies that each value (not key) stored in the map should be    * wrapped in a {@link SoftReference} (by default, strong references    * are used).    *    *<p>Soft values will be garbage collected in response to memory    * demand, and in a least-recently-used manner. This makes them a    * good candidate for caching.    *    *<p><b>Note:</b> the map will use identity ({@code ==}) comparison    * to determine equality of soft values. This will notably impact    * the behavior of {@link Map#containsValue(Object) containsValue},    * {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)},    * and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}.    *    * @throws IllegalStateException if the value strength was already set    * @see SoftReference    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"java.lang.ref.SoftReference"
argument_list|)
DECL|method|softValues ()
specifier|public
name|MapMaker
name|softValues
parameter_list|()
block|{
return|return
name|setValueStrength
argument_list|(
name|Strength
operator|.
name|SOFT
argument_list|)
return|;
block|}
DECL|method|setValueStrength (Strength strength)
specifier|private
name|MapMaker
name|setValueStrength
parameter_list|(
name|Strength
name|strength
parameter_list|)
block|{
if|if
condition|(
name|valueStrength
operator|!=
name|Strength
operator|.
name|STRONG
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Value strength was already set to "
operator|+
name|valueStrength
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|valueStrength
operator|=
name|strength
expr_stmt|;
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Specifies that each entry should be automatically removed from the    * map once a fixed duration has passed since the entry's creation.    *    * @param duration the length of time after an entry is created that it    *     should be automatically removed    * @param unit the unit that {@code duration} is expressed in    * @throws IllegalArgumentException if {@code duration} is not positive    * @throws IllegalStateException if the expiration time was already set    */
DECL|method|expiration (long duration, TimeUnit unit)
specifier|public
name|MapMaker
name|expiration
parameter_list|(
name|long
name|duration
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|expirationNanos
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"expiration time of "
operator|+
name|expirationNanos
operator|+
literal|" ns was already set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|duration
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid duration: "
operator|+
name|duration
argument_list|)
throw|;
block|}
name|this
operator|.
name|expirationNanos
operator|=
name|unit
operator|.
name|toNanos
argument_list|(
name|duration
argument_list|)
expr_stmt|;
name|useCustomMap
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Builds the final map, without on-demand computation of values. This method    * does not alter the state of this {@code MapMaker} instance, so it can be    * invoked again to create multiple independent maps.    *    * @param<K> the type of keys to be stored in the returned map    * @param<V> the type of values to be stored in the returned map    * @return a concurrent map having the requested features    */
DECL|method|makeMap ()
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeMap
parameter_list|()
block|{
return|return
name|useCustomMap
condition|?
operator|new
name|StrategyImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|.
name|map
else|:
operator|new
name|ConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|builder
operator|.
name|getInitialCapacity
argument_list|()
argument_list|,
literal|0.75f
argument_list|,
name|builder
operator|.
name|getConcurrencyLevel
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Builds a map that supports atomic, on-demand computation of values. {@link    * Map#get} either returns an already-computed value for the given key,    * atomically computes it using the supplied function, or, if another thread    * is currently computing the value for this key, simply waits for that thread    * to finish and returns its computed value. Note that the function may be    * executed concurrently by multiple threads, but only for distinct keys.    *    *<p>If an entry's value has not finished computing yet, query methods    * besides {@code get} return immediately as if an entry doesn't exist. In    * other words, an entry isn't externally visible until the value's    * computation completes.    *    *<p>{@link Map#get} on the returned map will never return {@code null}. It    * may throw:    *    *<ul>    *<li>{@link NullPointerException} if the key is null or the computing    *     function returns null    *<li>{@link ComputationException} if an exception was thrown by the    *     computing function. If that exception is already of type {@link    *     ComputationException}, it is propagated directly; otherwise it is    *     wrapped.    *</ul>    *    *<p><b>Note:</b> Callers of {@code get}<i>must</i> ensure that the key    * argument is of type {@code K}. The {@code get} method accepts {@code    * Object}, so the key type is not checked at compile time. Passing an object    * of a type other than {@code K} can result in that object being unsafely    * passed to the computing function as type {@code K}, and unsafely stored in    * the map.    *    *<p>If {@link Map#put} is called before a computation completes, other    * threads waiting on the computation will wake up and return the stored    * value. When the computation completes, its new result will overwrite the    * value that was put in the map manually.    *    *<p>This method does not alter the state of this {@code MapMaker} instance,    * so it can be invoked again to create multiple independent maps.    */
DECL|method|makeComputingMap ( Function<? super K, ? extends V> computingFunction)
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|makeComputingMap
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computingFunction
parameter_list|)
block|{
return|return
operator|new
name|StrategyImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|computingFunction
argument_list|)
operator|.
name|map
return|;
block|}
comment|// Remainder of this file is private implementation details
DECL|enum|Strength
specifier|private
enum|enum
name|Strength
block|{
DECL|enumConstant|WEAK
name|WEAK
block|{
annotation|@
name|Override
name|boolean
name|equal
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
annotation|@
name|Override
name|int
name|hash
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|(
name|next
operator|==
literal|null
operator|)
condition|?
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
else|:
operator|new
name|LinkedWeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|from
init|=
operator|(
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|original
decl_stmt|;
return|return
operator|(
name|newNext
operator|==
literal|null
operator|)
condition|?
operator|new
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|)
else|:
operator|new
name|LinkedWeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|SOFT
name|SOFT
block|{
annotation|@
name|Override
name|boolean
name|equal
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
annotation|@
name|Override
name|int
name|hash
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|,
name|entry
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|(
name|next
operator|==
literal|null
operator|)
condition|?
operator|new
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
else|:
operator|new
name|LinkedSoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|from
init|=
operator|(
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|original
decl_stmt|;
return|return
operator|(
name|newNext
operator|==
literal|null
operator|)
condition|?
operator|new
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|)
else|:
operator|new
name|LinkedSoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|STRONG
name|STRONG
block|{
annotation|@
name|Override
name|boolean
name|equal
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
annotation|@
name|Override
name|int
name|hash
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|StrongValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
operator|(
name|next
operator|==
literal|null
operator|)
condition|?
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
else|:
operator|new
name|LinkedStrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
annotation|@
name|Override
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|from
init|=
operator|(
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|original
decl_stmt|;
return|return
operator|(
name|newNext
operator|==
literal|null
operator|)
condition|?
operator|new
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|)
else|:
operator|new
name|LinkedStrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|from
operator|.
name|internals
argument_list|,
name|key
argument_list|,
name|from
operator|.
name|hash
argument_list|,
name|newNext
argument_list|)
return|;
block|}
block|}
block|;
comment|/**      * Determines if two keys or values are equal according to this      * strength strategy.      */
DECL|method|equal (Object a, Object b)
specifier|abstract
name|boolean
name|equal
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
function_decl|;
comment|/**      * Hashes a key according to this strategy.      */
DECL|method|hash (Object o)
specifier|abstract
name|int
name|hash
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**      * Creates a reference for the given value according to this value      * strength.      */
DECL|method|referenceValue ( ReferenceEntry<K, V> entry, V value)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|referenceValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Creates a new entry based on the current key strength.      */
DECL|method|newEntry ( Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash, ReferenceEntry<K, V> next)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
function_decl|;
comment|/**      * Creates a new entry and copies the value and other state from an      * existing entry.      */
DECL|method|copyEntry (K key, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
specifier|abstract
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
function_decl|;
block|}
DECL|class|StrategyImpl
specifier|private
specifier|static
class|class
name|StrategyImpl
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Serializable
implements|,
name|ComputingStrategy
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|keyStrength
specifier|final
name|Strength
name|keyStrength
decl_stmt|;
DECL|field|valueStrength
specifier|final
name|Strength
name|valueStrength
decl_stmt|;
DECL|field|map
specifier|final
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|expirationNanos
specifier|final
name|long
name|expirationNanos
decl_stmt|;
DECL|field|internals
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
decl_stmt|;
DECL|method|StrategyImpl (MapMaker maker)
name|StrategyImpl
parameter_list|(
name|MapMaker
name|maker
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|maker
operator|.
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|maker
operator|.
name|valueStrength
expr_stmt|;
name|this
operator|.
name|expirationNanos
operator|=
name|maker
operator|.
name|expirationNanos
expr_stmt|;
name|map
operator|=
name|maker
operator|.
name|builder
operator|.
name|buildMap
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|StrategyImpl ( MapMaker maker, Function<? super K, ? extends V> computer)
name|StrategyImpl
parameter_list|(
name|MapMaker
name|maker
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
parameter_list|)
block|{
name|this
operator|.
name|keyStrength
operator|=
name|maker
operator|.
name|keyStrength
expr_stmt|;
name|this
operator|.
name|valueStrength
operator|=
name|maker
operator|.
name|valueStrength
expr_stmt|;
name|this
operator|.
name|expirationNanos
operator|=
name|maker
operator|.
name|expirationNanos
expr_stmt|;
name|map
operator|=
name|maker
operator|.
name|builder
operator|.
name|buildComputingMap
argument_list|(
name|this
argument_list|,
name|computer
argument_list|)
expr_stmt|;
block|}
DECL|method|setValue (ReferenceEntry<K, V> entry, V value)
specifier|public
name|void
name|setValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|setValueReference
argument_list|(
name|entry
argument_list|,
name|valueStrength
operator|.
name|referenceValue
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expirationNanos
operator|>
literal|0
condition|)
block|{
name|scheduleRemoval
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|scheduleRemoval (K key, V value)
name|void
name|scheduleRemoval
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
comment|/*        * TODO: Keep weak reference to map, too. Build a priority        * queue out of the entries themselves instead of creating a        * task per entry. Then, we could have one recurring task per        * map (which would clean the entire map and then reschedule        * itself depending upon when the next expiration comes). We        * also want to avoid removing an entry prematurely if the        * entry was set to the same value again.        */
specifier|final
name|WeakReference
argument_list|<
name|K
argument_list|>
name|keyReference
init|=
operator|new
name|WeakReference
argument_list|<
name|K
argument_list|>
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|final
name|WeakReference
argument_list|<
name|V
argument_list|>
name|valueReference
init|=
operator|new
name|WeakReference
argument_list|<
name|V
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|ExpirationTimer
operator|.
name|instance
operator|.
name|schedule
argument_list|(
operator|new
name|TimerTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|K
name|key
init|=
name|keyReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
comment|// Remove if the value is still the same.
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|valueReference
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|expirationNanos
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|equalKeys (K a, Object b)
specifier|public
name|boolean
name|equalKeys
parameter_list|(
name|K
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|keyStrength
operator|.
name|equal
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|equalValues (V a, Object b)
specifier|public
name|boolean
name|equalValues
parameter_list|(
name|V
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|valueStrength
operator|.
name|equal
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|hashKey (Object key)
specifier|public
name|int
name|hashKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|keyStrength
operator|.
name|hash
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getKey (ReferenceEntry<K, V> entry)
specifier|public
name|K
name|getKey
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
DECL|method|getHash (ReferenceEntry<K, V> entry)
specifier|public
name|int
name|getHash
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getHash
argument_list|()
return|;
block|}
DECL|method|newEntry ( K key, int hash, ReferenceEntry<K, V> next)
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
return|return
name|keyStrength
operator|.
name|newEntry
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|)
return|;
block|}
DECL|method|copyEntry (K key, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext)
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newNext
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|original
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueReference
operator|==
name|COMPUTING
condition|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
operator|new
name|FutureValueReference
argument_list|(
name|original
argument_list|,
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
else|else
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
init|=
name|newEntry
argument_list|(
name|key
argument_list|,
name|original
operator|.
name|getHash
argument_list|()
argument_list|,
name|newNext
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setValueReference
argument_list|(
name|valueReference
operator|.
name|copyFor
argument_list|(
name|newEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newEntry
return|;
block|}
block|}
comment|/**      * Waits for a computation to complete. Returns the result of the      * computation or null if none was available.      */
DECL|method|waitForValue (ReferenceEntry<K, V> entry)
specifier|public
name|V
name|waitForValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueReference
operator|==
name|COMPUTING
condition|)
block|{
synchronized|synchronized
init|(
name|entry
init|)
block|{
while|while
condition|(
operator|(
name|valueReference
operator|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|)
operator|==
name|COMPUTING
condition|)
block|{
name|entry
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|valueReference
operator|.
name|waitForValue
argument_list|()
return|;
block|}
comment|/**      * Used by CustomConcurrentHashMap to retrieve values. Returns null      * instead of blocking or throwing an exception.      */
DECL|method|getValue (ReferenceEntry<K, V> entry)
specifier|public
name|V
name|getValue
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
return|return
name|valueReference
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute (K key, final ReferenceEntry<K, V> entry, Function<? super K, ? extends V> computer)
specifier|public
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|,
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|computer
parameter_list|)
block|{
name|V
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
name|computer
operator|.
name|apply
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ComputationException
name|e
parameter_list|)
block|{
comment|// if computer has thrown a computation exception, propagate rather
comment|// than wrap
name|setValueReference
argument_list|(
name|entry
argument_list|,
operator|new
name|ComputationExceptionReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|setValueReference
argument_list|(
name|entry
argument_list|,
operator|new
name|ComputationExceptionReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ComputationException
argument_list|(
name|t
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
name|computer
operator|+
literal|" returned null for key "
operator|+
name|key
operator|+
literal|"."
decl_stmt|;
name|setValueReference
argument_list|(
name|entry
argument_list|,
operator|new
name|NullOutputExceptionReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NullOutputException
argument_list|(
name|message
argument_list|)
throw|;
block|}
else|else
block|{
name|setValue
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Sets the value reference on an entry and notifies waiting      * threads.      */
DECL|method|setValueReference (ReferenceEntry<K, V> entry, ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|boolean
name|notifyOthers
init|=
operator|(
name|entry
operator|.
name|getValueReference
argument_list|()
operator|==
name|COMPUTING
operator|)
decl_stmt|;
name|entry
operator|.
name|setValueReference
argument_list|(
name|valueReference
argument_list|)
expr_stmt|;
if|if
condition|(
name|notifyOthers
condition|)
block|{
synchronized|synchronized
init|(
name|entry
init|)
block|{
name|entry
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Points to an old entry where a value is being computed. Used to      * support non-blocking copying of entries during table expansion,      * removals, etc.      */
DECL|class|FutureValueReference
specifier|private
class|class
name|FutureValueReference
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|original
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
decl_stmt|;
DECL|field|newEntry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
decl_stmt|;
DECL|method|FutureValueReference ( ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry)
name|FutureValueReference
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|original
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newEntry
parameter_list|)
block|{
name|this
operator|.
name|original
operator|=
name|original
expr_stmt|;
name|this
operator|.
name|newEntry
operator|=
name|newEntry
expr_stmt|;
block|}
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|V
name|value
init|=
name|original
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|value
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|removeEntry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|copyFor (ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|FutureValueReference
argument_list|(
name|original
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// assert that key != null
name|V
name|value
init|=
name|StrategyImpl
operator|.
name|this
operator|.
name|waitForValue
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|value
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|removeEntry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**        * Removes the entry in the event of an exception. Ideally,        * we'd clean up as soon as the computation completes, but we        * can't do that without keeping a reference to this entry from        * the original.        */
DECL|method|removeEntry ()
name|void
name|removeEntry
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|newEntry
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getNext ( ReferenceEntry<K, V> entry)
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getNext
argument_list|()
return|;
block|}
DECL|method|setInternals ( Internals<K, V, ReferenceEntry<K, V>> internals)
specifier|public
name|void
name|setInternals
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|)
block|{
name|this
operator|.
name|internals
operator|=
name|internals
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
DECL|method|writeObject (ObjectOutputStream out)
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Custom serialization code ensures that the key and value
comment|// strengths are written before the map. We'll need them to
comment|// deserialize the map entries.
name|out
operator|.
name|writeObject
argument_list|(
name|keyStrength
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|valueStrength
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|expirationNanos
argument_list|)
expr_stmt|;
comment|// TODO: It is possible for the strategy to try to use the map
comment|// or internals during deserialization, for example, if an
comment|// entry gets reclaimed. We could detect this case and queue up
comment|// removals to be flushed after we deserialize the map.
name|out
operator|.
name|writeObject
argument_list|(
name|internals
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fields used during deserialization. We use a nested class so we      * don't load them until we need them. We need to use reflection to      * set final fields outside of the constructor.      */
DECL|class|Fields
specifier|private
specifier|static
class|class
name|Fields
block|{
DECL|field|keyStrength
specifier|static
specifier|final
name|Field
name|keyStrength
init|=
name|findField
argument_list|(
literal|"keyStrength"
argument_list|)
decl_stmt|;
DECL|field|valueStrength
specifier|static
specifier|final
name|Field
name|valueStrength
init|=
name|findField
argument_list|(
literal|"valueStrength"
argument_list|)
decl_stmt|;
DECL|field|expirationNanos
specifier|static
specifier|final
name|Field
name|expirationNanos
init|=
name|findField
argument_list|(
literal|"expirationNanos"
argument_list|)
decl_stmt|;
DECL|field|internals
specifier|static
specifier|final
name|Field
name|internals
init|=
name|findField
argument_list|(
literal|"internals"
argument_list|)
decl_stmt|;
DECL|field|map
specifier|static
specifier|final
name|Field
name|map
init|=
name|findField
argument_list|(
literal|"map"
argument_list|)
decl_stmt|;
DECL|method|findField (String name)
specifier|static
name|Field
name|findField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|Field
name|f
init|=
name|StrategyImpl
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|readObject (ObjectInputStream in)
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
try|try
block|{
name|Fields
operator|.
name|keyStrength
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|valueStrength
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|expirationNanos
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|in
operator|.
name|readLong
argument_list|()
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|internals
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
name|Fields
operator|.
name|map
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** A reference to a value. */
DECL|interface|ValueReference
specifier|private
interface|interface
name|ValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value. Does not block or throw exceptions.      */
DECL|method|get ()
name|V
name|get
parameter_list|()
function_decl|;
comment|/** Creates a copy of this reference for the given entry. */
DECL|method|copyFor (ReferenceEntry<K, V> entry)
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
function_decl|;
comment|/**      * Waits for a value that may still be computing. Unlike get(),      * this method can block (in the case of FutureValueReference) or      * throw an exception.      */
DECL|method|waitForValue ()
name|V
name|waitForValue
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
block|}
DECL|field|COMPUTING
specifier|private
specifier|static
specifier|final
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|COMPUTING
init|=
operator|new
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|ValueReference
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
specifier|public
name|Object
name|waitForValue
parameter_list|()
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
comment|/**    * Singleton placeholder that indicates a value is being computed.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Safe because impl never uses a parameter or returns any non-null value
DECL|method|computing ()
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|computing
parameter_list|()
block|{
return|return
operator|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|COMPUTING
return|;
block|}
comment|/** Used to provide null output exceptions to other threads. */
DECL|class|NullOutputExceptionReference
specifier|private
specifier|static
class|class
name|NullOutputExceptionReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|message
specifier|final
name|String
name|message
decl_stmt|;
DECL|method|NullOutputExceptionReference (String message)
name|NullOutputExceptionReference
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|this
operator|.
name|message
operator|=
name|message
expr_stmt|;
block|}
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
throw|throw
operator|new
name|NullOutputException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
comment|/** Used to provide computation exceptions to other threads. */
DECL|class|ComputationExceptionReference
specifier|private
specifier|static
class|class
name|ComputationExceptionReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|t
specifier|final
name|Throwable
name|t
decl_stmt|;
DECL|method|ComputationExceptionReference (Throwable t)
name|ComputationExceptionReference
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|this
operator|.
name|t
operator|=
name|t
expr_stmt|;
block|}
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
throw|throw
operator|new
name|AsynchronousComputationException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
comment|/** Wrapper class ensures that queue isn't created until it's used. */
DECL|class|QueueHolder
specifier|private
specifier|static
class|class
name|QueueHolder
block|{
DECL|field|queue
specifier|static
specifier|final
name|FinalizableReferenceQueue
name|queue
init|=
operator|new
name|FinalizableReferenceQueue
argument_list|()
decl_stmt|;
block|}
comment|/**    * An entry in a reference map.    */
DECL|interface|ReferenceEntry
specifier|private
interface|interface
name|ReferenceEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**      * Gets the value reference from this entry.      */
DECL|method|getValueReference ()
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
function_decl|;
comment|/**      * Sets the value reference for this entry.      *      * @param valueReference      */
DECL|method|setValueReference (ValueReference<K, V> valueReference)
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
function_decl|;
comment|/**      * Removes this entry from the map if its value reference hasn't      * changed.  Used to clean up after values. The value reference can      * just call this method on the entry so it doesn't have to keep      * its own reference to the map.      */
DECL|method|valueReclaimed ()
name|void
name|valueReclaimed
parameter_list|()
function_decl|;
comment|/** Gets the next entry in the chain. */
DECL|method|getNext ()
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
function_decl|;
comment|/** Gets the entry's hash. */
DECL|method|getHash ()
name|int
name|getHash
parameter_list|()
function_decl|;
comment|/** Gets the key for this entry. */
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
function_decl|;
block|}
comment|/**    * Used for strongly-referenced keys.    */
DECL|class|StrongEntry
specifier|private
specifier|static
class|class
name|StrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|method|StrongEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash)
name|StrongEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|this
operator|.
name|internals
operator|=
name|internals
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|internals
specifier|final
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|computing
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
block|}
DECL|class|LinkedStrongEntry
specifier|private
specifier|static
class|class
name|LinkedStrongEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|StrongEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|LinkedStrongEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash, ReferenceEntry<K, V> next)
name|LinkedStrongEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|getNext ()
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/**    * Used for softly-referenced keys.    */
DECL|class|SoftEntry
specifier|private
specifier|static
class|class
name|SoftEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableSoftReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SoftEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash)
name|SoftEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|internals
operator|=
name|internals
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|internals
specifier|final
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|computing
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
block|}
DECL|class|LinkedSoftEntry
specifier|private
specifier|static
class|class
name|LinkedSoftEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SoftEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|LinkedSoftEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash, ReferenceEntry<K, V> next)
name|LinkedSoftEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|getNext ()
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/**    * Used for weakly-referenced keys.    */
DECL|class|WeakEntry
specifier|private
specifier|static
class|class
name|WeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableWeakReference
argument_list|<
name|K
argument_list|>
implements|implements
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WeakEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash)
name|WeakEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|internals
operator|=
name|internals
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// The code below is exactly the same for each entry type.
DECL|field|internals
specifier|final
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|valueReference
specifier|volatile
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
init|=
name|computing
argument_list|()
decl_stmt|;
DECL|method|getValueReference ()
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getValueReference
parameter_list|()
block|{
return|return
name|valueReference
return|;
block|}
DECL|method|setValueReference ( ValueReference<K, V> valueReference)
specifier|public
name|void
name|setValueReference
parameter_list|(
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueReference
parameter_list|)
block|{
name|this
operator|.
name|valueReference
operator|=
name|valueReference
expr_stmt|;
block|}
DECL|method|valueReclaimed ()
specifier|public
name|void
name|valueReclaimed
parameter_list|()
block|{
name|internals
operator|.
name|removeEntry
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getNext ()
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getHash ()
specifier|public
name|int
name|getHash
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
block|}
DECL|class|LinkedWeakEntry
specifier|private
specifier|static
class|class
name|LinkedWeakEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|WeakEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|LinkedWeakEntry (Internals<K, V, ReferenceEntry<K, V>> internals, K key, int hash, ReferenceEntry<K, V> next)
name|LinkedWeakEntry
parameter_list|(
name|Internals
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|internals
parameter_list|,
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|internals
argument_list|,
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|field|next
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|getNext ()
annotation|@
name|Override
specifier|public
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
comment|/** References a weak value. */
DECL|class|WeakValueReference
specifier|private
specifier|static
class|class
name|WeakValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableWeakReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|WeakValueReference (V referent, ReferenceEntry<K, V> entry)
name|WeakValueReference
parameter_list|(
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|entry
operator|.
name|valueReclaimed
argument_list|()
expr_stmt|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|WeakValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/** References a soft value. */
DECL|class|SoftValueReference
specifier|private
specifier|static
class|class
name|SoftValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|FinalizableSoftReference
argument_list|<
name|V
argument_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|entry
specifier|final
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
DECL|method|SoftValueReference (V referent, ReferenceEntry<K, V> entry)
name|SoftValueReference
parameter_list|(
name|V
name|referent
parameter_list|,
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|super
argument_list|(
name|referent
argument_list|,
name|QueueHolder
operator|.
name|queue
argument_list|)
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|finalizeReferent ()
specifier|public
name|void
name|finalizeReferent
parameter_list|()
block|{
name|entry
operator|.
name|valueReclaimed
argument_list|()
expr_stmt|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|new
name|SoftValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|get
argument_list|()
argument_list|,
name|entry
argument_list|)
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
comment|/** References a strong value. */
DECL|class|StrongValueReference
specifier|private
specifier|static
class|class
name|StrongValueReference
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|referent
specifier|final
name|V
name|referent
decl_stmt|;
DECL|method|StrongValueReference (V referent)
name|StrongValueReference
parameter_list|(
name|V
name|referent
parameter_list|)
block|{
name|this
operator|.
name|referent
operator|=
name|referent
expr_stmt|;
block|}
DECL|method|get ()
specifier|public
name|V
name|get
parameter_list|()
block|{
return|return
name|referent
return|;
block|}
DECL|method|copyFor ( ReferenceEntry<K, V> entry)
specifier|public
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyFor
parameter_list|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|this
return|;
block|}
DECL|method|waitForValue ()
specifier|public
name|V
name|waitForValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

