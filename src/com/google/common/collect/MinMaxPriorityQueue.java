begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkPositionIndex
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_comment
comment|/**  * A double-ended priority queue, which provides constant-time access to both  * its least element and its greatest element, as determined by the queue's  * specified comparator. If no comparator is given at construction time, the  * natural order of elements is used.  *  *<p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its  * head element -- the implicit target of the methods {@link #peek()}, {@link  * #poll()} and {@link #remove()} -- is defined as the<i>least</i> element in  * the queue according to the queue's comparator. But unlike a regular priority  * queue, the methods {@link #peekLast}, {@link #pollLast} and  * {@link #removeLast} are also provided, to act on the<i>greatest</i> element  * in the queue instead.  *  *<p>A min-max priority queue can be configured with a maximum size. If so,  * each time the size of the queue exceeds that value, the queue automatically  * removes its greatest element according to its comparator (which might be the  * element that was just added). This is different from conventional bounded  * queues, which either block or reject new elements when full.  *  *<p>This implementation is based on the  *<a href="http://portal.acm.org/citation.cfm?id=6621">min-max heap</a>  * developed by Atkinson, et al. Unlike many other double-ended priority queues,  * it stores elements in a single array, as compact as the traditional heap data  * structure used in {@link PriorityQueue}.  *  *<p>This class is not thread-safe, and does not accept null elements.  *  *<p><i>Performance notes:</i>  *  *<ul>  *<li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link  *     #peekLast}, {@link #element}, and {@link #size} are constant-time  *<li>The enqueing and dequeing operations ({@link #offer}, {@link #add}, and  *     all the forms of {@link #poll} and {@link #remove()}) run in {@code  *     O(log n) time}  *<li>The {@link #remove(Object)} and {@link #contains} operations require  *     linear ({@code O(n)}) time  *</ul>  *  * @author Sverre Sundsdal  * @author Torbjorn Gannholm  * @since 8  */
end_comment

begin_comment
comment|// TODO(kevinb): @GwtCompatible
end_comment

begin_class
annotation|@
name|Beta
DECL|class|MinMaxPriorityQueue
specifier|public
specifier|final
class|class
name|MinMaxPriorityQueue
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|E
argument_list|>
block|{
comment|/**    * Creates a new min-max priority queue with default settings: natural order,    * no maximum size, no initial contents, and an initial expected size of 11.    */
DECL|method|create ()
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|MinMaxPriorityQueue
argument_list|<
name|E
argument_list|>
name|create
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|Comparable
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|create
argument_list|()
return|;
block|}
comment|/**    * Creates a new min-max priority queue using natural order, no maximum size,    * and initially containing the given elements.    */
DECL|method|create ( Iterable<? extends E> initialContents)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
argument_list|<
name|E
argument_list|>
parameter_list|>
name|MinMaxPriorityQueue
argument_list|<
name|E
argument_list|>
name|create
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|initialContents
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|E
argument_list|>
argument_list|(
name|Ordering
operator|.
expr|<
name|E
operator|>
name|natural
argument_list|()
argument_list|)
operator|.
name|create
argument_list|(
name|initialContents
argument_list|)
return|;
block|}
comment|/**    * Creates and returns a new builder, configured to build {@code    * MinMaxPriorityQueue} instances that use {@code comparator} to determine the    * least and greatest elements.    */
DECL|method|orderedBy (Comparator<B> comparator)
specifier|public
specifier|static
parameter_list|<
name|B
parameter_list|>
name|Builder
argument_list|<
name|B
argument_list|>
name|orderedBy
parameter_list|(
name|Comparator
argument_list|<
name|B
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|B
argument_list|>
argument_list|(
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Creates and returns a new builder, configured to build {@code    * MinMaxPriorityQueue} instances sized appropriately to hold {@code    * expectedSize} elements.    */
DECL|method|expectedSize (int expectedSize)
specifier|public
specifier|static
name|Builder
argument_list|<
name|Comparable
argument_list|>
name|expectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|Comparable
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|expectedSize
argument_list|(
name|expectedSize
argument_list|)
return|;
block|}
comment|/**    * Creates and returns a new builder, configured to build {@code    * MinMaxPriorityQueue} instances that are limited to {@code maximumSize}    * elements. Each time a queue grows beyond this bound, it immediately    * removes its greatest element (according to its comparator), which might be    * the element that was just added.    */
DECL|method|maximumSize (int maximumSize)
specifier|public
specifier|static
name|Builder
argument_list|<
name|Comparable
argument_list|>
name|maximumSize
parameter_list|(
name|int
name|maximumSize
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|<
name|Comparable
argument_list|>
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|maximumSize
argument_list|(
name|maximumSize
argument_list|)
return|;
block|}
comment|/**    * The builder class used in creation of min-max priority queues. Instead of    * constructing one directly, use {@link    * MinMaxPriorityQueue#orderedBy(Comparator)}, {@link    * MinMaxPriorityQueue#expectedSize(int)} or {@link    * MinMaxPriorityQueue#maximumSize(int)}.    *    * @param<B> the upper bound on the eventual type that can be produced by    *     this builder (for example, a {@code Builder<Number>} can produce a    *     {@code Queue<Number>} or {@code Queue<Integer>} but not a {@code    *     Queue<Object>}).    * @since 8    */
annotation|@
name|Beta
DECL|class|Builder
specifier|public
specifier|static
specifier|final
class|class
name|Builder
parameter_list|<
name|B
parameter_list|>
block|{
comment|/*      * TODO(kevinb): when the dust settles, see if we still need this or can      * just default to DEFAULT_CAPACITY.      */
DECL|field|UNSET_EXPECTED_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|UNSET_EXPECTED_SIZE
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|B
argument_list|>
name|comparator
decl_stmt|;
DECL|field|expectedSize
specifier|private
name|int
name|expectedSize
init|=
name|UNSET_EXPECTED_SIZE
decl_stmt|;
DECL|field|maximumSize
specifier|private
name|int
name|maximumSize
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|Builder (Comparator<B> comparator)
specifier|private
name|Builder
parameter_list|(
name|Comparator
argument_list|<
name|B
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|checkNotNull
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * Configures this builder to build min-max priority queues with an initial      * expected size of {@code expectedSize}.      */
DECL|method|expectedSize (int expectedSize)
specifier|public
name|Builder
argument_list|<
name|B
argument_list|>
name|expectedSize
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|expectedSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|expectedSize
operator|=
name|expectedSize
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures this builder to build {@code MinMaxPriorityQueue} instances      * that are limited to {@code maximumSize} elements. Each time a queue grows      * beyond this bound, it immediately removes its greatest element (according      * to its comparator), which might be the element that was just added.      */
DECL|method|maximumSize (int maximumSize)
specifier|public
name|Builder
argument_list|<
name|B
argument_list|>
name|maximumSize
parameter_list|(
name|int
name|maximumSize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|maximumSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|maximumSize
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Builds a new min-max priority queue using the previously specified      * options, and having no initial contents.      */
DECL|method|create ()
specifier|public
parameter_list|<
name|T
extends|extends
name|B
parameter_list|>
name|MinMaxPriorityQueue
argument_list|<
name|T
argument_list|>
name|create
parameter_list|()
block|{
return|return
name|create
argument_list|(
name|Collections
operator|.
expr|<
name|T
operator|>
name|emptySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Builds a new min-max priority queue using the previously specified      * options, and having the given initial elements.      */
DECL|method|create ( Iterable<? extends T> initialContents)
specifier|public
parameter_list|<
name|T
extends|extends
name|B
parameter_list|>
name|MinMaxPriorityQueue
argument_list|<
name|T
argument_list|>
name|create
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|initialContents
parameter_list|)
block|{
name|MinMaxPriorityQueue
argument_list|<
name|T
argument_list|>
name|queue
init|=
operator|new
name|MinMaxPriorityQueue
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|initialQueueSize
argument_list|(
name|expectedSize
argument_list|,
name|maximumSize
argument_list|,
name|initialContents
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|T
name|element
range|:
name|initialContents
control|)
block|{
name|queue
operator|.
name|offer
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|queue
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// safe "contravariant cast"
DECL|method|ordering ()
specifier|private
parameter_list|<
name|T
extends|extends
name|B
parameter_list|>
name|Ordering
argument_list|<
name|T
argument_list|>
name|ordering
parameter_list|()
block|{
return|return
name|Ordering
operator|.
name|from
argument_list|(
operator|(
name|Comparator
argument_list|<
name|T
argument_list|>
operator|)
name|comparator
argument_list|)
return|;
block|}
block|}
DECL|field|minHeap
specifier|private
specifier|final
name|Heap
name|minHeap
decl_stmt|;
DECL|field|maxHeap
specifier|private
specifier|final
name|Heap
name|maxHeap
decl_stmt|;
DECL|field|maximumSize
annotation|@
name|VisibleForTesting
specifier|final
name|int
name|maximumSize
decl_stmt|;
DECL|field|queue
specifier|private
name|Object
index|[]
name|queue
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|modCount
specifier|private
name|int
name|modCount
decl_stmt|;
DECL|method|MinMaxPriorityQueue (Builder<? super E> builder, int queueSize)
specifier|private
name|MinMaxPriorityQueue
parameter_list|(
name|Builder
argument_list|<
name|?
super|super
name|E
argument_list|>
name|builder
parameter_list|,
name|int
name|queueSize
parameter_list|)
block|{
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
init|=
name|builder
operator|.
name|ordering
argument_list|()
decl_stmt|;
name|this
operator|.
name|minHeap
operator|=
operator|new
name|Heap
argument_list|(
name|ordering
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxHeap
operator|=
operator|new
name|Heap
argument_list|(
name|ordering
operator|.
name|reverse
argument_list|()
argument_list|)
expr_stmt|;
name|minHeap
operator|.
name|otherHeap
operator|=
name|maxHeap
expr_stmt|;
name|maxHeap
operator|.
name|otherHeap
operator|=
name|minHeap
expr_stmt|;
name|this
operator|.
name|maximumSize
operator|=
name|builder
operator|.
name|maximumSize
expr_stmt|;
comment|// TODO(kevinb): pad?
name|this
operator|.
name|queue
operator|=
operator|new
name|Object
index|[
name|queueSize
index|]
expr_stmt|;
block|}
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
comment|/**    * Adds the given element to this queue. If this queue has a maximum size,    * after adding {@code element} the queue will automatically evict its    * greatest element (according to its comparator), which may be {@code    * element} itself.    *    * @return {@code true} always    */
DECL|method|add (E element)
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|offer
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|addAll (Collection<? extends E> newElements)
annotation|@
name|Override
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|newElements
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|E
name|element
range|:
name|newElements
control|)
block|{
name|offer
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|modified
return|;
block|}
comment|/**    * Adds the given element to this queue. If this queue has a maximum size,    * after adding {@code element} the queue will automatically evict its    * greatest element (according to its comparator), which may be {@code    * element} itself.    */
DECL|method|offer (E element)
annotation|@
name|Override
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|element
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
name|int
name|insertIndex
init|=
name|size
operator|++
decl_stmt|;
name|growIfNeeded
argument_list|()
expr_stmt|;
comment|// Adds the element to the end of the heap and bubbles it up to the correct
comment|// position.
name|heapForIndex
argument_list|(
name|insertIndex
argument_list|)
operator|.
name|bubbleUp
argument_list|(
name|insertIndex
argument_list|,
name|element
argument_list|)
expr_stmt|;
return|return
name|size
operator|<=
name|maximumSize
operator|||
name|pollLast
argument_list|()
operator|!=
name|element
return|;
block|}
DECL|method|poll ()
annotation|@
name|Override
specifier|public
name|E
name|poll
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|removeAndGet
argument_list|(
literal|0
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// we must carefully only allow Es to get in
DECL|method|elementData (int index)
name|E
name|elementData
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|E
operator|)
name|queue
index|[
name|index
index|]
return|;
block|}
DECL|method|peek ()
annotation|@
name|Override
specifier|public
name|E
name|peek
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|elementData
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Returns the index of the max element.    */
DECL|method|getMaxElementIndex ()
specifier|private
name|int
name|getMaxElementIndex
parameter_list|()
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|0
return|;
comment|// The lone element in the queue is the maximum.
case|case
literal|2
case|:
return|return
literal|1
return|;
comment|// The lone element in the maxHeap is the maximum.
default|default:
comment|// The max element must sit on the first level of the maxHeap. It is
comment|// actually the *lesser* of the two from the maxHeap's perspective.
return|return
operator|(
name|maxHeap
operator|.
name|compareElements
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|<=
literal|0
operator|)
condition|?
literal|1
else|:
literal|2
return|;
block|}
block|}
comment|/**    * Removes and returns the least element of this queue, or returns {@code    * null} if the queue is empty.    */
DECL|method|pollFirst ()
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
return|return
name|poll
argument_list|()
return|;
block|}
comment|/**    * Removes and returns the least element of this queue.    *    * @throws NoSuchElementException if the queue is empty    */
DECL|method|removeFirst ()
specifier|public
name|E
name|removeFirst
parameter_list|()
block|{
return|return
name|remove
argument_list|()
return|;
block|}
comment|/**    * Retrieves, but does not remove, the least element of this queue, or returns    * {@code null} if the queue is empty.    */
DECL|method|peekFirst ()
specifier|public
name|E
name|peekFirst
parameter_list|()
block|{
return|return
name|peek
argument_list|()
return|;
block|}
comment|/**    * Removes and returns the greatest element of this queue, or returns {@code    * null} if the queue is empty.    */
DECL|method|pollLast ()
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|removeAndGet
argument_list|(
name|getMaxElementIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Removes and returns the greatest element of this queue.    *    * @throws NoSuchElementException if the queue is empty    */
DECL|method|removeLast ()
specifier|public
name|E
name|removeLast
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|removeAndGet
argument_list|(
name|getMaxElementIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Retrieves, but does not remove, the greatest element of this queue, or    * returns {@code null} if the queue is empty.    */
DECL|method|peekLast ()
specifier|public
name|E
name|peekLast
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|elementData
argument_list|(
name|getMaxElementIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Removes the element at position {@code index}.    *    *<p>Normally this method leaves the elements at up to {@code index - 1},    * inclusive, untouched.  Under these circumstances, it returns {@code null}.    *    *<p>Occasionally, in order to maintain the heap invariant, it must swap a    * later element of the list with one before {@code index}. Under these    * circumstances it returns a pair of elements as a {@link MoveDesc}. The    * first one is the element that was previously at the end of the heap and is    * now at some position before {@code index}. The second element is the one    * that was swapped down to replace the element at {@code index}. This fact is    * used by iterator.remove so as to visit elements during a traversal once and    * only once.    */
DECL|method|removeAt (int index)
annotation|@
name|VisibleForTesting
name|MoveDesc
argument_list|<
name|E
argument_list|>
name|removeAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkPositionIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|index
condition|)
block|{
name|queue
index|[
name|size
index|]
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
name|E
name|actualLastElement
init|=
name|elementData
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|lastElementAt
init|=
name|heapForIndex
argument_list|(
name|size
argument_list|)
operator|.
name|getCorrectLastElement
argument_list|(
name|actualLastElement
argument_list|)
decl_stmt|;
name|E
name|toTrickle
init|=
name|elementData
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|queue
index|[
name|size
index|]
operator|=
literal|null
expr_stmt|;
name|MoveDesc
argument_list|<
name|E
argument_list|>
name|changes
init|=
name|fillHole
argument_list|(
name|index
argument_list|,
name|toTrickle
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastElementAt
operator|<
name|index
condition|)
block|{
comment|// Last element is moved to before index, swapped with trickled element.
if|if
condition|(
name|changes
operator|==
literal|null
condition|)
block|{
comment|// The trickled element is still after index.
return|return
operator|new
name|MoveDesc
argument_list|<
name|E
argument_list|>
argument_list|(
name|actualLastElement
argument_list|,
name|toTrickle
argument_list|)
return|;
block|}
else|else
block|{
comment|// The trickled element is back before index, but the replaced element
comment|// has now been moved after index.
return|return
operator|new
name|MoveDesc
argument_list|<
name|E
argument_list|>
argument_list|(
name|actualLastElement
argument_list|,
name|changes
operator|.
name|replaced
argument_list|)
return|;
block|}
block|}
comment|// Trickled element was after index to begin with, no adjustment needed.
return|return
name|changes
return|;
block|}
DECL|method|fillHole (int index, E toTrickle)
specifier|private
name|MoveDesc
argument_list|<
name|E
argument_list|>
name|fillHole
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|toTrickle
parameter_list|)
block|{
name|Heap
name|heap
init|=
name|heapForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// We consider elementData(index) a "hole", and we want to fill it
comment|// with the last element of the heap, toTrickle.
comment|// Since the last element of the heap is from the bottom level, we
comment|// optimistically fill index position with elements from lower levels,
comment|// moving the hole down. In most cases this reduces the number of
comment|// comparisons with toTrickle, but in some cases we will need to bubble it
comment|// all the way up again.
name|int
name|vacated
init|=
name|heap
operator|.
name|fillHoleAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// Try to see if toTrickle can be bubbled up min levels.
name|int
name|bubbledTo
init|=
name|heap
operator|.
name|bubbleUpAlternatingLevels
argument_list|(
name|vacated
argument_list|,
name|toTrickle
argument_list|)
decl_stmt|;
if|if
condition|(
name|bubbledTo
operator|==
name|vacated
condition|)
block|{
comment|// Could not bubble toTrickle up min levels, try moving
comment|// it from min level to max level (or max to min level) and bubble up
comment|// there.
return|return
name|heap
operator|.
name|tryCrossOverAndBubbleUp
argument_list|(
name|index
argument_list|,
name|vacated
argument_list|,
name|toTrickle
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|bubbledTo
operator|<
name|index
operator|)
condition|?
operator|new
name|MoveDesc
argument_list|<
name|E
argument_list|>
argument_list|(
name|toTrickle
argument_list|,
name|elementData
argument_list|(
name|index
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
block|}
comment|// Returned from removeAt() to iterator.remove()
DECL|class|MoveDesc
specifier|static
class|class
name|MoveDesc
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|toTrickle
specifier|final
name|E
name|toTrickle
decl_stmt|;
DECL|field|replaced
specifier|final
name|E
name|replaced
decl_stmt|;
DECL|method|MoveDesc (E toTrickle, E replaced)
name|MoveDesc
parameter_list|(
name|E
name|toTrickle
parameter_list|,
name|E
name|replaced
parameter_list|)
block|{
name|this
operator|.
name|toTrickle
operator|=
name|toTrickle
expr_stmt|;
name|this
operator|.
name|replaced
operator|=
name|replaced
expr_stmt|;
block|}
block|}
comment|/**    * Removes and returns the value at {@code index}.    */
DECL|method|removeAndGet (int index)
specifier|private
name|E
name|removeAndGet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|E
name|value
init|=
name|elementData
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|heapForIndex (int i)
specifier|private
name|Heap
name|heapForIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|isEvenLevel
argument_list|(
name|i
argument_list|)
condition|?
name|minHeap
else|:
name|maxHeap
return|;
block|}
DECL|field|EVEN_POWERS_OF_TWO
specifier|private
specifier|static
specifier|final
name|int
name|EVEN_POWERS_OF_TWO
init|=
literal|0x55555555
decl_stmt|;
DECL|field|ODD_POWERS_OF_TWO
specifier|private
specifier|static
specifier|final
name|int
name|ODD_POWERS_OF_TWO
init|=
literal|0xaaaaaaaa
decl_stmt|;
DECL|method|isEvenLevel (int index)
annotation|@
name|VisibleForTesting
specifier|static
name|boolean
name|isEvenLevel
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|oneBased
init|=
name|index
operator|+
literal|1
decl_stmt|;
name|checkState
argument_list|(
name|oneBased
operator|>
literal|0
argument_list|,
literal|"negative index"
argument_list|)
expr_stmt|;
return|return
operator|(
name|oneBased
operator|&
name|EVEN_POWERS_OF_TWO
operator|)
operator|>
operator|(
name|oneBased
operator|&
name|ODD_POWERS_OF_TWO
operator|)
return|;
block|}
comment|/**    * Returns {@code true} if the MinMax heap structure holds. This is only used    * in testing.    *    * TODO(kevinb): move to the test class?    */
DECL|method|isIntact ()
annotation|@
name|VisibleForTesting
name|boolean
name|isIntact
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|heapForIndex
argument_list|(
name|i
argument_list|)
operator|.
name|verifyIndex
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Each instance of MinMaxPriortyQueue encapsulates two instances of Heap:    * a min-heap and a max-heap. Conceptually, these might each have their own    * array for storage, but for efficiency's sake they are stored interleaved on    * alternate heap levels in the same array (MMPQ.queue).    */
DECL|class|Heap
specifier|private
class|class
name|Heap
block|{
DECL|field|ordering
specifier|final
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
decl_stmt|;
DECL|field|otherHeap
name|Heap
name|otherHeap
decl_stmt|;
DECL|method|Heap (Ordering<E> ordering)
name|Heap
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|)
block|{
name|this
operator|.
name|ordering
operator|=
name|ordering
expr_stmt|;
block|}
DECL|method|compareElements (int a, int b)
name|int
name|compareElements
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|ordering
operator|.
name|compare
argument_list|(
name|elementData
argument_list|(
name|a
argument_list|)
argument_list|,
name|elementData
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Tries to move {@code toTrickle} from a min to a max level and      * bubble up there. If it moved before {@code removeIndex} this method      * returns a pair as described in {@link #removeAt}.      */
DECL|method|tryCrossOverAndBubbleUp ( int removeIndex, int vacated, E toTrickle)
name|MoveDesc
argument_list|<
name|E
argument_list|>
name|tryCrossOverAndBubbleUp
parameter_list|(
name|int
name|removeIndex
parameter_list|,
name|int
name|vacated
parameter_list|,
name|E
name|toTrickle
parameter_list|)
block|{
name|int
name|crossOver
init|=
name|crossOver
argument_list|(
name|vacated
argument_list|,
name|toTrickle
argument_list|)
decl_stmt|;
if|if
condition|(
name|crossOver
operator|==
name|vacated
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Successfully crossed over from min to max.
comment|// Bubble up max levels.
name|E
name|parent
decl_stmt|;
comment|// If toTrickle is moved up to a parent of removeIndex, the parent is
comment|// placed in removeIndex position. We must return that to the iterator so
comment|// that it knows to skip it.
if|if
condition|(
name|crossOver
operator|<
name|removeIndex
condition|)
block|{
comment|// We crossed over to the parent level in crossOver, so the parent
comment|// has already been moved.
name|parent
operator|=
name|elementData
argument_list|(
name|removeIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|=
name|elementData
argument_list|(
name|getParentIndex
argument_list|(
name|removeIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// bubble it up the opposite heap
if|if
condition|(
name|otherHeap
operator|.
name|bubbleUpAlternatingLevels
argument_list|(
name|crossOver
argument_list|,
name|toTrickle
argument_list|)
operator|<
name|removeIndex
condition|)
block|{
return|return
operator|new
name|MoveDesc
argument_list|<
name|E
argument_list|>
argument_list|(
name|toTrickle
argument_list|,
name|parent
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Bubbles a value from {@code index} up the appropriate heap if required.      */
DECL|method|bubbleUp (int index, E x)
name|void
name|bubbleUp
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|x
parameter_list|)
block|{
name|int
name|crossOver
init|=
name|crossOverUp
argument_list|(
name|index
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|Heap
name|heap
decl_stmt|;
if|if
condition|(
name|crossOver
operator|==
name|index
condition|)
block|{
name|heap
operator|=
name|this
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|crossOver
expr_stmt|;
name|heap
operator|=
name|otherHeap
expr_stmt|;
block|}
name|heap
operator|.
name|bubbleUpAlternatingLevels
argument_list|(
name|index
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/**      * Bubbles a value from {@code index} up the levels of this heap, and      * returns the index the element ended up at.      */
DECL|method|bubbleUpAlternatingLevels (int index, E x)
name|int
name|bubbleUpAlternatingLevels
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|x
parameter_list|)
block|{
while|while
condition|(
name|index
operator|>
literal|2
condition|)
block|{
name|int
name|grandParentIndex
init|=
name|getGrandparentIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|E
name|e
init|=
name|elementData
argument_list|(
name|grandParentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|ordering
operator|.
name|compare
argument_list|(
name|e
argument_list|,
name|x
argument_list|)
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|queue
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
name|index
operator|=
name|grandParentIndex
expr_stmt|;
block|}
name|queue
index|[
name|index
index|]
operator|=
name|x
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**      * Returns the index of minimum value between {@code index} and      * {@code index + len}, or {@code -1} if {@code index} is greater than      * {@code size}.      */
DECL|method|findMin (int index, int len)
name|int
name|findMin
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|size
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|checkState
argument_list|(
name|index
operator|>
literal|0
argument_list|)
expr_stmt|;
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|index
argument_list|,
name|size
operator|-
name|len
argument_list|)
operator|+
name|len
decl_stmt|;
name|int
name|minIndex
init|=
name|index
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compareElements
argument_list|(
name|i
argument_list|,
name|minIndex
argument_list|)
operator|<
literal|0
condition|)
block|{
name|minIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|minIndex
return|;
block|}
comment|/**      * Returns the minimum child or {@code -1} if no child exists.      */
DECL|method|findMinChild (int index)
name|int
name|findMinChild
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|findMin
argument_list|(
name|getLeftChildIndex
argument_list|(
name|index
argument_list|)
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/**      * Returns the minimum grand child or -1 if no grand child exists.      */
DECL|method|findMinGrandChild (int index)
name|int
name|findMinGrandChild
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|leftChildIndex
init|=
name|getLeftChildIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftChildIndex
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|findMin
argument_list|(
name|getLeftChildIndex
argument_list|(
name|leftChildIndex
argument_list|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
comment|/**      * Moves an element one level up from a min level to a max level      * (or vice versa).      * Returns the new position of the element.      */
DECL|method|crossOverUp (int index, E x)
name|int
name|crossOverUp
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|x
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|queue
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|parentIndex
init|=
name|getParentIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|E
name|parentElement
init|=
name|elementData
argument_list|(
name|parentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentIndex
operator|!=
literal|0
condition|)
block|{
comment|// This is a guard for the case of the childless uncle.
comment|// Since the end of the array is actually the middle of the heap,
comment|// a smaller childless uncle can become a child of x when we
comment|// bubble up alternate levels, violating the invariant.
name|int
name|grandparentIndex
init|=
name|getParentIndex
argument_list|(
name|parentIndex
argument_list|)
decl_stmt|;
name|int
name|uncleIndex
init|=
name|getRightChildIndex
argument_list|(
name|grandparentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|uncleIndex
operator|!=
name|parentIndex
operator|&&
name|getLeftChildIndex
argument_list|(
name|uncleIndex
argument_list|)
operator|>=
name|size
condition|)
block|{
name|E
name|uncleElement
init|=
name|elementData
argument_list|(
name|uncleIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|ordering
operator|.
name|compare
argument_list|(
name|uncleElement
argument_list|,
name|parentElement
argument_list|)
operator|<
literal|0
condition|)
block|{
name|parentIndex
operator|=
name|uncleIndex
expr_stmt|;
name|parentElement
operator|=
name|uncleElement
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ordering
operator|.
name|compare
argument_list|(
name|parentElement
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|queue
index|[
name|index
index|]
operator|=
name|parentElement
expr_stmt|;
name|queue
index|[
name|parentIndex
index|]
operator|=
name|x
expr_stmt|;
return|return
name|parentIndex
return|;
block|}
name|queue
index|[
name|index
index|]
operator|=
name|x
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**      * Returns the conceptually correct last element of the heap.      *      *<p>Since the last element of the array is actually in the      * middle of the sorted structure, a childless uncle node could be      * smaller, which would corrupt the invariant if this element      * becomes the new parent of the uncle. In that case, we first      * switch the last element with its uncle, before returning.      */
DECL|method|getCorrectLastElement (E actualLastElement)
name|int
name|getCorrectLastElement
parameter_list|(
name|E
name|actualLastElement
parameter_list|)
block|{
name|int
name|parentIndex
init|=
name|getParentIndex
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentIndex
operator|!=
literal|0
condition|)
block|{
name|int
name|grandparentIndex
init|=
name|getParentIndex
argument_list|(
name|parentIndex
argument_list|)
decl_stmt|;
name|int
name|uncleIndex
init|=
name|getRightChildIndex
argument_list|(
name|grandparentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|uncleIndex
operator|!=
name|parentIndex
operator|&&
name|getLeftChildIndex
argument_list|(
name|uncleIndex
argument_list|)
operator|>=
name|size
condition|)
block|{
name|E
name|uncleElement
init|=
name|elementData
argument_list|(
name|uncleIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|ordering
operator|.
name|compare
argument_list|(
name|uncleElement
argument_list|,
name|actualLastElement
argument_list|)
operator|<
literal|0
condition|)
block|{
name|queue
index|[
name|uncleIndex
index|]
operator|=
name|actualLastElement
expr_stmt|;
name|queue
index|[
name|size
index|]
operator|=
name|uncleElement
expr_stmt|;
return|return
name|uncleIndex
return|;
block|}
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**      * Crosses an element over to the opposite heap by moving it one level down      * (or up if there are no elements below it).      *      * Returns the new position of the element.      */
DECL|method|crossOver (int index, E x)
name|int
name|crossOver
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|x
parameter_list|)
block|{
name|int
name|minChildIndex
init|=
name|findMinChild
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// TODO(kevinb): split the&& into two if's and move crossOverUp so it's
comment|// only called when there's no child.
if|if
condition|(
operator|(
name|minChildIndex
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ordering
operator|.
name|compare
argument_list|(
name|elementData
argument_list|(
name|minChildIndex
argument_list|)
argument_list|,
name|x
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|queue
index|[
name|index
index|]
operator|=
name|elementData
argument_list|(
name|minChildIndex
argument_list|)
expr_stmt|;
name|queue
index|[
name|minChildIndex
index|]
operator|=
name|x
expr_stmt|;
return|return
name|minChildIndex
return|;
block|}
return|return
name|crossOverUp
argument_list|(
name|index
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/**      * Fills the hole at {@code index} by moving in the least of its      * grandchildren to this position, then recursively filling the new hole      * created.      *      * @return the position of the new hole (where the lowest grandchild moved      *     from, that had no grandchild to replace it)      */
DECL|method|fillHoleAt (int index)
name|int
name|fillHoleAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|minGrandchildIndex
decl_stmt|;
while|while
condition|(
operator|(
name|minGrandchildIndex
operator|=
name|findMinGrandChild
argument_list|(
name|index
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|queue
index|[
name|index
index|]
operator|=
name|elementData
argument_list|(
name|minGrandchildIndex
argument_list|)
expr_stmt|;
name|index
operator|=
name|minGrandchildIndex
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
DECL|method|verifyIndex (int i)
specifier|private
name|boolean
name|verifyIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|(
name|getLeftChildIndex
argument_list|(
name|i
argument_list|)
operator|<
name|size
operator|)
operator|&&
operator|(
name|compareElements
argument_list|(
name|i
argument_list|,
name|getLeftChildIndex
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|getRightChildIndex
argument_list|(
name|i
argument_list|)
operator|<
name|size
operator|)
operator|&&
operator|(
name|compareElements
argument_list|(
name|i
argument_list|,
name|getRightChildIndex
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|compareElements
argument_list|(
name|i
argument_list|,
name|getParentIndex
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|>
literal|2
operator|)
operator|&&
operator|(
name|compareElements
argument_list|(
name|getGrandparentIndex
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// These would be static if inner classes could have static members.
DECL|method|getLeftChildIndex (int i)
specifier|private
name|int
name|getLeftChildIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|*
literal|2
operator|+
literal|1
return|;
block|}
DECL|method|getRightChildIndex (int i)
specifier|private
name|int
name|getRightChildIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|*
literal|2
operator|+
literal|2
return|;
block|}
DECL|method|getParentIndex (int i)
specifier|private
name|int
name|getParentIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
return|;
block|}
DECL|method|getGrandparentIndex (int i)
specifier|private
name|int
name|getGrandparentIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|getParentIndex
argument_list|(
name|getParentIndex
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
comment|// (i - 3) / 4
block|}
block|}
comment|/**    * Iterates the elements of the queue in no particular order.    *    * If the underlying queue is modified during iteration an exception will be    * thrown.    */
DECL|class|QueueIterator
specifier|private
class|class
name|QueueIterator
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|cursor
specifier|private
name|int
name|cursor
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|expectedModCount
specifier|private
name|int
name|expectedModCount
init|=
name|modCount
decl_stmt|;
comment|// TODO(user): Switch to ArrayDeque once Guava supports it.
DECL|field|forgetMeNot
specifier|private
name|Queue
argument_list|<
name|E
argument_list|>
name|forgetMeNot
decl_stmt|;
DECL|field|skipMe
specifier|private
name|List
argument_list|<
name|E
argument_list|>
name|skipMe
decl_stmt|;
DECL|field|lastFromForgetMeNot
specifier|private
name|E
name|lastFromForgetMeNot
decl_stmt|;
DECL|field|canRemove
specifier|private
name|boolean
name|canRemove
decl_stmt|;
DECL|method|hasNext ()
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|checkModCount
argument_list|()
expr_stmt|;
return|return
operator|(
name|nextNotInSkipMe
argument_list|(
name|cursor
operator|+
literal|1
argument_list|)
operator|<
name|size
argument_list|()
operator|)
operator|||
operator|(
operator|(
name|forgetMeNot
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|forgetMeNot
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
DECL|method|next ()
annotation|@
name|Override
specifier|public
name|E
name|next
parameter_list|()
block|{
name|checkModCount
argument_list|()
expr_stmt|;
name|int
name|tempCursor
init|=
name|nextNotInSkipMe
argument_list|(
name|cursor
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tempCursor
operator|<
name|size
argument_list|()
condition|)
block|{
name|cursor
operator|=
name|tempCursor
expr_stmt|;
name|canRemove
operator|=
literal|true
expr_stmt|;
return|return
name|elementData
argument_list|(
name|cursor
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|forgetMeNot
operator|!=
literal|null
condition|)
block|{
name|cursor
operator|=
name|size
argument_list|()
expr_stmt|;
name|lastFromForgetMeNot
operator|=
name|forgetMeNot
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastFromForgetMeNot
operator|!=
literal|null
condition|)
block|{
name|canRemove
operator|=
literal|true
expr_stmt|;
return|return
name|lastFromForgetMeNot
return|;
block|}
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"iterator moved past last element in queue."
argument_list|)
throw|;
block|}
DECL|method|remove ()
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|checkState
argument_list|(
name|canRemove
argument_list|,
literal|"no calls to remove() since the last call to next()"
argument_list|)
expr_stmt|;
name|checkModCount
argument_list|()
expr_stmt|;
name|canRemove
operator|=
literal|false
expr_stmt|;
name|expectedModCount
operator|++
expr_stmt|;
if|if
condition|(
name|cursor
operator|<
name|size
argument_list|()
condition|)
block|{
name|MoveDesc
argument_list|<
name|E
argument_list|>
name|moved
init|=
name|removeAt
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|moved
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|forgetMeNot
operator|==
literal|null
condition|)
block|{
name|forgetMeNot
operator|=
operator|new
name|LinkedList
argument_list|<
name|E
argument_list|>
argument_list|()
expr_stmt|;
name|skipMe
operator|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|forgetMeNot
operator|.
name|add
argument_list|(
name|moved
operator|.
name|toTrickle
argument_list|)
expr_stmt|;
name|skipMe
operator|.
name|add
argument_list|(
name|moved
operator|.
name|replaced
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// we must have set lastFromForgetMeNot in next()
name|checkState
argument_list|(
name|removeExact
argument_list|(
name|lastFromForgetMeNot
argument_list|)
argument_list|)
expr_stmt|;
name|lastFromForgetMeNot
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Finds only this exact instance, not others that are equals()
DECL|method|containsExact (Iterable<E> elements, E target)
specifier|private
name|boolean
name|containsExact
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|,
name|E
name|target
parameter_list|)
block|{
for|for
control|(
name|E
name|element
range|:
name|elements
control|)
block|{
if|if
condition|(
name|element
operator|==
name|target
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Removes only this exact instance, not others that are equals()
DECL|method|removeExact (Object target)
name|boolean
name|removeExact
parameter_list|(
name|Object
name|target
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|queue
index|[
name|i
index|]
operator|==
name|target
condition|)
block|{
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkModCount ()
name|void
name|checkModCount
parameter_list|()
block|{
if|if
condition|(
name|modCount
operator|!=
name|expectedModCount
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Returns the index of the first element after {@code c} that is not in      * {@code skipMe} and returns {@code size()} if there is no such element.      */
DECL|method|nextNotInSkipMe (int c)
specifier|private
name|int
name|nextNotInSkipMe
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|skipMe
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|c
operator|<
name|size
argument_list|()
operator|&&
name|containsExact
argument_list|(
name|skipMe
argument_list|,
name|elementData
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
comment|/**    * Returns an iterator over the elements contained in this collection,    *<i>in no particular order</i>.    *    *<p>The iterator is<i>fail-fast</i>: If the MinMaxPriorityQueue is modified    * at any time after the iterator is created, in any way except through the    * iterator's own remove method, the iterator will generally throw a    * {@link ConcurrentModificationException}. Thus, in the face of concurrent    * modification, the iterator fails quickly and cleanly, rather than risking    * arbitrary, non-deterministic behavior at an undetermined time in the    * future.    *    *<p>Note that the fail-fast behavior of an iterator cannot be guaranteed    * as it is, generally speaking, impossible to make any hard guarantees in the    * presence of unsynchronized concurrent modification.  Fail-fast iterators    * throw {@code ConcurrentModificationException} on a best-effort basis.    * Therefore, it would be wrong to write a program that depended on this    * exception for its correctness:<i>the fail-fast behavior of iterators    * should be used only to detect bugs.</i>    *    * @return an iterator over the elements contained in this collection    */
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|QueueIterator
argument_list|()
return|;
block|}
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|queue
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|Object
index|[]
name|copyTo
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|queue
argument_list|,
literal|0
argument_list|,
name|copyTo
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|copyTo
return|;
block|}
comment|/**    * Returns the comparator used to order the elements in this queue. Obeys the    * general contract of {@link PriorityQueue#comparator}, but returns {@link    * Ordering#natural} instead of {@code null} to indicate natural ordering.    */
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|minHeap
operator|.
name|ordering
return|;
block|}
DECL|method|capacity ()
annotation|@
name|VisibleForTesting
name|int
name|capacity
parameter_list|()
block|{
return|return
name|queue
operator|.
name|length
return|;
block|}
comment|// Size/capacity-related methods
DECL|field|DEFAULT_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|11
decl_stmt|;
DECL|method|initialQueueSize (int configuredExpectedSize, int maximumSize, Iterable<?> initialContents)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|initialQueueSize
parameter_list|(
name|int
name|configuredExpectedSize
parameter_list|,
name|int
name|maximumSize
parameter_list|,
name|Iterable
argument_list|<
name|?
argument_list|>
name|initialContents
parameter_list|)
block|{
comment|// Start with what they said, if they said it, otherwise DEFAULT_CAPACITY
name|int
name|result
init|=
operator|(
name|configuredExpectedSize
operator|==
name|Builder
operator|.
name|UNSET_EXPECTED_SIZE
operator|)
condition|?
name|DEFAULT_CAPACITY
else|:
name|configuredExpectedSize
decl_stmt|;
comment|// Enlarge to contain initial contents
if|if
condition|(
name|initialContents
operator|instanceof
name|Collection
condition|)
block|{
name|int
name|initialSize
init|=
operator|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|initialContents
operator|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|=
name|Math
operator|.
name|max
argument_list|(
name|result
argument_list|,
name|initialSize
argument_list|)
expr_stmt|;
block|}
comment|// Now cap it at maxSize + 1
return|return
name|capAtMaximumSize
argument_list|(
name|result
argument_list|,
name|maximumSize
argument_list|)
return|;
block|}
DECL|method|growIfNeeded ()
specifier|private
name|void
name|growIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|size
operator|>
name|queue
operator|.
name|length
condition|)
block|{
name|int
name|newCapacity
init|=
name|calculateNewCapacity
argument_list|()
decl_stmt|;
name|Object
index|[]
name|newQueue
init|=
operator|new
name|Object
index|[
name|newCapacity
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|queue
argument_list|,
literal|0
argument_list|,
name|newQueue
argument_list|,
literal|0
argument_list|,
name|queue
operator|.
name|length
argument_list|)
expr_stmt|;
name|queue
operator|=
name|newQueue
expr_stmt|;
block|}
block|}
comment|/** Returns ~2x the old capacity if small; ~1.5x otherwise. */
DECL|method|calculateNewCapacity ()
specifier|private
name|int
name|calculateNewCapacity
parameter_list|()
block|{
name|int
name|oldCapacity
init|=
name|queue
operator|.
name|length
decl_stmt|;
name|int
name|newCapacity
init|=
operator|(
name|oldCapacity
operator|<
literal|64
operator|)
condition|?
operator|(
name|oldCapacity
operator|+
literal|1
operator|)
operator|*
literal|2
else|:
operator|(
name|oldCapacity
operator|/
literal|2
operator|)
operator|*
literal|3
decl_stmt|;
if|if
condition|(
name|newCapacity
operator|<
literal|0
condition|)
block|{
name|newCapacity
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// overflow - hotspot will throw OOME
block|}
return|return
name|capAtMaximumSize
argument_list|(
name|newCapacity
argument_list|,
name|maximumSize
argument_list|)
return|;
block|}
comment|/** There's no reason for the queueSize to ever be more than maxSize + 1 */
DECL|method|capAtMaximumSize (int queueSize, int maximumSize)
specifier|private
specifier|static
name|int
name|capAtMaximumSize
parameter_list|(
name|int
name|queueSize
parameter_list|,
name|int
name|maximumSize
parameter_list|)
block|{
return|return
name|Math
operator|.
name|min
argument_list|(
name|queueSize
operator|-
literal|1
argument_list|,
name|maximumSize
argument_list|)
operator|+
literal|1
return|;
comment|// don't overflow
block|}
block|}
end_class

end_unit

