begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.net
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|net
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteStreams
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Inet4Address
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Inet6Address
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@link InetAddress} instances.  *  *<p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the  * methods of this class never cause DNS services to be accessed. For  * this reason, you should prefer these methods as much as possible over  * their JDK equivalents whenever you are expecting to handle only  * IP address string literals -- there is no blocking DNS penalty for a  * malformed string.  *  *<p>This class hooks into the {@code sun.net.util.IPAddressUtil} class  * to make use of the {@code textToNumericFormatV4} and  * {@code textToNumericFormatV6} methods directly as a means to avoid  * accidentally traversing all nameservices (it can be vitally important  * to avoid, say, blocking on DNS at times).  *  *<p>When dealing with {@link Inet4Address} and {@link Inet6Address}  * objects as byte arrays (vis. {@code InetAddress.getAddress()}) they  * are 4 and 16 bytes in length, respectively, and represent the address  * in network byte order.  *  *<p>Examples of IP addresses and their byte representations:  *<ul>  *<li>The IPv4 loopback address, {@code "127.0.0.1"}.<br/>  *     {@code 7f 00 00 01}  *  *<li>The IPv6 loopback address, {@code "::1"}.<br/>  *     {@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}  *  *<li>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}),  *     {@code "2001:db8::1"}.<br/>  *     {@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}  *  *<li>An IPv6 "IPv4 compatible" (or "compat") address,  *     {@code "::192.168.0.1"}.<br/>  *     {@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}  *  *<li>An IPv6 "IPv4 mapped" address, {@code "::ffff:192.168.0.1"}.<br/>  *     {@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}  *</ul>  *  *<p>A few notes about IPv6 "IPv4 mapped" addresses and their observed  * use in Java.  *<br><br>  * "IPv4 mapped" addresses were originally a representation of IPv4  * addresses for use on an IPv6 socket that could receive both IPv4  * and IPv6 connections (by disabling the {@code IPV6_V6ONLY} socket  * option on an IPv6 socket).  Yes, it's confusing.  Nevertheless,  * these "mapped" addresses were never supposed to be seen on the  * wire.  That assumption was dropped, some say mistakenly, in later  * RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.  *  *<p>Technically one<i>can</i> create a 128bit IPv6 address with the wire  * format of a "mapped" address, as shown above, and transmit it in an  * IPv6 packet header.  However, Java's InetAddress creation methods  * appear to adhere doggedly to the original intent of the "mapped"  * address: all "mapped" addresses return {@link Inet4Address} objects.  *  *<p>For added safety, it is common for IPv6 network operators to filter  * all packets where either the source or destination address appears to  * be a "compat" or "mapped" address.  Filtering suggestions usually  * recommend discarding any packets with source or destination addresses  * in the invalid range {@code ::/3}, which includes both of these bizarre  * address formats.  For more information on "bogons", including lists  * of IPv6 bogon space, see:  *  *<ul>  *<li><a target="_parent"  *        href="http://en.wikipedia.org/wiki/Bogon_filtering"  *>http://en.wikipedia.org/wiki/Bogon_filtering</a>  *<li><a target="_parent"  *        href="http://www.cymru.com/Bogons/ipv6.txt"  *>http://www.cymru.com/Bogons/ipv6.txt</a>  *<li><a target="_parent"  *        href="http://www.cymru.com/Bogons/v6bogon.html"  *>http://www.cymru.com/Bogons/v6bogon.html</a>  *<li><a target="_parent"  *        href="http://www.space.net/~gert/RIPE/ipv6-filters.html"  *>http://www.space.net/~gert/RIPE/ipv6-filters.html</a>  *</ul>  *  * @author Erik Kline  * @since 5  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|InetAddresses
specifier|public
specifier|final
class|class
name|InetAddresses
block|{
DECL|field|IPV4_PART_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|IPV4_PART_COUNT
init|=
literal|4
decl_stmt|;
DECL|field|IPV6_PART_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|IPV6_PART_COUNT
init|=
literal|8
decl_stmt|;
DECL|field|LOOPBACK4
specifier|private
specifier|static
specifier|final
name|Inet4Address
name|LOOPBACK4
init|=
operator|(
name|Inet4Address
operator|)
name|forString
argument_list|(
literal|"127.0.0.1"
argument_list|)
decl_stmt|;
DECL|field|ANY4
specifier|private
specifier|static
specifier|final
name|Inet4Address
name|ANY4
init|=
operator|(
name|Inet4Address
operator|)
name|forString
argument_list|(
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
DECL|method|InetAddresses ()
specifier|private
name|InetAddresses
parameter_list|()
block|{}
comment|/**    * Returns an {@link Inet4Address}, given a byte array representation    * of the IPv4 address.    *    * @param bytes byte array representing an IPv4 address (should be    *              of length 4).    * @return {@link Inet4Address} corresponding to the supplied byte    *         array.    * @throws IllegalArgumentException if a valid {@link Inet4Address}    *         can not be created.    */
DECL|method|getInet4Address (byte[] bytes)
specifier|private
specifier|static
name|Inet4Address
name|getInet4Address
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bytes
operator|.
name|length
operator|==
literal|4
argument_list|,
literal|"Byte array has invalid length for an IPv4 address: %s != 4."
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|InetAddress
name|ipv4
init|=
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ipv4
operator|instanceof
name|Inet4Address
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"'%s' is not an IPv4 address."
argument_list|,
name|ipv4
operator|.
name|getHostAddress
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|(
name|Inet4Address
operator|)
name|ipv4
return|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
comment|/*        * This really shouldn't happen in practice since all our byte        * sequences should be valid IP addresses.        *        * However {@link InetAddress#getByAddress} is documented as        * potentially throwing this "if IP address is of illegal length".        *        * This is mapped to IllegalArgumentException since, presumably,        * the argument triggered some bizarre processing bug.        */
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Host address '%s' is not a valid IPv4 address."
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|bytes
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the {@link InetAddress} having the given string    * representation.    *    *<p>This deliberately avoids all nameservice lookups (e.g. no DNS).    *    * @param ipString {@code String} containing an IPv4 or IPv6 string literal,    *                 e.g. {@code "192.168.0.1"} or {@code "2001:db8::1"}    * @return {@link InetAddress} representing the argument    * @throws IllegalArgumentException if the argument is not a valid    *         IP string literal    */
DECL|method|forString (String ipString)
specifier|public
specifier|static
name|InetAddress
name|forString
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
name|byte
index|[]
name|addr
init|=
name|textToNumericFormatV4
argument_list|(
name|ipString
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
comment|// Scanning for IPv4 string literal failed; try IPv6.
name|addr
operator|=
name|textToNumericFormatV6
argument_list|(
name|ipString
argument_list|)
expr_stmt|;
block|}
comment|// The argument was malformed, i.e. not an IP string literal.
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"'%s' is not an IP string literal."
argument_list|,
name|ipString
argument_list|)
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|addr
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
comment|/*        * This really shouldn't happen in practice since all our byte        * sequences should be valid IP addresses.        *        * However {@link InetAddress#getByAddress} is documented as        * potentially throwing this "if IP address is of illegal length".        *        * This is mapped to IllegalArgumentException since, presumably,        * the argument triggered some processing bug in either        * {@link IPAddressUtil#textToNumericFormatV4} or        * {@link IPAddressUtil#textToNumericFormatV6}.        */
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"'%s' is extremely broken."
argument_list|,
name|ipString
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns {@code true} if the supplied string is a valid IP string    * literal, {@code false} otherwise.    *    * @param ipString {@code String} to evaluated as an IP string literal    * @return {@code true} if the argument is a valid IP string literal    */
DECL|method|isInetAddress (String ipString)
specifier|public
specifier|static
name|boolean
name|isInetAddress
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
try|try
block|{
name|forString
argument_list|(
name|ipString
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|textToNumericFormatV4 (String ipString)
specifier|private
specifier|static
name|byte
index|[]
name|textToNumericFormatV4
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
name|boolean
name|isIpv6
init|=
literal|false
decl_stmt|;
comment|// handle IPv6 forms of IPv4 addresses
comment|// TODO: use Ascii.toUpperCase() when available
if|if
condition|(
name|ipString
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"::FFFF:"
argument_list|)
condition|)
block|{
name|ipString
operator|=
name|ipString
operator|.
name|substring
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ipString
operator|.
name|startsWith
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|ipString
operator|=
name|ipString
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|isIpv6
operator|=
literal|true
expr_stmt|;
block|}
name|String
index|[]
name|address
init|=
name|ipString
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|.
name|length
operator|!=
name|IPV4_PART_COUNT
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|IPV4_PART_COUNT
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|piece
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|address
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|piece
argument_list|<
literal|0
operator|||
name|piece
argument_list|>
literal|255
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// No leading zeroes are allowed.  See
comment|// http://tools.ietf.org/html/draft-main-ipaddr-text-rep-00
comment|// section 2.1 for discussion.
if|if
condition|(
name|address
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
literal|"0"
argument_list|)
operator|&&
name|address
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|piece
expr_stmt|;
block|}
if|if
condition|(
name|isIpv6
condition|)
block|{
comment|// prepend with zeroes;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2
operator|*
name|IPV6_PART_COUNT
index|]
decl_stmt|;
comment|// Java initializes arrays to zero
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|12
argument_list|,
name|IPV4_PART_COUNT
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
else|else
block|{
return|return
name|bytes
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|textToNumericFormatV6 (String ipString)
specifier|private
specifier|static
name|byte
index|[]
name|textToNumericFormatV6
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ipString
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|ipString
operator|.
name|contains
argument_list|(
literal|":::"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|ipString
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|ipString
operator|=
name|convertDottedQuadToHex
argument_list|(
name|ipString
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipString
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|ipString
operator|=
name|padIpString
argument_list|(
name|ipString
argument_list|)
expr_stmt|;
try|try
block|{
name|String
index|[]
name|address
init|=
name|ipString
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
name|IPV6_PART_COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|.
name|length
operator|!=
name|IPV6_PART_COUNT
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|2
operator|*
name|IPV6_PART_COUNT
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IPV6_PART_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|int
name|piece
init|=
name|address
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|?
literal|0
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|address
index|[
name|i
index|]
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|bytes
index|[
literal|2
operator|*
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|piece
operator|&
literal|0xFF00
operator|)
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|bytes
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|piece
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Fill in any omitted colons
DECL|method|padIpString (String ipString)
specifier|private
specifier|static
name|String
name|padIpString
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
if|if
condition|(
name|ipString
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|numberOfColons
argument_list|(
name|ipString
argument_list|)
decl_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|+
name|count
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
name|ipString
operator|=
name|ipString
operator|.
name|replace
argument_list|(
literal|"::"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|ipString
return|;
block|}
DECL|method|numberOfColons (String s)
specifier|private
specifier|static
name|int
name|numberOfColons
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|method|convertDottedQuadToHex (String ipString)
specifier|private
specifier|static
name|String
name|convertDottedQuadToHex
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
name|int
name|lastColon
init|=
name|ipString
operator|.
name|lastIndexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|String
name|initialPart
init|=
name|ipString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lastColon
operator|+
literal|1
argument_list|)
decl_stmt|;
name|String
name|dottedQuad
init|=
name|ipString
operator|.
name|substring
argument_list|(
name|lastColon
operator|+
literal|1
argument_list|)
decl_stmt|;
name|byte
index|[]
name|quad
init|=
name|textToNumericFormatV4
argument_list|(
name|dottedQuad
argument_list|)
decl_stmt|;
if|if
condition|(
name|quad
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|penultimate
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
operator|(
operator|(
name|quad
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|quad
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
decl_stmt|;
name|String
name|ultimate
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
operator|(
operator|(
name|quad
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|quad
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
argument_list|)
decl_stmt|;
return|return
name|initialPart
operator|+
name|penultimate
operator|+
literal|":"
operator|+
name|ultimate
return|;
block|}
comment|/**    * Returns the string representation of an {@link InetAddress} suitable    * for inclusion in a URI.    *    *<p>For IPv4 addresses, this is identical to    * {@link InetAddress#getHostAddress()}, but for IPv6 addresses it    * surrounds this text with square brackets; for example    * {@code "[2001:db8::1]"}.    *    *<p>Per section 3.2.2 of    *<a target="_parent"    *    href="http://tools.ietf.org/html/rfc3986#section-3.2.2"    *>http://tools.ietf.org/html/rfc3986</a>,    * a URI containing an IPv6 string literal is of the form    * {@code "http://[2001:db8::1]:8888/index.html"}.    *    *<p>Use of either {@link InetAddress#getHostAddress()} or this    * method is recommended over {@link InetAddress#toString()} when an    * IP address string literal is desired.  This is because    * {@link InetAddress#toString()} prints the hostname and the IP    * address string joined by a "/".    *    * @param ip {@link InetAddress} to be converted to URI string literal    * @return {@code String} containing URI-safe string literal    */
DECL|method|toUriString (InetAddress ip)
specifier|public
specifier|static
name|String
name|toUriString
parameter_list|(
name|InetAddress
name|ip
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|instanceof
name|Inet6Address
condition|)
block|{
return|return
literal|"["
operator|+
name|ip
operator|.
name|getHostAddress
argument_list|()
operator|+
literal|"]"
return|;
block|}
return|return
name|ip
operator|.
name|getHostAddress
argument_list|()
return|;
block|}
comment|/**    * Returns an InetAddress representing the literal IPv4 or IPv6 host    * portion of a URL, encoded in the format specified by RFC 3986 section 3.2.2.    *    *<p>This function is similar to {@link InetAddresses#forString(String)},    * however, it requires that IPv6 addresses are surrounded by square brackets.    *    *<p>This function is the inverse of    * {@link InetAddresses#toUriString(java.net.InetAddress)}.    *    * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address    * @return an InetAddress representing the address in {@code hostAddr}    * @throws IllegalArgumentException if {@code hostAddr} is not a valid    *     IPv4 address, or IPv6 address surrounded by square brackets    */
DECL|method|forUriString (String hostAddr)
specifier|public
specifier|static
name|InetAddress
name|forUriString
parameter_list|(
name|String
name|hostAddr
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|hostAddr
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|hostAddr
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|,
literal|"host string is empty"
argument_list|)
expr_stmt|;
name|InetAddress
name|retval
init|=
literal|null
decl_stmt|;
comment|// IPv4 address?
try|try
block|{
name|retval
operator|=
name|forString
argument_list|(
name|hostAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|instanceof
name|Inet4Address
condition|)
block|{
return|return
name|retval
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Not a valid IP address, fall through.
block|}
comment|// IPv6 address
if|if
condition|(
operator|!
operator|(
name|hostAddr
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
operator|&&
name|hostAddr
operator|.
name|endsWith
argument_list|(
literal|"]"
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not a valid address: \""
operator|+
name|hostAddr
operator|+
literal|'"'
argument_list|)
throw|;
block|}
name|retval
operator|=
name|forString
argument_list|(
name|hostAddr
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|hostAddr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|instanceof
name|Inet6Address
condition|)
block|{
return|return
name|retval
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not a valid address: \""
operator|+
name|hostAddr
operator|+
literal|'"'
argument_list|)
throw|;
block|}
comment|/**    * Returns {@code true} if the supplied string is a valid URI IP string    * literal, {@code false} otherwise.    *    * @param ipString {@code String} to evaluated as an IP URI host string literal    * @return {@code true} if the argument is a valid IP URI host    */
DECL|method|isUriInetAddress (String ipString)
specifier|public
specifier|static
name|boolean
name|isUriInetAddress
parameter_list|(
name|String
name|ipString
parameter_list|)
block|{
try|try
block|{
name|forUriString
argument_list|(
name|ipString
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Evaluates whether the argument is an IPv6 "compat" address.    *    *<p>An "IPv4 compatible", or "compat", address is one with 96 leading    * bits of zero, with the remaining 32 bits interpreted as an    * IPv4 address.  These are conventionally represented in string    * literals as {@code "::192.168.0.1"}, though {@code "::c0a8:1"} is    * also considered an IPv4 compatible address (and equivalent to    * {@code "::192.168.0.1"}).    *    *<p>For more on IPv4 compatible addresses see section 2.5.5.1 of    *<a target="_parent"    *    href="http://tools.ietf.org/html/rfc4291#section-2.5.5.1"    *>http://tools.ietf.org/html/rfc4291</a>    *    *<p>NOTE: This method is different from    * {@link Inet6Address#isIPv4CompatibleAddress} in that it more    * correctly classifies {@code "::"} and {@code "::1"} as    * proper IPv6 addresses (which they are), NOT IPv4 compatible    * addresses (which they are generally NOT considered to be).    *    * @param ip {@link Inet6Address} to be examined for embedded IPv4    *           compatible address format    * @return {@code true} if the argument is a valid "compat" address    */
DECL|method|isCompatIPv4Address (Inet6Address ip)
specifier|public
specifier|static
name|boolean
name|isCompatIPv4Address
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ip
operator|.
name|isIPv4CompatibleAddress
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bytes
index|[
literal|12
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|13
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|14
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bytes
index|[
literal|15
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes
index|[
literal|15
index|]
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns the IPv4 address embedded in an IPv4 compatible address.    *    * @param ip {@link Inet6Address} to be examined for an embedded    *           IPv4 address    * @return {@link Inet4Address} of the embedded IPv4 address    * @throws IllegalArgumentException if the argument is not a valid    *         IPv4 compatible address    */
DECL|method|getCompatIPv4Address (Inet6Address ip)
specifier|public
specifier|static
name|Inet4Address
name|getCompatIPv4Address
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isCompatIPv4Address
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"Address '%s' is not IPv4-compatible."
argument_list|,
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getInet4Address
argument_list|(
name|copyOfRange
argument_list|(
name|ip
operator|.
name|getAddress
argument_list|()
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Evaluates whether the argument is a 6to4 address.    *    *<p>6to4 addresses begin with the {@code "2002::/16"} prefix.    * The next 32 bits are the IPv4 address of the host to which    * IPv6-in-IPv4 tunneled packets should be routed.    *    *<p>For more on 6to4 addresses see section 2 of    *<a target="_parent" href="http://tools.ietf.org/html/rfc3056#section-2"    *>http://tools.ietf.org/html/rfc3056</a>    *    * @param ip {@link Inet6Address} to be examined for 6to4 address    *        format    * @return {@code true} if the argument is a 6to4 address    */
DECL|method|is6to4Address (Inet6Address ip)
specifier|public
specifier|static
name|boolean
name|is6to4Address
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
return|return
operator|(
name|bytes
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x20
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x02
operator|)
return|;
block|}
comment|/**    * Returns the IPv4 address embedded in a 6to4 address.    *    * @param ip {@link Inet6Address} to be examined for embedded IPv4    *           in 6to4 address.    * @return {@link Inet4Address} of embedded IPv4 in 6to4 address.    * @throws IllegalArgumentException if the argument is not a valid    *         IPv6 6to4 address.    */
DECL|method|get6to4IPv4Address (Inet6Address ip)
specifier|public
specifier|static
name|Inet4Address
name|get6to4IPv4Address
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|is6to4Address
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"Address '%s' is not a 6to4 address."
argument_list|,
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getInet4Address
argument_list|(
name|copyOfRange
argument_list|(
name|ip
operator|.
name|getAddress
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * A simple data class to encapsulate the information to be found in a    * Teredo address.    *    *<p>All of the fields in this class are encoded in various portions    * of the IPv6 address as part of the protocol.  More protocols details    * can be found at:    *<a target="_parent" href="http://en.wikipedia.org/wiki/Teredo_tunneling"    *>http://en.wikipedia.org/wiki/Teredo_tunneling</a>.    *    *<p>The RFC can be found here:    *<a target="_parent" href="http://tools.ietf.org/html/rfc4380"    *>http://tools.ietf.org/html/rfc4380</a>.    *    * @since 5    */
annotation|@
name|Beta
DECL|class|TeredoInfo
specifier|public
specifier|static
specifier|final
class|class
name|TeredoInfo
block|{
DECL|field|server
specifier|private
specifier|final
name|Inet4Address
name|server
decl_stmt|;
DECL|field|client
specifier|private
specifier|final
name|Inet4Address
name|client
decl_stmt|;
DECL|field|port
specifier|private
specifier|final
name|int
name|port
decl_stmt|;
DECL|field|flags
specifier|private
specifier|final
name|int
name|flags
decl_stmt|;
comment|/**      * Constructs a TeredoInfo instance.      *      *<p>Both server and client can be {@code null}, in which case the      * value {@code "0.0.0.0"} will be assumed.      *      * @throws IllegalArgumentException if either of the {@code port}      *         or the {@code flags} arguments are out of range of an      *         unsigned short      */
comment|// TODO: why is this public?
DECL|method|TeredoInfo (@ullable Inet4Address server, @Nullable Inet4Address client, int port, int flags)
specifier|public
name|TeredoInfo
parameter_list|(
annotation|@
name|Nullable
name|Inet4Address
name|server
parameter_list|,
annotation|@
name|Nullable
name|Inet4Address
name|client
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|(
name|port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|port
operator|<=
literal|0xffff
operator|)
argument_list|,
literal|"port '%d' is out of range (0<= port<= 0xffff)"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|(
name|flags
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|flags
operator|<=
literal|0xffff
operator|)
argument_list|,
literal|"flags '%d' is out of range (0<= flags<= 0xffff)"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|server
operator|=
name|ANY4
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|client
operator|=
name|ANY4
expr_stmt|;
block|}
name|this
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
DECL|method|getServer ()
specifier|public
name|Inet4Address
name|getServer
parameter_list|()
block|{
return|return
name|server
return|;
block|}
DECL|method|getClient ()
specifier|public
name|Inet4Address
name|getClient
parameter_list|()
block|{
return|return
name|client
return|;
block|}
DECL|method|getPort ()
specifier|public
name|int
name|getPort
parameter_list|()
block|{
return|return
name|port
return|;
block|}
DECL|method|getFlags ()
specifier|public
name|int
name|getFlags
parameter_list|()
block|{
return|return
name|flags
return|;
block|}
block|}
comment|/**    * Evaluates whether the argument is a Teredo address.    *    *<p>Teredo addresses begin with the {@code "2001::/32"} prefix.    *    * @param ip {@link Inet6Address} to be examined for Teredo address    *        format.    * @return {@code true} if the argument is a Teredo address    */
DECL|method|isTeredoAddress (Inet6Address ip)
specifier|public
specifier|static
name|boolean
name|isTeredoAddress
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
return|return
operator|(
name|bytes
index|[
literal|0
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x20
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x01
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|3
index|]
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Returns the Teredo information embedded in a Teredo address.    *    * @param ip {@link Inet6Address} to be examined for embedded Teredo    *           information    * @return extracted {@code TeredoInfo}    * @throws IllegalArgumentException if the argument is not a valid    *         IPv6 Teredo address    */
DECL|method|getTeredoInfo (Inet6Address ip)
specifier|public
specifier|static
name|TeredoInfo
name|getTeredoInfo
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isTeredoAddress
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"Address '%s' is not a Teredo address."
argument_list|,
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
name|Inet4Address
name|server
init|=
name|getInet4Address
argument_list|(
name|copyOfRange
argument_list|(
name|bytes
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|ByteStreams
operator|.
name|newDataInput
argument_list|(
name|bytes
argument_list|,
literal|8
argument_list|)
operator|.
name|readShort
argument_list|()
operator|&
literal|0xffff
decl_stmt|;
comment|// Teredo obfuscates the mapped client port, per section 4 of the RFC.
name|int
name|port
init|=
operator|~
name|ByteStreams
operator|.
name|newDataInput
argument_list|(
name|bytes
argument_list|,
literal|10
argument_list|)
operator|.
name|readShort
argument_list|()
operator|&
literal|0xffff
decl_stmt|;
name|byte
index|[]
name|clientBytes
init|=
name|copyOfRange
argument_list|(
name|bytes
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clientBytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Teredo obfuscates the mapped client IP, per section 4 of the RFC.
name|clientBytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
operator|~
name|clientBytes
index|[
name|i
index|]
expr_stmt|;
block|}
name|Inet4Address
name|client
init|=
name|getInet4Address
argument_list|(
name|clientBytes
argument_list|)
decl_stmt|;
return|return
operator|new
name|TeredoInfo
argument_list|(
name|server
argument_list|,
name|client
argument_list|,
name|port
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/**    * Evaluates whether the argument is an ISATAP address.    *    *<p>From RFC 5214: "ISATAP interface identifiers are constructed in    * Modified EUI-64 format [...] by concatenating the 24-bit IANA OUI    * (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit IPv4    * address in network byte order [...]"    *    *<p>For more on ISATAP addresses see section 6.1 of    *<a target="_parent" href="http://tools.ietf.org/html/rfc5214#section-6.1"    *>http://tools.ietf.org/html/rfc5214</a>    *    * @param ip {@link Inet6Address} to be examined for ISATAP address    *        format.    * @return {@code true} if the argument is an ISATAP address    */
DECL|method|isIsatapAddress (Inet6Address ip)
specifier|public
specifier|static
name|boolean
name|isIsatapAddress
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
comment|// If it's a Teredo address with the right port (41217, or 0xa101)
comment|// which would be encoded as 0x5efe then it can't be an ISATAP address.
if|if
condition|(
name|isTeredoAddress
argument_list|(
name|ip
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bytes
index|[
literal|8
index|]
operator||
operator|(
name|byte
operator|)
literal|0x03
operator|)
operator|!=
operator|(
name|byte
operator|)
literal|0x03
condition|)
block|{
comment|// Verify that high byte of the 64 bit identifier is zero, modulo
comment|// the U/L and G bits, with which we are not concerned.
return|return
literal|false
return|;
block|}
return|return
operator|(
name|bytes
index|[
literal|9
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x00
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|10
index|]
operator|==
operator|(
name|byte
operator|)
literal|0x5e
operator|)
operator|&&
operator|(
name|bytes
index|[
literal|11
index|]
operator|==
operator|(
name|byte
operator|)
literal|0xfe
operator|)
return|;
block|}
comment|/**    * Returns the IPv4 address embedded in an ISATAP address.    *    * @param ip {@link Inet6Address} to be examined for embedded IPv4    *           in ISATAP address    * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address    * @throws IllegalArgumentException if the argument is not a valid    *         IPv6 ISATAP address    */
DECL|method|getIsatapIPv4Address (Inet6Address ip)
specifier|public
specifier|static
name|Inet4Address
name|getIsatapIPv4Address
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isIsatapAddress
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"Address '%s' is not an ISATAP address."
argument_list|,
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getInet4Address
argument_list|(
name|copyOfRange
argument_list|(
name|ip
operator|.
name|getAddress
argument_list|()
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Examines the Inet6Address to determine if it is an IPv6 address of one    * of the specified address types that contain an embedded IPv4 address.    *    *<p>NOTE: ISATAP addresses are explicitly excluded from this method    * due to their trivial spoofability.  With other transition addresses    * spoofing involves (at least) infection of one's BGP routing table.    *    * @param ip {@link Inet6Address} to be examined for embedded IPv4    *           client address.    * @return {@code true} if there is an embedded IPv4 client address.    * @since 7    */
DECL|method|hasEmbeddedIPv4ClientAddress (Inet6Address ip)
specifier|public
specifier|static
name|boolean
name|hasEmbeddedIPv4ClientAddress
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
return|return
name|isCompatIPv4Address
argument_list|(
name|ip
argument_list|)
operator|||
name|is6to4Address
argument_list|(
name|ip
argument_list|)
operator|||
name|isTeredoAddress
argument_list|(
name|ip
argument_list|)
return|;
block|}
comment|/**    * Examines the Inet6Address to extract the embedded IPv4 client address    * if the InetAddress is an IPv6 address of one of the specified address    * types that contain an embedded IPv4 address.    *    *<p>NOTE: ISATAP addresses are explicitly excluded from this method    * due to their trivial spoofability.  With other transition addresses    * spoofing involves (at least) infection of one's BGP routing table.    *    * @param ip {@link Inet6Address} to be examined for embedded IPv4    *           client address.    * @return {@link Inet4Address} of embedded IPv4 client address.    * @throws IllegalArgumentException if the argument does not have a valid    *         embedded IPv4 address.    */
DECL|method|getEmbeddedIPv4ClientAddress (Inet6Address ip)
specifier|public
specifier|static
name|Inet4Address
name|getEmbeddedIPv4ClientAddress
parameter_list|(
name|Inet6Address
name|ip
parameter_list|)
block|{
if|if
condition|(
name|isCompatIPv4Address
argument_list|(
name|ip
argument_list|)
condition|)
block|{
return|return
name|getCompatIPv4Address
argument_list|(
name|ip
argument_list|)
return|;
block|}
if|if
condition|(
name|is6to4Address
argument_list|(
name|ip
argument_list|)
condition|)
block|{
return|return
name|get6to4IPv4Address
argument_list|(
name|ip
argument_list|)
return|;
block|}
if|if
condition|(
name|isTeredoAddress
argument_list|(
name|ip
argument_list|)
condition|)
block|{
return|return
name|getTeredoInfo
argument_list|(
name|ip
argument_list|)
operator|.
name|getClient
argument_list|()
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"'%s' has no embedded IPv4 address."
argument_list|,
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Coerces an IPv6 address into an IPv4 address.    *    *<p>HACK: As long as applications continue to use IPv4 addresses for    * indexing into tables, accounting, et cetera, it may be necessary to    *<b>coerce</b> IPv6 addresses into IPv4 addresses. This function does    * so by hashing the upper 64 bits into {@code 224.0.0.0/3}    * (64 bits into 29 bits).    *    *<p>A "coerced" IPv4 address is equivalent to itself.    *    *<p>NOTE: This function is failsafe for security purposes: ALL IPv6    * addresses (except localhost (::1)) are hashed to avoid the security    * risk associated with extracting an embedded IPv4 address that might    * permit elevated privileges.    *    * @param ip {@link InetAddress} to "coerce"    * @return {@link Inet4Address} represented "coerced" address    * @since 7    */
DECL|method|getCoercedIPv4Address (InetAddress ip)
specifier|public
specifier|static
name|Inet4Address
name|getCoercedIPv4Address
parameter_list|(
name|InetAddress
name|ip
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|instanceof
name|Inet4Address
condition|)
block|{
return|return
operator|(
name|Inet4Address
operator|)
name|ip
return|;
block|}
comment|// Special cases:
name|byte
index|[]
name|bytes
init|=
name|ip
operator|.
name|getAddress
argument_list|()
decl_stmt|;
name|boolean
name|leadingBytesOfZero
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bytes
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|leadingBytesOfZero
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|leadingBytesOfZero
operator|&&
operator|(
name|bytes
index|[
literal|15
index|]
operator|==
literal|1
operator|)
condition|)
block|{
return|return
name|LOOPBACK4
return|;
comment|// ::1
block|}
elseif|else
if|if
condition|(
name|leadingBytesOfZero
operator|&&
operator|(
name|bytes
index|[
literal|15
index|]
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|ANY4
return|;
comment|// ::0
block|}
name|Inet6Address
name|ip6
init|=
operator|(
name|Inet6Address
operator|)
name|ip
decl_stmt|;
name|long
name|addressAsLong
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasEmbeddedIPv4ClientAddress
argument_list|(
name|ip6
argument_list|)
condition|)
block|{
name|addressAsLong
operator|=
operator|(
name|long
operator|)
name|getEmbeddedIPv4ClientAddress
argument_list|(
name|ip6
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Just extract the high 64 bits (assuming the rest is user-modifiable).
name|addressAsLong
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|ip6
operator|.
name|getAddress
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
operator|.
name|getLong
argument_list|()
expr_stmt|;
block|}
comment|// Many strategies for hashing are possible.  This might suffice for now.
name|int
name|coercedHash
init|=
name|hash64To32
argument_list|(
name|addressAsLong
argument_list|)
decl_stmt|;
comment|// Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).
name|coercedHash
operator||=
literal|0xe0000000
expr_stmt|;
comment|// Fixup to avoid some "illegal" values.  Currently the only potential
comment|// illegal value is 255.255.255.255.
if|if
condition|(
name|coercedHash
operator|==
literal|0xffffffff
condition|)
block|{
name|coercedHash
operator|=
literal|0xfffffffe
expr_stmt|;
block|}
return|return
name|getInet4Address
argument_list|(
name|Ints
operator|.
name|toByteArray
argument_list|(
name|coercedHash
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an {@code int} hash of a 64-bit long.    *    * This comes from http://www.concentric.net/~ttwang/tech/inthash.htm    *     * This hash gives no guarantees on the cryptographic suitability nor the    * quality of randomness produced, and the mapping may change in the future.    *    * @param key A 64-bit number to hash    * @return {@code int} the input hashed into 32 bits    */
DECL|method|hash64To32 (long key)
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|hash64To32
parameter_list|(
name|long
name|key
parameter_list|)
block|{
name|key
operator|=
operator|(
operator|~
name|key
operator|)
operator|+
operator|(
name|key
operator|<<
literal|18
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|31
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|*
literal|21
expr_stmt|;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|11
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|+
operator|(
name|key
operator|<<
literal|6
operator|)
expr_stmt|;
name|key
operator|=
name|key
operator|^
operator|(
name|key
operator|>>>
literal|22
operator|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|key
return|;
block|}
comment|/**    * Returns an integer representing an IPv4 address regardless of    * whether the supplied argument is an IPv4 address or not.    *    *<p>IPv6 addresses are<b>coerced</b> to IPv4 addresses before being    * converted to integers.    *    *<p>As long as there are applications that assume that all IP addresses    * are IPv4 addresses and can therefore be converted safely to integers    * (for whatever purpose) this function can be used to handle IPv6    * addresses as well until the application is suitably fixed.    *    *<p>NOTE: an IPv6 address coerced to an IPv4 address can only be used    * for such purposes as rudimentary identification or indexing into a    * collection of real {@link InetAddress}es.  They cannot be used as    * real addresses for the purposes of network communication.    *    * @param ip {@link InetAddress} to convert    * @return {@code int}, "coerced" if ip is not an IPv4 address    * @since 7    */
DECL|method|coerceToInteger (InetAddress ip)
specifier|public
specifier|static
name|int
name|coerceToInteger
parameter_list|(
name|InetAddress
name|ip
parameter_list|)
block|{
return|return
name|ByteStreams
operator|.
name|newDataInput
argument_list|(
name|getCoercedIPv4Address
argument_list|(
name|ip
argument_list|)
operator|.
name|getAddress
argument_list|()
argument_list|)
operator|.
name|readInt
argument_list|()
return|;
block|}
comment|/**    * Returns an Inet4Address having the integer value specified by    * the argument.    *    * @param address {@code int}, the 32bit integer address to be converted    * @return {@link Inet4Address} equivalent of the argument    */
DECL|method|fromInteger (int address)
specifier|public
specifier|static
name|Inet4Address
name|fromInteger
parameter_list|(
name|int
name|address
parameter_list|)
block|{
return|return
name|getInet4Address
argument_list|(
name|Ints
operator|.
name|toByteArray
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns an address from a<b>little-endian ordered</b> byte array    * (the opposite of what {@link InetAddress#getByAddress} expects).    *    *<p>IPv4 address byte array must be 4 bytes long and IPv6 byte array    * must be 16 bytes long.    *    * @param addr the raw IP address in little-endian byte order    * @return an InetAddress object created from the raw IP address    * @throws UnknownHostException if IP address is of illegal length    */
DECL|method|fromLittleEndianByteArray (byte[] addr)
specifier|public
specifier|static
name|InetAddress
name|fromLittleEndianByteArray
parameter_list|(
name|byte
index|[]
name|addr
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|byte
index|[]
name|reversed
init|=
operator|new
name|byte
index|[
name|addr
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|reversed
index|[
name|i
index|]
operator|=
name|addr
index|[
name|addr
operator|.
name|length
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
return|return
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|reversed
argument_list|)
return|;
block|}
comment|/**    * This method emulates the Java 6 method    * {@code Arrays.copyOfRange(byte, int, int)}, which is not available in    * Java 5, and thus cannot be used in Guava code.    */
DECL|method|copyOfRange (byte[] original, int from, int to)
specifier|private
specifier|static
name|byte
index|[]
name|copyOfRange
parameter_list|(
name|byte
index|[]
name|original
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|original
argument_list|)
expr_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|to
argument_list|,
name|original
operator|.
name|length
argument_list|)
decl_stmt|;
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|to
operator|-
name|from
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|original
argument_list|,
name|from
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|end
operator|-
name|from
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

