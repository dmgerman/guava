begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to {@code String} or {@code CharSequence}  * instances.  *  * @author Kevin Bourrillion  * @since Guava release 03  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|Strings
specifier|public
specifier|final
class|class
name|Strings
block|{
DECL|method|Strings ()
specifier|private
name|Strings
parameter_list|()
block|{}
comment|/**    * Returns the given string if it is non-null; the empty string otherwise.    *    * @param string the string to test and possibly return    * @return {@code string} itself if it is non-null; {@code ""} if it is null    */
DECL|method|nullToEmpty (@ullable String string)
specifier|public
specifier|static
name|String
name|nullToEmpty
parameter_list|(
annotation|@
name|Nullable
name|String
name|string
parameter_list|)
block|{
return|return
operator|(
name|string
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
name|string
return|;
block|}
comment|/**    * Returns the given string if it is nonempty; {@code null} otherwise.    *    * @param string the string to test and possibly return    * @return {@code string} itself if it is nonempty; {@code null} if it is    *     empty or null    */
DECL|method|emptyToNull (@ullable String string)
specifier|public
specifier|static
annotation|@
name|Nullable
name|String
name|emptyToNull
parameter_list|(
annotation|@
name|Nullable
name|String
name|string
parameter_list|)
block|{
return|return
name|isNullOrEmpty
argument_list|(
name|string
argument_list|)
condition|?
literal|null
else|:
name|string
return|;
block|}
comment|/**    * Returns {@code true} if the given string is null or is the empty string.    *    *<p>Consider normalizing your string references with {@link #nullToEmpty}.    * If you do, you can use {@link String#isEmpty()} instead of this    * method, and you won't need special null-safe forms of methods like {@link    * String#toUpperCase} either. Or, if you'd like to normalize "in the other    * direction," converting empty strings to {@code null}, you can use {@link    * #emptyToNull}.    *    * @param string a string reference to check    * @return {@code true} if the string is null or is the empty string    */
DECL|method|isNullOrEmpty (@ullable String string)
specifier|public
specifier|static
name|boolean
name|isNullOrEmpty
parameter_list|(
annotation|@
name|Nullable
name|String
name|string
parameter_list|)
block|{
return|return
name|string
operator|==
literal|null
operator|||
name|string
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
comment|// string.isEmpty() in Java 6
block|}
comment|/**    * Returns a string, of length at least {@code minLength}, consisting of    * {@code string} prepended with as many copies of {@code padChar} as are    * necessary to reach that length. For example,    *    *<ul>    *<li>{@code padStart("7", 3, '0')} returns {@code "007"}    *<li>{@code padStart("2010", 3, '0')} returns {@code "2010"}    *</ul>    *    *<p>See {@link Formatter} for a richer set of formatting capabilities.    *    * @param string the string which should appear at the end of the result    * @param minLength the minimum length the resulting string must have. Can be    *     zero or negative, in which case the input string is always returned.    * @param padChar the character to insert at the beginning of the result until    *     the minimum length is reached    * @return the padded string    */
DECL|method|padStart (String string, int minLength, char padChar)
specifier|public
specifier|static
name|String
name|padStart
parameter_list|(
name|String
name|string
parameter_list|,
name|int
name|minLength
parameter_list|,
name|char
name|padChar
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|// eager for GWT.
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|>=
name|minLength
condition|)
block|{
return|return
name|string
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|minLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|string
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|minLength
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|padChar
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a string, of length at least {@code minLength}, consisting of    * {@code string} appended with as many copies of {@code padChar} as are    * necessary to reach that length. For example,    *    *<ul>    *<li>{@code padEnd("4.", 5, '0')} returns {@code "4.000"}    *<li>{@code padEnd("2010", 3, '!')} returns {@code "2010"}    *</ul>    *    *<p>See {@link Formatter} for a richer set of formatting capabilities.    *    * @param string the string which should appear at the beginning of the result    * @param minLength the minimum length the resulting string must have. Can be    *     zero or negative, in which case the input string is always returned.    * @param padChar the character to append to the end of the result until the    *     minimum length is reached    * @return the padded string    */
DECL|method|padEnd (String string, int minLength, char padChar)
specifier|public
specifier|static
name|String
name|padEnd
parameter_list|(
name|String
name|string
parameter_list|,
name|int
name|minLength
parameter_list|,
name|char
name|padChar
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|// eager for GWT.
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|>=
name|minLength
condition|)
block|{
return|return
name|string
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|minLength
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|string
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|minLength
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|padChar
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a string consisting of a specific number of concatenated copies of    * an input string. For example, {@code repeat("hey", 3)} returns the string    * {@code "heyheyhey"}.    *    * @param string any non-null string    * @param count the number of times to repeat it; a nonnegative integer    * @return a string containing {@code string} repeated {@code count} times    *     (the empty string if {@code count} is zero)    * @throws IllegalArgumentException if {@code count} is negative    */
DECL|method|repeat (String string, int count)
specifier|public
specifier|static
name|String
name|repeat
parameter_list|(
name|String
name|string
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|// eager for GWT.
name|checkArgument
argument_list|(
name|count
operator|>=
literal|0
argument_list|,
literal|"invalid count: %s"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|// If this multiplication overflows, a NegativeArraySizeException or
comment|// OutOfMemoryError is not far behind
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|string
operator|.
name|length
argument_list|()
operator|*
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

