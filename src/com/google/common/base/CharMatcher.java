begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the  * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  * express or implied. See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.base
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does  * for any {@link Object}. Also offers basic text processing methods based on this function.  * Implementations are strongly encouraged to be side-effect-free and immutable.  *  *<p>Throughout the documentation of this class, the phrase "matching character" is used to mean  * "any character {@code c} for which {@code this.matches(c)} returns {@code true}".  *  *<p><b>Note:</b> This class deals only with {@code char} values; it does not understand  * supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical  * characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}  * treats these just as two separate characters.  *  * @author Kevin Bourrillion  * @since 1  */
end_comment

begin_class
annotation|@
name|Beta
comment|// Possibly change from chars to code points; decide constants vs. methods
annotation|@
name|GwtCompatible
DECL|class|CharMatcher
specifier|public
specifier|abstract
class|class
name|CharMatcher
implements|implements
name|Predicate
argument_list|<
name|Character
argument_list|>
block|{
comment|// Constants
comment|// Excludes 2000-2000a, which is handled as a range
DECL|field|BREAKING_WHITESPACE_CHARS
specifier|private
specifier|static
specifier|final
name|String
name|BREAKING_WHITESPACE_CHARS
init|=
literal|"\t\n\013\f\r \u0085\u1680\u2028\u2029\u205f\u3000"
decl_stmt|;
comment|// Excludes 2007, which is handled as a gap in a pair of ranges
DECL|field|NON_BREAKING_WHITESPACE_CHARS
specifier|private
specifier|static
specifier|final
name|String
name|NON_BREAKING_WHITESPACE_CHARS
init|=
literal|"\u00a0\u180e\u202f"
decl_stmt|;
comment|/**    * Determines whether a character is whitespace according to the latest Unicode standard, as    * illustrated    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.    * This is not the same definition used by other Java APIs. (See a    *<a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several    * definitions of "whitespace"</a>.)    *    *<p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up    * to date.    */
DECL|field|WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|WHITESPACE
init|=
name|anyOf
argument_list|(
name|BREAKING_WHITESPACE_CHARS
operator|+
name|NON_BREAKING_WHITESPACE_CHARS
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2000'
argument_list|,
literal|'\u200a'
argument_list|)
argument_list|)
operator|.
name|precomputed
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a breaking whitespace (that is, a whitespace which can be    * interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a    * discussion of that term.    *    * @since 2    */
DECL|field|BREAKING_WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|BREAKING_WHITESPACE
init|=
name|anyOf
argument_list|(
name|BREAKING_WHITESPACE_CHARS
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2000'
argument_list|,
literal|'\u2006'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2008'
argument_list|,
literal|'\u200a'
argument_list|)
argument_list|)
operator|.
name|precomputed
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is ASCII, meaning that its code point is less than 128.    */
DECL|field|ASCII
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ASCII
init|=
name|inRange
argument_list|(
literal|'\0'
argument_list|,
literal|'\u007f'
argument_list|)
decl_stmt|;
comment|/**    * Determines whether a character is a digit according to    *<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>.    */
DECL|field|DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|DIGIT
decl_stmt|;
static|static
block|{
name|CharMatcher
name|digit
init|=
name|inRange
argument_list|(
literal|'0'
argument_list|,
literal|'9'
argument_list|)
decl_stmt|;
name|String
name|zeroes
init|=
literal|"\u0660\u06f0\u07c0\u0966\u09e6\u0a66\u0ae6\u0b66\u0be6\u0c66"
operator|+
literal|"\u0ce6\u0d66\u0e50\u0ed0\u0f20\u1040\u1090\u17e0\u1810\u1946"
operator|+
literal|"\u19d0\u1b50\u1bb0\u1c40\u1c50\ua620\ua8d0\ua900\uaa50\uff10"
decl_stmt|;
for|for
control|(
name|char
name|base
range|:
name|zeroes
operator|.
name|toCharArray
argument_list|()
control|)
block|{
name|digit
operator|=
name|digit
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
name|base
argument_list|,
call|(
name|char
call|)
argument_list|(
name|base
operator|+
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DIGIT
operator|=
name|digit
operator|.
name|precomputed
argument_list|()
expr_stmt|;
block|}
comment|/**    * Determines whether a character is whitespace according to {@link Character#isWhitespace(char)    * Java's definition}; it is usually preferable to use {@link #WHITESPACE}. (See a    *<a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several    * definitions of "whitespace"</a>.)    */
DECL|field|JAVA_WHITESPACE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_WHITESPACE
init|=
name|inRange
argument_list|(
literal|'\u0009'
argument_list|,
operator|(
name|char
operator|)
literal|13
argument_list|)
comment|// \\u000d doesn't work as a char literal
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u001c'
argument_list|,
literal|'\u0020'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u1680'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u180e'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2000'
argument_list|,
literal|'\u2006'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2008'
argument_list|,
literal|'\u200b'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2028'
argument_list|,
literal|'\u2029'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u205f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u3000'
argument_list|)
argument_list|)
operator|.
name|precomputed
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is a digit according to {@link Character#isDigit(char) Java's    * definition}. If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.    */
DECL|field|JAVA_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_DIGIT
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is a letter according to {@link Character#isLetter(char) Java's    * definition}. If you only care to match letters of the Latin alphabet, you can use {@code    * inRange('a', 'z').or(inRange('A', 'Z'))}.    */
DECL|field|JAVA_LETTER
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is a letter or digit according to {@link    * Character#isLetterOrDigit(char) Java's definition}.    */
DECL|field|JAVA_LETTER_OR_DIGIT
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LETTER_OR_DIGIT
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is upper case according to {@link Character#isUpperCase(char)    * Java's definition}.    */
DECL|field|JAVA_UPPER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_UPPER_CASE
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is lower case according to {@link Character#isLowerCase(char)    * Java's definition}.    */
DECL|field|JAVA_LOWER_CASE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_LOWER_CASE
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Determines whether a character is an ISO control character as specified by {@link    * Character#isISOControl(char)}.    */
DECL|field|JAVA_ISO_CONTROL
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|JAVA_ISO_CONTROL
init|=
name|inRange
argument_list|(
literal|'\u0000'
argument_list|,
literal|'\u001f'
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u007f'
argument_list|,
literal|'\u009f'
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Determines whether a character is invisible; that is, if its Unicode category is any of    * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and    * PRIVATE_USE according to ICU4J.    */
DECL|field|INVISIBLE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|INVISIBLE
init|=
name|inRange
argument_list|(
literal|'\u0000'
argument_list|,
literal|'\u0020'
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u007f'
argument_list|,
literal|'\u00a0'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u00ad'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u0600'
argument_list|,
literal|'\u0603'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|anyOf
argument_list|(
literal|"\u06dd\u070f\u1680\u17b4\u17b5\u180e"
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2000'
argument_list|,
literal|'\u200f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2028'
argument_list|,
literal|'\u202f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u205f'
argument_list|,
literal|'\u2064'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u206a'
argument_list|,
literal|'\u206f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u3000'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\ud800'
argument_list|,
literal|'\uf8ff'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|anyOf
argument_list|(
literal|"\ufeff\ufff9\ufffa\ufffb"
argument_list|)
argument_list|)
operator|.
name|precomputed
argument_list|()
decl_stmt|;
comment|/**    * Determines whether a character is single-width (not double-width). When in doubt, this matcher    * errs on the side of returning {@code false} (that is, it tends to assume a character is    * double-width).    *    *<p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to    * date.    */
DECL|field|SINGLE_WIDTH
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|SINGLE_WIDTH
init|=
name|inRange
argument_list|(
literal|'\u0000'
argument_list|,
literal|'\u04f9'
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u05be'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u05d0'
argument_list|,
literal|'\u05ea'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u05f3'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|is
argument_list|(
literal|'\u05f4'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u0600'
argument_list|,
literal|'\u06ff'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u0750'
argument_list|,
literal|'\u077f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u0e00'
argument_list|,
literal|'\u0e7f'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u1e00'
argument_list|,
literal|'\u20af'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\u2100'
argument_list|,
literal|'\u213a'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\ufb50'
argument_list|,
literal|'\ufdff'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\ufe70'
argument_list|,
literal|'\ufeff'
argument_list|)
argument_list|)
operator|.
name|or
argument_list|(
name|inRange
argument_list|(
literal|'\uff61'
argument_list|,
literal|'\uffdc'
argument_list|)
argument_list|)
operator|.
name|precomputed
argument_list|()
decl_stmt|;
comment|/** Matches any character. */
DECL|field|ANY
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|ANY
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|==
name|length
operator|)
condition|?
operator|-
literal|1
else|:
name|start
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|char
index|[]
name|array
init|=
operator|new
name|char
index|[
name|sequence
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|array
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|array
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|StringBuilder
name|retval
init|=
operator|new
name|StringBuilder
argument_list|(
name|sequence
operator|.
name|length
argument_list|()
operator|*
name|replacement
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
operator|(
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|String
operator|.
name|valueOf
argument_list|(
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|NONE
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
decl_stmt|;
comment|/** Matches no characters. */
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|CharMatcher
name|NONE
init|=
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|ANY
return|;
block|}
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
decl_stmt|;
comment|// Static factories
comment|/**    * Returns a {@code char} matcher that matches only one specified character.    */
DECL|method|is (final char match)
specifier|public
specifier|static
name|CharMatcher
name|is
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|match
argument_list|,
name|replacement
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|this
else|:
name|NONE
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|other
else|:
name|super
operator|.
name|or
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|isNot
argument_list|(
name|match
argument_list|)
return|;
block|}
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character except the one specified.    *    *<p>To negate another {@code CharMatcher}, use {@link #negate()}.    */
DECL|method|isNot (final char match)
specifier|public
specifier|static
name|CharMatcher
name|isNot
parameter_list|(
specifier|final
name|char
name|match
parameter_list|)
block|{
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|!=
name|match
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|super
operator|.
name|and
argument_list|(
name|other
argument_list|)
else|:
name|other
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|matches
argument_list|(
name|match
argument_list|)
condition|?
name|ANY
else|:
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|is
argument_list|(
name|match
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character present in the given character    * sequence.    */
DECL|method|anyOf (final CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|anyOf
parameter_list|(
specifier|final
name|CharSequence
name|sequence
parameter_list|)
block|{
switch|switch
condition|(
name|sequence
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|NONE
return|;
case|case
literal|1
case|:
return|return
name|is
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
specifier|final
name|char
name|match1
init|=
name|sequence
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|char
name|match2
init|=
name|sequence
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|match1
operator|||
name|c
operator|==
name|match2
return|;
block|}
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
name|table
operator|.
name|set
argument_list|(
name|match1
argument_list|)
expr_stmt|;
name|table
operator|.
name|set
argument_list|(
name|match2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
return|;
block|}
specifier|final
name|char
index|[]
name|chars
init|=
name|sequence
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|chars
argument_list|)
expr_stmt|;
comment|// not worth collapsing duplicates
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|chars
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
return|;
block|}
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character not present in the given character    * sequence.    */
DECL|method|noneOf (CharSequence sequence)
specifier|public
specifier|static
name|CharMatcher
name|noneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|anyOf
argument_list|(
name|sequence
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
comment|/**    * Returns a {@code char} matcher that matches any character in a given range (both endpoints are    * inclusive). For example, to match any lowercase letter of the English alphabet, use {@code    * CharMatcher.inRange('a', 'z')}.    *    * @throws IllegalArgumentException if {@code endInclusive< startInclusive}    */
DECL|method|inRange (final char startInclusive, final char endInclusive)
specifier|public
specifier|static
name|CharMatcher
name|inRange
parameter_list|(
specifier|final
name|char
name|startInclusive
parameter_list|,
specifier|final
name|char
name|endInclusive
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|endInclusive
operator|>=
name|startInclusive
argument_list|)
expr_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|startInclusive
operator|<=
name|c
operator|&&
name|c
operator|<=
name|endInclusive
return|;
block|}
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
name|char
name|c
init|=
name|startInclusive
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|++
operator|==
name|endInclusive
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a matcher with identical behavior to the given {@link Character}-based predicate, but    * which operates on primitive {@code char} instances instead.    */
DECL|method|forPredicate (final Predicate<? super Character> predicate)
specifier|public
specifier|static
name|CharMatcher
name|forPredicate
parameter_list|(
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|Character
argument_list|>
name|predicate
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|predicate
operator|instanceof
name|CharMatcher
condition|)
block|{
return|return
operator|(
name|CharMatcher
operator|)
name|predicate
return|;
block|}
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|apply
argument_list|(
name|checkNotNull
argument_list|(
name|character
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|// Abstract methods
comment|/** Determines a true or false value for the given character. */
DECL|method|matches (char c)
specifier|public
specifier|abstract
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
comment|// Non-static factories
comment|/**    * Returns a matcher that matches any character not matched by this matcher.    */
DECL|method|negate ()
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
specifier|final
name|CharMatcher
name|original
init|=
name|this
decl_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|!
name|original
operator|.
name|matches
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesNoneOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|original
operator|.
name|matchesAllOf
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|sequence
operator|.
name|length
argument_list|()
operator|-
name|original
operator|.
name|countIn
argument_list|(
name|sequence
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CharMatcher
name|negate
parameter_list|()
block|{
return|return
name|original
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a matcher that matches any character matched by both this matcher and {@code other}.    */
DECL|method|and (CharMatcher other)
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|And
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|class|And
specifier|private
specifier|static
class|class
name|And
extends|extends
name|CharMatcher
block|{
DECL|field|components
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|components
decl_stmt|;
DECL|method|And (List<CharMatcher> components)
name|And
parameter_list|(
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|components
parameter_list|)
block|{
name|this
operator|.
name|components
operator|=
name|components
expr_stmt|;
comment|// Skip defensive copy (private)
block|}
DECL|method|matches (char c)
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
for|for
control|(
name|CharMatcher
name|matcher
range|:
name|components
control|)
block|{
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|and (CharMatcher other)
annotation|@
name|Override
specifier|public
name|CharMatcher
name|and
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|newComponents
init|=
operator|new
name|ArrayList
argument_list|<
name|CharMatcher
argument_list|>
argument_list|(
name|components
argument_list|)
decl_stmt|;
name|newComponents
operator|.
name|add
argument_list|(
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|And
argument_list|(
name|newComponents
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a matcher that matches any character matched by either this matcher or {@code other}.    */
DECL|method|or (CharMatcher other)
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
return|return
operator|new
name|Or
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|class|Or
specifier|private
specifier|static
class|class
name|Or
extends|extends
name|CharMatcher
block|{
DECL|field|components
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|components
decl_stmt|;
DECL|method|Or (List<CharMatcher> components)
name|Or
parameter_list|(
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|components
parameter_list|)
block|{
name|this
operator|.
name|components
operator|=
name|components
expr_stmt|;
comment|// Skip defensive copy (private)
block|}
DECL|method|matches (char c)
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
for|for
control|(
name|CharMatcher
name|matcher
range|:
name|components
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|or (CharMatcher other)
annotation|@
name|Override
specifier|public
name|CharMatcher
name|or
parameter_list|(
name|CharMatcher
name|other
parameter_list|)
block|{
name|List
argument_list|<
name|CharMatcher
argument_list|>
name|newComponents
init|=
operator|new
name|ArrayList
argument_list|<
name|CharMatcher
argument_list|>
argument_list|(
name|components
argument_list|)
decl_stmt|;
name|newComponents
operator|.
name|add
argument_list|(
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Or
argument_list|(
name|newComponents
argument_list|)
return|;
block|}
DECL|method|setBits (LookupTable table)
annotation|@
name|Override
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
for|for
control|(
name|CharMatcher
name|matcher
range|:
name|components
control|)
block|{
name|matcher
operator|.
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to    * query than the original; your mileage may vary. Precomputation takes time and is likely to be    * worthwhile only if the precomputed matcher is queried many thousands of times.    *    *<p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a    * precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a    * worthwhile tradeoff in a browser.    */
DECL|method|precomputed ()
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|Platform
operator|.
name|precomputeCharMatcher
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * This is the actual implementation of {@link #precomputed}, but we bounce calls through a method    * on {@link Platform} so that we can have different behavior in GWT.    *    *<p>The default precomputation is to cache the configuration of the original matcher in an    * eight-kilobyte bit array. In some situations this produces a matcher which is faster to query    * than the original.    *    *<p>The default implementation creates a new bit array and passes it to {@link    * #setBits(LookupTable)}.    */
DECL|method|precomputedInternal ()
name|CharMatcher
name|precomputedInternal
parameter_list|()
block|{
specifier|final
name|LookupTable
name|table
init|=
operator|new
name|LookupTable
argument_list|()
decl_stmt|;
name|setBits
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
operator|new
name|CharMatcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|table
operator|.
name|get
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|// TODO(kevinb): make methods like negate() smart?
annotation|@
name|Override
specifier|public
name|CharMatcher
name|precomputed
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
return|;
block|}
comment|/**    * For use by implementors; sets the bit corresponding to each character ('\0' to '{@literal    * \}uFFFF') that matches this matcher in the given bit array, leaving all other bits untouched.    *    *<p>The default implementation loops over every possible character value, invoking {@link    * #matches} for each one.    */
DECL|method|setBits (LookupTable table)
name|void
name|setBits
parameter_list|(
name|LookupTable
name|table
parameter_list|)
block|{
name|char
name|c
init|=
name|Character
operator|.
name|MIN_VALUE
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|table
operator|.
name|set
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|++
operator|==
name|Character
operator|.
name|MAX_VALUE
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/**    * A bit array with one bit per {@code char} value, used by {@link CharMatcher#precomputed}.    *    *<p>TODO(kevinb): possibly share a common BitArray class with BloomFilter and others... a    * simpler java.util.BitSet.    */
DECL|class|LookupTable
specifier|private
specifier|static
specifier|final
class|class
name|LookupTable
block|{
DECL|field|data
name|int
index|[]
name|data
init|=
operator|new
name|int
index|[
literal|2048
index|]
decl_stmt|;
DECL|method|set (char index)
name|void
name|set
parameter_list|(
name|char
name|index
parameter_list|)
block|{
name|data
index|[
name|index
operator|>>
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
block|}
DECL|method|get (char index)
name|boolean
name|get
parameter_list|(
name|char
name|index
parameter_list|)
block|{
return|return
operator|(
name|data
index|[
name|index
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
block|}
comment|// Text processing routines
comment|/**    * Returns {@code true} if a character sequence contains only matching characters.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code false} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches every character in the sequence, including when    *         the sequence is empty    */
DECL|method|matchesAllOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesAllOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns {@code true} if a character sequence contains no matching characters.    *    *<p>The default implementation iterates over the sequence, invoking {@link #matches} for each    * character, until this returns {@code false} or the end is reached.    *    * @param sequence the character sequence to examine, possibly empty    * @return {@code true} if this matcher matches every character in the sequence, including when    *         the sequence is empty    */
DECL|method|matchesNoneOf (CharSequence sequence)
specifier|public
name|boolean
name|matchesNoneOf
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|indexIn
argument_list|(
name|sequence
argument_list|)
operator|==
operator|-
literal|1
return|;
block|}
comment|// TODO(kevinb): add matchesAnyOf()
comment|/**    * Returns the index of the first matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in forward order calling {@link    * #matches} for each character.    *    * @param sequence the character sequence to examine from the beginning    * @return an index, or {@code -1} if no character matches    */
DECL|method|indexIn (CharSequence sequence)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the first matching character in a character sequence, starting from a    * given position, or {@code -1} if no character matches after that position.    *    *<p>The default implementation iterates over the sequence in forward order, beginning at {@code    * start}, calling {@link #matches} for each character.    *    * @param sequence the character sequence to examine    * @param start the first index to examine; must be nonnegative and no greater than {@code    *        sequence.length()}    * @return the index of the first matching character, guaranteed to be no less than {@code start},    *         or {@code -1} if no character matches    * @throws IndexOutOfBoundsException if start is negative or greater than {@code    *         sequence.length()}    */
DECL|method|indexIn (CharSequence sequence, int start)
specifier|public
name|int
name|indexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the index of the last matching character in a character sequence, or {@code -1} if no    * matching character is present.    *    *<p>The default implementation iterates over the sequence in reverse order calling {@link    * #matches} for each character.    *    * @param sequence the character sequence to examine from the end    * @return an index, or {@code -1} if no character matches    */
DECL|method|lastIndexIn (CharSequence sequence)
specifier|public
name|int
name|lastIndexIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequence
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns the number of matching characters found in a character sequence.    */
DECL|method|countIn (CharSequence sequence)
specifier|public
name|int
name|countIn
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns a string containing all non-matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').removeFrom("bazaar")}</pre>    *    * ... returns {@code "bzr"}.    */
DECL|method|removeFrom (CharSequence sequence)
specifier|public
name|String
name|removeFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|spread
init|=
literal|1
decl_stmt|;
comment|// This unusual loop comes from extensive benchmarking
name|OUT
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|pos
operator|++
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|chars
operator|.
name|length
condition|)
block|{
break|break
name|OUT
break|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|chars
index|[
name|pos
operator|-
name|spread
index|]
operator|=
name|chars
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|spread
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|pos
operator|-
name|spread
argument_list|)
return|;
block|}
comment|/**    * Returns a string containing all matching characters of a character sequence, in order. For    * example:<pre>   {@code    *    *   CharMatcher.is('a').retainFrom("bazaar")}</pre>    *    * ... returns {@code "aaa"}.    */
DECL|method|retainFrom (CharSequence sequence)
specifier|public
name|String
name|retainFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
return|return
name|negate
argument_list|()
operator|.
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement character. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>    *    * ... returns {@code "rodor"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the character to append to the result string in place of each matching    *        character in {@code sequence}    * @return the new string    */
DECL|method|replaceFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|char
index|[]
name|chars
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|chars
index|[
name|pos
index|]
operator|=
name|replacement
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pos
operator|+
literal|1
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|chars
index|[
name|i
index|]
operator|=
name|replacement
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|)
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each character that matches this    * matcher replaced by a given replacement sequence. For example:<pre>   {@code    *    *   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>    *    * ... returns {@code "yoohoo"}.    *    *<p><b>Note:</b> If the replacement is a fixed string with only one character, you are better    * off calling {@link #replaceFrom(CharSequence, char)} directly.    *    * @param sequence the character sequence to replace matching characters in    * @param replacement the characters to append to the result string in place of each matching    *        character in {@code sequence}    * @return the new string    */
DECL|method|replaceFrom (CharSequence sequence, CharSequence replacement)
specifier|public
name|String
name|replaceFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|CharSequence
name|replacement
parameter_list|)
block|{
name|int
name|replacementLen
init|=
name|replacement
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|replacementLen
operator|==
literal|0
condition|)
block|{
return|return
name|removeFrom
argument_list|(
name|sequence
argument_list|)
return|;
block|}
if|if
condition|(
name|replacementLen
operator|==
literal|1
condition|)
block|{
return|return
name|replaceFrom
argument_list|(
name|sequence
argument_list|,
name|replacement
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|String
name|string
init|=
name|sequence
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|indexIn
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|string
return|;
block|}
name|int
name|len
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
operator|(
name|len
operator|*
literal|3
operator|/
literal|2
operator|)
operator|+
literal|16
argument_list|)
decl_stmt|;
name|int
name|oldpos
init|=
literal|0
decl_stmt|;
do|do
block|{
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
name|indexIn
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
do|;
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|,
name|oldpos
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning and from the end of the string. For example:<pre>   {@code    *    *   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>    *    * ... returns {@code "cat"}.    *    *<p>Note that:<pre>   {@code    *    *   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>    *    * ... is equivalent to {@link String#trim()}.    */
DECL|method|trimFrom (CharSequence sequence)
specifier|public
name|String
name|trimFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|last
operator|=
name|len
operator|-
literal|1
init|;
name|last
operator|>
name|first
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the beginning of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>    *    * ... returns {@code "catbab"}.    */
DECL|method|trimLeadingFrom (CharSequence sequence)
specifier|public
name|String
name|trimLeadingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|first
decl_stmt|;
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|len
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
name|first
argument_list|,
name|len
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a substring of the input character sequence that omits all characters this matcher    * matches from the end of the string. For example:<pre> {@code    *    *   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>    *    * ... returns {@code "abacat"}.    */
DECL|method|trimTrailingFrom (CharSequence sequence)
specifier|public
name|String
name|trimTrailingFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
name|int
name|len
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|len
operator|-
literal|1
init|;
name|last
operator|>=
literal|0
condition|;
name|last
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|sequence
operator|.
name|charAt
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|sequence
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|last
operator|+
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a string copy of the input character sequence, with each group of consecutive    * characters that match this matcher replaced by a single replacement character. For example:    *<pre>   {@code    *    *   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>    *    * ... returns {@code "b-p-r"}.    *    *<p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching    * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each    * character.    *    * @param sequence the character sequence to replace matching groups of characters in    * @param replacement the character to append to the result string in place of each group of    *        matching characters in {@code sequence}    * @return the new string    */
DECL|method|collapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|collapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|int
name|first
init|=
name|indexIn
argument_list|(
name|sequence
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|sequence
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// TODO(kevinb): see if this implementation can be made faster
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|sequence
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|sequence
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|first
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
decl_stmt|;
name|boolean
name|in
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|first
operator|+
literal|1
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|apply
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|in
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|in
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that    * groups of matching characters at the start or end of the sequence are removed without    * replacement.    */
DECL|method|trimAndCollapseFrom (CharSequence sequence, char replacement)
specifier|public
name|String
name|trimAndCollapseFrom
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|char
name|replacement
parameter_list|)
block|{
name|int
name|first
init|=
name|negate
argument_list|()
operator|.
name|indexIn
argument_list|(
name|sequence
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|""
return|;
comment|// everything matches. nothing's left.
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|sequence
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|inMatchingGroup
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|first
init|;
name|i
operator|<
name|sequence
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|apply
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|inMatchingGroup
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inMatchingGroup
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|inMatchingGroup
operator|=
literal|false
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Predicate interface
comment|/**    * Returns {@code true} if this matcher matches the given character.    *    * @throws NullPointerException if {@code character} is null    */
DECL|method|apply (Character character)
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Character
name|character
parameter_list|)
block|{
return|return
name|matches
argument_list|(
name|character
argument_list|)
return|;
block|}
block|}
end_class

end_unit

