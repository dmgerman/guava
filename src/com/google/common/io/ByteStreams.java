begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.io
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_comment
comment|/**  * Provides utility methods for working with byte arrays and I/O streams.  *  *<p>All method parameters must be non-null unless documented otherwise.  *  * @author Chris Nokleberg  * @since Guava release 01  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|ByteStreams
specifier|public
specifier|final
class|class
name|ByteStreams
block|{
DECL|field|BUF_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUF_SIZE
init|=
literal|0x1000
decl_stmt|;
comment|// 4K
DECL|method|ByteStreams ()
specifier|private
name|ByteStreams
parameter_list|()
block|{}
comment|/**    * Returns a factory that will supply instances of    * {@link ByteArrayInputStream} that read from the given byte array.    *    * @param b the input buffer    * @return the factory    */
DECL|method|newInputStreamSupplier ( byte[] b)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|ByteArrayInputStream
argument_list|>
name|newInputStreamSupplier
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|newInputStreamSupplier
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Returns a factory that will supply instances of    * {@link ByteArrayInputStream} that read from the given byte array.    *    * @param b the input buffer    * @param off the offset in the buffer of the first byte to read    * @param len the maximum number of bytes to read from the buffer    * @return the factory    */
DECL|method|newInputStreamSupplier ( final byte[] b, final int off, final int len)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|ByteArrayInputStream
argument_list|>
name|newInputStreamSupplier
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
block|{
return|return
operator|new
name|InputSupplier
argument_list|<
name|ByteArrayInputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ByteArrayInputStream
name|getInput
parameter_list|()
block|{
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Writes a byte array to an output stream from the given supplier.    *    * @param from the bytes to write    * @param to the output supplier    * @throws IOException if an I/O error occurs    */
DECL|method|write (byte[] from, OutputSupplier<? extends OutputStream> to)
specifier|public
specifier|static
name|void
name|write
parameter_list|(
name|byte
index|[]
name|from
parameter_list|,
name|OutputSupplier
argument_list|<
name|?
extends|extends
name|OutputStream
argument_list|>
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|OutputStream
name|out
init|=
name|to
operator|.
name|getOutput
argument_list|()
decl_stmt|;
try|try
block|{
name|out
operator|.
name|write
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|out
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Opens input and output streams from the given suppliers, copies all    * bytes from the input to the output, and closes the streams.    *    * @param from the input factory    * @param to the output factory    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (InputSupplier<? extends InputStream> from, OutputSupplier<? extends OutputStream> to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|from
parameter_list|,
name|OutputSupplier
argument_list|<
name|?
extends|extends
name|OutputStream
argument_list|>
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
name|from
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
name|OutputStream
name|out
init|=
name|to
operator|.
name|getOutput
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|count
init|=
name|copy
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|count
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|out
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Opens an input stream from the supplier, copies all bytes from the    * input to the output, and closes the input stream. Does not close    * or flush the output stream.    *    * @param from the input factory    * @param to the output stream to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (InputSupplier<? extends InputStream> from, OutputStream to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
name|from
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|count
init|=
name|copy
argument_list|(
name|in
argument_list|,
name|to
argument_list|)
decl_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|count
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Copies all bytes from the input stream to the output stream.    * Does not close or flush either stream.    *    * @param from the input stream to read from    * @param to the output stream to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (InputStream from, OutputStream to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|InputStream
name|from
parameter_list|,
name|OutputStream
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|r
init|=
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|total
operator|+=
name|r
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Copies all bytes from the readable channel to the writable channel.    * Does not close or flush either channel.    *    * @param from the readable channel to read from    * @param to the writable channel to write to    * @return the number of bytes copied    * @throws IOException if an I/O error occurs    */
DECL|method|copy (ReadableByteChannel from, WritableByteChannel to)
specifier|public
specifier|static
name|long
name|copy
parameter_list|(
name|ReadableByteChannel
name|from
parameter_list|,
name|WritableByteChannel
name|to
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|BUF_SIZE
argument_list|)
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|from
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|total
operator|+=
name|to
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Reads all bytes from an input stream into a byte array.    * Does not close the stream.    *    * @param in the input stream to read from    * @return a byte array containing all the bytes from the stream    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray (InputStream in)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|copy
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Returns the data from a {@link InputStream} factory as a byte array.    *    * @param supplier the factory    * @throws IOException if an I/O error occurs    */
DECL|method|toByteArray ( InputSupplier<? extends InputStream> supplier)
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
name|supplier
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|result
init|=
name|toByteArray
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code    * bytes} array from the beginning.    */
DECL|method|newDataInput (byte[] bytes)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
operator|new
name|ByteArrayDataInputStream
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataInput} instance to read from the {@code    * bytes} array, starting at the given position.    *    * @throws IndexOutOfBoundsException if {@code start} is negative or greater    *     than the length of the array    */
DECL|method|newDataInput (byte[] bytes, int start)
specifier|public
specifier|static
name|ByteArrayDataInput
name|newDataInput
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkPositionIndex
argument_list|(
name|start
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|ByteArrayDataInputStream
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|)
return|;
block|}
DECL|class|ByteArrayDataInputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataInputStream
implements|implements
name|ByteArrayDataInput
block|{
DECL|field|input
specifier|final
name|DataInput
name|input
decl_stmt|;
DECL|method|ByteArrayDataInputStream (byte[] bytes)
name|ByteArrayDataInputStream
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|ByteArrayDataInputStream (byte[] bytes, int start)
name|ByteArrayDataInputStream
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|readFully (byte b[])
annotation|@
name|Override
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readFully (byte b[], int off, int len)
annotation|@
name|Override
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|input
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|skipBytes (int n)
annotation|@
name|Override
specifier|public
name|int
name|skipBytes
parameter_list|(
name|int
name|n
parameter_list|)
block|{
try|try
block|{
return|return
name|input
operator|.
name|skipBytes
argument_list|(
name|n
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readBoolean ()
annotation|@
name|Override
specifier|public
name|boolean
name|readBoolean
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readBoolean
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readByte ()
annotation|@
name|Override
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|readUnsignedByte ()
annotation|@
name|Override
specifier|public
name|int
name|readUnsignedByte
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedByte
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readShort ()
annotation|@
name|Override
specifier|public
name|short
name|readShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readUnsignedShort ()
annotation|@
name|Override
specifier|public
name|int
name|readUnsignedShort
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUnsignedShort
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readChar ()
annotation|@
name|Override
specifier|public
name|char
name|readChar
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readChar
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readInt ()
annotation|@
name|Override
specifier|public
name|int
name|readInt
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readInt
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readLong ()
annotation|@
name|Override
specifier|public
name|long
name|readLong
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLong
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readFloat ()
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readFloat
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readDouble ()
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readDouble
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readLine ()
annotation|@
name|Override
specifier|public
name|String
name|readLine
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readLine
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|readUTF ()
annotation|@
name|Override
specifier|public
name|String
name|readUTF
parameter_list|()
block|{
try|try
block|{
return|return
name|input
operator|.
name|readUTF
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance with a default size.    */
DECL|method|newDataOutput ()
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|()
block|{
return|return
operator|new
name|ByteArrayDataOutputStream
argument_list|()
return|;
block|}
comment|/**    * Returns a new {@link ByteArrayDataOutput} instance sized to hold    * {@code size} bytes before resizing.    *    * @throws IllegalArgumentException if {@code size} is negative    */
DECL|method|newDataOutput (int size)
specifier|public
specifier|static
name|ByteArrayDataOutput
name|newDataOutput
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|size
operator|>=
literal|0
argument_list|,
literal|"Invalid size: %s"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|new
name|ByteArrayDataOutputStream
argument_list|(
name|size
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// for writeBytes
DECL|class|ByteArrayDataOutputStream
specifier|private
specifier|static
class|class
name|ByteArrayDataOutputStream
implements|implements
name|ByteArrayDataOutput
block|{
DECL|field|output
specifier|final
name|DataOutput
name|output
decl_stmt|;
DECL|field|byteArrayOutputSteam
specifier|final
name|ByteArrayOutputStream
name|byteArrayOutputSteam
decl_stmt|;
DECL|method|ByteArrayDataOutputStream ()
name|ByteArrayDataOutputStream
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|ByteArrayDataOutputStream (int size)
name|ByteArrayDataOutputStream
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|ByteArrayDataOutputStream (ByteArrayOutputStream byteArrayOutputSteam)
name|ByteArrayDataOutputStream
parameter_list|(
name|ByteArrayOutputStream
name|byteArrayOutputSteam
parameter_list|)
block|{
name|this
operator|.
name|byteArrayOutputSteam
operator|=
name|byteArrayOutputSteam
expr_stmt|;
name|output
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|byteArrayOutputSteam
argument_list|)
expr_stmt|;
block|}
DECL|method|write (int b)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|write (byte[] b)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|write (byte[] b, int off, int len)
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBoolean (boolean v)
annotation|@
name|Override
specifier|public
name|void
name|writeBoolean
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBoolean
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeByte (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeByte
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBytes (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeBytes
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeChar (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeChar
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChar
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeChars (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeChars
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeChars
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeDouble (double v)
annotation|@
name|Override
specifier|public
name|void
name|writeDouble
parameter_list|(
name|double
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeDouble
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeFloat (float v)
annotation|@
name|Override
specifier|public
name|void
name|writeFloat
parameter_list|(
name|float
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeFloat
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeInt (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeLong (long v)
annotation|@
name|Override
specifier|public
name|void
name|writeLong
parameter_list|(
name|long
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeLong
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeShort (int v)
annotation|@
name|Override
specifier|public
name|void
name|writeShort
parameter_list|(
name|int
name|v
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeShort
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|writeUTF (String s)
annotation|@
name|Override
specifier|public
name|void
name|writeUTF
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
name|output
operator|.
name|writeUTF
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|impossible
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|impossible
argument_list|)
throw|;
block|}
block|}
DECL|method|toByteArray ()
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|byteArrayOutputSteam
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
comment|// TODO(chrisn): Not all streams support skipping.
comment|/** Returns the length of a supplied input stream, in bytes. */
DECL|method|length (InputSupplier<? extends InputStream> supplier)
specifier|public
specifier|static
name|long
name|length
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
name|supplier
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// We skip only Integer.MAX_VALUE due to JDK overflow bugs.
name|long
name|amt
init|=
name|in
operator|.
name|skip
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|count
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|count
operator|+=
name|amt
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns true if the supplied input streams contain the same bytes.    *    * @throws IOException if an I/O error occurs    */
DECL|method|equal (InputSupplier<? extends InputStream> supplier1, InputSupplier<? extends InputStream> supplier2)
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier1
parameter_list|,
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier2
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf1
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|byte
index|[]
name|buf2
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in1
init|=
name|supplier1
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
name|InputStream
name|in2
init|=
name|supplier2
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|read1
init|=
name|read
argument_list|(
name|in1
argument_list|,
name|buf1
argument_list|,
literal|0
argument_list|,
name|BUF_SIZE
argument_list|)
decl_stmt|;
name|int
name|read2
init|=
name|read
argument_list|(
name|in2
argument_list|,
name|buf2
argument_list|,
literal|0
argument_list|,
name|BUF_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|read1
operator|!=
name|read2
operator|||
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|threw
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|read1
operator|!=
name|BUF_SIZE
condition|)
block|{
name|threw
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in2
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in1
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Attempts to read enough bytes from the stream to fill the given byte array,    * with the same behavior as {@link DataInput#readFully(byte[])}.    * Does not close the stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @throws EOFException if this stream reaches the end before reading all    *     the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully (InputStream in, byte[] b)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempts to read {@code len} bytes from the stream into the given array    * starting at {@code off}, with the same behavior as    * {@link DataInput#readFully(byte[], int, int)}. Does not close the    * stream.    *    * @param in the input stream to read from.    * @param b the buffer into which the data is read.    * @param off an int specifying the offset into the data.    * @param len an int specifying the number of bytes to read.    * @throws EOFException if this stream reaches the end before reading all    *     the bytes.    * @throws IOException if an I/O error occurs.    */
DECL|method|readFully (InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|read
argument_list|(
name|in
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Discards {@code n} bytes of data from the input stream. This method    * will block until the full amount has been skipped. Does not close the    * stream.    *    * @param in the input stream to read from    * @param n the number of bytes to skip    * @throws EOFException if this stream reaches the end before skipping all    *     the bytes    * @throws IOException if an I/O error occurs, or the stream does not    *     support skipping    */
DECL|method|skipFully (InputStream in, long n)
specifier|public
specifier|static
name|void
name|skipFully
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|long
name|amt
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|==
literal|0
condition|)
block|{
comment|// Force a blocking read to avoid infinite loop
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
name|n
operator|--
expr_stmt|;
block|}
else|else
block|{
name|n
operator|-=
name|amt
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Process the bytes of a supplied stream    *    * @param supplier the input stream factory    * @param processor the object to which to pass the bytes of the stream    * @return the result of the byte processor    * @throws IOException if an I/O error occurs    */
DECL|method|readBytes (InputSupplier<? extends InputStream> supplier, ByteProcessor<T> processor)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|readBytes
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|,
name|ByteProcessor
argument_list|<
name|T
argument_list|>
name|processor
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
name|InputStream
name|in
init|=
name|supplier
operator|.
name|getInput
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|amt
decl_stmt|;
do|do
block|{
name|amt
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt
operator|==
operator|-
literal|1
condition|)
block|{
name|threw
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|processor
operator|.
name|processBytes
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
condition|)
do|;
return|return
name|processor
operator|.
name|getResult
argument_list|()
return|;
block|}
finally|finally
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|in
argument_list|,
name|threw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Computes and returns the checksum value for a supplied input stream.    * The checksum object is reset when this method returns successfully.    *    * @param supplier the input stream factory    * @param checksum the checksum object    * @return the result of {@link Checksum#getValue} after updating the    *     checksum object with all of the bytes in the stream    * @throws IOException if an I/O error occurs    */
DECL|method|getChecksum (InputSupplier<? extends InputStream> supplier, final Checksum checksum)
specifier|public
specifier|static
name|long
name|getChecksum
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|,
specifier|final
name|Checksum
name|checksum
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readBytes
argument_list|(
name|supplier
argument_list|,
operator|new
name|ByteProcessor
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processBytes
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|checksum
operator|.
name|update
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Long
name|getResult
parameter_list|()
block|{
name|long
name|result
init|=
name|checksum
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|checksum
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Computes and returns the digest value for a supplied input stream.    * The digest object is reset when this method returns successfully.    *    * @param supplier the input stream factory    * @param md the digest object    * @return the result of {@link MessageDigest#digest()} after updating the    *     digest object with all of the bytes in the stream    * @throws IOException if an I/O error occurs    */
DECL|method|getDigest (InputSupplier<? extends InputStream> supplier, final MessageDigest md)
specifier|public
specifier|static
name|byte
index|[]
name|getDigest
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|,
specifier|final
name|MessageDigest
name|md
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readBytes
argument_list|(
name|supplier
argument_list|,
operator|new
name|ByteProcessor
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processBytes
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|md
operator|.
name|update
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getResult
parameter_list|()
block|{
return|return
name|md
operator|.
name|digest
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Reads some bytes from an input stream and stores them into the buffer array    * {@code b}. This method blocks until {@code len} bytes of input data have    * been read into the array, or end of file is detected. The number of bytes    * read is returned, possibly zero. Does not close the stream.    *    *<p>A caller can detect EOF if the number of bytes read is less than    * {@code len}. All subsequent calls on the same stream will return zero.    *    *<p>If {@code b} is null, a {@code NullPointerException} is thrown. If    * {@code off} is negative, or {@code len} is negative, or {@code off+len} is    * greater than the length of the array {@code b}, then an    * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then    * no bytes are read. Otherwise, the first byte read is stored into element    * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number    * of bytes read is, at most, equal to {@code len}.    *    * @param in the input stream to read from    * @param b the buffer into which the data is read    * @param off an int specifying the offset into the data    * @param len an int specifying the number of bytes to read    * @return the number of bytes read    * @throws IOException if an I/O error occurs    */
DECL|method|read (InputStream in, byte[] b, int off, int len)
specifier|public
specifier|static
name|int
name|read
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len is negative"
argument_list|)
throw|;
block|}
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|total
argument_list|,
name|len
operator|-
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|total
operator|+=
name|result
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Returns an {@link InputSupplier} that returns input streams from the    * an underlying supplier, where each stream starts at the given    * offset and is limited to the specified number of bytes.    *    * @param supplier the supplier from which to get the raw streams    * @param offset the offset in bytes into the underlying stream where    *     the returned streams will start    * @param length the maximum length of the returned streams    * @throws IllegalArgumentException if offset or length are negative    */
DECL|method|slice ( final InputSupplier<? extends InputStream> supplier, final long offset, final long length)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|InputStream
argument_list|>
name|slice
parameter_list|(
specifier|final
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
name|supplier
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|supplier
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|>=
literal|0
argument_list|,
literal|"offset is negative"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|,
literal|"length is negative"
argument_list|)
expr_stmt|;
return|return
operator|new
name|InputSupplier
argument_list|<
name|InputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|InputStream
name|getInput
parameter_list|()
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
name|supplier
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|skipFully
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|Closeables
operator|.
name|closeQuietly
argument_list|(
name|in
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
operator|new
name|LimitInputStream
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Joins multiple {@link InputStream} suppliers into a single supplier.    * Streams returned from the supplier will contain the concatenated data from    * the streams of the underlying suppliers.    *    *<p>Only one underlying input stream will be open at a time. Closing the    * joined stream will close the open underlying stream.    *    *<p>Reading from the joined stream will throw a {@link NullPointerException}    * if any of the suppliers are null or return null.    *    * @param suppliers the suppliers to concatenate    * @return a supplier that will return a stream containing the concatenated    *     stream data    */
DECL|method|join ( final Iterable<? extends InputSupplier<? extends InputStream>> suppliers)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|InputStream
argument_list|>
name|join
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
argument_list|>
name|suppliers
parameter_list|)
block|{
return|return
operator|new
name|InputSupplier
argument_list|<
name|InputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|InputStream
name|getInput
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|MultiInputStream
argument_list|(
name|suppliers
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Varargs form of {@link #join(Iterable)}. */
DECL|method|join ( InputSupplier<? extends InputStream>.... suppliers)
specifier|public
specifier|static
name|InputSupplier
argument_list|<
name|InputStream
argument_list|>
name|join
parameter_list|(
name|InputSupplier
argument_list|<
name|?
extends|extends
name|InputStream
argument_list|>
modifier|...
name|suppliers
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|suppliers
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

