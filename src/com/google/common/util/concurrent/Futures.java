begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to the {@link Future} interface.  *  * @author Kevin Bourrillion  * @author Nishant Thakkar  * @author Sven Mawson  * @since 1  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|Futures
specifier|public
specifier|final
class|class
name|Futures
block|{
DECL|method|Futures ()
specifier|private
name|Futures
parameter_list|()
block|{}
comment|/**    * Returns an uninterruptible view of a {@code Future}. If a thread is    * interrupted during an attempt to {@code get()} from the returned future, it    * continues to wait on the result until it is available or the timeout    * elapses, and only then re-interrupts the thread.    */
DECL|method|makeUninterruptible ( final Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
name|makeUninterruptible
parameter_list|(
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|UninterruptibleFuture
condition|)
block|{
return|return
operator|(
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeoutDuration
parameter_list|,
name|TimeUnit
name|timeoutUnit
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|ExecutionException
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|long
name|timeoutNanos
init|=
name|timeoutUnit
operator|.
name|toNanos
argument_list|(
name|timeoutDuration
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|timeoutNanos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|(
name|timeoutNanos
argument_list|,
name|NANOSECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Future treats negative timeouts just like zero.
name|timeoutNanos
operator|=
name|end
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|ExecutionException
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
comment|/**    * Creates a {@link ListenableFuture} out of a normal {@link Future}. The    * returned future will create a thread to wait for the source future to    * complete before executing the listeners.    *    *<p>Callers who have a future that subclasses    * {@link java.util.concurrent.FutureTask} may want to instead subclass    * {@link ListenableFutureTask}, which adds the {@link ListenableFuture}    * functionality to the standard {@code FutureTask} implementation.    */
DECL|method|makeListenable (Future<T> future)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ListenableFuture
argument_list|<
name|T
argument_list|>
name|makeListenable
parameter_list|(
name|Future
argument_list|<
name|T
argument_list|>
name|future
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
condition|)
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|T
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|ListenableFutureAdapter
argument_list|<
name|T
argument_list|>
argument_list|(
name|future
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link CheckedFuture} out of a normal {@link Future} and a    * {@link Function} that maps from {@link Exception} instances into the    * appropriate checked type.    *    *<p>The given mapping function will be applied to an    * {@link InterruptedException}, a {@link CancellationException}, or an    * {@link ExecutionException} with the actual cause of the exception.    * See {@link Future#get()} for details on the exceptions thrown.    */
DECL|method|makeChecked ( Future<T> future, Function<Exception, E> mapper)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|T
argument_list|,
name|E
argument_list|>
name|makeChecked
parameter_list|(
name|Future
argument_list|<
name|T
argument_list|>
name|future
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|E
argument_list|>
name|mapper
parameter_list|)
block|{
return|return
operator|new
name|MappingCheckedFuture
argument_list|<
name|T
argument_list|,
name|E
argument_list|>
argument_list|(
name|makeListenable
argument_list|(
name|future
argument_list|)
argument_list|,
name|mapper
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code ListenableFuture} which has its value set immediately upon    * construction. The getters just return the value. This {@code Future} can't    * be canceled or timed out and its {@code isDone()} method always returns    * {@code true}. It's useful for returning something that implements the    * {@code ListenableFuture} interface but already has the result.    */
DECL|method|immediateFuture (@ullable T value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ListenableFuture
argument_list|<
name|T
argument_list|>
name|immediateFuture
parameter_list|(
annotation|@
name|Nullable
name|T
name|value
parameter_list|)
block|{
name|ValueFuture
argument_list|<
name|T
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Creates a {@code CheckedFuture} which has its value set immediately upon    * construction. The getters just return the value. This {@code Future} can't    * be canceled or timed out and its {@code isDone()} method always returns    * {@code true}. It's useful for returning something that implements the    * {@code CheckedFuture} interface but already has the result.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|T
argument_list|,
name|E
argument_list|>
DECL|method|immediateCheckedFuture (@ullable T value)
name|immediateCheckedFuture
parameter_list|(
annotation|@
name|Nullable
name|T
name|value
parameter_list|)
block|{
name|ValueFuture
argument_list|<
name|T
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|Futures
operator|.
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|E
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"impossible"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code ListenableFuture} which has an exception set immediately    * upon construction. The getters just return the value. This {@code Future}    * can't be canceled or timed out and its {@code isDone()} method always    * returns {@code true}. It's useful for returning something that implements    * the {@code ListenableFuture} interface but already has a failed    * result. Calling {@code get()} will throw the provided {@code Throwable}    * (wrapped in an {@code ExecutionException}).    *    * @throws Error if the throwable was an {@link Error}.    */
DECL|method|immediateFailedFuture ( Throwable throwable)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ListenableFuture
argument_list|<
name|T
argument_list|>
name|immediateFailedFuture
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
name|ValueFuture
argument_list|<
name|T
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Creates a {@code CheckedFuture} which has an exception set immediately    * upon construction. The getters just return the value. This {@code Future}    * can't be canceled or timed out and its {@code isDone()} method always    * returns {@code true}. It's useful for returning something that implements    * the {@code CheckedFuture} interface but already has a failed result.    * Calling {@code get()} will throw the provided {@code Throwable} (wrapped in    * an {@code ExecutionException}) and calling {@code checkedGet()} will throw    * the provided exception itself.    *    * @throws Error if the throwable was an {@link Error}.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|T
argument_list|,
name|E
argument_list|>
DECL|method|immediateFailedCheckedFuture (final E exception)
name|immediateFailedCheckedFuture
parameter_list|(
specifier|final
name|E
name|exception
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return
name|makeChecked
argument_list|(
name|Futures
operator|.
expr|<
name|T
operator|>
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|E
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|exception
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} that wraps another    * {@code ListenableFuture}.  The result of the new future is the result of    * the provided function called on the result of the provided future.    * The resulting future doesn't interrupt when aborted.    *    *<p>TODO: Add a version that accepts a normal {@code Future}    *    *<p>The typical use for this method would be when a RPC call is dependent on    * the results of another RPC.  One would call the first RPC (input), create a    * function that calls another RPC based on input's result, and then call    * chain on input and that function to get a {@code ListenableFuture} of    * the result.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|chain
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} that wraps another    * {@code ListenableFuture}.  The result of the new future is the result of    * the provided function called on the result of the provided future.    * The resulting future doesn't interrupt when aborted.    *    *<p>This version allows an arbitrary executor to be passed in for running    * the chained Function. When using {@link MoreExecutors#sameThreadExecutor},    * the thread chained Function executes in will be whichever thread set the    * result of the input Future, which may be the network thread in the case of    * RPC-based Futures.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|chain
init|=
operator|new
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|function
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|chain
argument_list|,
name|exec
argument_list|)
expr_stmt|;
return|return
name|chain
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} that wraps another    * {@code ListenableFuture}.  The result of the new future is the result of    * the provided function called on the result of the provided future.    * The resulting future doesn't interrupt when aborted.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the composition.    */
DECL|method|compose (ListenableFuture<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|future
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code ListenableFuture} that wraps another    * {@code ListenableFuture}.  The result of the new future is the result of    * the provided function called on the result of the provided future.    * The resulting future doesn't interrupt when aborted.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    *<p>This version allows an arbitrary executor to be passed in for running    * the chained Function. When using {@link MoreExecutors#sameThreadExecutor},    * the thread chained Function executes in will be whichever thread set the    * result of the input Future, which may be the network thread in the case of    * RPC-based Futures.    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the composition.    * @since 2    */
DECL|method|compose (ListenableFuture<I> future, final Function<? super I, ? extends O> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
name|wrapperFunction
init|=
operator|new
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|apply
parameter_list|(
name|I
name|input
parameter_list|)
block|{
name|O
name|output
init|=
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|immediateFuture
argument_list|(
name|output
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|chain
argument_list|(
name|future
argument_list|,
name|wrapperFunction
argument_list|,
name|exec
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@code Future} that wraps another {@code Future}.    * The result of the new future is the result of the provided function called    * on the result of the provided future.    *    *<p>An example use of this method is to convert a Future that produces a    * handle to an object to a future that produces the object itself.    *    *<p>Each call to {@code Future<O>.get(*)} results in a call to    * {@code Future<I>.get(*)}, but {@code function} is only applied once, so it    * is assumed that {@code Future<I>.get(*)} is idempotent.    *    *<p>When calling {@link Future#get(long, TimeUnit)} on the returned    * future, the timeout only applies to the future passed in to this method.    * Any additional time taken by applying {@code function} is not considered.    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that calls one of the varieties of {@code get()}.    * @return A future that computes result of the composition.    */
DECL|method|compose (final Future<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|Future
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
specifier|final
name|Future
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|Future
argument_list|<
name|O
argument_list|>
argument_list|()
block|{
comment|/*        * Concurrency detail:        *        *<p>To preserve the idempotency of calls to this.get(*) calls to the        * function are only applied once. A lock is required to prevent multiple        * applications of the function. The calls to future.get(*) are performed        * outside the lock, as is required to prevent calls to        * get(long, TimeUnit) to persist beyond their timeout.        *        *<p>Calls to future.get(*) on every call to this.get(*) also provide        * the cancellation behavior for this.        *        *<p>(Consider: in thread A, call get(), in thread B call get(long,        * TimeUnit). Thread B may have to wait for Thread A to finish, which        * would be unacceptable.)        *        *<p>Note that each call to Future<O>.get(*) results in a call to        * Future<I>.get(*), but the function is only applied once, so        * Future<I>.get(*) is assumed to be idempotent.        */
specifier|private
specifier|final
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|set
init|=
literal|false
decl_stmt|;
specifier|private
name|O
name|value
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|O
name|apply
parameter_list|(
name|I
name|raw
parameter_list|)
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|value
operator|=
name|function
operator|.
name|apply
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|set
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * An implementation of {@code ListenableFuture} that also implements    * {@code Runnable} so that it can be used to nest ListenableFutures.    * Once the passed-in {@code ListenableFuture} is complete, it calls the    * passed-in {@code Function} to generate the result.    * The resulting future doesn't interrupt when aborted.    *    *<p>If the function throws any checked exceptions, they should be wrapped    * in a {@code UndeclaredThrowableException} so that this class can get    * access to the cause.    */
DECL|class|ChainingListenableFuture
specifier|private
specifier|static
class|class
name|ChainingListenableFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
extends|extends
name|AbstractListenableFuture
argument_list|<
name|O
argument_list|>
implements|implements
name|Runnable
block|{
specifier|private
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
DECL|field|function
name|function
decl_stmt|;
DECL|field|inputFuture
specifier|private
name|UninterruptibleFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
decl_stmt|;
DECL|method|ChainingListenableFuture ( Function<? super I, ? extends ListenableFuture<? extends O>> function, ListenableFuture<? extends I> inputFuture)
specifier|private
name|ChainingListenableFuture
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputFuture
operator|=
name|makeUninterruptible
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
block|}
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|Future
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|future
init|=
name|inputFuture
decl_stmt|;
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|I
name|sourceResult
decl_stmt|;
try|try
block|{
name|sourceResult
operator|=
name|inputFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
name|cancel
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|function
operator|.
name|apply
argument_list|(
name|sourceResult
argument_list|)
decl_stmt|;
name|outputFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Here it would have been nice to have had an
comment|// UninterruptibleListenableFuture, but we don't want to start a
comment|// combinatorial explosion of interfaces, so we have to make do.
name|set
argument_list|(
name|makeUninterruptible
argument_list|(
name|outputFuture
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// This exception is irrelevant in this thread, but useful for the
comment|// client
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
comment|// This seems evil, but the client needs to know an error occured and
comment|// the error needs to be propagated ASAP.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
comment|// Don't pin inputs beyond completion
name|function
operator|=
literal|null
expr_stmt|;
name|inputFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A checked future that uses a function to map from exceptions to the    * appropriate checked type.    */
DECL|class|MappingCheckedFuture
specifier|private
specifier|static
class|class
name|MappingCheckedFuture
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Exception
parameter_list|>
extends|extends
name|AbstractCheckedFuture
argument_list|<
name|T
argument_list|,
name|E
argument_list|>
block|{
DECL|field|mapper
specifier|final
name|Function
argument_list|<
name|Exception
argument_list|,
name|E
argument_list|>
name|mapper
decl_stmt|;
DECL|method|MappingCheckedFuture (ListenableFuture<T> delegate, Function<Exception, E> mapper)
name|MappingCheckedFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|T
argument_list|>
name|delegate
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|E
argument_list|>
name|mapper
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapper
operator|=
name|checkNotNull
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mapException (Exception e)
specifier|protected
name|E
name|mapException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|mapper
operator|.
name|apply
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
comment|/**    * An adapter to turn a {@link Future} into a {@link ListenableFuture}.  This    * will wait on the future to finish, and when it completes, run the    * listeners.  This implementation will wait on the source future    * indefinitely, so if the source future never completes, the adapter will    * never complete either.    *    *<p>If the delegate future is interrupted or throws an unexpected unchecked    * exception, the listeners will not be invoked.    */
DECL|class|ListenableFutureAdapter
specifier|private
specifier|static
class|class
name|ListenableFutureAdapter
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForwardingFuture
argument_list|<
name|T
argument_list|>
implements|implements
name|ListenableFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|adapterExecutor
specifier|private
specifier|static
specifier|final
name|Executor
name|adapterExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|()
decl_stmt|;
comment|// The execution list to hold our listeners.
DECL|field|executionList
specifier|private
specifier|final
name|ExecutionList
name|executionList
init|=
operator|new
name|ExecutionList
argument_list|()
decl_stmt|;
comment|// This allows us to only start up a thread waiting on the delegate future
comment|// when the first listener is added.
DECL|field|hasListeners
specifier|private
specifier|final
name|AtomicBoolean
name|hasListeners
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// The delegate future.
DECL|field|delegate
specifier|private
specifier|final
name|Future
argument_list|<
name|T
argument_list|>
name|delegate
decl_stmt|;
DECL|method|ListenableFutureAdapter (final Future<T> delegate)
name|ListenableFutureAdapter
parameter_list|(
specifier|final
name|Future
argument_list|<
name|T
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Future
argument_list|<
name|T
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor exec)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
comment|// When a listener is first added, we run a task that will wait for
comment|// the delegate to finish, and when it is done will run the listeners.
if|if
condition|(
operator|!
name|hasListeners
operator|.
name|get
argument_list|()
operator|&&
name|hasListeners
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|adapterExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delegate
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// The task was cancelled, so it is done, run the listeners.
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// This thread was interrupted.  This should never happen, so we
comment|// throw an IllegalStateException.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Adapter thread interrupted!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// The task caused an exception, so it is done, run the listeners.
block|}
name|executionList
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|executionList
operator|.
name|add
argument_list|(
name|listener
argument_list|,
name|exec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

