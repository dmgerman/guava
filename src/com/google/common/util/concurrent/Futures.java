begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|Beta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Static utility methods pertaining to the {@link Future} interface.  *  * @author Kevin Bourrillion  * @author Nishant Thakkar  * @author Sven Mawson  * @since 1  */
end_comment

begin_class
annotation|@
name|Beta
DECL|class|Futures
specifier|public
specifier|final
class|class
name|Futures
block|{
DECL|method|Futures ()
specifier|private
name|Futures
parameter_list|()
block|{}
comment|/**    * Returns an uninterruptible view of a {@code Future}. If a thread is    * interrupted during an attempt to {@code get()} from the returned future, it    * continues to wait on the result until it is available or the timeout    * elapses, and only then re-interrupts the thread.    */
DECL|method|makeUninterruptible ( final Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
name|makeUninterruptible
parameter_list|(
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|UninterruptibleFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|UninterruptibleFuture
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
specifier|public
name|V
name|get
parameter_list|(
name|long
name|timeoutDuration
parameter_list|,
name|TimeUnit
name|timeoutUnit
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|ExecutionException
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|long
name|timeoutNanos
init|=
name|timeoutUnit
operator|.
name|toNanos
argument_list|(
name|timeoutDuration
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|timeoutNanos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|(
name|timeoutNanos
argument_list|,
name|NANOSECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Future treats negative timeouts just like zero.
name|timeoutNanos
operator|=
name|end
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|V
name|get
parameter_list|()
throws|throws
name|ExecutionException
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
comment|/**    * Creates a {@link ListenableFuture} out of a normal {@link Future}. The    * returned future will create a thread to wait for the source future to    * complete before executing the listeners.    *    *<p>Callers who have a future that subclasses    * {@link java.util.concurrent.FutureTask} may want to instead subclass    * {@link ListenableFutureTask}, which adds the {@link ListenableFuture}    * functionality to the standard {@code FutureTask} implementation.    */
DECL|method|makeListenable (Future<V> future)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|makeListenable
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|ListenableFutureAdapter
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link ListenableFuture} out of a normal {@link Future} and uses    * the given {@link Executor} to get the value of the Future. The    * returned future will create a thread using the given executor to wait for    * the source future to complete before executing the listeners.    *    *<p>Callers who have a future that subclasses    * {@link java.util.concurrent.FutureTask} may want to instead subclass    * {@link ListenableFutureTask}, which adds the {@link ListenableFuture}    * functionality to the standard {@code FutureTask} implementation.    */
DECL|method|makeListenable ( Future<V> future, Executor executor)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|makeListenable
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
operator|)
name|future
return|;
block|}
return|return
operator|new
name|ListenableFutureAdapter
argument_list|<
name|V
argument_list|>
argument_list|(
name|future
argument_list|,
name|executor
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link CheckedFuture} out of a normal {@link Future} and a    * {@link Function} that maps from {@link Exception} instances into the    * appropriate checked type.    *    *<p>The given mapping function will be applied to an    * {@link InterruptedException}, a {@link CancellationException}, or an    * {@link ExecutionException} with the actual cause of the exception.    * See {@link Future#get()} for details on the exceptions thrown.    */
DECL|method|makeChecked ( Future<V> future, Function<Exception, X> mapper)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
name|makeChecked
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|future
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
parameter_list|)
block|{
return|return
operator|new
name|MappingCheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
argument_list|(
name|makeListenable
argument_list|(
name|future
argument_list|)
argument_list|,
name|mapper
argument_list|)
return|;
block|}
comment|/**    * Creates a {@code ListenableFuture} which has its value set immediately upon    * construction. The getters just return the value. This {@code Future} can't    * be canceled or timed out and its {@code isDone()} method always returns    * {@code true}. It's useful for returning something that implements the    * {@code ListenableFuture} interface but already has the result.    */
DECL|method|immediateFuture (@ullable V value)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|ValueFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Returns a {@code CheckedFuture} which has its value set immediately upon    * construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} or {@code    * checkedGet()} will immediately return the provided value.    */
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
DECL|method|immediateCheckedFuture (@ullable V value)
name|immediateCheckedFuture
parameter_list|(
annotation|@
name|Nullable
name|V
name|value
parameter_list|)
block|{
name|ValueFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|Futures
operator|.
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
argument_list|()
block|{
specifier|public
name|X
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"impossible"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns a {@code ListenableFuture} which has an exception set immediately    * upon construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} will immediately    * throw the provided {@code Throwable} wrapped in an {@code    * ExecutionException}.    *    * @throws Error if the throwable is an {@link Error}.    */
DECL|method|immediateFailedFuture ( Throwable throwable)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|immediateFailedFuture
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
name|ValueFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|ValueFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
comment|/**    * Returns a {@code CheckedFuture} which has an exception set immediately upon    * construction.    *    *<p>The returned {@code Future} can't be cancelled, and its {@code isDone()}    * method always returns {@code true}. Calling {@code get()} will immediately    * throw the provided {@code Throwable} wrapped in an {@code    * ExecutionException}, and calling {@code checkedGet()} will throw the    * provided exception itself.    *    * @throws Error if the throwable is an {@link Error}.    */
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
name|CheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
DECL|method|immediateFailedCheckedFuture (final X exception)
name|immediateFailedCheckedFuture
parameter_list|(
specifier|final
name|X
name|exception
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return
name|makeChecked
argument_list|(
name|Futures
operator|.
expr|<
name|V
operator|>
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
argument_list|()
block|{
specifier|public
name|X
name|apply
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|exception
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code Function} to the result of the original {@code    * Future}.    *    *<p>Successful cancellation of either the input future or the result of    * function application will cause the returned future to be cancelled.    * Cancelling the returned future will succeed if it is currently running.    * In this case, attempts will be made to cancel the input future and the    * result of the function, however there is no guarantee of success.    *    *<p>TODO: Add a version that accepts a normal {@code Future}    *    *<p>The typical use for this method would be when a RPC call is dependent on    * the results of another RPC.  One would call the first RPC (input), create a    * function that calls another RPC based on input's result, and then call    * chain on input and that function to get a {@code ListenableFuture} of    * the result.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|chain
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is asynchronously    * derived from the result of the given {@code Future}. More precisely, the    * returned {@code Future} takes its result from a {@code Future} produced by    * applying the given {@code Function} to the result of the original {@code    * Future}.    *    *<p>Successful cancellation of either the input future or the result of    * function application will cause the returned future to be cancelled.    * Cancelling the returned future will succeed if it is currently running.    * In this case, attempts will be made to cancel the input future and the    * result of the function, however there is no guarantee of success.    *    *<p>This version allows an arbitrary executor to be passed in for running    * the chained Function. When using {@link MoreExecutors#sameThreadExecutor},    * the thread chained Function executes in will be whichever thread set the    * result of the input Future, which may be the network thread in the case of    * RPC-based Futures.    *    * @param input The future to chain    * @param function A function to chain the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the chain.    */
DECL|method|chain (ListenableFuture<I> input, Function<? super I, ? extends ListenableFuture<? extends O>> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|chain
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|input
parameter_list|,
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|chain
init|=
operator|new
name|ChainingListenableFuture
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|function
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|input
operator|.
name|addListener
argument_list|(
name|chain
argument_list|,
name|exec
argument_list|)
expr_stmt|;
return|return
name|chain
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}.    *    *<p>Successful cancellation of the input future will cause the returned    * future to be cancelled.  Cancelling the returned future will succeed if it    * is currently running.  In this case, an attempt will be made to cancel the    * input future, however there is no guarantee of success.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that notifies input it is complete.    * @return A future that holds result of the composition.    */
DECL|method|compose (ListenableFuture<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|compose
argument_list|(
name|future
argument_list|,
name|function
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code ListenableFuture} whose result is the product of    * applying the given {@code Function} to the result of the given {@code    * Future}.    *    *<p>Successful cancellation of the input future will cause the returned    * future to be cancelled.  Cancelling the returned future will succeed if it    * is currently running.  In this case, an attempt will be made to cancel the    * input future, however there is no guarantee of success.    *    *<p>An example use of this method is to convert a serializable object    * returned from an RPC into a POJO.    *    *<p>This version allows an arbitrary executor to be passed in for running    * the chained Function. When using {@link MoreExecutors#sameThreadExecutor},    * the thread chained Function executes in will be whichever thread set the    * result of the input Future, which may be the network thread in the case of    * RPC-based Futures.    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.    * @param exec Executor to run the function in.    * @return A future that holds result of the composition.    * @since 2    */
DECL|method|compose (ListenableFuture<I> future, final Function<? super I, ? extends O> function, Executor exec)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
name|wrapperFunction
init|=
operator|new
name|Function
argument_list|<
name|I
argument_list|,
name|ListenableFuture
argument_list|<
name|O
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|apply
parameter_list|(
name|I
name|input
parameter_list|)
block|{
name|O
name|output
init|=
name|function
operator|.
name|apply
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|immediateFuture
argument_list|(
name|output
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|chain
argument_list|(
name|future
argument_list|,
name|wrapperFunction
argument_list|,
name|exec
argument_list|)
return|;
block|}
comment|/**    * Returns a new {@code Future} whose result is the product of applying the    * given {@code Function} to the result of the given {@code Future}.    *    *<p>An example use of this method is to convert a Future that produces a    * handle to an object to a future that produces the object itself.    *    *<p>Each call to {@code Future<O>.get(*)} results in a call to    * {@code Future<I>.get(*)}, but {@code function} is only applied once, so it    * is assumed that {@code Future<I>.get(*)} is idempotent.    *    *<p>When calling {@link Future#get(long, TimeUnit)} on the returned    * future, the timeout only applies to the future passed in to this method.    * Any additional time taken by applying {@code function} is not considered.    * (Exception: If the input future is a {@link ListenableFuture}, timeouts    * will be strictly enforced.)    *    * @param future The future to compose    * @param function A Function to compose the results of the provided future    *     to the results of the returned future.  This will be run in the thread    *     that calls one of the varieties of {@code get()}.    * @return A future that computes result of the composition.    */
DECL|method|compose (final Future<I> future, final Function<? super I, ? extends O> function)
specifier|public
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|Future
argument_list|<
name|O
argument_list|>
name|compose
parameter_list|(
specifier|final
name|Future
argument_list|<
name|I
argument_list|>
name|future
parameter_list|,
specifier|final
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|O
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|future
operator|instanceof
name|ListenableFuture
condition|)
block|{
return|return
name|compose
argument_list|(
operator|(
name|ListenableFuture
argument_list|<
name|I
argument_list|>
operator|)
name|future
argument_list|,
name|function
argument_list|)
return|;
block|}
name|checkNotNull
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|new
name|Future
argument_list|<
name|O
argument_list|>
argument_list|()
block|{
comment|/*        * Concurrency detail:        *        *<p>To preserve the idempotency of calls to this.get(*) calls to the        * function are only applied once. A lock is required to prevent multiple        * applications of the function. The calls to future.get(*) are performed        * outside the lock, as is required to prevent calls to        * get(long, TimeUnit) to persist beyond their timeout.        *        *<p>Calls to future.get(*) on every call to this.get(*) also provide        * the cancellation behavior for this.        *        *<p>(Consider: in thread A, call get(), in thread B call get(long,        * TimeUnit). Thread B may have to wait for Thread A to finish, which        * would be unacceptable.)        *        *<p>Note that each call to Future<O>.get(*) results in a call to        * Future<I>.get(*), but the function is only applied once, so        * Future<I>.get(*) is assumed to be idempotent.        */
specifier|private
specifier|final
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|set
init|=
literal|false
decl_stmt|;
specifier|private
name|O
name|value
init|=
literal|null
decl_stmt|;
specifier|private
name|ExecutionException
name|exception
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
name|apply
argument_list|(
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|O
name|apply
parameter_list|(
name|I
name|raw
parameter_list|)
throws|throws
name|ExecutionException
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|set
condition|)
block|{
try|try
block|{
name|value
operator|=
name|function
operator|.
name|apply
argument_list|(
name|raw
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|exception
operator|=
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|exception
operator|=
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
return|return
name|value
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|future
operator|.
name|isCancelled
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|future
operator|.
name|isDone
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * An implementation of {@code ListenableFuture} that also implements    * {@code Runnable} so that it can be used to nest ListenableFutures.    * Once the passed-in {@code ListenableFuture} is complete, it calls the    * passed-in {@code Function} to generate the result.    *    *<p>If the function throws any checked exceptions, they should be wrapped    * in a {@code UndeclaredThrowableException} so that this class can get    * access to the cause.    */
DECL|class|ChainingListenableFuture
specifier|private
specifier|static
class|class
name|ChainingListenableFuture
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
extends|extends
name|AbstractListenableFuture
argument_list|<
name|O
argument_list|>
implements|implements
name|Runnable
block|{
specifier|private
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
DECL|field|function
name|function
decl_stmt|;
DECL|field|inputFuture
specifier|private
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
decl_stmt|;
DECL|field|outputFuture
specifier|private
specifier|volatile
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
decl_stmt|;
DECL|field|mayInterruptIfRunningChannel
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Boolean
argument_list|>
name|mayInterruptIfRunningChannel
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Boolean
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|outputCreated
specifier|private
specifier|final
name|CountDownLatch
name|outputCreated
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|ChainingListenableFuture ( Function<? super I, ? extends ListenableFuture<? extends O>> function, ListenableFuture<? extends I> inputFuture)
specifier|private
name|ChainingListenableFuture
parameter_list|(
name|Function
argument_list|<
name|?
super|super
name|I
argument_list|,
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
argument_list|>
name|function
parameter_list|,
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|checkNotNull
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputFuture
operator|=
name|checkNotNull
argument_list|(
name|inputFuture
argument_list|)
expr_stmt|;
block|}
comment|/**      * Delegate the get() to the input and output futures, in case      * their implementations defer starting computation until their      * own get() is invoked.      */
annotation|@
name|Override
DECL|method|get ()
specifier|public
name|O
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
comment|// Invoking get on the inputFuture will ensure our own run()
comment|// method below is invoked as a listener when inputFuture sets
comment|// its value.  Therefore when get() returns we should then see
comment|// the outputFuture be created.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
init|=
name|this
operator|.
name|inputFuture
decl_stmt|;
if|if
condition|(
name|inputFuture
operator|!=
literal|null
condition|)
block|{
name|inputFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
comment|// If our listener was scheduled to run on an executor we may
comment|// need to wait for our listener to finish running before the
comment|// outputFuture has been constructed by the function.
name|outputCreated
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// Like above with the inputFuture, we have a listener on
comment|// the outputFuture that will set our own value when its
comment|// value is set.  Invoking get will ensure the output can
comment|// complete and invoke our listener, so that we can later
comment|// get the result.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
decl_stmt|;
if|if
condition|(
name|outputFuture
operator|!=
literal|null
condition|)
block|{
name|outputFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Delegate the get() to the input and output futures, in case      * their implementations defer starting computation until their      * own get() is invoked.      */
annotation|@
name|Override
DECL|method|get (long timeout, TimeUnit unit)
specifier|public
name|O
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|ExecutionException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
comment|// Use a single time unit so we can decrease remaining timeout
comment|// as we wait for various phases to complete.
if|if
condition|(
name|unit
operator|!=
name|NANOSECONDS
condition|)
block|{
name|timeout
operator|=
name|NANOSECONDS
operator|.
name|convert
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|NANOSECONDS
expr_stmt|;
block|}
comment|// Invoking get on the inputFuture will ensure our own run()
comment|// method below is invoked as a listener when inputFuture sets
comment|// its value.  Therefore when get() returns we should then see
comment|// the outputFuture be created.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|I
argument_list|>
name|inputFuture
init|=
name|this
operator|.
name|inputFuture
decl_stmt|;
if|if
condition|(
name|inputFuture
operator|!=
literal|null
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|inputFuture
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|timeout
operator|-=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
comment|// If our listener was scheduled to run on an executor we may
comment|// need to wait for our listener to finish running before the
comment|// outputFuture has been constructed by the function.
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|outputCreated
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
name|timeout
operator|-=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
comment|// Like above with the inputFuture, we have a listener on
comment|// the outputFuture that will set our own value when its
comment|// value is set.  Invoking get will ensure the output can
comment|// complete and invoke our listener, so that we can later
comment|// get the result.
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
decl_stmt|;
if|if
condition|(
name|outputFuture
operator|!=
literal|null
condition|)
block|{
name|outputFuture
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cancel (boolean mayInterruptIfRunning)
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
if|if
condition|(
name|cancel
argument_list|()
condition|)
block|{
try|try
block|{
comment|// This should never block since only one thread is allowed to cancel
comment|// this Future.
name|mayInterruptIfRunningChannel
operator|.
name|put
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|cancel
argument_list|(
name|inputFuture
argument_list|,
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
name|cancel
argument_list|(
name|outputFuture
argument_list|,
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|cancel (@ullable Future<?> future, boolean mayInterruptIfRunning)
specifier|private
name|void
name|cancel
parameter_list|(
annotation|@
name|Nullable
name|Future
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|I
name|sourceResult
decl_stmt|;
try|try
block|{
name|sourceResult
operator|=
name|makeUninterruptible
argument_list|(
name|inputFuture
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
name|cancel
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ListenableFuture
argument_list|<
name|?
extends|extends
name|O
argument_list|>
name|outputFuture
init|=
name|this
operator|.
name|outputFuture
operator|=
name|function
operator|.
name|apply
argument_list|(
name|sourceResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCancelled
argument_list|()
condition|)
block|{
comment|// Handles the case where cancel was called while the function was
comment|// being applied.
try|try
block|{
comment|// There is a gap in cancel(boolean) between calling cancel() and
comment|// storing the value of mayInterruptIfRunning, so this thread needs
comment|// to block, waiting for that value.
name|outputFuture
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunningChannel
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|outputFuture
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|outputFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Here it would have been nice to have had an
comment|// UninterruptibleListenableFuture, but we don't want to start a
comment|// combinatorial explosion of interfaces, so we have to make do.
name|set
argument_list|(
name|makeUninterruptible
argument_list|(
name|outputFuture
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
comment|// Cancel this future and return.
name|cancel
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Don't pin inputs beyond completion
name|ChainingListenableFuture
operator|.
name|this
operator|.
name|outputFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
comment|// Set the cause of the exception as this future's exception
name|setException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// This exception is irrelevant in this thread, but useful for the
comment|// client
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
comment|// Propagate errors up ASAP - our superclass will rethrow the error
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Don't pin inputs beyond completion
name|function
operator|=
literal|null
expr_stmt|;
name|inputFuture
operator|=
literal|null
expr_stmt|;
comment|// Allow our get routines to examine outputFuture now.
name|outputCreated
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A checked future that uses a function to map from exceptions to the    * appropriate checked type.    */
DECL|class|MappingCheckedFuture
specifier|private
specifier|static
class|class
name|MappingCheckedFuture
parameter_list|<
name|V
parameter_list|,
name|X
extends|extends
name|Exception
parameter_list|>
extends|extends
name|AbstractCheckedFuture
argument_list|<
name|V
argument_list|,
name|X
argument_list|>
block|{
DECL|field|mapper
specifier|final
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
decl_stmt|;
DECL|method|MappingCheckedFuture (ListenableFuture<V> delegate, Function<Exception, X> mapper)
name|MappingCheckedFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|Function
argument_list|<
name|Exception
argument_list|,
name|X
argument_list|>
name|mapper
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapper
operator|=
name|checkNotNull
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mapException (Exception e)
specifier|protected
name|X
name|mapException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|mapper
operator|.
name|apply
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
comment|/**    * An adapter to turn a {@link Future} into a {@link ListenableFuture}.  This    * will wait on the future to finish, and when it completes, run the    * listeners.  This implementation will wait on the source future    * indefinitely, so if the source future never completes, the adapter will    * never complete either.    *    *<p>If the delegate future is interrupted or throws an unexpected unchecked    * exception, the listeners will not be invoked.    */
DECL|class|ListenableFutureAdapter
specifier|private
specifier|static
class|class
name|ListenableFutureAdapter
parameter_list|<
name|V
parameter_list|>
extends|extends
name|ForwardingFuture
argument_list|<
name|V
argument_list|>
implements|implements
name|ListenableFuture
argument_list|<
name|V
argument_list|>
block|{
DECL|field|threadFactory
specifier|private
specifier|static
specifier|final
name|ThreadFactory
name|threadFactory
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"ListenableFutureAdapter-thread-%d"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|defaultAdapterExecutor
specifier|private
specifier|static
specifier|final
name|Executor
name|defaultAdapterExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
name|threadFactory
argument_list|)
decl_stmt|;
DECL|field|adapterExecutor
specifier|private
specifier|final
name|Executor
name|adapterExecutor
decl_stmt|;
comment|// The execution list to hold our listeners.
DECL|field|executionList
specifier|private
specifier|final
name|ExecutionList
name|executionList
init|=
operator|new
name|ExecutionList
argument_list|()
decl_stmt|;
comment|// This allows us to only start up a thread waiting on the delegate future
comment|// when the first listener is added.
DECL|field|hasListeners
specifier|private
specifier|final
name|AtomicBoolean
name|hasListeners
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// The delegate future.
DECL|field|delegate
specifier|private
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|ListenableFutureAdapter (Future<V> delegate)
name|ListenableFutureAdapter
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
argument_list|(
name|delegate
argument_list|,
name|defaultAdapterExecutor
argument_list|)
expr_stmt|;
block|}
DECL|method|ListenableFutureAdapter (Future<V> delegate, Executor adapterExecutor)
name|ListenableFutureAdapter
parameter_list|(
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|,
name|Executor
name|adapterExecutor
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|checkNotNull
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|adapterExecutor
operator|=
name|checkNotNull
argument_list|(
name|adapterExecutor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delegate ()
specifier|protected
name|Future
argument_list|<
name|V
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
DECL|method|addListener (Runnable listener, Executor exec)
specifier|public
name|void
name|addListener
parameter_list|(
name|Runnable
name|listener
parameter_list|,
name|Executor
name|exec
parameter_list|)
block|{
name|executionList
operator|.
name|add
argument_list|(
name|listener
argument_list|,
name|exec
argument_list|)
expr_stmt|;
comment|// When a listener is first added, we run a task that will wait for
comment|// the delegate to finish, and when it is done will run the listeners.
if|if
condition|(
name|hasListeners
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|delegate
operator|.
name|isDone
argument_list|()
condition|)
block|{
comment|// If the delegate is already done, run the execution list
comment|// immediately on the current thread.
name|executionList
operator|.
name|run
argument_list|()
expr_stmt|;
return|return;
block|}
name|adapterExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delegate
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// This thread was interrupted.  This should never happen, so we
comment|// throw an IllegalStateException.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Adapter thread interrupted!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// ExecutionException / CancellationException / RuntimeException
comment|// The task is done, run the listeners.
block|}
name|executionList
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

