begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|contrib
operator|.
name|truth
operator|.
name|Truth
operator|.
name|ASSERT
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|IteratorFeature
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|IteratorTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link FluentIterable}.  *  * @author Marcin Mikosik  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|FluentIterableTest
specifier|public
class|class
name|FluentIterableTest
extends|extends
name|TestCase
block|{
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NullPointerTester"
argument_list|)
DECL|method|testNullPointerExceptions ()
specifier|public
name|void
name|testNullPointerExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|NullPointerTester
name|tester
init|=
operator|new
name|NullPointerTester
argument_list|()
decl_stmt|;
name|tester
operator|.
name|testAllPublicStaticMethods
argument_list|(
name|FluentIterable
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|testFrom ()
specifier|public
name|void
name|testFrom
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testFrom_alreadyFluentIterable ()
specifier|public
name|void
name|testFrom_alreadyFluentIterable
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|iterable
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSize1Collection ()
specifier|public
name|void
name|testSize1Collection
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"a"
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSize2NonCollection ()
specifier|public
name|void
name|testSize2NonCollection
parameter_list|()
block|{
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|iterable
init|=
operator|new
name|Iterable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSize_collectionDoesntIterate ()
specifier|public
name|void
name|testSize_collectionDoesntIterate
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|nums
init|=
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|collection
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|nums
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
name|fail
argument_list|(
literal|"Don't iterate me!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|collection
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nullSetYes ()
specifier|public
name|void
name|testContains_nullSetYes
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nullSetNo ()
specifier|public
name|void
name|testContains_nullSetNo
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSortedSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nullIterableYes ()
specifier|public
name|void
name|testContains_nullIterableYes
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|iterable
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nullIterableNo ()
specifier|public
name|void
name|testContains_nullIterableNo
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|iterable
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nonNullSetYes ()
specifier|public
name|void
name|testContains_nonNullSetYes
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|contains
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nonNullSetNo ()
specifier|public
name|void
name|testContains_nonNullSetNo
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|contains
argument_list|(
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nonNullIterableYes ()
specifier|public
name|void
name|testContains_nonNullIterableYes
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|set
init|=
name|iterable
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|contains
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testContains_nonNullIterableNo ()
specifier|public
name|void
name|testContains_nonNullIterableNo
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|iterable
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
operator|.
name|contains
argument_list|(
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetOnlyElement_noDefaultValid ()
specifier|public
name|void
name|testGetOnlyElement_noDefaultValid
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|getOnlyElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetOnlyElement_noDefaultMultiple ()
specifier|public
name|void
name|testGetOnlyElement_noDefaultMultiple
parameter_list|()
block|{
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
argument_list|)
operator|.
name|getOnlyElement
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Invoking getOnly element on two element FluentIterable should cause exception."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testGetOnlyElement_withDefaultSingleton ()
specifier|public
name|void
name|testGetOnlyElement_withDefaultSingleton
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|getOnlyElement
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGetOnlyElement_withDefaultMultiple ()
specifier|public
name|void
name|testGetOnlyElement_withDefaultMultiple
parameter_list|()
block|{
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
argument_list|)
operator|.
name|getOnlyElement
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCycle ()
specifier|public
name|void
name|testCycle
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|cycle
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
argument_list|)
operator|.
name|cycle
argument_list|()
decl_stmt|;
name|int
name|howManyChecked
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|string
range|:
name|cycle
control|)
block|{
name|String
name|expected
init|=
operator|(
name|howManyChecked
operator|%
literal|2
operator|==
literal|0
operator|)
condition|?
literal|"a"
else|:
literal|"b"
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|howManyChecked
operator|++
operator|==
literal|5
condition|)
block|{
break|break;
block|}
block|}
comment|// We left the last iterator pointing to "b". But a new iterator should
comment|// always point to "a".
for|for
control|(
name|String
name|string
range|:
name|cycle
control|)
block|{
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|string
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|method|testCycle_removingAllElementsStopsCycle ()
specifier|public
name|void
name|testCycle_removingAllElementsStopsCycle
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
name|cycle
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|.
name|cycle
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
init|=
name|cycle
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cycle
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAppend ()
specifier|public
name|void
name|testAppend
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|FluentIterable
operator|.
expr|<
name|Integer
operator|>
name|from
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[1, 2, 3, 4, 5, 6]"
argument_list|,
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|FluentIterable
operator|.
expr|<
name|Integer
operator|>
name|from
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[1, 2, 3, 4, 5, 6]"
argument_list|,
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAppend_emptyList ()
specifier|public
name|void
name|testAppend_emptyList
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|FluentIterable
operator|.
expr|<
name|Integer
operator|>
name|from
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|Lists
operator|.
expr|<
name|Integer
operator|>
name|newArrayList
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Tests for partition(int size) method.    */
DECL|method|testPartition ()
specifier|public
name|void
name|testPartition
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|partitioned
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1, 2, 3], [4, 5]]"
argument_list|,
name|partitioned
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_negativeSize ()
specifier|public
name|void
name|testPartition_negativeSize
parameter_list|()
block|{
try|try
block|{
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|.
name|partition
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invoking partition method with negative value should throw IAE."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPartition_zeroSize ()
specifier|public
name|void
name|testPartition_zeroSize
parameter_list|()
block|{
try|try
block|{
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|.
name|partition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invoking partition method with zero value should throw IAE."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPartition_noFirstRowExamination ()
specifier|public
name|void
name|testPartition_noFirstRowExamination
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_rowSizeEqualsListSize ()
specifier|public
name|void
name|testPartition_rowSizeEqualsListSize
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|5
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_rowSizeGreaterThanList ()
specifier|public
name|void
name|testPartition_rowSizeGreaterThanList
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|6
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_size1 ()
specifier|public
name|void
name|testPartition_size1
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_multipleIterators ()
specifier|public
name|void
name|testPartition_multipleIterators
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|partitioned
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter1
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter1
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter2
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter1
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter1
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter2
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter2
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter2
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_multipleIteratorsFromInnerIterable ()
specifier|public
name|void
name|testPartition_multipleIteratorsFromInnerIterable
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|innerIterable1
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable1
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable1
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|innerIterable2
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable2
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable2
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_sizeIsMultipleOfPartitionSize ()
specifier|public
name|void
name|testPartition_sizeIsMultipleOfPartitionSize
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
operator|.
name|partition
argument_list|(
literal|2
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_empty ()
specifier|public
name|void
name|testPartition_empty
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|fluent
argument_list|()
operator|.
name|partition
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartition_nullElementWithoutPadding ()
specifier|public
name|void
name|testPartition_nullElementWithoutPadding
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partition
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*    * Tests for partitionWithPadding(int size) method.    */
DECL|method|testPartitionWithPadding ()
specifier|public
name|void
name|testPartitionWithPadding
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|partitioned
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1, 2, 3], [4, 5, null]]"
argument_list|,
name|partitioned
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionWithPadding_negativeSize ()
specifier|public
name|void
name|testPartitionWithPadding_negativeSize
parameter_list|()
block|{
try|try
block|{
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invoking partitionWithPadding method with negative value should throw IAE."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPartitionWithPadding_zeroSize ()
specifier|public
name|void
name|testPartitionWithPadding_zeroSize
parameter_list|()
block|{
try|try
block|{
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invoking partitionWithPadding method with zero value should throw IAE."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testPartitionWithPadding_noFirstRowExamination ()
specifier|public
name|void
name|testPartitionWithPadding_noFirstRowExamination
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionPadding_rowSizeEqualsListSize ()
specifier|public
name|void
name|testPartitionPadding_rowSizeEqualsListSize
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|5
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionPadding_rowSizeGreaterThanList ()
specifier|public
name|void
name|testPartitionPadding_rowSizeGreaterThanList
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|6
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionPadding_size1 ()
specifier|public
name|void
name|testPartitionPadding_size1
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionWithPadding_multipleIterators ()
specifier|public
name|void
name|testPartitionWithPadding_multipleIterators
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|partitioned
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter1
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter1
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter2
init|=
name|partitioned
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter1
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter1
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter2
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter2
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter2
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionWithPadding_multipleIteratorsFromInnerIterable ()
specifier|public
name|void
name|testPartitionWithPadding_multipleIteratorsFromInnerIterable
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|innerIterable1
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable1
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable1
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|innerIterable2
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable2
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|innerIterable2
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionPadding_sizeIsMultipleOfPartitionSize ()
specifier|public
name|void
name|testPartitionPadding_sizeIsMultipleOfPartitionSize
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|2
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionWithPadding_empty ()
specifier|public
name|void
name|testPartitionWithPadding_empty
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|fluent
argument_list|()
operator|.
name|partitionWithPadding
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartitionPadding_nullElement ()
specifier|public
name|void
name|testPartitionPadding_nullElement
parameter_list|()
block|{
name|Iterator
argument_list|<
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
operator|.
name|partitionWithPadding
argument_list|(
literal|3
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilter ()
specifier|public
name|void
name|testFilter
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|filtered
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|Predicates
operator|.
name|equalTo
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|expected
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|actual
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|filtered
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|assertCanIterateAgain
argument_list|(
name|filtered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[foo]"
argument_list|,
name|filtered
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|TypeA
specifier|private
specifier|static
class|class
name|TypeA
block|{}
DECL|interface|TypeB
specifier|private
interface|interface
name|TypeB
block|{}
DECL|class|HasBoth
specifier|private
specifier|static
class|class
name|HasBoth
extends|extends
name|TypeA
implements|implements
name|TypeB
block|{}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"Iterables.filter(Iterable, Class)"
argument_list|)
DECL|method|testFilterByType ()
specifier|public
name|void
name|testFilterByType
parameter_list|()
throws|throws
name|Exception
block|{
name|HasBoth
name|hasBoth
init|=
operator|new
name|HasBoth
argument_list|()
decl_stmt|;
name|FluentIterable
argument_list|<
name|TypeA
argument_list|>
name|alist
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
operator|new
name|TypeA
argument_list|()
argument_list|,
operator|new
name|TypeA
argument_list|()
argument_list|,
name|hasBoth
argument_list|,
operator|new
name|TypeA
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|TypeB
argument_list|>
name|blist
init|=
name|alist
operator|.
name|filter
argument_list|(
name|TypeB
operator|.
name|class
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|blist
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|hasBoth
argument_list|)
expr_stmt|;
block|}
DECL|method|testAnyMatch ()
specifier|public
name|void
name|testAnyMatch
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
expr|<
name|String
operator|>
name|from
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|Predicate
argument_list|<
name|String
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|equalTo
argument_list|(
literal|"pants"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|iterable
operator|.
name|anyMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
literal|"cool"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterable
operator|.
name|anyMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
literal|"pants"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iterable
operator|.
name|anyMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllMatch ()
specifier|public
name|void
name|testAllMatch
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
expr|<
name|String
operator|>
name|from
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|Predicate
argument_list|<
name|String
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|equalTo
argument_list|(
literal|"cool"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|iterable
operator|.
name|allMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
literal|"cool"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iterable
operator|.
name|allMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
literal|"pants"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterable
operator|.
name|allMatch
argument_list|(
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirstMatch ()
specifier|public
name|void
name|testFirstMatch
parameter_list|()
block|{
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"cool"
argument_list|,
literal|"pants"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"cool"
argument_list|)
argument_list|,
name|iterable
operator|.
name|firstMatch
argument_list|(
name|Predicates
operator|.
name|equalTo
argument_list|(
literal|"cool"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"pants"
argument_list|)
argument_list|,
name|iterable
operator|.
name|firstMatch
argument_list|(
name|Predicates
operator|.
name|equalTo
argument_list|(
literal|"pants"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|iterable
operator|.
name|firstMatch
argument_list|(
name|Predicates
operator|.
name|alwaysFalse
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
literal|"cool"
argument_list|)
argument_list|,
name|iterable
operator|.
name|firstMatch
argument_list|(
name|Predicates
operator|.
name|alwaysTrue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|IntegerValueOfFunction
specifier|private
specifier|static
specifier|final
class|class
name|IntegerValueOfFunction
implements|implements
name|Function
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
block|{
annotation|@
name|Override
DECL|method|apply (String from)
specifier|public
name|Integer
name|apply
parameter_list|(
name|String
name|from
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
DECL|method|testTransformWith ()
specifier|public
name|void
name|testTransformWith
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|input
init|=
name|asList
argument_list|(
literal|"1"
argument_list|,
literal|"2"
argument_list|,
literal|"3"
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|input
argument_list|)
operator|.
name|transform
argument_list|(
operator|new
name|IntegerValueOfFunction
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|iterable
argument_list|)
argument_list|)
expr_stmt|;
name|assertCanIterateAgain
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[1, 2, 3]"
argument_list|,
name|iterable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformWith_poorlyBehavedTransform ()
specifier|public
name|void
name|testTransformWith_poorlyBehavedTransform
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|input
init|=
name|asList
argument_list|(
literal|"1"
argument_list|,
literal|null
argument_list|,
literal|"3"
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|iterable
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|input
argument_list|)
operator|.
name|transform
argument_list|(
operator|new
name|IntegerValueOfFunction
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|resultIterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|resultIterator
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|resultIterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Transforming null to int should throw NumberFormatException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|expected
parameter_list|)
block|{     }
block|}
DECL|class|StringValueOfFunction
specifier|private
specifier|static
specifier|final
class|class
name|StringValueOfFunction
implements|implements
name|Function
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
block|{
annotation|@
name|Override
DECL|method|apply (Integer from)
specifier|public
name|String
name|apply
parameter_list|(
name|Integer
name|from
parameter_list|)
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
DECL|method|testTransformWith_nullFriendlyTransform ()
specifier|public
name|void
name|testTransformWith_nullFriendlyTransform
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|input
init|=
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|String
argument_list|>
name|result
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|input
argument_list|)
operator|.
name|transform
argument_list|(
operator|new
name|StringValueOfFunction
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|asList
argument_list|(
literal|"1"
argument_list|,
literal|"2"
argument_list|,
literal|"null"
argument_list|,
literal|"3"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_list ()
specifier|public
name|void
name|testFirst_list
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_null ()
specifier|public
name|void
name|testFirst_null
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|null
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|first
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testFirst_emptyList ()
specifier|public
name|void
name|testFirst_emptyList
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_sortedSet ()
specifier|public
name|void
name|testFirst_sortedSet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedSet
init|=
name|ImmutableSortedSet
operator|.
name|of
argument_list|(
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|sortedSet
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_emptySortedSet ()
specifier|public
name|void
name|testFirst_emptySortedSet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedSet
init|=
name|ImmutableSortedSet
operator|.
name|of
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|sortedSet
argument_list|)
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_iterable ()
specifier|public
name|void
name|testFirst_iterable
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFirst_emptyIterable ()
specifier|public
name|void
name|testFirst_emptyIterable
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_list ()
specifier|public
name|void
name|testLast_list
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|last
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_null ()
specifier|public
name|void
name|testLast_null
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|last
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testLast_emptyList ()
specifier|public
name|void
name|testLast_emptyList
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_sortedSet ()
specifier|public
name|void
name|testLast_sortedSet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedSet
init|=
name|ImmutableSortedSet
operator|.
name|of
argument_list|(
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|sortedSet
argument_list|)
operator|.
name|last
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_emptySortedSet ()
specifier|public
name|void
name|testLast_emptySortedSet
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedSet
init|=
name|ImmutableSortedSet
operator|.
name|of
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|sortedSet
argument_list|)
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_iterable ()
specifier|public
name|void
name|testLast_iterable
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|last
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLast_emptyIterable ()
specifier|public
name|void
name|testLast_emptyIterable
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Optional
operator|.
name|absent
argument_list|()
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_simple ()
specifier|public
name|void
name|testSkip_simple
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"e"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[c, d, e]"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_simpleList ()
specifier|public
name|void
name|testSkip_simpleList
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"e"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[c, d, e]"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_pastEnd ()
specifier|public
name|void
name|testSkip_pastEnd
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_pastEndList ()
specifier|public
name|void
name|testSkip_pastEndList
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_skipNone ()
specifier|public
name|void
name|testSkip_skipNone
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|set
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_skipNoneList ()
specifier|public
name|void
name|testSkip_skipNoneList
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_iterator ()
specifier|public
name|void
name|testSkip_iterator
parameter_list|()
throws|throws
name|Exception
block|{
operator|new
name|IteratorTester
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|5
argument_list|,
name|IteratorFeature
operator|.
name|MODIFIABLE
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|IteratorTester
operator|.
name|KnownOrder
operator|.
name|KNOWN_ORDER
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|newTargetIterator
parameter_list|()
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|collection
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|collection
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|collection
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
operator|.
name|test
argument_list|()
expr_stmt|;
block|}
DECL|method|testSkip_iteratorList ()
specifier|public
name|void
name|testSkip_iteratorList
parameter_list|()
throws|throws
name|Exception
block|{
operator|new
name|IteratorTester
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|5
argument_list|,
name|IteratorFeature
operator|.
name|MODIFIABLE
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|IteratorTester
operator|.
name|KnownOrder
operator|.
name|KNOWN_ORDER
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|newTargetIterator
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
operator|.
name|test
argument_list|()
expr_stmt|;
block|}
DECL|method|testSkip_nonStructurallyModifiedList ()
specifier|public
name|void
name|testSkip_nonStructurallyModifiedList
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|tail
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|tailIterator
init|=
name|tail
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|list
operator|.
name|set
argument_list|(
literal|2
argument_list|,
literal|"c2"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"b"
argument_list|,
name|tailIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"c2"
argument_list|,
name|tailIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tailIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_structurallyModifiedSkipSome ()
specifier|public
name|void
name|testSkip_structurallyModifiedSkipSome
parameter_list|()
throws|throws
name|Exception
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|tail
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"X"
argument_list|,
literal|"Y"
argument_list|,
literal|"Z"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|tail
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|"c"
argument_list|,
literal|"X"
argument_list|,
literal|"Y"
argument_list|,
literal|"Z"
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_structurallyModifiedSkipSomeList ()
specifier|public
name|void
name|testSkip_structurallyModifiedSkipSomeList
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|tail
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
name|list
operator|.
name|addAll
argument_list|(
literal|0
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"X"
argument_list|,
literal|"Y"
argument_list|,
literal|"Z"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|tail
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|"Y"
argument_list|,
literal|"Z"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_structurallyModifiedSkipAll ()
specifier|public
name|void
name|testSkip_structurallyModifiedSkipAll
parameter_list|()
throws|throws
name|Exception
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|set
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|set
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|tail
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|set
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|set
operator|.
name|remove
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tail
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSkip_structurallyModifiedSkipAllList ()
specifier|public
name|void
name|testSkip_structurallyModifiedSkipAllList
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|tail
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|list
argument_list|)
operator|.
name|skip
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|tail
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
DECL|method|testSkip_illegalArgument ()
specifier|public
name|void
name|testSkip_illegalArgument
parameter_list|()
block|{
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|skip
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Skipping negative number of elements should throw IllegalArgumentException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testLimit ()
specifier|public
name|void
name|testLimit
parameter_list|()
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|iterable
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|,
literal|"baz"
argument_list|)
decl_stmt|;
name|FluentIterable
argument_list|<
name|String
argument_list|>
name|limited
init|=
name|FluentIterable
operator|.
name|from
argument_list|(
name|iterable
argument_list|)
operator|.
name|limit
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|limited
argument_list|)
argument_list|)
expr_stmt|;
name|assertCanIterateAgain
argument_list|(
name|limited
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[foo, bar]"
argument_list|,
name|limited
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLimit_illegalArgument ()
specifier|public
name|void
name|testLimit_illegalArgument
parameter_list|()
block|{
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|limit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Passing negative number to limit(...) method should throw IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testIsEmpty ()
specifier|public
name|void
name|testIsEmpty
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|FluentIterable
operator|.
expr|<
name|String
operator|>
name|from
argument_list|(
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|FluentIterable
operator|.
expr|<
name|String
operator|>
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testToImmutableList ()
specifier|public
name|void
name|testToImmutableList
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|,
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
operator|.
name|toImmutableList
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testToImmutableList_empty ()
specifier|public
name|void
name|testToImmutableList_empty
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|fluent
argument_list|()
operator|.
name|toImmutableList
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testToImmutableSet ()
specifier|public
name|void
name|testToImmutableSet
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
operator|.
name|toImmutableSet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
DECL|method|testToImmutableSet_removeDuplicates ()
specifier|public
name|void
name|testToImmutableSet_removeDuplicates
parameter_list|()
block|{
name|ASSERT
operator|.
name|that
argument_list|(
name|fluent
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|.
name|toImmutableSet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
DECL|method|testToImmutableSet_empty ()
specifier|public
name|void
name|testToImmutableSet_empty
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|fluent
argument_list|()
operator|.
name|toImmutableSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testGet ()
specifier|public
name|void
name|testGet
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"b"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGet_outOfBounds ()
specifier|public
name|void
name|testGet_outOfBounds
parameter_list|()
block|{
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|assertCanIterateAgain (Iterable<?> iterable)
specifier|private
specifier|static
name|void
name|assertCanIterateAgain
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|)
block|{
for|for
control|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|Object
name|obj
range|:
name|iterable
control|)
block|{     }
block|}
DECL|method|fluent (Integer... elements)
specifier|private
specifier|static
name|FluentIterable
argument_list|<
name|Integer
argument_list|>
name|fluent
parameter_list|(
name|Integer
modifier|...
name|elements
parameter_list|)
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
DECL|method|iterable (String... elements)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|String
argument_list|>
name|iterable
parameter_list|(
name|String
modifier|...
name|elements
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|asList
argument_list|(
name|elements
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|list
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

