begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|transformEntries
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|testers
operator|.
name|CollectionIteratorTester
operator|.
name|getIteratorUnknownOrderRemoveSupportedMethod
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|contrib
operator|.
name|truth
operator|.
name|Truth
operator|.
name|ASSERT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalences
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|EntryTransformer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|ValueDifferenceImpl
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetsTest
operator|.
name|Derived
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|MapTestSuiteBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|SortedMapInterfaceTest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|TestStringMapGenerator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|features
operator|.
name|CollectionSize
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|features
operator|.
name|MapFeature
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|EqualsTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestSuite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_comment
comment|/**  * Unit test for {@code Maps}.  *  * @author Kevin Bourrillion  * @author Mike Bostock  * @author Jared Levy  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|MapsTest
specifier|public
class|class
name|MapsTest
extends|extends
name|TestCase
block|{
DECL|field|SOME_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|SOME_COMPARATOR
init|=
name|Collections
operator|.
name|reverseOrder
argument_list|()
decl_stmt|;
DECL|method|testHashMap ()
specifier|public
name|void
name|testHashMap
parameter_list|()
block|{
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashMapWithInitialMap ()
specifier|public
name|void
name|testHashMapWithInitialMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testHashMapGeneralizesTypes ()
specifier|public
name|void
name|testHashMapGeneralizesTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|(
operator|(
name|Map
argument_list|<
name|?
extends|extends
name|Object
argument_list|,
name|?
extends|extends
name|Object
argument_list|>
operator|)
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testCapacityForNegativeSizeFails ()
specifier|public
name|void
name|testCapacityForNegativeSizeFails
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
name|capacity
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Negative expected size must result in IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{     }
block|}
comment|/**    * Tests that nHMWES makes hash maps large enough that adding the expected    * number of elements won't cause a rehash.    *    * This test may fail miserably on non-OpenJDK environments...    */
annotation|@
name|GwtIncompatible
argument_list|(
literal|"reflection"
argument_list|)
DECL|method|testNewHashMapWithExpectedSize_wontGrow ()
specifier|public
name|void
name|testNewHashMapWithExpectedSize_wontGrow
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|size
init|=
literal|0
init|;
name|size
operator|<
literal|200
condition|;
name|size
operator|++
control|)
block|{
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
name|map1
init|=
name|Maps
operator|.
name|newHashMapWithExpectedSize
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|startSize
init|=
name|sizeOf
argument_list|(
name|map1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|map1
operator|.
name|put
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"table size after adding "
operator|+
name|size
operator|+
literal|"elements"
argument_list|,
name|startSize
argument_list|,
name|sizeOf
argument_list|(
name|map1
argument_list|)
argument_list|)
expr_stmt|;
comment|/*        * Something slightly different happens when the entries are added all at        * once; make sure that passes too.        */
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
name|map2
init|=
name|Maps
operator|.
name|newHashMapWithExpectedSize
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|map2
operator|.
name|putAll
argument_list|(
name|map1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"table size after adding "
operator|+
name|size
operator|+
literal|"elements"
argument_list|,
name|startSize
argument_list|,
name|sizeOf
argument_list|(
name|map2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"reflection"
argument_list|)
DECL|method|sizeOf (HashMap<?, ?> hashMap)
specifier|private
specifier|static
name|int
name|sizeOf
parameter_list|(
name|HashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|hashMap
parameter_list|)
throws|throws
name|Exception
block|{
name|Field
name|tableField
init|=
name|HashMap
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"table"
argument_list|)
decl_stmt|;
name|tableField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
index|[]
name|table
init|=
operator|(
name|Object
index|[]
operator|)
name|tableField
operator|.
name|get
argument_list|(
name|hashMap
argument_list|)
decl_stmt|;
return|return
name|table
operator|.
name|length
return|;
block|}
DECL|method|testCapacityForLargeSizes ()
specifier|public
name|void
name|testCapacityForLargeSizes
parameter_list|()
block|{
name|int
index|[]
name|largeExpectedSizes
init|=
operator|new
name|int
index|[]
block|{
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|-
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
operator|+
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
block|,
name|Integer
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
for|for
control|(
name|int
name|expectedSize
range|:
name|largeExpectedSizes
control|)
block|{
name|int
name|capacity
init|=
name|Maps
operator|.
name|capacity
argument_list|(
name|expectedSize
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"capacity ("
operator|+
name|capacity
operator|+
literal|") must be>= expectedSize ("
operator|+
name|expectedSize
operator|+
literal|")"
argument_list|,
name|capacity
operator|>=
name|expectedSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testLinkedHashMap ()
specifier|public
name|void
name|testLinkedHashMap
parameter_list|()
block|{
name|LinkedHashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|method|testLinkedHashMapWithInitialMap ()
specifier|public
name|void
name|testLinkedHashMapWithInitialMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
block|{
name|put
argument_list|(
literal|"Hello"
argument_list|,
literal|"World"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"first"
argument_list|,
literal|"second"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"polygene"
argument_list|,
literal|"lubricants"
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"alpha"
argument_list|,
literal|"betical"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iter
init|=
name|copy
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Hello"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"World"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"first"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"second"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"polygene"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"lubricants"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"alpha"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"betical"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iter
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testLinkedHashMapGeneralizesTypes ()
specifier|public
name|void
name|testLinkedHashMapGeneralizesTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|original
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|original
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|Maps
operator|.
expr|<
name|Object
decl_stmt|,
name|Object
decl|>
name|newLinkedHashMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testIdentityHashMap ()
specifier|public
name|void
name|testIdentityHashMap
parameter_list|()
block|{
name|IdentityHashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testConcurrentMap ()
specifier|public
name|void
name|testConcurrentMap
parameter_list|()
block|{
name|ConcurrentMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMap ()
specifier|public
name|void
name|testTreeMap
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapDerived ()
specifier|public
name|void
name|testTreeMapDerived
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Derived
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
operator|new
name|Derived
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|Derived
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|map
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapNonGeneric ()
specifier|public
name|void
name|testTreeMapNonGeneric
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|LegacyComparable
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
operator|new
name|LegacyComparable
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
operator|new
name|LegacyComparable
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|map
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapWithComparator ()
specifier|public
name|void
name|testTreeMapWithComparator
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|SOME_COMPARATOR
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|SOME_COMPARATOR
argument_list|,
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTreeMapWithInitialMap ()
specifier|public
name|void
name|testTreeMapWithInitialMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|copy
operator|.
name|comparator
argument_list|()
argument_list|,
name|map
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|enum|SomeEnum
DECL|enumConstant|SOME_INSTANCE
specifier|public
enum|enum
name|SomeEnum
block|{
name|SOME_INSTANCE
block|}
DECL|method|testEnumMap ()
specifier|public
name|void
name|testEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapNullClass ()
specifier|public
name|void
name|testEnumMapNullClass
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
expr|<
name|SomeEnum
operator|,
name|Long
operator|>
name|newEnumMap
argument_list|(
operator|(
name|Class
argument_list|<
name|MapsTest
operator|.
name|SomeEnum
argument_list|>
operator|)
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"no exception thrown"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testEnumMapWithInitialEnumMap ()
specifier|public
name|void
name|testEnumMapWithInitialEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialEmptyEnumMap ()
specifier|public
name|void
name|testEnumMapWithInitialEmptyEnumMap
parameter_list|()
block|{
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|SomeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialMap ()
specifier|public
name|void
name|testEnumMapWithInitialMap
parameter_list|()
block|{
name|HashMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|original
operator|.
name|put
argument_list|(
name|SomeEnum
operator|.
name|SOME_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EnumMap
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|copy
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|original
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
DECL|method|testEnumMapWithInitialEmptyMap ()
specifier|public
name|void
name|testEnumMapWithInitialEmptyMap
parameter_list|()
block|{
name|Map
argument_list|<
name|SomeEnum
argument_list|,
name|Integer
argument_list|>
name|original
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|original
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Empty map must result in an IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"NullPointerTester"
argument_list|)
DECL|method|testNullPointerExceptions ()
specifier|public
name|void
name|testNullPointerExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|NullPointerTester
name|tester
init|=
operator|new
name|NullPointerTester
argument_list|()
decl_stmt|;
name|tester
operator|.
name|setDefault
argument_list|(
name|BiMap
operator|.
name|class
argument_list|,
name|ImmutableBiMap
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|tester
operator|.
name|setDefault
argument_list|(
name|EntryTransformer
operator|.
name|class
argument_list|,
name|ALWAYS_NULL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|setDefault
argument_list|(
name|Equivalence
operator|.
name|class
argument_list|,
name|Equivalences
operator|.
name|equals
argument_list|()
argument_list|)
expr_stmt|;
name|tester
operator|.
name|setDefault
argument_list|(
name|SortedMap
operator|.
name|class
argument_list|,
name|Maps
operator|.
name|newTreeMap
argument_list|()
argument_list|)
expr_stmt|;
name|tester
operator|.
name|ignore
argument_list|(
name|Maps
operator|.
name|class
operator|.
name|getDeclaredMethod
argument_list|(
literal|"uniqueIndex"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Function
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|tester
operator|.
name|testAllPublicStaticMethods
argument_list|(
name|Maps
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|field|ALWAYS_NULL
specifier|private
specifier|static
specifier|final
name|EntryTransformer
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|Object
argument_list|>
name|ALWAYS_NULL
init|=
operator|new
name|EntryTransformer
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|transformEntry
parameter_list|(
name|Object
name|k
parameter_list|,
name|Object
name|v1
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|EMPTY
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|SINGLETON
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SINGLETON
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
DECL|method|testMapDifferenceEmptyEmpty ()
specifier|public
name|void
name|testMapDifferenceEmptyEmpty
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|EMPTY
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"equal"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceEmptySingleton ()
specifier|public
name|void
name|testMapDifferenceEmptySingleton
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|EMPTY
argument_list|,
name|SINGLETON
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on right={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceSingletonEmpty ()
specifier|public
name|void
name|testMapDifferenceSingletonEmpty
parameter_list|()
block|{
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SINGLETON
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceTypical ()
specifier|public
name|void
name|testMapDifferenceTypical
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={2=b, 4=d}: only on right={6=z}: "
operator|+
literal|"value differences={3=(c, f), 5=(e, g)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"f"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"g"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(f, c), 5=(g, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMapDifferenceEquals ()
specifier|public
name|void
name|testMapDifferenceEquals
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right2
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"h"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|original
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|same
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|reverse
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right2
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|original
argument_list|,
name|same
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|reverse
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|diff2
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testMapDifferencePredicateTypical ()
specifier|public
name|void
name|testMapDifferencePredicateTypical
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"A"
argument_list|,
literal|3
argument_list|,
literal|"F"
argument_list|,
literal|5
argument_list|,
literal|"G"
argument_list|,
literal|6
argument_list|,
literal|"Z"
argument_list|)
decl_stmt|;
comment|// TODO(kevinb): replace with Ascii.caseInsensitiveEquivalence() when it
comment|// exists
name|Equivalence
argument_list|<
name|String
argument_list|>
name|caseInsensitiveEquivalence
init|=
name|Equivalences
operator|.
name|equals
argument_list|()
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|caseInsensitiveEquivalence
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"Z"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"F"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"G"
argument_list|)
argument_list|)
argument_list|,
name|diff1
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={2=b, 4=d}: only on right={6=Z}: "
operator|+
literal|"value differences={3=(c, F), 5=(e, G)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|caseInsensitiveEquivalence
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|"Z"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"A"
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"F"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"G"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=Z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(F, c), 5=(G, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|SORTED_EMPTY
specifier|private
specifier|static
specifier|final
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SORTED_EMPTY
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
DECL|field|SORTED_SINGLETON
specifier|private
specifier|static
specifier|final
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|SORTED_SINGLETON
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
DECL|method|testMapDifferenceOfSortedMapIsSorted ()
specifier|public
name|void
name|testMapDifferenceOfSortedMapIsSorted
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|SORTED_SINGLETON
decl_stmt|;
name|MapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|difference
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|map
argument_list|,
name|EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|difference
operator|instanceof
name|SortedMapDifference
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceEmptyEmpty ()
specifier|public
name|void
name|testSortedMapDifferenceEmptyEmpty
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|SORTED_EMPTY
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"equal"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceEmptySingleton ()
specifier|public
name|void
name|testSortedMapDifferenceEmptySingleton
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|SORTED_SINGLETON
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on right={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceSingletonEmpty ()
specifier|public
name|void
name|testSortedMapDifferenceSingletonEmpty
parameter_list|()
block|{
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|diff
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|SORTED_EMPTY
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_SINGLETON
argument_list|,
name|diff
operator|.
name|entriesOnlyOnLeft
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesOnlyOnRight
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesInCommon
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SORTED_EMPTY
argument_list|,
name|diff
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={1=2}"
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceTypical ()
specifier|public
name|void
name|testSortedMapDifferenceTypical
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableSortedMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|String
decl|>
name|reverseOrder
argument_list|()
decl|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
decl|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
decl|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"c"
argument_list|)
decl|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
decl|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"e"
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesDiffering
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={4=d, 2=b}: only on right={6=z}: "
operator|+
literal|"value differences={5=(e, g), 3=(c, f)}"
argument_list|,
name|diff1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|diff2
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff2
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff2
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"f"
argument_list|,
literal|"c"
argument_list|)
argument_list|,
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"g"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|,
name|diff2
operator|.
name|entriesDiffering
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"not equal: only on left={6=z}: only on right={2=b, 4=d}: "
operator|+
literal|"value differences={3=(f, c), 5=(g, e)}"
argument_list|,
name|diff2
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapDifferenceImmutable ()
specifier|public
name|void
name|testSortedMapDifferenceImmutable
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff1
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|left
operator|.
name|put
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|diff1
operator|.
name|areEqual
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|2
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|4
argument_list|,
literal|"d"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|6
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|diff1
operator|.
name|entriesDiffering
argument_list|()
operator|.
name|entrySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|3
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"c"
argument_list|,
literal|"f"
argument_list|)
argument_list|)
argument_list|,
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|5
argument_list|,
name|ValueDifferenceImpl
operator|.
name|create
argument_list|(
literal|"e"
argument_list|,
literal|"g"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|diff1
operator|.
name|entriesInCommon
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|diff1
operator|.
name|entriesOnlyOnLeft
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|diff1
operator|.
name|entriesOnlyOnRight
argument_list|()
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testSortedMapDifferenceEquals ()
specifier|public
name|void
name|testSortedMapDifferenceEquals
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|left
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|3
argument_list|,
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"d"
argument_list|,
literal|5
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"f"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|right2
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|"a"
argument_list|,
literal|3
argument_list|,
literal|"h"
argument_list|,
literal|5
argument_list|,
literal|"g"
argument_list|,
literal|6
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|original
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|same
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|reverse
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|SortedMapDifference
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|diff2
init|=
name|Maps
operator|.
name|difference
argument_list|(
name|left
argument_list|,
name|right2
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|original
argument_list|,
name|same
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|reverse
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|diff2
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|field|INT_TO_STRING_MAP
specifier|private
specifier|static
specifier|final
name|BiMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|INT_TO_STRING_MAP
init|=
operator|new
name|ImmutableBiMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|method|testUniqueIndexCollection ()
specifier|public
name|void
name|testUniqueIndexCollection
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testUniqueIndexIterable ()
specifier|public
name|void
name|testUniqueIndexIterable
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
operator|new
name|Iterable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: evil, never do this
DECL|class|IterableIterator
specifier|private
specifier|abstract
specifier|static
class|class
name|IterableIterator
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForwardingIterator
argument_list|<
name|T
argument_list|>
implements|implements
name|Iterable
argument_list|<
name|T
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// that is the purpose of this test
DECL|method|testUniqueIndexIterableIterator ()
specifier|public
name|void
name|testUniqueIndexIterableIterator
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
operator|new
name|IterableIterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|iterator
return|;
block|}
block|}
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
DECL|method|testUniqueIndexIterator ()
specifier|public
name|void
name|testUniqueIndexIterator
parameter_list|()
block|{
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|outputMap
init|=
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|Functions
operator|.
name|forMap
argument_list|(
name|INT_TO_STRING_MAP
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|INT_TO_STRING_MAP
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
comment|/** Can't create the map if more than one value maps to the same key. */
DECL|method|testUniqueIndexDuplicates ()
specifier|public
name|void
name|testUniqueIndexDuplicates
parameter_list|()
block|{
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|"uno"
argument_list|)
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
comment|/** Null values are not allowed. */
DECL|method|testUniqueIndexNullValue ()
specifier|public
name|void
name|testUniqueIndexNullValue
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|listWithNull
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|listWithNull
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
comment|/** Null keys aren't allowed either. */
DECL|method|testUniqueIndexNullKey ()
specifier|public
name|void
name|testUniqueIndexNullKey
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|oneStringList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|uniqueIndex
argument_list|(
name|oneStringList
argument_list|,
name|Functions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"Maps.fromProperties"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// StringBufferInputStream
DECL|method|testFromProperties ()
specifier|public
name|void
name|testFromProperties
parameter_list|()
throws|throws
name|IOException
block|{
name|Properties
name|testProp
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|testProp
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|testProp
operator|.
name|setProperty
argument_list|(
literal|"first"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|result
operator|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|testProp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"true"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"first"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|testProp
operator|.
name|setProperty
argument_list|(
literal|"second"
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
name|result
operator|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|testProp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"true"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"first"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"null"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"second"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now test values loaded from a stream.
name|String
name|props
init|=
literal|"test\n second = 2\n Third item :   a short  phrase   "
decl_stmt|;
comment|// TODO: change to StringReader in Java 1.6
name|testProp
operator|.
name|load
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|StringBufferInputStream
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|testProp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"true"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"first"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"second"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"item :   a short  phrase   "
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"Third"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|result
operator|.
name|containsKey
argument_list|(
literal|"not here"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test loading system properties
name|result
operator|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|containsKey
argument_list|(
literal|"java.version"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test that defaults work, too.
name|testProp
operator|=
operator|new
name|Properties
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|override
init|=
literal|"test\njava.version : hidden"
decl_stmt|;
comment|// TODO: change to StringReader in Java 1.6
name|testProp
operator|.
name|load
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|StringBufferInputStream
argument_list|(
name|override
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|Maps
operator|.
name|fromProperties
argument_list|(
name|testProp
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|>
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"hidden"
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"java.version"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|"java.version"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"Maps.fromProperties"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// never serialized
DECL|method|testFromPropertiesNullKey ()
specifier|public
name|void
name|testFromPropertiesNullKey
parameter_list|()
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enumeration
argument_list|<
name|?
argument_list|>
name|propertyNames
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|asEnumeration
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|null
argument_list|,
literal|"first"
argument_list|,
literal|"second"
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|properties
operator|.
name|setProperty
argument_list|(
literal|"first"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|setProperty
argument_list|(
literal|"second"
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
try|try
block|{
name|Maps
operator|.
name|fromProperties
argument_list|(
name|properties
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{}
block|}
annotation|@
name|GwtIncompatible
argument_list|(
literal|"Maps.fromProperties"
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
comment|// never serialized
DECL|method|testFromPropertiesNonStringKeys ()
specifier|public
name|void
name|testFromPropertiesNonStringKeys
parameter_list|()
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enumeration
argument_list|<
name|?
argument_list|>
name|propertyNames
parameter_list|()
block|{
return|return
name|Iterators
operator|.
name|asEnumeration
argument_list|(
name|Arrays
operator|.
expr|<
name|Object
operator|>
name|asList
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|123
argument_list|)
argument_list|,
literal|"first"
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
name|Maps
operator|.
name|fromProperties
argument_list|(
name|properties
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|expected
parameter_list|)
block|{}
block|}
comment|/**    * Constructs a "nefarious" map entry with the specified key and value,    * meaning an entry that is suitable for testing that map entries cannot be    * modified via a nefarious implementation of equals. This is used for testing    * unmodifiable collections of map entries; for example, it should not be    * possible to access the raw (modifiable) map entry via a nefarious equals    * method.    */
DECL|method|nefariousEntry ( final K key, final V value)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nefariousEntry
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|AbstractMapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|o
decl_stmt|;
name|e
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// muhahaha!
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|testUnmodifiableBiMap ()
specifier|public
name|void
name|testUnmodifiableBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|mod
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|mod
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|BiMap
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
name|unmod
init|=
name|Maps
operator|.
expr|<
name|Number
decl_stmt|,
name|String
decl|>
name|unmodifiableBiMap
argument_list|(
name|mod
argument_list|)
decl_stmt|;
comment|/* No aliasing on inverse operations. */
name|assertSame
argument_list|(
name|unmod
operator|.
name|inverse
argument_list|()
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|unmod
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Unmodifiable is a view. */
name|mod
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
name|unmod
operator|.
name|get
argument_list|(
literal|4
argument_list|)
operator|.
name|equals
argument_list|(
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
name|unmod
operator|.
name|inverse
argument_list|()
operator|.
name|get
argument_list|(
literal|"four"
argument_list|)
operator|.
name|equals
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UnsupportedOperationException on direct modifications. */
try|try
block|{
name|unmod
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|unmod
operator|.
name|forcePut
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|unmod
operator|.
name|putAll
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
comment|/* UnsupportedOperationException on indirect modifications. */
name|BiMap
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|inverse
init|=
name|unmod
operator|.
name|inverse
argument_list|()
decl_stmt|;
try|try
block|{
name|inverse
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|inverse
operator|.
name|forcePut
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|inverse
operator|.
name|putAll
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|Set
argument_list|<
name|String
argument_list|>
name|values
init|=
name|unmod
operator|.
name|values
argument_list|()
decl_stmt|;
try|try
block|{
name|values
operator|.
name|remove
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
argument_list|>
name|entries
init|=
name|unmod
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Number
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|entries
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setValue
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry2
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|entries
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
try|try
block|{
name|entry2
operator|.
name|setValue
argument_list|(
literal|"four"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|testBiMapEntrySetIteratorRemove ()
specifier|public
name|void
name|testBiMapEntrySetIteratorRemove
parameter_list|()
block|{
name|BiMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|map
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|entries
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|iterator
init|=
name|entries
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setValue
argument_list|(
literal|"two"
argument_list|)
expr_stmt|;
comment|// changes the iterator's current entry value
name|assertEquals
argument_list|(
literal|"two"
argument_list|,
name|map
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// removes the updated entry
name|assertTrue
argument_list|(
name|map
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testImmutableEntry ()
specifier|public
name|void
name|testImmutableEntry
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|e
init|=
name|Maps
operator|.
name|immutableEntry
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|e
operator|.
name|setValue
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
literal|"foo=1"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|101575
argument_list|,
name|e
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testImmutableEntryNull ()
specifier|public
name|void
name|testImmutableEntryNull
parameter_list|()
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|e
init|=
name|Maps
operator|.
name|immutableEntry
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|,
operator|(
name|Integer
operator|)
literal|null
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|e
operator|.
name|setValue
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"UnsupportedOperationException expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
literal|"null=null"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link SynchronizedBiMapTest} for more tests. */
DECL|method|testSynchronizedBiMap ()
specifier|public
name|void
name|testSynchronizedBiMap
parameter_list|()
block|{
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|bimap
init|=
name|HashBiMap
operator|.
name|create
argument_list|()
decl_stmt|;
name|bimap
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BiMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|sync
init|=
name|Maps
operator|.
name|synchronizedBiMap
argument_list|(
name|bimap
argument_list|)
decl_stmt|;
name|bimap
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sync
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|bimap
operator|.
name|inverse
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|sync
operator|.
name|inverse
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|NOT_LENGTH_3
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|NOT_LENGTH_3
init|=
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
name|input
operator|.
name|length
argument_list|()
operator|!=
literal|3
return|;
block|}
block|}
decl_stmt|;
DECL|field|EVEN
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Integer
argument_list|>
name|EVEN
init|=
operator|new
name|Predicate
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Integer
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
name|input
operator|%
literal|2
operator|==
literal|0
return|;
block|}
block|}
decl_stmt|;
DECL|field|CORRECT_LENGTH
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|CORRECT_LENGTH
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|()
operator|==
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|testFilteredKeysIllegalPut ()
specifier|public
name|void
name|testFilteredKeysIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"c"
argument_list|,
literal|3
argument_list|,
literal|"zzz"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredKeysChangeFiltered ()
specifier|public
name|void
name|testFilteredKeysChangeFiltered
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|remove
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredKeysChangeUnfiltered ()
specifier|public
name|void
name|testFilteredKeysChangeUnfiltered
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|remove
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesIllegalPut ()
specifier|public
name|void
name|testFilteredValuesIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"c"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"c"
argument_list|,
literal|4
argument_list|,
literal|"zzz"
argument_list|,
literal|5
argument_list|,
literal|"b"
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesIllegalSetValue ()
specifier|public
name|void
name|testFilteredValuesIllegalSetValue
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"b"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
name|filtered
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|entry
operator|.
name|setValue
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|,
literal|"b"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredValuesClear ()
specifier|public
name|void
name|testFilteredValuesClear
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"three"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"four"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"two"
argument_list|,
literal|2
argument_list|,
literal|"four"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"one"
argument_list|,
literal|1
argument_list|,
literal|"three"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|filtered
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesIllegalPut ()
specifier|public
name|void
name|testFilteredEntriesIllegalPut
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|CORRECT_LENGTH
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
name|filtered
operator|.
name|put
argument_list|(
literal|"chicken"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|put
argument_list|(
literal|"cow"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
try|try
block|{
name|filtered
operator|.
name|putAll
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"sheep"
argument_list|,
literal|5
argument_list|,
literal|"cow"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"horse"
argument_list|,
literal|5
argument_list|,
literal|"chicken"
argument_list|,
literal|7
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesObjectPredicate ()
specifier|public
name|void
name|testFilteredEntriesObjectPredicate
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Object
argument_list|>
name|predicate
init|=
name|Predicates
operator|.
name|alwaysFalse
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|filtered
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFilteredEntriesWildCardEntryPredicate ()
specifier|public
name|void
name|testFilteredEntriesWildCardEntryPredicate
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"dog"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|"horse"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|predicate
init|=
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|input
parameter_list|)
block|{
return|return
literal|"cat"
operator|.
name|equals
argument_list|(
name|input
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|Integer
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
operator|==
name|input
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"cat"
argument_list|,
literal|3
argument_list|,
literal|"dog"
argument_list|,
literal|2
argument_list|)
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformValues ()
specifier|public
name|void
name|testTransformValues
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|sqrt
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Double
name|apply
parameter_list|(
name|Integer
name|in
parameter_list|)
block|{
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|in
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|transformed
init|=
name|Maps
operator|.
name|transformValues
argument_list|(
name|map
argument_list|,
name|sqrt
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2.0
argument_list|,
literal|"b"
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformEntries ()
specifier|public
name|void
name|testTransformEntries
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"4"
argument_list|,
literal|"b"
argument_list|,
literal|"9"
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
name|concat
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|key
operator|+
name|value
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|Maps
operator|.
name|transformEntries
argument_list|(
name|map
argument_list|,
name|concat
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a4"
argument_list|,
literal|"b"
argument_list|,
literal|"b9"
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformEntriesGenerics ()
specifier|public
name|void
name|testTransformEntriesGenerics
parameter_list|()
block|{
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map1
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Number
argument_list|>
name|map2
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|map3
init|=
name|ImmutableMap
operator|.
expr|<
name|Object
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Object
argument_list|>
name|map4
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|>
name|map5
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Integer
argument_list|>
name|map6
init|=
name|ImmutableMap
operator|.
expr|<
name|Number
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|map7
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Object
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Number
argument_list|>
name|map8
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Number
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map9
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|Integer
decl|>
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|?
extends|extends
name|Number
argument_list|,
name|?
extends|extends
name|Number
argument_list|>
name|map0
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|,
name|Double
argument_list|>
name|transformer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|Number
argument_list|,
name|Number
argument_list|,
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Double
name|transformEntry
parameter_list|(
name|Number
name|key
parameter_list|,
name|Number
name|value
parameter_list|)
block|{
return|return
name|key
operator|.
name|doubleValue
argument_list|()
operator|+
name|value
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Double
argument_list|>
name|objectKeyed
decl_stmt|;
name|Map
argument_list|<
name|Number
argument_list|,
name|Double
argument_list|>
name|numberKeyed
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|integerKeyed
decl_stmt|;
name|numberKeyed
operator|=
name|transformEntries
argument_list|(
name|map5
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|numberKeyed
operator|=
name|transformEntries
argument_list|(
name|map6
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|integerKeyed
operator|=
name|transformEntries
argument_list|(
name|map8
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|integerKeyed
operator|=
name|transformEntries
argument_list|(
name|map9
argument_list|,
name|transformer
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|?
extends|extends
name|Number
argument_list|,
name|Double
argument_list|>
name|wildcarded
init|=
name|transformEntries
argument_list|(
name|map0
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
comment|// Can't loosen the key type:
comment|// objectKeyed = transformEntries(map5, transformer);
comment|// objectKeyed = transformEntries(map6, transformer);
comment|// objectKeyed = transformEntries(map8, transformer);
comment|// objectKeyed = transformEntries(map9, transformer);
comment|// numberKeyed = transformEntries(map8, transformer);
comment|// numberKeyed = transformEntries(map9, transformer);
comment|// Can't loosen the value type:
comment|// Map<Number, Number> looseValued1 = transformEntries(map5, transformer);
comment|// Map<Number, Number> looseValued2 = transformEntries(map6, transformer);
comment|// Map<Integer, Number> looseValued3 = transformEntries(map8, transformer);
comment|// Map<Integer, Number> looseValued4 = transformEntries(map9, transformer);
comment|// Can't call with too loose a key:
comment|// transformEntries(map1, transformer);
comment|// transformEntries(map2, transformer);
comment|// transformEntries(map3, transformer);
comment|// Can't call with too loose a value:
comment|// transformEntries(map1, transformer);
comment|// transformEntries(map4, transformer);
comment|// transformEntries(map7, transformer);
block|}
DECL|method|testTransformEntriesExample ()
specifier|public
name|void
name|testTransformEntriesExample
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|options
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"verbose"
argument_list|,
literal|true
argument_list|,
literal|"sort"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|,
name|String
argument_list|>
name|flagPrefixer
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
name|key
else|:
literal|"no"
operator|+
name|key
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|Maps
operator|.
name|transformEntries
argument_list|(
name|options
argument_list|,
name|flagPrefixer
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"{verbose=verbose, sort=nosort}"
argument_list|,
name|transformed
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TestStringMapGenerator uses entries of the form "one=January" and so forth.
comment|// To test the filtered collections, we'll create a map containing the entries
comment|// they ask for, plus some bogus numeric entries. Then our predicates will
comment|// simply filter numeric entries back out.
DECL|field|ENTRIES_TO_FILTER_OUT
specifier|private
specifier|static
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|ENTRIES_TO_FILTER_OUT
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
operator|.
name|put
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|)
operator|.
name|put
argument_list|(
literal|"1"
argument_list|,
literal|"1"
argument_list|)
operator|.
name|put
argument_list|(
literal|"2"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|GwtIncompatible
argument_list|(
literal|"suite"
argument_list|)
DECL|class|FilteredMapTests
specifier|public
specifier|static
class|class
name|FilteredMapTests
extends|extends
name|TestCase
block|{
DECL|method|suite ()
specifier|public
specifier|static
name|Test
name|suite
parameter_list|()
block|{
name|TestSuite
name|suite
init|=
operator|new
name|TestSuite
argument_list|()
decl_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MapTestSuiteBuilder
operator|.
name|using
argument_list|(
operator|new
name|TestStringMapGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|create
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|entries
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|putAll
argument_list|(
name|ENTRIES_TO_FILTER_OUT
argument_list|)
expr_stmt|;
return|return
name|Maps
operator|.
name|filterKeys
argument_list|(
name|map
argument_list|,
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
operator|(
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'a'
operator|&&
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'z'
operator|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|named
argument_list|(
literal|"Maps.filterKeys"
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_KEYS
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_VALUES
argument_list|,
name|MapFeature
operator|.
name|GENERAL_PURPOSE
argument_list|)
operator|.
name|suppressing
argument_list|(
name|getIteratorUnknownOrderRemoveSupportedMethod
argument_list|()
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MapTestSuiteBuilder
operator|.
name|using
argument_list|(
operator|new
name|TestStringMapGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|create
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|entries
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|putAll
argument_list|(
name|ENTRIES_TO_FILTER_OUT
argument_list|)
expr_stmt|;
return|return
name|Maps
operator|.
name|filterValues
argument_list|(
name|map
argument_list|,
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
operator|(
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'A'
operator|&&
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'Z'
operator|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|named
argument_list|(
literal|"Maps.filterValues"
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_KEYS
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_VALUES
argument_list|,
name|MapFeature
operator|.
name|GENERAL_PURPOSE
argument_list|)
operator|.
name|suppressing
argument_list|(
name|getIteratorUnknownOrderRemoveSupportedMethod
argument_list|()
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MapTestSuiteBuilder
operator|.
name|using
argument_list|(
operator|new
name|TestStringMapGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|create
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|entries
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|putAll
argument_list|(
name|ENTRIES_TO_FILTER_OUT
argument_list|)
expr_stmt|;
return|return
name|Maps
operator|.
name|filterEntries
argument_list|(
name|map
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
parameter_list|)
block|{
name|String
name|input
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
name|input
operator|==
literal|null
operator|||
operator|(
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'a'
operator|&&
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'z'
operator|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|named
argument_list|(
literal|"Maps.filterEntries"
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_KEYS
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_VALUES
argument_list|,
name|MapFeature
operator|.
name|GENERAL_PURPOSE
argument_list|)
operator|.
name|suppressing
argument_list|(
name|getIteratorUnknownOrderRemoveSupportedMethod
argument_list|()
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MapTestSuiteBuilder
operator|.
name|using
argument_list|(
operator|new
name|TestStringMapGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|create
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
index|[]
name|entries
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|putAll
argument_list|(
name|ENTRIES_TO_FILTER_OUT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|""
argument_list|,
literal|"weird"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|withoutEmptyKey
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|map
argument_list|,
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
name|input
operator|.
name|length
argument_list|()
operator|!=
literal|0
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|Maps
operator|.
name|filterKeys
argument_list|(
name|withoutEmptyKey
argument_list|,
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|input
operator|==
literal|null
operator|||
operator|(
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'a'
operator|&&
name|input
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'z'
operator|)
return|;
block|}
block|}
argument_list|)
return|;
comment|// note: these filters were deliberately chosen so that an
comment|// element somehow getting around the first filter would cause
comment|// an exception in the second
block|}
block|}
argument_list|)
operator|.
name|named
argument_list|(
literal|"Maps.filterKeys, chained"
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_KEYS
argument_list|,
name|MapFeature
operator|.
name|ALLOWS_NULL_VALUES
argument_list|,
name|MapFeature
operator|.
name|GENERAL_PURPOSE
argument_list|)
operator|.
name|suppressing
argument_list|(
name|getIteratorUnknownOrderRemoveSupportedMethod
argument_list|()
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|suite
return|;
block|}
block|}
DECL|method|testSortedMapTransformValues ()
specifier|public
name|void
name|testSortedMapTransformValues
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|,
literal|"b"
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
name|sqrt
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Double
name|apply
parameter_list|(
name|Integer
name|in
parameter_list|)
block|{
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|in
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|transformed
init|=
name|Maps
operator|.
name|transformValues
argument_list|(
name|map
argument_list|,
name|sqrt
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|2.0
argument_list|,
literal|"b"
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapTransformEntries ()
specifier|public
name|void
name|testSortedMapTransformEntries
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"4"
argument_list|,
literal|"b"
argument_list|,
literal|"9"
argument_list|)
decl_stmt|;
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
name|concat
init|=
operator|new
name|EntryTransformer
argument_list|<
name|String
argument_list|,
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transformEntry
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|key
operator|+
name|value
return|;
block|}
block|}
decl_stmt|;
name|SortedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|transformed
init|=
name|Maps
operator|.
name|transformEntries
argument_list|(
name|map
argument_list|,
name|concat
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSortedMap
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a4"
argument_list|,
literal|"b"
argument_list|,
literal|"b9"
argument_list|)
argument_list|,
name|transformed
argument_list|)
expr_stmt|;
block|}
comment|/*    * Not testing Map methods of Maps.filter*(SortedMap), since the    * implementation doesn't override Maps.FilteredEntryMap, which is already    * tested.    */
DECL|method|testSortedMapFilterKeys ()
specifier|public
name|void
name|testSortedMapFilterKeys
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"five"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|6
argument_list|,
literal|"six"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"seven"
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterKeys
argument_list|(
name|unfiltered
argument_list|,
name|EVEN
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|filtered
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|Integer
operator|)
literal|2
argument_list|,
name|filtered
operator|.
name|firstKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|Integer
operator|)
literal|6
argument_list|,
name|filtered
operator|.
name|lastKey
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|headMap
argument_list|(
literal|5
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|tailMap
argument_list|(
literal|3
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|subMap
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedMapFilterValues ()
specifier|public
name|void
name|testSortedMapFilterValues
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|unfiltered
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"five"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|6
argument_list|,
literal|"six"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|7
argument_list|,
literal|"seven"
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|filtered
init|=
name|Maps
operator|.
name|filterValues
argument_list|(
name|unfiltered
argument_list|,
name|NOT_LENGTH_3
argument_list|)
decl_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|filtered
operator|.
name|comparator
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|Integer
operator|)
literal|3
argument_list|,
name|filtered
operator|.
name|firstKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|Integer
operator|)
literal|7
argument_list|,
name|filtered
operator|.
name|lastKey
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|headMap
argument_list|(
literal|5
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|tailMap
argument_list|(
literal|4
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|ASSERT
operator|.
name|that
argument_list|(
name|filtered
operator|.
name|subMap
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|hasContentsInOrder
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
DECL|field|EVEN_AND_LENGTH_3
name|EVEN_AND_LENGTH_3
init|=
operator|new
name|Predicate
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|||
name|entry
operator|.
name|getKey
argument_list|()
operator|%
literal|2
operator|==
literal|0
operator|)
operator|&&
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
operator|||
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|3
operator|)
return|;
block|}
block|}
decl_stmt|;
DECL|class|ContainsKeySafeSortedMap
specifier|private
specifier|static
class|class
name|ContainsKeySafeSortedMap
extends|extends
name|ForwardingSortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
block|{
DECL|field|delegate
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|delegate
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|delegate ()
annotation|@
name|Override
specifier|protected
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
comment|// Needed by MapInterfaceTest.testContainsKey()
DECL|method|containsKey (Object key)
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
DECL|class|FilteredEntriesSortedMapInterfaceTest
specifier|public
specifier|static
class|class
name|FilteredEntriesSortedMapInterfaceTest
extends|extends
name|SortedMapInterfaceTest
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
block|{
DECL|method|FilteredEntriesSortedMapInterfaceTest ()
specifier|public
name|FilteredEntriesSortedMapInterfaceTest
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|makeEmptyMap ()
annotation|@
name|Override
specifier|protected
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|makeEmptyMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|unfiltered
init|=
operator|new
name|ContainsKeySafeSortedMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"five"
argument_list|)
expr_stmt|;
return|return
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|EVEN_AND_LENGTH_3
argument_list|)
return|;
block|}
DECL|method|makePopulatedMap ()
annotation|@
name|Override
specifier|protected
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|makePopulatedMap
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|unfiltered
init|=
operator|new
name|ContainsKeySafeSortedMap
argument_list|()
decl_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|2
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|3
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|4
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|5
argument_list|,
literal|"five"
argument_list|)
expr_stmt|;
name|unfiltered
operator|.
name|put
argument_list|(
literal|6
argument_list|,
literal|"six"
argument_list|)
expr_stmt|;
return|return
name|Maps
operator|.
name|filterEntries
argument_list|(
name|unfiltered
argument_list|,
name|EVEN_AND_LENGTH_3
argument_list|)
return|;
block|}
DECL|method|getKeyNotInPopulatedMap ()
annotation|@
name|Override
specifier|protected
name|Integer
name|getKeyNotInPopulatedMap
parameter_list|()
block|{
return|return
literal|10
return|;
block|}
DECL|method|getValueNotInPopulatedMap ()
annotation|@
name|Override
specifier|protected
name|String
name|getValueNotInPopulatedMap
parameter_list|()
block|{
return|return
literal|"ten"
return|;
block|}
comment|// Iterators don't support remove.
DECL|method|testEntrySetIteratorRemove ()
annotation|@
name|Override
specifier|public
name|void
name|testEntrySetIteratorRemove
parameter_list|()
block|{}
DECL|method|testValuesIteratorRemove ()
annotation|@
name|Override
specifier|public
name|void
name|testValuesIteratorRemove
parameter_list|()
block|{}
comment|// These tests fail on GWT.
comment|// TODO: Investigate why.
DECL|method|testEntrySetRemoveAll ()
annotation|@
name|Override
specifier|public
name|void
name|testEntrySetRemoveAll
parameter_list|()
block|{}
DECL|method|testEntrySetRetainAll ()
annotation|@
name|Override
specifier|public
name|void
name|testEntrySetRetainAll
parameter_list|()
block|{}
block|}
block|}
end_class

end_unit

