begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMakerInternalMap
operator|.
name|Strength
operator|.
name|STRONG
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMakerInternalMap
operator|.
name|Strength
operator|.
name|WEAK
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|SerializableTester
operator|.
name|reserializeAndAssert
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|easymock
operator|.
name|EasyMock
operator|.
name|eq
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|easymock
operator|.
name|EasyMock
operator|.
name|expect
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|easymock
operator|.
name|EasyMock
operator|.
name|isA
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Equivalence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|RemovalListener
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
operator|.
name|RemovalNotification
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|features
operator|.
name|CollectionFeature
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|features
operator|.
name|CollectionSize
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|google
operator|.
name|MultisetTestSuiteBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|google
operator|.
name|TestStringMultisetGenerator
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|easymock
operator|.
name|EasyMock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * Test case for {@link ConcurrentHashMultiset}.  *  * @author Cliff L. Biffle  * @author mike nonemacher  */
end_comment

begin_class
DECL|class|ConcurrentHashMultisetTest
specifier|public
class|class
name|ConcurrentHashMultisetTest
extends|extends
name|TestCase
block|{
annotation|@
name|SuppressUnderAndroid
DECL|method|suite ()
specifier|public
specifier|static
name|Test
name|suite
parameter_list|()
block|{
name|TestSuite
name|suite
init|=
operator|new
name|TestSuite
argument_list|()
decl_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MultisetTestSuiteBuilder
operator|.
name|using
argument_list|(
name|concurrentHashMultisetGenerator
argument_list|()
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|CollectionFeature
operator|.
name|GENERAL_PURPOSE
argument_list|,
name|CollectionFeature
operator|.
name|SERIALIZABLE
argument_list|,
name|CollectionFeature
operator|.
name|ALLOWS_NULL_QUERIES
argument_list|)
operator|.
name|named
argument_list|(
literal|"ConcurrentHashMultiset"
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|MultisetTestSuiteBuilder
operator|.
name|using
argument_list|(
name|concurrentSkipListMultisetGenerator
argument_list|()
argument_list|)
operator|.
name|withFeatures
argument_list|(
name|CollectionSize
operator|.
name|ANY
argument_list|,
name|CollectionFeature
operator|.
name|KNOWN_ORDER
argument_list|,
name|CollectionFeature
operator|.
name|GENERAL_PURPOSE
argument_list|,
name|CollectionFeature
operator|.
name|SERIALIZABLE
argument_list|,
name|CollectionFeature
operator|.
name|ALLOWS_NULL_QUERIES
argument_list|)
operator|.
name|named
argument_list|(
literal|"ConcurrentSkipListMultiset"
argument_list|)
operator|.
name|createTestSuite
argument_list|()
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTestSuite
argument_list|(
name|ConcurrentHashMultisetTest
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|suite
return|;
block|}
DECL|method|concurrentHashMultisetGenerator ()
specifier|private
specifier|static
name|TestStringMultisetGenerator
name|concurrentHashMultisetGenerator
parameter_list|()
block|{
return|return
operator|new
name|TestStringMultisetGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Multiset
argument_list|<
name|String
argument_list|>
name|create
parameter_list|(
name|String
index|[]
name|elements
parameter_list|)
block|{
return|return
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|asList
argument_list|(
name|elements
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|concurrentSkipListMultisetGenerator ()
specifier|private
specifier|static
name|TestStringMultisetGenerator
name|concurrentSkipListMultisetGenerator
parameter_list|()
block|{
return|return
operator|new
name|TestStringMultisetGenerator
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Multiset
argument_list|<
name|String
argument_list|>
name|create
parameter_list|(
name|String
index|[]
name|elements
parameter_list|)
block|{
name|Multiset
argument_list|<
name|String
argument_list|>
name|multiset
init|=
operator|new
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
argument_list|(
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|multiset
argument_list|,
name|elements
argument_list|)
expr_stmt|;
return|return
name|multiset
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|order
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|insertionOrder
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|sortedCopy
argument_list|(
name|insertionOrder
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|field|KEY
specifier|private
specifier|static
specifier|final
name|String
name|KEY
init|=
literal|"puppies"
decl_stmt|;
DECL|field|backingMap
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|backingMap
decl_stmt|;
DECL|field|multiset
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|multiset
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|setUp ()
annotation|@
name|Override
specifier|protected
name|void
name|setUp
parameter_list|()
block|{
name|backingMap
operator|=
name|EasyMock
operator|.
name|createMock
argument_list|(
name|ConcurrentMap
operator|.
name|class
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|isEmpty
argument_list|()
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|multiset
operator|=
operator|new
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
argument_list|(
name|backingMap
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|method|testCount_elementPresent ()
specifier|public
name|void
name|testCount_elementPresent
parameter_list|()
block|{
specifier|final
name|int
name|COUNT
init|=
literal|12
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
operator|new
name|AtomicInteger
argument_list|(
name|COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|COUNT
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|KEY
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testCount_elementAbsent ()
specifier|public
name|void
name|testCount_elementAbsent
parameter_list|()
block|{
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|KEY
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testAdd_zero ()
specifier|public
name|void
name|testAdd_zero
parameter_list|()
block|{
specifier|final
name|int
name|INITIAL_COUNT
init|=
literal|32
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
operator|new
name|AtomicInteger
argument_list|(
name|INITIAL_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|INITIAL_COUNT
argument_list|,
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testAdd_firstFewWithSuccess ()
specifier|public
name|void
name|testAdd_firstFewWithSuccess
parameter_list|()
block|{
specifier|final
name|int
name|COUNT
init|=
literal|400
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|putIfAbsent
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|,
name|COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testAdd_laterFewWithSuccess ()
specifier|public
name|void
name|testAdd_laterFewWithSuccess
parameter_list|()
block|{
name|int
name|INITIAL_COUNT
init|=
literal|32
decl_stmt|;
name|int
name|COUNT_TO_ADD
init|=
literal|400
decl_stmt|;
name|AtomicInteger
name|initial
init|=
operator|new
name|AtomicInteger
argument_list|(
name|INITIAL_COUNT
argument_list|)
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|initial
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|INITIAL_COUNT
argument_list|,
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|,
name|COUNT_TO_ADD
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|INITIAL_COUNT
operator|+
name|COUNT_TO_ADD
argument_list|,
name|initial
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testAdd_laterFewWithOverflow ()
specifier|public
name|void
name|testAdd_laterFewWithOverflow
parameter_list|()
block|{
specifier|final
name|int
name|INITIAL_COUNT
init|=
literal|92384930
decl_stmt|;
specifier|final
name|int
name|COUNT_TO_ADD
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|INITIAL_COUNT
operator|+
literal|1
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
operator|new
name|AtomicInteger
argument_list|(
name|INITIAL_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
try|try
block|{
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|,
name|COUNT_TO_ADD
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Must reject arguments that would cause counter overflow."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
name|verify
argument_list|()
expr_stmt|;
block|}
comment|/**    * Simulate some of the races that can happen on add. We can't easily simulate the race that    * happens when an {@link AtomicInteger#compareAndSet} fails, but we can simulate the case where    * the putIfAbsent returns a non-null value, and the case where the replace() of an observed    * zero fails.    */
DECL|method|testAdd_withFailures ()
specifier|public
name|void
name|testAdd_withFailures
parameter_list|()
block|{
name|AtomicInteger
name|existing
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|AtomicInteger
name|existingZero
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// initial map.get()
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// since get returned null, try a putIfAbsent; that fails due to a simulated race
name|expect
argument_list|(
name|backingMap
operator|.
name|putIfAbsent
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|existingZero
argument_list|)
expr_stmt|;
comment|// since the putIfAbsent returned a zero, we'll try to replace...
name|expect
argument_list|(
name|backingMap
operator|.
name|replace
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|eq
argument_list|(
name|existingZero
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// ...and then putIfAbsent. Simulate failure on both
name|expect
argument_list|(
name|backingMap
operator|.
name|putIfAbsent
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|existing
argument_list|)
expr_stmt|;
comment|// next map.get()
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|existingZero
argument_list|)
expr_stmt|;
comment|// since get returned zero, try a replace; that fails due to a simulated race
name|expect
argument_list|(
name|backingMap
operator|.
name|replace
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|eq
argument_list|(
name|existingZero
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|putIfAbsent
argument_list|(
name|eq
argument_list|(
name|KEY
argument_list|)
argument_list|,
name|isA
argument_list|(
name|AtomicInteger
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|existing
argument_list|)
expr_stmt|;
comment|// another map.get()
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|existing
argument_list|)
expr_stmt|;
comment|// we shouldn't see any more map operations; CHM will now just update the AtomicInteger
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|15
argument_list|,
name|existing
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemove_zeroFromSome ()
specifier|public
name|void
name|testRemove_zeroFromSome
parameter_list|()
block|{
specifier|final
name|int
name|INITIAL_COUNT
init|=
literal|14
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
operator|new
name|AtomicInteger
argument_list|(
name|INITIAL_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|INITIAL_COUNT
argument_list|,
name|multiset
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemove_zeroFromNone ()
specifier|public
name|void
name|testRemove_zeroFromNone
parameter_list|()
block|{
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemove_nonePresent ()
specifier|public
name|void
name|testRemove_nonePresent
parameter_list|()
block|{
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
literal|400
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemove_someRemaining ()
specifier|public
name|void
name|testRemove_someRemaining
parameter_list|()
block|{
name|int
name|countToRemove
init|=
literal|30
decl_stmt|;
name|int
name|countRemaining
init|=
literal|1
decl_stmt|;
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|(
name|countToRemove
operator|+
name|countRemaining
argument_list|)
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|countToRemove
operator|+
name|countRemaining
argument_list|,
name|multiset
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
name|countToRemove
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|countRemaining
argument_list|,
name|current
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemove_noneRemaining ()
specifier|public
name|void
name|testRemove_noneRemaining
parameter_list|()
block|{
name|int
name|countToRemove
init|=
literal|30
decl_stmt|;
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|(
name|countToRemove
argument_list|)
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|// it's ok if removal fails: another thread may have done the remove
name|expect
argument_list|(
name|backingMap
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
name|current
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|countToRemove
argument_list|,
name|multiset
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
name|countToRemove
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|current
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testRemoveExactly ()
specifier|public
name|void
name|testRemoveExactly
parameter_list|()
block|{
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|cms
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
name|cms
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cms
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
try|try
block|{
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"a"
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|assertTrue
argument_list|(
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"a"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|cms
operator|.
name|count
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"c"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|cms
operator|.
name|count
argument_list|(
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"a"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|cms
operator|.
name|count
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|cms
operator|.
name|count
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cms
operator|.
name|removeExactly
argument_list|(
literal|"b"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|cms
operator|.
name|count
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testIteratorRemove_actualMap ()
specifier|public
name|void
name|testIteratorRemove_actualMap
parameter_list|()
block|{
comment|// Override to avoid using mocks.
name|multiset
operator|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|KEY
operator|+
literal|"_2"
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|KEY
argument_list|)
expr_stmt|;
name|int
name|mutations
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|multiset
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|mutations
operator|++
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|multiset
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|mutations
argument_list|)
expr_stmt|;
block|}
DECL|method|testSetCount_basic ()
specifier|public
name|void
name|testSetCount_basic
parameter_list|()
block|{
name|int
name|initialCount
init|=
literal|20
decl_stmt|;
name|int
name|countToSet
init|=
literal|40
decl_stmt|;
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|(
name|initialCount
argument_list|)
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|initialCount
argument_list|,
name|multiset
operator|.
name|setCount
argument_list|(
name|KEY
argument_list|,
name|countToSet
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|countToSet
argument_list|,
name|current
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testSetCount_asRemove ()
specifier|public
name|void
name|testSetCount_asRemove
parameter_list|()
block|{
name|int
name|countToRemove
init|=
literal|40
decl_stmt|;
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|(
name|countToRemove
argument_list|)
decl_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|backingMap
operator|.
name|remove
argument_list|(
name|KEY
argument_list|,
name|current
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|countToRemove
argument_list|,
name|multiset
operator|.
name|setCount
argument_list|(
name|KEY
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|current
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testSetCount_0_nonePresent ()
specifier|public
name|void
name|testSetCount_0_nonePresent
parameter_list|()
block|{
name|expect
argument_list|(
name|backingMap
operator|.
name|get
argument_list|(
name|KEY
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|replay
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|setCount
argument_list|(
name|KEY
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|()
expr_stmt|;
block|}
DECL|method|testCreate ()
specifier|public
name|void
name|testCreate
parameter_list|()
block|{
name|ConcurrentHashMultiset
argument_list|<
name|Integer
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
block|}
DECL|method|testCreateFromIterable ()
specifier|public
name|void
name|testCreateFromIterable
parameter_list|()
block|{
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|iterable
init|=
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|ConcurrentHashMultiset
argument_list|<
name|Integer
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|iterable
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
block|}
DECL|method|testIdentityKeyEquality_strongKeys ()
specifier|public
name|void
name|testIdentityKeyEquality_strongKeys
parameter_list|()
block|{
name|testIdentityKeyEquality
argument_list|(
name|STRONG
argument_list|)
expr_stmt|;
block|}
DECL|method|testIdentityKeyEquality_weakKeys ()
specifier|public
name|void
name|testIdentityKeyEquality_weakKeys
parameter_list|()
block|{
name|testIdentityKeyEquality
argument_list|(
name|WEAK
argument_list|)
expr_stmt|;
block|}
DECL|method|testIdentityKeyEquality ( MapMakerInternalMap.Strength keyStrength)
specifier|private
name|void
name|testIdentityKeyEquality
parameter_list|(
name|MapMakerInternalMap
operator|.
name|Strength
name|keyStrength
parameter_list|)
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|Equivalence
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
decl_stmt|;
name|String
name|s1
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|// Stating the obvious.
name|assertTrue
argument_list|(
name|s1
operator|!=
name|s2
argument_list|)
expr_stmt|;
comment|// Stating the obvious.
name|multiset
operator|.
name|add
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|s2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|remove
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testLogicalKeyEquality_strongKeys ()
specifier|public
name|void
name|testLogicalKeyEquality_strongKeys
parameter_list|()
block|{
name|testLogicalKeyEquality
argument_list|(
name|STRONG
argument_list|)
expr_stmt|;
block|}
DECL|method|testLogicalKeyEquality_weakKeys ()
specifier|public
name|void
name|testLogicalKeyEquality_weakKeys
parameter_list|()
block|{
name|testLogicalKeyEquality
argument_list|(
name|WEAK
argument_list|)
expr_stmt|;
block|}
DECL|method|testLogicalKeyEquality ( MapMakerInternalMap.Strength keyStrength)
specifier|private
name|void
name|testLogicalKeyEquality
parameter_list|(
name|MapMakerInternalMap
operator|.
name|Strength
name|keyStrength
parameter_list|)
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|setKeyStrength
argument_list|(
name|keyStrength
argument_list|)
operator|.
name|keyEquivalence
argument_list|(
name|Equivalence
operator|.
name|equals
argument_list|()
argument_list|)
decl_stmt|;
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
decl_stmt|;
name|String
name|s1
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|// Stating the obvious.
name|multiset
operator|.
name|add
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
name|s2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|remove
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSerializationWithMapMaker1 ()
specifier|public
name|void
name|testSerializationWithMapMaker1
parameter_list|()
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
decl_stmt|;
name|multiset
operator|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
block|}
DECL|method|testSerializationWithMapMaker2 ()
specifier|public
name|void
name|testSerializationWithMapMaker2
parameter_list|()
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
decl_stmt|;
name|multiset
operator|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|addAll
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
block|}
DECL|method|testSerializationWithMapMaker3 ()
specifier|public
name|void
name|testSerializationWithMapMaker3
parameter_list|()
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|expireAfterWrite
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
name|multiset
operator|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|addAll
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
block|}
DECL|method|testSerializationWithMapMaker_preservesIdentityKeyEquivalence ()
specifier|public
name|void
name|testSerializationWithMapMaker_preservesIdentityKeyEquivalence
parameter_list|()
block|{
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|keyEquivalence
argument_list|(
name|Equivalence
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
decl_stmt|;
name|multiset
operator|=
name|reserializeAndAssert
argument_list|(
name|multiset
argument_list|)
expr_stmt|;
name|String
name|s1
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
operator|new
name|String
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|// Stating the obvious.
name|assertTrue
argument_list|(
name|s1
operator|!=
name|s2
argument_list|)
expr_stmt|;
comment|// Stating the obvious.
name|multiset
operator|.
name|add
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//  @Suppress(owner = "bmanes", detail = "Does not call the eviction listener")
comment|//  public void testWithMapMakerEvictionListener_BROKEN1()
comment|//      throws InterruptedException {
comment|//    MapEvictionListener<String, Number> evictionListener =
comment|//        mockEvictionListener();
comment|//    evictionListener.onEviction("a", 5);
comment|//    EasyMock.replay(evictionListener);
comment|//
comment|//    GenericMapMaker<String, Number> mapMaker = new MapMaker()
comment|//        .expireAfterWrite(100, TimeUnit.MILLISECONDS)
comment|//        .evictionListener(evictionListener);
comment|//
comment|//    ConcurrentHashMultiset<String> multiset =
comment|//        ConcurrentHashMultiset.create(mapMaker);
comment|//
comment|//    multiset.add("a", 5);
comment|//
comment|//    assertTrue(multiset.contains("a"));
comment|//    assertEquals(5, multiset.count("a"));
comment|//
comment|//    Thread.sleep(2000);
comment|//
comment|//    EasyMock.verify(evictionListener);
comment|//  }
comment|//  @Suppress(owner = "bmanes", detail = "Does not call the eviction listener")
comment|//  public void testWithMapMakerEvictionListener_BROKEN2()
comment|//      throws InterruptedException {
comment|//    MapEvictionListener<String, Number> evictionListener =
comment|//        mockEvictionListener();
comment|//    evictionListener.onEviction("a", 5);
comment|//    EasyMock.replay(evictionListener);
comment|//
comment|//    GenericMapMaker<String, Number> mapMaker = new MapMaker()
comment|//        .expireAfterWrite(100, TimeUnit.MILLISECONDS)
comment|//        .evictionListener(evictionListener);
comment|//
comment|//    ConcurrentHashMultiset<String> multiset =
comment|//        ConcurrentHashMultiset.create(mapMaker);
comment|//
comment|//    multiset.add("a", 5);
comment|//
comment|//    assertTrue(multiset.contains("a"));
comment|//    assertEquals(5, multiset.count("a"));
comment|//
comment|//    Thread.sleep(2000);
comment|//
comment|//    // This call should have the side-effect of calling the
comment|//    // eviction listener, but it does not.
comment|//    assertFalse(multiset.contains("a"));
comment|//
comment|//    EasyMock.verify(evictionListener);
comment|//  }
DECL|method|testWithMapMakerEvictionListener ()
specifier|public
name|void
name|testWithMapMakerEvictionListener
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RemovalNotification
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
argument_list|>
name|notificationQueue
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|RemovalListener
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|removalListener
init|=
operator|new
name|RemovalListener
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onRemoval
parameter_list|(
name|RemovalNotification
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|notification
parameter_list|)
block|{
name|notificationQueue
operator|.
name|add
argument_list|(
name|notification
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// TODO(kevinb): what to do?
name|MapMaker
name|mapMaker
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|concurrencyLevel
argument_list|(
literal|1
argument_list|)
operator|.
name|maximumSize
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/*      * Cleverly ignore the return type now that ConcurrentHashMultiset accepts only MapMaker and not      * the deprecated GenericMapMaker. We know that a RemovalListener<String, Number> is a type that      * will work with ConcurrentHashMultiset.      */
name|mapMaker
operator|.
name|removalListener
argument_list|(
name|removalListener
argument_list|)
expr_stmt|;
name|ConcurrentHashMultiset
argument_list|<
name|String
argument_list|>
name|multiset
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|(
name|mapMaker
argument_list|)
decl_stmt|;
name|multiset
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|multiset
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|multiset
operator|.
name|contains
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|multiset
operator|.
name|count
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|RemovalNotification
argument_list|<
name|String
argument_list|,
name|Number
argument_list|>
name|notification
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|notificationQueue
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|notification
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// The map evicted this entry, so CHM didn't have a chance to zero it.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|notification
operator|.
name|getValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|replay ()
specifier|private
name|void
name|replay
parameter_list|()
block|{
name|EasyMock
operator|.
name|replay
argument_list|(
name|backingMap
argument_list|)
expr_stmt|;
block|}
DECL|method|verify ()
specifier|private
name|void
name|verify
parameter_list|()
block|{
name|EasyMock
operator|.
name|verify
argument_list|(
name|backingMap
argument_list|)
expr_stmt|;
block|}
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|EasyMock
operator|.
name|reset
argument_list|(
name|backingMap
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

