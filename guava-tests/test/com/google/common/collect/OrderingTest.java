begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2007 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.collect
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|SerializableTester
operator|.
name|reserialize
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|SerializableTester
operator|.
name|reserializeAndAssert
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
operator|.
name|ArbitraryOrdering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
operator|.
name|IncomparableValueException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|testing
operator|.
name|Helpers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|EqualsTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@code Ordering}.  *  * @author Jesse Wilson  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|OrderingTest
specifier|public
class|class
name|OrderingTest
extends|extends
name|TestCase
block|{
comment|// TODO(cpovirk): some of these are inexplicably slow (20-30s) under GWT
DECL|field|numberOrdering
specifier|private
specifier|final
name|Ordering
argument_list|<
name|Number
argument_list|>
name|numberOrdering
init|=
operator|new
name|NumberOrdering
argument_list|()
decl_stmt|;
DECL|method|testAllEqual ()
specifier|public
name|void
name|testAllEqual
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Object
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|allEqual
argument_list|()
decl_stmt|;
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|comparator
operator|.
name|reverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
operator|new
name|Object
argument_list|()
argument_list|,
operator|new
name|Object
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"apples"
argument_list|,
literal|"oranges"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|reserialize
argument_list|(
name|comparator
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.allEqual()"
argument_list|,
name|comparator
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|strings
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"b"
argument_list|,
literal|"a"
argument_list|,
literal|"d"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|strings
argument_list|,
name|comparator
operator|.
name|sortedCopy
argument_list|(
name|strings
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|strings
argument_list|,
name|comparator
operator|.
name|immutableSortedCopy
argument_list|(
name|strings
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// From https://github.com/google/guava/issues/1342
DECL|method|testComplicatedOrderingExample ()
specifier|public
name|void
name|testComplicatedOrderingExample
parameter_list|()
block|{
name|Integer
name|nullInt
init|=
operator|(
name|Integer
operator|)
literal|null
decl_stmt|;
name|Ordering
argument_list|<
name|Iterable
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|example
init|=
name|Ordering
operator|.
expr|<
name|Integer
operator|>
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
operator|.
name|reverse
argument_list|()
operator|.
name|lexicographical
argument_list|()
operator|.
name|reverse
argument_list|()
operator|.
name|nullsLast
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list1
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list2
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list3
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list4
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list5
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list6
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list7
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nullInt
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list8
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|list1
argument_list|,
name|list2
argument_list|,
name|list3
argument_list|,
name|list4
argument_list|,
name|list5
argument_list|,
name|list6
argument_list|,
name|list7
argument_list|,
name|list8
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|sorted
init|=
name|example
operator|.
name|sortedCopy
argument_list|(
name|list
argument_list|)
decl_stmt|;
comment|// [[null, null], [null], [1, null, 2], [1, 1], [1, 2], [1], [2], [], null]
name|assertThat
argument_list|(
name|sorted
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|,
literal|2
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|2
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|()
argument_list|,
literal|null
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testNatural ()
specifier|public
name|void
name|testNatural
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|comparator
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
try|try
block|{
name|comparator
operator|.
name|compare
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|comparator
operator|.
name|compare
argument_list|(
literal|null
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|comparator
operator|.
name|compare
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{}
name|assertSame
argument_list|(
name|comparator
argument_list|,
name|reserialize
argument_list|(
name|comparator
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.natural()"
argument_list|,
name|comparator
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFrom ()
specifier|public
name|void
name|testFrom
parameter_list|()
block|{
name|Ordering
argument_list|<
name|String
argument_list|>
name|caseInsensitiveOrdering
init|=
name|Ordering
operator|.
name|from
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|caseInsensitiveOrdering
operator|.
name|compare
argument_list|(
literal|"A"
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|caseInsensitiveOrdering
operator|.
name|compare
argument_list|(
literal|"a"
argument_list|,
literal|"B"
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|caseInsensitiveOrdering
operator|.
name|compare
argument_list|(
literal|"B"
argument_list|,
literal|"a"
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
comment|// test of deprecated method
name|Ordering
argument_list|<
name|String
argument_list|>
name|orderingFromOrdering
init|=
name|Ordering
operator|.
name|from
argument_list|(
name|Ordering
operator|.
expr|<
name|String
operator|>
name|natural
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|caseInsensitiveOrdering
argument_list|,
name|Ordering
operator|.
name|from
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|orderingFromOrdering
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testExplicit_none ()
specifier|public
name|void
name|testExplicit_none
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|c
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IncomparableValueException
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|expected
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|reserializeAndAssert
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|testExplicit_one ()
specifier|public
name|void
name|testExplicit_one
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|c
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|c
operator|.
name|compare
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IncomparableValueException
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|expected
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|reserializeAndAssert
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.explicit([0])"
argument_list|,
name|c
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testExplicit_two ()
specifier|public
name|void
name|testExplicit_two
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
literal|42
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|c
operator|.
name|compare
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|c
operator|.
name|compare
argument_list|(
literal|5
argument_list|,
literal|42
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|c
operator|.
name|compare
argument_list|(
literal|42
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|c
operator|.
name|compare
argument_list|(
literal|5
argument_list|,
literal|666
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IncomparableValueException
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|666
argument_list|,
name|expected
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|c
argument_list|,
name|Ordering
operator|.
name|explicit
argument_list|(
literal|42
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|explicit
argument_list|(
literal|5
argument_list|,
literal|42
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|explicit
argument_list|(
literal|42
argument_list|)
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|testExplicit_sortingExample ()
specifier|public
name|void
name|testExplicit_sortingExample
parameter_list|()
block|{
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|list
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|8
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|testExplicit_withDuplicates ()
specifier|public
name|void
name|testExplicit_withDuplicates
parameter_list|()
block|{
try|try
block|{
name|Ordering
operator|.
name|explicit
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
comment|// A more limited test than the one that follows, but this one uses the
comment|// actual public API.
DECL|method|testArbitrary_withoutCollisions ()
specifier|public
name|void
name|testArbitrary_withoutCollisions
parameter_list|()
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|new
name|Object
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Ordering
argument_list|<
name|Object
argument_list|>
name|arbitrary
init|=
name|Ordering
operator|.
name|arbitrary
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|,
name|arbitrary
argument_list|)
expr_stmt|;
comment|// Now we don't care what order it's put the list in, only that
comment|// comparing any pair of elements gives the answer we expect.
name|Helpers
operator|.
name|testComparator
argument_list|(
name|arbitrary
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.arbitrary()"
argument_list|,
name|arbitrary
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testArbitrary_withCollisions ()
specifier|public
name|void
name|testArbitrary_withCollisions
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|Ordering
argument_list|<
name|Object
argument_list|>
name|arbitrary
init|=
operator|new
name|ArbitraryOrdering
argument_list|()
block|{
annotation|@
name|Override
name|int
name|identityHashCode
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Integer
operator|)
name|object
operator|)
operator|%
literal|5
return|;
comment|// fake tons of collisions!
block|}
block|}
decl_stmt|;
comment|// Don't let the elements be in such a predictable order
name|list
operator|=
name|shuffledCopy
argument_list|(
name|list
argument_list|,
operator|new
name|Random
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|,
name|arbitrary
argument_list|)
expr_stmt|;
comment|// Now we don't care what order it's put the list in, only that
comment|// comparing any pair of elements gives the answer we expect.
name|Helpers
operator|.
name|testComparator
argument_list|(
name|arbitrary
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
DECL|method|testUsingToString ()
specifier|public
name|void
name|testUsingToString
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Object
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|usingToString
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|ordering
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
literal|124
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.usingToString()"
argument_list|,
name|ordering
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|ordering
argument_list|,
name|reserialize
argument_list|(
name|ordering
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// use an enum to get easy serializability
DECL|enum|CharAtFunction
specifier|private
enum|enum
name|CharAtFunction
implements|implements
name|Function
argument_list|<
name|String
argument_list|,
name|Character
argument_list|>
block|{
DECL|enumConstant|AT0
name|AT0
argument_list|(
literal|0
argument_list|)
block|,
DECL|enumConstant|AT1
name|AT1
argument_list|(
literal|1
argument_list|)
block|,
DECL|enumConstant|AT2
name|AT2
argument_list|(
literal|2
argument_list|)
block|,
DECL|enumConstant|AT3
name|AT3
argument_list|(
literal|3
argument_list|)
block|,
DECL|enumConstant|AT4
name|AT4
argument_list|(
literal|4
argument_list|)
block|,
DECL|enumConstant|AT5
name|AT5
argument_list|(
literal|5
argument_list|)
block|,     ;
DECL|field|index
specifier|final
name|int
name|index
decl_stmt|;
DECL|method|CharAtFunction (int index)
name|CharAtFunction
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|apply (String string)
specifier|public
name|Character
name|apply
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
name|string
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
DECL|method|byCharAt (int index)
specifier|private
specifier|static
name|Ordering
argument_list|<
name|String
argument_list|>
name|byCharAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
name|CharAtFunction
operator|.
name|values
argument_list|()
index|[
name|index
index|]
argument_list|)
return|;
block|}
DECL|method|testCompound_static ()
specifier|public
name|void
name|testCompound_static
parameter_list|()
block|{
name|Comparator
argument_list|<
name|String
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|compound
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|byCharAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|byCharAt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|byCharAt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|byCharAt
argument_list|(
literal|3
argument_list|)
argument_list|,
name|byCharAt
argument_list|(
literal|4
argument_list|)
argument_list|,
name|byCharAt
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|comparator
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"applesauce"
argument_list|,
literal|"apricot"
argument_list|,
literal|"artichoke"
argument_list|,
literal|"banality"
argument_list|,
literal|"banana"
argument_list|,
literal|"banquet"
argument_list|,
literal|"tangelo"
argument_list|,
literal|"tangerine"
argument_list|)
argument_list|)
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
DECL|method|testCompound_instance ()
specifier|public
name|void
name|testCompound_instance
parameter_list|()
block|{
name|Comparator
argument_list|<
name|String
argument_list|>
name|comparator
init|=
name|byCharAt
argument_list|(
literal|1
argument_list|)
operator|.
name|compound
argument_list|(
name|byCharAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|comparator
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"red"
argument_list|,
literal|"yellow"
argument_list|,
literal|"violet"
argument_list|,
literal|"blue"
argument_list|,
literal|"indigo"
argument_list|,
literal|"green"
argument_list|,
literal|"orange"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testCompound_instance_generics ()
specifier|public
name|void
name|testCompound_instance_generics
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Object
argument_list|>
name|objects
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
operator|(
name|Object
operator|)
literal|1
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Number
argument_list|>
name|numbers
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
operator|(
name|Number
operator|)
literal|1
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|integers
init|=
name|Ordering
operator|.
name|explicit
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Like by like equals like
name|Ordering
argument_list|<
name|Number
argument_list|>
name|a
init|=
name|numbers
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
decl_stmt|;
comment|// The compound takes the more specific type of the two, regardless of order
name|Ordering
argument_list|<
name|Number
argument_list|>
name|b
init|=
name|numbers
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Number
argument_list|>
name|c
init|=
name|objects
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|d
init|=
name|numbers
operator|.
name|compound
argument_list|(
name|integers
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|e
init|=
name|integers
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
decl_stmt|;
comment|// This works with three levels too (IDEA falsely reports errors as noted
comment|// below. Both javac and eclipse handle these cases correctly.)
name|Ordering
argument_list|<
name|Number
argument_list|>
name|f
init|=
name|numbers
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
decl_stmt|;
comment|//bad IDEA
name|Ordering
argument_list|<
name|Number
argument_list|>
name|g
init|=
name|objects
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Number
argument_list|>
name|h
init|=
name|objects
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Number
argument_list|>
name|i
init|=
name|numbers
operator|.
name|compound
argument_list|(
name|objects
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Number
argument_list|>
name|j
init|=
name|objects
operator|.
name|compound
argument_list|(
name|numbers
operator|.
name|compound
argument_list|(
name|objects
argument_list|)
argument_list|)
decl_stmt|;
comment|//bad IDEA
name|Ordering
argument_list|<
name|Number
argument_list|>
name|k
init|=
name|objects
operator|.
name|compound
argument_list|(
name|objects
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
argument_list|)
decl_stmt|;
comment|// You can also arbitrarily assign a more restricted type - not an intended
comment|// feature, exactly, but unavoidable (I think) and harmless
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|l
init|=
name|objects
operator|.
name|compound
argument_list|(
name|numbers
argument_list|)
decl_stmt|;
comment|// This correctly doesn't work:
comment|// Ordering<Object> m = numbers.compound(objects);
comment|// Sadly, the following works in javac 1.6, but at least it fails for
comment|// eclipse, and is *correctly* highlighted red in IDEA.
comment|// Ordering<Object> n = objects.compound(numbers);
block|}
DECL|method|testReverse ()
specifier|public
name|void
name|testReverse
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Number
argument_list|>
name|reverseOrder
init|=
name|numberOrdering
operator|.
name|reverse
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|reverseOrder
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|reverseOrder
argument_list|,
name|numberOrdering
operator|.
name|reverse
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testReverseOfReverseSameAsForward ()
specifier|public
name|void
name|testReverseOfReverseSameAsForward
parameter_list|()
block|{
comment|// Not guaranteed by spec, but it works, and saves us from testing
comment|// exhaustively
name|assertSame
argument_list|(
name|numberOrdering
argument_list|,
name|numberOrdering
operator|.
name|reverse
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|enum|StringLengthFunction
specifier|private
enum|enum
name|StringLengthFunction
implements|implements
name|Function
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
block|{
DECL|enumConstant|StringLength
name|StringLength
block|;
annotation|@
name|Override
DECL|method|apply (String string)
specifier|public
name|Integer
name|apply
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
name|string
operator|.
name|length
argument_list|()
return|;
block|}
block|}
DECL|field|DECREASING_INTEGER
specifier|private
specifier|static
specifier|final
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|DECREASING_INTEGER
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|reverse
argument_list|()
decl_stmt|;
DECL|method|testOnResultOf_natural ()
specifier|public
name|void
name|testOnResultOf_natural
parameter_list|()
block|{
name|Comparator
argument_list|<
name|String
argument_list|>
name|comparator
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
name|StringLengthFunction
operator|.
name|StringLength
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"to"
argument_list|,
literal|"be"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"or"
argument_list|,
literal|"not"
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"that"
argument_list|,
literal|"to"
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|comparator
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|onResultOf
argument_list|(
name|StringLengthFunction
operator|.
name|StringLength
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|DECREASING_INTEGER
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.natural().onResultOf(StringLength)"
argument_list|,
name|comparator
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testOnResultOf_chained ()
specifier|public
name|void
name|testOnResultOf_chained
parameter_list|()
block|{
name|Comparator
argument_list|<
name|String
argument_list|>
name|comparator
init|=
name|DECREASING_INTEGER
operator|.
name|onResultOf
argument_list|(
name|StringLengthFunction
operator|.
name|StringLength
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"to"
argument_list|,
literal|"be"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"not"
argument_list|,
literal|"or"
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|comparator
operator|.
name|compare
argument_list|(
literal|"to"
argument_list|,
literal|"that"
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|comparator
argument_list|,
name|DECREASING_INTEGER
operator|.
name|onResultOf
argument_list|(
name|StringLengthFunction
operator|.
name|StringLength
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|DECREASING_INTEGER
operator|.
name|onResultOf
argument_list|(
name|Functions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
name|reserializeAndAssert
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordering.natural().reverse().onResultOf(StringLength)"
argument_list|,
name|comparator
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dang varargs
DECL|method|testLexicographical ()
specifier|public
name|void
name|testLexicographical
parameter_list|()
block|{
name|Ordering
argument_list|<
name|String
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
name|Ordering
argument_list|<
name|Iterable
argument_list|<
name|String
argument_list|>
argument_list|>
name|lexy
init|=
name|ordering
operator|.
name|lexicographical
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|empty
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|a
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|aa
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|ab
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|b
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"b"
argument_list|)
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|lexy
argument_list|,
name|empty
argument_list|,
name|a
argument_list|,
name|aa
argument_list|,
name|ab
argument_list|,
name|b
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|lexy
argument_list|,
name|ordering
operator|.
name|lexicographical
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|numberOrdering
operator|.
name|lexicographical
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testNullsFirst ()
specifier|public
name|void
name|testNullsFirst
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|ordering
argument_list|,
literal|null
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|ordering
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|numberOrdering
operator|.
name|nullsFirst
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testNullsLast ()
specifier|public
name|void
name|testNullsLast
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
decl_stmt|;
name|Helpers
operator|.
name|testComparator
argument_list|(
name|ordering
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|ordering
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|numberOrdering
operator|.
name|nullsLast
argument_list|()
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
DECL|method|testBinarySearch ()
specifier|public
name|void
name|testBinarySearch
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ints
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|7
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|numberOrdering
operator|.
name|binarySearch
argument_list|(
name|ints
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedCopy ()
specifier|public
name|void
name|testSortedCopy
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|unsortedInts
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortedInts
init|=
name|numberOrdering
operator|.
name|nullsLast
argument_list|()
operator|.
name|sortedCopy
argument_list|(
name|unsortedInts
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|,
literal|null
argument_list|)
argument_list|,
name|sortedInts
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|numberOrdering
operator|.
name|sortedCopy
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testImmutableSortedCopy ()
specifier|public
name|void
name|testImmutableSortedCopy
parameter_list|()
block|{
name|ImmutableList
argument_list|<
name|Integer
argument_list|>
name|unsortedInts
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|Integer
argument_list|>
name|sortedInts
init|=
name|numberOrdering
operator|.
name|immutableSortedCopy
argument_list|(
name|unsortedInts
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|)
argument_list|,
name|sortedInts
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|,
name|numberOrdering
operator|.
name|immutableSortedCopy
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|listWithNull
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|null
argument_list|,
literal|9
argument_list|)
decl_stmt|;
try|try
block|{
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
operator|.
name|immutableSortedCopy
argument_list|(
name|listWithNull
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testIsOrdered ()
specifier|public
name|void
name|testIsOrdered
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|asList
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isOrdered
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testIsStrictlyOrdered ()
specifier|public
name|void
name|testIsStrictlyOrdered
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|asList
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|asList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|numberOrdering
operator|.
name|isStrictlyOrdered
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_empty_0 ()
specifier|public
name|void
name|testLeastOfIterable_empty_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
expr|<
name|Integer
operator|>
name|asList
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_empty_0 ()
specifier|public
name|void
name|testLeastOfIterator_empty_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
expr|<
name|Integer
operator|>
name|emptyIterator
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_empty_1 ()
specifier|public
name|void
name|testLeastOfIterable_empty_1
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
expr|<
name|Integer
operator|>
name|asList
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_empty_1 ()
specifier|public
name|void
name|testLeastOfIterator_empty_1
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
expr|<
name|Integer
operator|>
name|emptyIterator
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_negativeOne ()
specifier|public
name|void
name|testLeastOfIterable_simple_negativeOne
parameter_list|()
block|{
try|try
block|{
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testLeastOfIterator_simple_negativeOne ()
specifier|public
name|void
name|testLeastOfIterator_simple_negativeOne
parameter_list|()
block|{
try|try
block|{
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
name|forArray
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testLeastOfIterable_singleton_0 ()
specifier|public
name|void
name|testLeastOfIterable_singleton_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_singleton_0 ()
specifier|public
name|void
name|testLeastOfIterator_singleton_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
name|singletonIterator
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_0 ()
specifier|public
name|void
name|testLeastOfIterable_simple_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_0 ()
specifier|public
name|void
name|testLeastOfIterator_simple_0
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
name|forArray
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_1 ()
specifier|public
name|void
name|testLeastOfIterable_simple_1
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_1 ()
specifier|public
name|void
name|testLeastOfIterator_simple_1
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|Iterators
operator|.
name|forArray
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_nMinusOne_withNullElement ()
specifier|public
name|void
name|testLeastOfIterable_simple_nMinusOne_withNullElement
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|null
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_nMinusOne_withNullElement ()
specifier|public
name|void
name|testLeastOfIterator_simple_nMinusOne_withNullElement
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|itr
init|=
name|Iterators
operator|.
name|forArray
argument_list|(
literal|3
argument_list|,
literal|null
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
operator|.
name|leastOf
argument_list|(
name|itr
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_nMinusOne ()
specifier|public
name|void
name|testLeastOfIterable_simple_nMinusOne
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_nMinusOne ()
specifier|public
name|void
name|testLeastOfIterator_simple_nMinusOne
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_n ()
specifier|public
name|void
name|testLeastOfIterable_simple_n
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_n ()
specifier|public
name|void
name|testLeastOfIterator_simple_n
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_n_withNullElement ()
specifier|public
name|void
name|testLeastOfIterable_simple_n_withNullElement
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_n_withNullElement ()
specifier|public
name|void
name|testLeastOfIterator_simple_n_withNullElement
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsLast
argument_list|()
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_simple_nPlusOne ()
specifier|public
name|void
name|testLeastOfIterable_simple_nPlusOne
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_simple_nPlusOne ()
specifier|public
name|void
name|testLeastOfIterator_simple_nPlusOne
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|RandomAccess
argument_list|)
expr_stmt|;
name|assertListImmutable
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterable_ties ()
specifier|public
name|void
name|testLeastOfIterable_ties
parameter_list|()
block|{
name|Integer
name|foo
init|=
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|10
argument_list|)
decl_stmt|;
name|Integer
name|bar
init|=
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|10
argument_list|)
decl_stmt|;
name|assertNotSame
argument_list|(
name|foo
argument_list|,
name|bar
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|foo
argument_list|,
name|bar
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
name|foo
argument_list|,
name|bar
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
name|foo
argument_list|,
name|bar
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIterator_ties ()
specifier|public
name|void
name|testLeastOfIterator_ties
parameter_list|()
block|{
name|Integer
name|foo
init|=
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|10
argument_list|)
decl_stmt|;
name|Integer
name|bar
init|=
operator|new
name|Integer
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|10
argument_list|)
decl_stmt|;
name|assertNotSame
argument_list|(
name|foo
argument_list|,
name|bar
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|foo
argument_list|,
name|bar
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
name|foo
argument_list|,
name|bar
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
name|numberOrdering
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
name|foo
argument_list|,
name|bar
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// slow
DECL|method|testLeastOf_reconcileAgainstSortAndSublist ()
specifier|public
name|void
name|testLeastOf_reconcileAgainstSortAndSublist
parameter_list|()
block|{
name|runLeastOfComparison
argument_list|(
literal|1000
argument_list|,
literal|300
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOf_reconcileAgainstSortAndSublistSmall ()
specifier|public
name|void
name|testLeastOf_reconcileAgainstSortAndSublistSmall
parameter_list|()
block|{
name|runLeastOfComparison
argument_list|(
literal|10
argument_list|,
literal|30
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
DECL|method|runLeastOfComparison ( int iterations, int elements, int seeds)
specifier|private
specifier|static
name|void
name|runLeastOfComparison
parameter_list|(
name|int
name|iterations
parameter_list|,
name|int
name|elements
parameter_list|,
name|int
name|seeds
parameter_list|)
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|natural
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iterations
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|elements
condition|;
name|j
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
literal|10
operator|*
name|i
operator|+
name|j
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|seed
init|=
literal|1
init|;
name|seed
operator|<
name|seeds
condition|;
name|seed
operator|++
control|)
block|{
name|int
name|k
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
operator|*
name|seed
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|ordering
operator|.
name|sortedCopy
argument_list|(
name|list
argument_list|)
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|k
argument_list|)
argument_list|,
name|ordering
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testLeastOfIterableLargeK ()
specifier|public
name|void
name|testLeastOfIterableLargeK
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|leastOf
argument_list|(
name|list
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testLeastOfIteratorLargeK ()
specifier|public
name|void
name|testLeastOfIteratorLargeK
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|leastOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGreatestOfIterable_simple ()
specifier|public
name|void
name|testGreatestOfIterable_simple
parameter_list|()
block|{
comment|/*      * If greatestOf() promised to be implemented as reverse().leastOf(), this      * test would be enough. It doesn't... but we'll cheat and act like it does      * anyway. There's a comment there to remind us to fix this if we change it.      */
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numberOrdering
operator|.
name|greatestOf
argument_list|(
name|list
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testGreatestOfIterator_simple ()
specifier|public
name|void
name|testGreatestOfIterator_simple
parameter_list|()
block|{
comment|/*      * If greatestOf() promised to be implemented as reverse().leastOf(), this      * test would be enough. It doesn't... but we'll cheat and act like it does      * anyway. There's a comment there to remind us to fix this if we change it.      */
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numberOrdering
operator|.
name|greatestOf
argument_list|(
name|list
operator|.
name|iterator
argument_list|()
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertListImmutable (List<Integer> result)
specifier|private
specifier|static
name|void
name|assertListImmutable
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|result
parameter_list|)
block|{
try|try
block|{
name|result
operator|.
name|set
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{
comment|// pass
block|}
block|}
DECL|method|testIteratorMinAndMax ()
specifier|public
name|void
name|testIteratorMinAndMax
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ints
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
name|ints
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
name|ints
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// when the values are the same, the first argument should be returned
name|Integer
name|a
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Integer
name|b
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|ints
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|max
argument_list|(
name|ints
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|min
argument_list|(
name|ints
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testIteratorMinExhaustsIterator ()
specifier|public
name|void
name|testIteratorMinExhaustsIterator
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ints
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
init|=
name|ints
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testIteratorMaxExhaustsIterator ()
specifier|public
name|void
name|testIteratorMaxExhaustsIterator
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ints
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
init|=
name|ints
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testIterableMinAndMax ()
specifier|public
name|void
name|testIterableMinAndMax
parameter_list|()
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|ints
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
name|ints
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
name|ints
argument_list|)
argument_list|)
expr_stmt|;
comment|// when the values are the same, the first argument should be returned
name|Integer
name|a
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Integer
name|b
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|ints
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|max
argument_list|(
name|ints
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|min
argument_list|(
name|ints
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testVarargsMinAndMax ()
specifier|public
name|void
name|testVarargsMinAndMax
parameter_list|()
block|{
comment|// try the min and max values in all positions, since some values are proper
comment|// parameters and others are from the varargs array
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|9
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|5
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|9
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// when the values are the same, the first argument should be returned
name|Integer
name|a
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Integer
name|b
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|max
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|min
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testParameterMinAndMax ()
specifier|public
name|void
name|testParameterMinAndMax
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|5
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|max
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
operator|(
name|int
operator|)
name|numberOrdering
operator|.
name|min
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// when the values are the same, the first argument should be returned
name|Integer
name|a
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Integer
name|b
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|max
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|a
argument_list|,
name|numberOrdering
operator|.
name|min
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|class|NumberOrdering
specifier|private
specifier|static
class|class
name|NumberOrdering
extends|extends
name|Ordering
argument_list|<
name|Number
argument_list|>
block|{
DECL|method|compare (Number a, Number b)
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Number
name|a
parameter_list|,
name|Number
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Double
operator|)
name|a
operator|.
name|doubleValue
argument_list|()
operator|)
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
DECL|method|hashCode ()
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|NumberOrdering
operator|.
name|class
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object other)
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|NumberOrdering
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|0
decl_stmt|;
block|}
comment|/*    * Now we have monster tests that create hundreds of Orderings using different    * combinations of methods, then checks compare(), binarySearch() and so    * forth on each one.    */
comment|// should periodically try increasing this, but it makes the test run long
DECL|field|RECURSE_DEPTH
specifier|private
specifier|static
specifier|final
name|int
name|RECURSE_DEPTH
init|=
literal|2
decl_stmt|;
DECL|method|testCombinationsExhaustively_startingFromNatural ()
specifier|public
name|void
name|testCombinationsExhaustively_startingFromNatural
parameter_list|()
block|{
name|testExhaustively
argument_list|(
name|Ordering
operator|.
expr|<
name|String
operator|>
name|natural
argument_list|()
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// too slow
DECL|method|testCombinationsExhaustively_startingFromExplicit ()
specifier|public
name|void
name|testCombinationsExhaustively_startingFromExplicit
parameter_list|()
block|{
name|testExhaustively
argument_list|(
name|Ordering
operator|.
name|explicit
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|)
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// too slow
DECL|method|testCombinationsExhaustively_startingFromUsingToString ()
specifier|public
name|void
name|testCombinationsExhaustively_startingFromUsingToString
parameter_list|()
block|{
name|testExhaustively
argument_list|(
name|Ordering
operator|.
name|usingToString
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// too slow
DECL|method|testCombinationsExhaustively_startingFromFromComparator ()
specifier|public
name|void
name|testCombinationsExhaustively_startingFromFromComparator
parameter_list|()
block|{
name|testExhaustively
argument_list|(
name|Ordering
operator|.
name|from
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
argument_list|,
literal|"A"
argument_list|,
literal|"b"
argument_list|,
literal|"C"
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// too slow
DECL|method|testCombinationsExhaustively_startingFromArbitrary ()
specifier|public
name|void
name|testCombinationsExhaustively_startingFromArbitrary
parameter_list|()
block|{
name|Ordering
argument_list|<
name|Object
argument_list|>
name|arbitrary
init|=
name|Ordering
operator|.
name|arbitrary
argument_list|()
decl_stmt|;
name|Object
index|[]
name|array
init|=
block|{
literal|1
block|,
literal|"foo"
block|,
operator|new
name|Object
argument_list|()
block|}
decl_stmt|;
comment|// There's no way to tell what the order should be except empirically
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|,
name|arbitrary
argument_list|)
expr_stmt|;
name|testExhaustively
argument_list|(
name|arbitrary
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
comment|/**    * Requires at least 3 elements in {@code strictlyOrderedElements} in order to    * test the varargs version of min/max.    */
DECL|method|testExhaustively ( Ordering<? super T> ordering, T... strictlyOrderedElements)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|testExhaustively
parameter_list|(
name|Ordering
argument_list|<
name|?
super|super
name|T
argument_list|>
name|ordering
parameter_list|,
name|T
modifier|...
name|strictlyOrderedElements
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|strictlyOrderedElements
operator|.
name|length
operator|>=
literal|3
argument_list|,
literal|"strictlyOrderedElements "
operator|+
literal|"requires at least 3 elements"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|strictlyOrderedElements
argument_list|)
decl_stmt|;
comment|// for use calling Collection.toArray later
name|T
index|[]
name|emptyArray
init|=
name|Platform
operator|.
name|newArray
argument_list|(
name|strictlyOrderedElements
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// shoot me, but I didn't want to deal with wildcards through the whole test
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Scenario
argument_list|<
name|T
argument_list|>
name|starter
init|=
operator|new
name|Scenario
argument_list|<
name|T
argument_list|>
argument_list|(
operator|(
name|Ordering
operator|)
name|ordering
argument_list|,
name|list
argument_list|,
name|emptyArray
argument_list|)
decl_stmt|;
name|verifyScenario
argument_list|(
name|starter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyScenario (Scenario<T> scenario, int level)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|verifyScenario
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|scenario
operator|.
name|testCompareTo
argument_list|()
expr_stmt|;
name|scenario
operator|.
name|testIsOrdered
argument_list|()
expr_stmt|;
name|scenario
operator|.
name|testMinAndMax
argument_list|()
expr_stmt|;
name|scenario
operator|.
name|testBinarySearch
argument_list|()
expr_stmt|;
name|scenario
operator|.
name|testSortedCopy
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|RECURSE_DEPTH
condition|)
block|{
for|for
control|(
name|OrderingMutation
name|alteration
range|:
name|OrderingMutation
operator|.
name|values
argument_list|()
control|)
block|{
name|verifyScenario
argument_list|(
name|alteration
operator|.
name|mutate
argument_list|(
name|scenario
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * An aggregation of an ordering with a list (of size> 1) that should prove    * to be in strictly increasing order according to that ordering.    */
DECL|class|Scenario
specifier|private
specifier|static
class|class
name|Scenario
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|ordering
specifier|final
name|Ordering
argument_list|<
name|T
argument_list|>
name|ordering
decl_stmt|;
DECL|field|strictlyOrderedList
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|strictlyOrderedList
decl_stmt|;
DECL|field|emptyArray
specifier|final
name|T
index|[]
name|emptyArray
decl_stmt|;
DECL|method|Scenario (Ordering<T> ordering, List<T> strictlyOrderedList, T[] emptyArray)
name|Scenario
parameter_list|(
name|Ordering
argument_list|<
name|T
argument_list|>
name|ordering
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|strictlyOrderedList
parameter_list|,
name|T
index|[]
name|emptyArray
parameter_list|)
block|{
name|this
operator|.
name|ordering
operator|=
name|ordering
expr_stmt|;
name|this
operator|.
name|strictlyOrderedList
operator|=
name|strictlyOrderedList
expr_stmt|;
name|this
operator|.
name|emptyArray
operator|=
name|emptyArray
expr_stmt|;
block|}
DECL|method|testCompareTo ()
name|void
name|testCompareTo
parameter_list|()
block|{
name|Helpers
operator|.
name|testComparator
argument_list|(
name|ordering
argument_list|,
name|strictlyOrderedList
argument_list|)
expr_stmt|;
block|}
DECL|method|testIsOrdered ()
name|void
name|testIsOrdered
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|ordering
operator|.
name|isOrdered
argument_list|(
name|strictlyOrderedList
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ordering
operator|.
name|isStrictlyOrdered
argument_list|(
name|strictlyOrderedList
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// generic arrays and unchecked cast
DECL|method|testMinAndMax ()
name|void
name|testMinAndMax
parameter_list|()
block|{
name|List
argument_list|<
name|T
argument_list|>
name|shuffledList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|strictlyOrderedList
argument_list|)
decl_stmt|;
name|shuffledList
operator|=
name|shuffledCopy
argument_list|(
name|shuffledList
argument_list|,
operator|new
name|Random
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|T
name|min
init|=
name|strictlyOrderedList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|T
name|max
init|=
name|strictlyOrderedList
operator|.
name|get
argument_list|(
name|strictlyOrderedList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|T
name|first
init|=
name|shuffledList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|T
name|second
init|=
name|shuffledList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|T
name|third
init|=
name|shuffledList
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|T
index|[]
name|rest
init|=
name|shuffledList
operator|.
name|subList
argument_list|(
literal|3
argument_list|,
name|shuffledList
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
name|emptyArray
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|min
argument_list|,
name|ordering
operator|.
name|min
argument_list|(
name|shuffledList
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|min
argument_list|,
name|ordering
operator|.
name|min
argument_list|(
name|shuffledList
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|min
argument_list|,
name|ordering
operator|.
name|min
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|third
argument_list|,
name|rest
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|min
argument_list|,
name|ordering
operator|.
name|min
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|min
argument_list|,
name|ordering
operator|.
name|min
argument_list|(
name|max
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|max
argument_list|,
name|ordering
operator|.
name|max
argument_list|(
name|shuffledList
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|max
argument_list|,
name|ordering
operator|.
name|max
argument_list|(
name|shuffledList
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|max
argument_list|,
name|ordering
operator|.
name|max
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|third
argument_list|,
name|rest
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|max
argument_list|,
name|ordering
operator|.
name|max
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|max
argument_list|,
name|ordering
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testBinarySearch ()
name|void
name|testBinarySearch
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strictlyOrderedList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|ordering
operator|.
name|binarySearch
argument_list|(
name|strictlyOrderedList
argument_list|,
name|strictlyOrderedList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|T
argument_list|>
name|newList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|strictlyOrderedList
argument_list|)
decl_stmt|;
name|T
name|valueNotInList
init|=
name|newList
operator|.
name|remove
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|2
argument_list|,
name|ordering
operator|.
name|binarySearch
argument_list|(
name|newList
argument_list|,
name|valueNotInList
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testSortedCopy ()
name|void
name|testSortedCopy
parameter_list|()
block|{
name|List
argument_list|<
name|T
argument_list|>
name|shuffledList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|strictlyOrderedList
argument_list|)
decl_stmt|;
name|shuffledList
operator|=
name|shuffledCopy
argument_list|(
name|shuffledList
argument_list|,
operator|new
name|Random
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|strictlyOrderedList
argument_list|,
name|ordering
operator|.
name|sortedCopy
argument_list|(
name|shuffledList
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strictlyOrderedList
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|strictlyOrderedList
argument_list|,
name|ordering
operator|.
name|immutableSortedCopy
argument_list|(
name|shuffledList
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A means for changing an Ordering into another Ordering. Each instance is    * responsible for creating the alternate Ordering, and providing a List that    * is known to be ordered, based on an input List known to be ordered    * according to the input Ordering.    */
DECL|enum|OrderingMutation
specifier|private
enum|enum
name|OrderingMutation
block|{
DECL|enumConstant|REVERSE
name|REVERSE
block|{
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|newList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|scenario
operator|.
name|strictlyOrderedList
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|newList
argument_list|)
expr_stmt|;
return|return
operator|new
name|Scenario
argument_list|<
name|T
argument_list|>
argument_list|(
name|scenario
operator|.
name|ordering
operator|.
name|reverse
argument_list|()
argument_list|,
name|newList
argument_list|,
name|scenario
operator|.
name|emptyArray
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|NULLS_FIRST
name|NULLS_FIRST
block|{
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|T
argument_list|>
name|newList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
operator|(
name|T
operator|)
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Scenario
argument_list|<
name|T
argument_list|>
argument_list|(
name|scenario
operator|.
name|ordering
operator|.
name|nullsFirst
argument_list|()
argument_list|,
name|newList
argument_list|,
name|scenario
operator|.
name|emptyArray
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|NULLS_LAST
name|NULLS_LAST
block|{
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|newList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|newList
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
operator|new
name|Scenario
argument_list|<
name|T
argument_list|>
argument_list|(
name|scenario
operator|.
name|ordering
operator|.
name|nullsLast
argument_list|()
argument_list|,
name|newList
argument_list|,
name|scenario
operator|.
name|emptyArray
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|ON_RESULT_OF
name|ON_RESULT_OF
block|{
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
specifier|final
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|ordering
init|=
name|scenario
operator|.
name|ordering
operator|.
name|onResultOf
argument_list|(
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|T
name|apply
parameter_list|(
annotation|@
name|Nullable
name|Integer
name|from
parameter_list|)
block|{
return|return
name|scenario
operator|.
name|strictlyOrderedList
operator|.
name|get
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scenario
operator|.
name|strictlyOrderedList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Scenario
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|ordering
argument_list|,
name|list
argument_list|,
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|COMPOUND_THIS_WITH_NATURAL
name|COMPOUND_THIS_WITH_NATURAL
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// raw array
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|List
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
name|composites
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
name|composites
operator|.
name|add
argument_list|(
operator|new
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|composites
operator|.
name|add
argument_list|(
operator|new
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Ordering
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
name|ordering
init|=
name|scenario
operator|.
name|ordering
operator|.
name|onResultOf
argument_list|(
name|Composite
operator|.
expr|<
name|T
operator|>
name|getValueFunction
argument_list|()
argument_list|)
operator|.
name|compound
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Scenario
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
name|ordering
argument_list|,
name|composites
argument_list|,
operator|new
name|Composite
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|COMPOUND_NATURAL_WITH_THIS
name|COMPOUND_NATURAL_WITH_THIS
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// raw array
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|List
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
name|composites
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
name|composites
operator|.
name|add
argument_list|(
operator|new
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
name|composites
operator|.
name|add
argument_list|(
operator|new
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Ordering
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|compound
argument_list|(
name|scenario
operator|.
name|ordering
operator|.
name|onResultOf
argument_list|(
name|Composite
operator|.
expr|<
name|T
operator|>
name|getValueFunction
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|Scenario
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
name|ordering
argument_list|,
name|composites
argument_list|,
operator|new
name|Composite
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
block|,
DECL|enumConstant|LEXICOGRAPHICAL
name|LEXICOGRAPHICAL
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dang varargs
annotation|@
name|Override
argument_list|<
name|T
argument_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
block|{
name|List
argument_list|<
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|>
name|words
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|words
operator|.
name|add
argument_list|(
name|Collections
operator|.
expr|<
name|T
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|t
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
name|words
operator|.
name|add
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|s
range|:
name|scenario
operator|.
name|strictlyOrderedList
control|)
block|{
name|words
operator|.
name|add
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Scenario
argument_list|<
name|Iterable
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
name|scenario
operator|.
name|ordering
operator|.
name|lexicographical
argument_list|()
argument_list|,
name|words
argument_list|,
operator|new
name|Iterable
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
block|,     ;
DECL|method|mutate (Scenario<T> scenario)
specifier|abstract
parameter_list|<
name|T
parameter_list|>
name|Scenario
argument_list|<
name|?
argument_list|>
name|mutate
parameter_list|(
name|Scenario
argument_list|<
name|T
argument_list|>
name|scenario
parameter_list|)
function_decl|;
block|}
comment|/**    * A dummy object we create so that we can have something meaningful to have    * a compound ordering over.    */
DECL|class|Composite
specifier|private
specifier|static
class|class
name|Composite
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|value
specifier|final
name|T
name|value
decl_stmt|;
DECL|field|rank
specifier|final
name|int
name|rank
decl_stmt|;
DECL|method|Composite (T value, int rank)
name|Composite
parameter_list|(
name|T
name|value
parameter_list|,
name|int
name|rank
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|rank
operator|=
name|rank
expr_stmt|;
block|}
comment|// natural order is by rank only; the test will compound() this with the
comment|// order of 't'.
annotation|@
name|Override
DECL|method|compareTo (Composite<T> that)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Composite
argument_list|<
name|T
argument_list|>
name|that
parameter_list|)
block|{
return|return
name|Ints
operator|.
name|compare
argument_list|(
name|rank
argument_list|,
name|that
operator|.
name|rank
argument_list|)
return|;
block|}
DECL|method|getValueFunction ()
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Function
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|,
name|T
argument_list|>
name|getValueFunction
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Composite
argument_list|<
name|T
argument_list|>
argument_list|,
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|T
name|apply
parameter_list|(
name|Composite
argument_list|<
name|T
argument_list|>
name|from
parameter_list|)
block|{
return|return
name|from
operator|.
name|value
return|;
block|}
block|}
return|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// NullPointerTester
DECL|method|testNullPointerExceptions ()
specifier|public
name|void
name|testNullPointerExceptions
parameter_list|()
block|{
name|NullPointerTester
name|tester
init|=
operator|new
name|NullPointerTester
argument_list|()
decl_stmt|;
name|tester
operator|.
name|testAllPublicStaticMethods
argument_list|(
name|Ordering
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// any Ordering<Object> instance that accepts nulls should be good enough
name|tester
operator|.
name|testAllPublicInstanceMethods
argument_list|(
name|Ordering
operator|.
name|usingToString
argument_list|()
operator|.
name|nullsFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|shuffledCopy (List<T> in, Random random)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|shuffledCopy
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|in
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|mutable
init|=
name|newArrayList
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|out
init|=
name|newArrayList
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|mutable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
name|mutable
operator|.
name|remove
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|mutable
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
block|}
end_class

end_unit

