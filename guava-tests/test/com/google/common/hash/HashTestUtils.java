begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright 2011 Google Inc. All Rights Reserved.
end_comment

begin_package
DECL|package|com.google.common.hash
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_comment
comment|/**  * @author andreou@google.com (Dimitris Andreou)  */
end_comment

begin_class
DECL|class|HashTestUtils
class|class
name|HashTestUtils
block|{
DECL|method|HashTestUtils ()
specifier|private
name|HashTestUtils
parameter_list|()
block|{}
comment|/**    * Converts a string, which should contain only ascii-representable characters, to a byte[].    */
DECL|method|ascii (String string)
specifier|static
name|byte
index|[]
name|ascii
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|string
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|string
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|/**    * Returns a byte array representation for a sequence of longs, in big-endian order.     */
DECL|method|toBytes (ByteOrder bo, long... longs)
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|ByteOrder
name|bo
parameter_list|,
name|long
modifier|...
name|longs
parameter_list|)
block|{
name|ByteBuffer
name|bb
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|longs
operator|.
name|length
operator|*
literal|8
index|]
argument_list|)
operator|.
name|order
argument_list|(
name|bo
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|x
range|:
name|longs
control|)
block|{
name|bb
operator|.
name|putLong
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|bb
operator|.
name|array
argument_list|()
return|;
block|}
DECL|interface|HashFn
interface|interface
name|HashFn
block|{
DECL|method|hash (byte[] input, int seed)
name|byte
index|[]
name|hash
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|int
name|seed
parameter_list|)
function_decl|;
block|}
DECL|method|verifyHashFunction (HashFn hashFunction, int hashbits, int expected)
specifier|static
name|void
name|verifyHashFunction
parameter_list|(
name|HashFn
name|hashFunction
parameter_list|,
name|int
name|hashbits
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|int
name|hashBytes
init|=
name|hashbits
operator|/
literal|8
decl_stmt|;
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
name|byte
index|[]
name|hashes
init|=
operator|new
name|byte
index|[
name|hashBytes
operator|*
literal|256
index|]
decl_stmt|;
comment|// Hash keys of the form {}, {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|key
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
name|int
name|seed
init|=
literal|256
operator|-
name|i
decl_stmt|;
name|byte
index|[]
name|hash
init|=
name|hashFunction
operator|.
name|hash
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|key
argument_list|,
name|i
argument_list|)
argument_list|,
name|seed
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
name|hashes
argument_list|,
name|i
operator|*
name|hashBytes
argument_list|,
name|hash
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Then hash the result array
name|byte
index|[]
name|result
init|=
name|hashFunction
operator|.
name|hash
argument_list|(
name|hashes
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// interpreted in little-endian order.
name|int
name|verification
init|=
name|Integer
operator|.
name|reverseBytes
argument_list|(
name|Ints
operator|.
name|fromByteArray
argument_list|(
name|result
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|verification
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected: "
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|expected
argument_list|)
operator|+
literal|" got: "
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|verification
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|assertEqualHashes (byte[] expectedHash, byte[] actualHash)
specifier|static
name|void
name|assertEqualHashes
parameter_list|(
name|byte
index|[]
name|expectedHash
parameter_list|,
name|byte
index|[]
name|actualHash
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|expectedHash
argument_list|,
name|actualHash
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Should be: %x, was %x"
argument_list|,
name|expectedHash
argument_list|,
name|actualHash
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|BAD_FUNNEL
specifier|static
specifier|final
name|Funnel
argument_list|<
name|Object
argument_list|>
name|BAD_FUNNEL
init|=
operator|new
name|Funnel
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|funnel
parameter_list|(
name|Object
name|object
parameter_list|,
name|Sink
name|byteSink
parameter_list|)
block|{
name|byteSink
operator|.
name|putInt
argument_list|(
name|object
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|enum|RandomHasherAction
specifier|static
enum|enum
name|RandomHasherAction
block|{
DECL|enumConstant|PUT_BOOLEAN
DECL|method|PUT_BOOLEAN ()
name|PUT_BOOLEAN
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|boolean
name|value
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBoolean
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTE
DECL|method|PUT_BYTE ()
name|PUT_BYTE
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|int
name|value
init|=
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putByte
argument_list|(
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_SHORT
DECL|method|PUT_SHORT ()
name|PUT_SHORT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|short
name|value
init|=
operator|(
name|short
operator|)
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putShort
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_CHAR
DECL|method|PUT_CHAR ()
name|PUT_CHAR
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|char
name|value
init|=
operator|(
name|char
operator|)
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putChar
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_INT
DECL|method|PUT_INT ()
name|PUT_INT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|int
name|value
init|=
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_LONG
DECL|method|PUT_LONG ()
name|PUT_LONG
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|long
name|value
init|=
name|random
operator|.
name|nextLong
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_FLOAT
DECL|method|PUT_FLOAT ()
name|PUT_FLOAT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|float
name|value
init|=
name|random
operator|.
name|nextFloat
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putFloat
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_DOUBLE
DECL|method|PUT_DOUBLE ()
name|PUT_DOUBLE
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|double
name|value
init|=
name|random
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putDouble
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTES
DECL|method|PUT_BYTES ()
name|PUT_BYTES
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTES_INT_INT
DECL|method|PUT_BYTES_INT_INT ()
name|PUT_BYTES_INT_INT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|off
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|value
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|value
operator|.
name|length
operator|-
name|off
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|Sink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|;
DECL|method|performAction (Random random, Iterable<? extends Sink> sinks)
specifier|abstract
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Sink
argument_list|>
name|sinks
parameter_list|)
function_decl|;
DECL|field|actions
specifier|private
specifier|static
specifier|final
name|RandomHasherAction
index|[]
name|actions
init|=
name|values
argument_list|()
decl_stmt|;
DECL|method|pickAtRandom (Random random)
specifier|static
name|RandomHasherAction
name|pickAtRandom
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|actions
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|actions
operator|.
name|length
argument_list|)
index|]
return|;
block|}
block|}
block|}
end_class

end_unit

