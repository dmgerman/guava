begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright 2011 Google Inc. All Rights Reserved.
end_comment

begin_package
DECL|package|com.google.common.hash
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Various utilities for testing {@link HashFunction}s.  *  * @author andreou@google.com (Dimitris Andreou)  * @author kak@google.com (Kurt Alfred Kluever)  */
end_comment

begin_class
DECL|class|HashTestUtils
specifier|final
class|class
name|HashTestUtils
block|{
DECL|method|HashTestUtils ()
specifier|private
name|HashTestUtils
parameter_list|()
block|{}
comment|/**    * Converts a string, which should contain only ascii-representable characters, to a byte[].    */
DECL|method|ascii (String string)
specifier|static
name|byte
index|[]
name|ascii
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|string
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|string
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|/**    * Returns a byte array representation for a sequence of longs, in big-endian order.    */
DECL|method|toBytes (ByteOrder bo, long... longs)
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|ByteOrder
name|bo
parameter_list|,
name|long
modifier|...
name|longs
parameter_list|)
block|{
name|ByteBuffer
name|bb
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|longs
operator|.
name|length
operator|*
literal|8
index|]
argument_list|)
operator|.
name|order
argument_list|(
name|bo
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|x
range|:
name|longs
control|)
block|{
name|bb
operator|.
name|putLong
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|bb
operator|.
name|array
argument_list|()
return|;
block|}
DECL|interface|HashFn
interface|interface
name|HashFn
block|{
DECL|method|hash (byte[] input, int seed)
name|byte
index|[]
name|hash
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|int
name|seed
parameter_list|)
function_decl|;
block|}
DECL|method|verifyHashFunction (HashFn hashFunction, int hashbits, int expected)
specifier|static
name|void
name|verifyHashFunction
parameter_list|(
name|HashFn
name|hashFunction
parameter_list|,
name|int
name|hashbits
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|int
name|hashBytes
init|=
name|hashbits
operator|/
literal|8
decl_stmt|;
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
name|byte
index|[]
name|hashes
init|=
operator|new
name|byte
index|[
name|hashBytes
operator|*
literal|256
index|]
decl_stmt|;
comment|// Hash keys of the form {}, {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|key
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
name|int
name|seed
init|=
literal|256
operator|-
name|i
decl_stmt|;
name|byte
index|[]
name|hash
init|=
name|hashFunction
operator|.
name|hash
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|key
argument_list|,
name|i
argument_list|)
argument_list|,
name|seed
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
name|hashes
argument_list|,
name|i
operator|*
name|hashBytes
argument_list|,
name|hash
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Then hash the result array
name|byte
index|[]
name|result
init|=
name|hashFunction
operator|.
name|hash
argument_list|(
name|hashes
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// interpreted in little-endian order.
name|int
name|verification
init|=
name|Integer
operator|.
name|reverseBytes
argument_list|(
name|Ints
operator|.
name|fromByteArray
argument_list|(
name|result
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|verification
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected: "
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|expected
argument_list|)
operator|+
literal|" got: "
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|verification
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|field|BAD_FUNNEL
specifier|static
specifier|final
name|Funnel
argument_list|<
name|Object
argument_list|>
name|BAD_FUNNEL
init|=
operator|new
name|Funnel
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|funnel
parameter_list|(
name|Object
name|object
parameter_list|,
name|PrimitiveSink
name|bytePrimitiveSink
parameter_list|)
block|{
name|bytePrimitiveSink
operator|.
name|putInt
argument_list|(
name|object
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|enum|RandomHasherAction
specifier|static
enum|enum
name|RandomHasherAction
block|{
DECL|enumConstant|PUT_BOOLEAN
DECL|method|PUT_BOOLEAN ()
name|PUT_BOOLEAN
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|boolean
name|value
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBoolean
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTE
DECL|method|PUT_BYTE ()
name|PUT_BYTE
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|int
name|value
init|=
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putByte
argument_list|(
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_SHORT
DECL|method|PUT_SHORT ()
name|PUT_SHORT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|short
name|value
init|=
operator|(
name|short
operator|)
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putShort
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_CHAR
DECL|method|PUT_CHAR ()
name|PUT_CHAR
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|char
name|value
init|=
operator|(
name|char
operator|)
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putChar
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_INT
DECL|method|PUT_INT ()
name|PUT_INT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|int
name|value
init|=
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_LONG
DECL|method|PUT_LONG ()
name|PUT_LONG
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|long
name|value
init|=
name|random
operator|.
name|nextLong
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_FLOAT
DECL|method|PUT_FLOAT ()
name|PUT_FLOAT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|float
name|value
init|=
name|random
operator|.
name|nextFloat
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putFloat
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_DOUBLE
DECL|method|PUT_DOUBLE ()
name|PUT_DOUBLE
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|double
name|value
init|=
name|random
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putDouble
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTES
DECL|method|PUT_BYTES ()
name|PUT_BYTES
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|,
DECL|enumConstant|PUT_BYTES_INT_INT
DECL|method|PUT_BYTES_INT_INT ()
name|PUT_BYTES_INT_INT
parameter_list|()
block|{
annotation|@
name|Override
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|off
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|value
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|value
operator|.
name|length
operator|-
name|off
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|PrimitiveSink
name|sink
range|:
name|sinks
control|)
block|{
name|sink
operator|.
name|putBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|;
DECL|method|performAction (Random random, Iterable<? extends PrimitiveSink> sinks)
specifier|abstract
name|void
name|performAction
parameter_list|(
name|Random
name|random
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|PrimitiveSink
argument_list|>
name|sinks
parameter_list|)
function_decl|;
DECL|field|actions
specifier|private
specifier|static
specifier|final
name|RandomHasherAction
index|[]
name|actions
init|=
name|values
argument_list|()
decl_stmt|;
DECL|method|pickAtRandom (Random random)
specifier|static
name|RandomHasherAction
name|pickAtRandom
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|actions
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|actions
operator|.
name|length
argument_list|)
index|]
return|;
block|}
block|}
comment|/**    * Test that the hash function contains no funnels. A funnel is a situation where a set of input    * (key) bits 'affects' a strictly smaller set of output bits. Funneling is bad because it can    * result in more-than-ideal collisions for a non-uniformly distributed key space. In practice,    * most key spaces are ANYTHING BUT uniformly distributed. A bit(i) in the input is said to    * 'affect' a bit(j) in the output if two inputs, identical but for bit(i), will differ at output    * bit(j) about half the time    *    *<p>Funneling is pretty simple to detect. The key idea is to find example keys which    * unequivocably demonstrate that funneling cannot be occuring. This is done bit-by-bit. For    * each input bit(i) and output bit(j), two pairs of keys must be found with all bits identical    * except bit(i). One pair must differ in output bit(j), and one pair must not. This proves that    * input bit(i) can alter output bit(j).    */
DECL|method|checkNoFunnels (HashFunction function)
specifier|static
name|void
name|checkNoFunnels
parameter_list|(
name|HashFunction
name|function
parameter_list|)
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|keyBits
init|=
literal|32
decl_stmt|;
name|int
name|hashBits
init|=
name|function
operator|.
name|bits
argument_list|()
decl_stmt|;
comment|// output loop tests input bit
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyBits
condition|;
name|i
operator|++
control|)
block|{
name|int
name|same
init|=
literal|0x0
decl_stmt|;
comment|// bitset for output bits with same values
name|int
name|diff
init|=
literal|0x0
decl_stmt|;
comment|// bitset for output bits with different values
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// originally was 2 * Math.log(...), making it try more times to avoid flakiness issues
name|int
name|maxCount
init|=
call|(
name|int
call|)
argument_list|(
literal|4
operator|*
name|Math
operator|.
name|log
argument_list|(
literal|2
operator|*
name|keyBits
operator|*
name|hashBits
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|same
operator|!=
literal|0xffffffff
operator|||
name|diff
operator|!=
literal|0xffffffff
condition|)
block|{
name|int
name|key1
init|=
name|rand
operator|.
name|nextInt
argument_list|()
decl_stmt|;
comment|// flip input bit for key2
name|int
name|key2
init|=
name|key1
operator|^
operator|(
literal|1
operator|<<
name|i
operator|)
decl_stmt|;
comment|// get hashes
name|int
name|hash1
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key1
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
name|int
name|hash2
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key2
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
comment|// test whether the hash values have same output bits
name|same
operator||=
operator|~
operator|(
name|hash1
operator|^
name|hash2
operator|)
expr_stmt|;
comment|// test whether the hash values have different output bits
name|diff
operator||=
operator|(
name|hash1
operator|^
name|hash2
operator|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|// check whether we've exceeded the probabilistically
comment|// likely number of trials to have proven no funneling
if|if
condition|(
name|count
operator|>
name|maxCount
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"input bit("
operator|+
name|i
operator|+
literal|") was found not to affect all "
operator|+
name|hashBits
operator|+
literal|" output bits; The unaffected bits are "
operator|+
literal|"as follows: "
operator|+
operator|~
operator|(
name|same
operator|&
name|diff
operator|)
operator|+
literal|". This was "
operator|+
literal|"determined after "
operator|+
name|count
operator|+
literal|" trials."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Test for avalanche. Avalanche means that output bits differ with roughly 1/2 probability on    * different input keys. This test verifies that each possible 1-bit key delta achieves avalanche.    *    *<p>For more information: http://burtleburtle.net/bob/hash/avalanche.html    */
DECL|method|checkAvalanche (HashFunction function, int trials, double epsilon)
specifier|static
name|void
name|checkAvalanche
parameter_list|(
name|HashFunction
name|function
parameter_list|,
name|int
name|trials
parameter_list|,
name|double
name|epsilon
parameter_list|)
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|keyBits
init|=
literal|32
decl_stmt|;
name|int
name|hashBits
init|=
name|function
operator|.
name|bits
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyBits
condition|;
name|i
operator|++
control|)
block|{
name|int
index|[]
name|same
init|=
operator|new
name|int
index|[
name|hashBits
index|]
decl_stmt|;
name|int
index|[]
name|diff
init|=
operator|new
name|int
index|[
name|hashBits
index|]
decl_stmt|;
comment|// go through trials to compute probability
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|trials
condition|;
name|j
operator|++
control|)
block|{
name|int
name|key1
init|=
name|rand
operator|.
name|nextInt
argument_list|()
decl_stmt|;
comment|// flip input bit for key2
name|int
name|key2
init|=
name|key1
operator|^
operator|(
literal|1
operator|<<
name|i
operator|)
decl_stmt|;
comment|// compute hash values
name|int
name|hash1
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key1
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
name|int
name|hash2
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key2
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|hashBits
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hash1
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
operator|==
operator|(
name|hash2
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
condition|)
block|{
name|same
index|[
name|k
index|]
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|diff
index|[
name|k
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// measure probability and assert it's within margin of error
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|hashBits
condition|;
name|j
operator|++
control|)
block|{
name|double
name|prob
init|=
operator|(
name|double
operator|)
name|diff
index|[
name|j
index|]
operator|/
call|(
name|double
call|)
argument_list|(
name|diff
index|[
name|j
index|]
operator|+
name|same
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0.50d
argument_list|,
name|prob
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test for 2-bit characteristics. A characteristic is a delta in the input which is repeated in    * the output. For example, if f() is a block cipher and c is a characteristic, then    * f(x^c) = f(x)^c with greater than expected probability. The test for funneling is merely a test    * for 1-bit characteristics.    *    *<p>There is more general code provided by Bob Jenkins to test arbitrarily sized characteristics    * using the magic of gaussian elimination: http://burtleburtle.net/bob/crypto/findingc.html.    */
DECL|method|checkNo2BitCharacteristics (HashFunction function)
specifier|static
name|void
name|checkNo2BitCharacteristics
parameter_list|(
name|HashFunction
name|function
parameter_list|)
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|keyBits
init|=
literal|32
decl_stmt|;
comment|// get every one of (keyBits choose 2) deltas:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyBits
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keyBits
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<=
name|i
condition|)
continue|continue;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|maxCount
init|=
literal|20
decl_stmt|;
comment|// the probability of error here is miniscule
name|boolean
name|diff
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|diff
operator|==
literal|false
condition|)
block|{
name|int
name|delta
init|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator||
operator|(
literal|1
operator|<<
name|j
operator|)
decl_stmt|;
name|int
name|key1
init|=
name|rand
operator|.
name|nextInt
argument_list|()
decl_stmt|;
comment|// apply delta
name|int
name|key2
init|=
name|key1
operator|^
name|delta
decl_stmt|;
comment|// get hashes
name|int
name|hash1
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key1
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
name|int
name|hash2
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key2
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
comment|// this 2-bit candidate delta is not a characteristic
comment|// if deltas are different
if|if
condition|(
operator|(
name|hash1
operator|^
name|hash2
operator|)
operator|!=
name|delta
condition|)
block|{
name|diff
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// check if we've exceeded the probabilistically
comment|// likely number of trials to have proven 2-bit candidate
comment|// is not a characteristic
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|maxCount
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"2-bit delta ("
operator|+
name|i
operator|+
literal|", "
operator|+
name|j
operator|+
literal|") is likely a "
operator|+
literal|"characteristic for this hash. This was "
operator|+
literal|"determined after "
operator|+
name|count
operator|+
literal|" trials"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Test for avalanche with 2-bit deltas. Most probabilities of output bit(j) differing are well    * within 50%.    */
DECL|method|check2BitAvalanche (HashFunction function, int trials, double epsilon)
specifier|static
name|void
name|check2BitAvalanche
parameter_list|(
name|HashFunction
name|function
parameter_list|,
name|int
name|trials
parameter_list|,
name|double
name|epsilon
parameter_list|)
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|keyBits
init|=
literal|32
decl_stmt|;
name|int
name|hashBits
init|=
name|function
operator|.
name|bits
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bit1
init|=
literal|0
init|;
name|bit1
operator|<
name|keyBits
condition|;
name|bit1
operator|++
control|)
block|{
for|for
control|(
name|int
name|bit2
init|=
literal|0
init|;
name|bit2
operator|<
name|keyBits
condition|;
name|bit2
operator|++
control|)
block|{
if|if
condition|(
name|bit2
operator|<=
name|bit1
condition|)
continue|continue;
name|int
name|delta
init|=
operator|(
literal|1
operator|<<
name|bit1
operator|)
operator||
operator|(
literal|1
operator|<<
name|bit2
operator|)
decl_stmt|;
name|int
index|[]
name|same
init|=
operator|new
name|int
index|[
name|hashBits
index|]
decl_stmt|;
name|int
index|[]
name|diff
init|=
operator|new
name|int
index|[
name|hashBits
index|]
decl_stmt|;
comment|// go through trials to compute probability
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|trials
condition|;
name|j
operator|++
control|)
block|{
name|int
name|key1
init|=
name|rand
operator|.
name|nextInt
argument_list|()
decl_stmt|;
comment|// flip input bit for key2
name|int
name|key2
init|=
name|key1
operator|^
name|delta
decl_stmt|;
comment|// compute hash values
name|int
name|hash1
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key1
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
name|int
name|hash2
init|=
name|function
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|key2
argument_list|)
operator|.
name|hash
argument_list|()
operator|.
name|asInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|hashBits
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hash1
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
operator|==
operator|(
name|hash2
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
condition|)
block|{
name|same
index|[
name|k
index|]
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|diff
index|[
name|k
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// measure probability and assert it's within margin of error
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|hashBits
condition|;
name|j
operator|++
control|)
block|{
name|double
name|prob
init|=
operator|(
name|double
operator|)
name|diff
index|[
name|j
index|]
operator|/
call|(
name|double
call|)
argument_list|(
name|diff
index|[
name|j
index|]
operator|+
name|same
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0.50d
argument_list|,
name|prob
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Checks that a Hasher returns the same HashCode when given the same input, and also    * that the collision rate looks sane.    */
DECL|method|assertInvariants (HashFunction hashFunction)
specifier|static
name|void
name|assertInvariants
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|)
block|{
name|int
name|objects
init|=
literal|100
decl_stmt|;
name|Set
argument_list|<
name|HashCode
argument_list|>
name|hashcodes
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|objects
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|objects
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|o
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
name|HashCode
name|hashcode1
init|=
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putObject
argument_list|(
name|o
argument_list|,
name|HashTestUtils
operator|.
name|BAD_FUNNEL
argument_list|)
operator|.
name|hash
argument_list|()
decl_stmt|;
name|HashCode
name|hashcode2
init|=
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putObject
argument_list|(
name|o
argument_list|,
name|HashTestUtils
operator|.
name|BAD_FUNNEL
argument_list|)
operator|.
name|hash
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|hashcode1
argument_list|,
name|hashcode2
argument_list|)
expr_stmt|;
comment|// idempotent
name|Assert
operator|.
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|bits
argument_list|()
argument_list|,
name|hashcode1
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|bits
argument_list|()
argument_list|,
name|hashcode1
operator|.
name|asBytes
argument_list|()
operator|.
name|length
operator|*
literal|8
argument_list|)
expr_stmt|;
name|hashcodes
operator|.
name|add
argument_list|(
name|hashcode1
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|hashcodes
operator|.
name|size
argument_list|()
operator|>
name|objects
operator|*
literal|0.95
argument_list|)
expr_stmt|;
comment|// quite relaxed test
name|assertHashBytesThrowsCorrectExceptions
argument_list|(
name|hashFunction
argument_list|)
expr_stmt|;
name|assertIndependentHashers
argument_list|(
name|hashFunction
argument_list|)
expr_stmt|;
name|assertShortcutsAreEquivalent
argument_list|(
name|hashFunction
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHashBytesThrowsCorrectExceptions (HashFunction hashFunction)
specifier|static
name|void
name|assertHashBytesThrowsCorrectExceptions
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|)
block|{
name|hashFunction
operator|.
name|hashBytes
argument_list|(
operator|new
name|byte
index|[
literal|64
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|hashFunction
operator|.
name|hashBytes
argument_list|(
operator|new
name|byte
index|[
literal|128
index|]
argument_list|,
operator|-
literal|1
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|hashFunction
operator|.
name|hashBytes
argument_list|(
operator|new
name|byte
index|[
literal|128
index|]
argument_list|,
literal|64
argument_list|,
literal|256
comment|/* too long len */
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|hashFunction
operator|.
name|hashBytes
argument_list|(
operator|new
name|byte
index|[
literal|64
index|]
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|expected
parameter_list|)
block|{}
block|}
DECL|method|assertIndependentHashers (HashFunction hashFunction)
specifier|static
name|void
name|assertIndependentHashers
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|)
block|{
name|int
name|numActions
init|=
literal|100
decl_stmt|;
comment|// hashcodes from non-overlapping hash computations
name|HashCode
name|expected1
init|=
name|randomHash
argument_list|(
name|hashFunction
argument_list|,
operator|new
name|Random
argument_list|(
literal|1L
argument_list|)
argument_list|,
name|numActions
argument_list|)
decl_stmt|;
name|HashCode
name|expected2
init|=
name|randomHash
argument_list|(
name|hashFunction
argument_list|,
operator|new
name|Random
argument_list|(
literal|2L
argument_list|)
argument_list|,
name|numActions
argument_list|)
decl_stmt|;
comment|// equivalent, but overlapping, computations (should produce the same results as above)
name|Random
name|random1
init|=
operator|new
name|Random
argument_list|(
literal|1L
argument_list|)
decl_stmt|;
name|Random
name|random2
init|=
operator|new
name|Random
argument_list|(
literal|2L
argument_list|)
decl_stmt|;
name|Hasher
name|hasher1
init|=
name|hashFunction
operator|.
name|newHasher
argument_list|()
decl_stmt|;
name|Hasher
name|hasher2
init|=
name|hashFunction
operator|.
name|newHasher
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numActions
condition|;
name|i
operator|++
control|)
block|{
name|RandomHasherAction
operator|.
name|pickAtRandom
argument_list|(
name|random1
argument_list|)
operator|.
name|performAction
argument_list|(
name|random1
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|hasher1
argument_list|)
argument_list|)
expr_stmt|;
name|RandomHasherAction
operator|.
name|pickAtRandom
argument_list|(
name|random2
argument_list|)
operator|.
name|performAction
argument_list|(
name|random2
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|hasher2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected1
argument_list|,
name|hasher1
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected2
argument_list|,
name|hasher2
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|randomHash (HashFunction hashFunction, Random random, int numActions)
specifier|static
name|HashCode
name|randomHash
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|Random
name|random
parameter_list|,
name|int
name|numActions
parameter_list|)
block|{
name|Hasher
name|hasher
init|=
name|hashFunction
operator|.
name|newHasher
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numActions
condition|;
name|i
operator|++
control|)
block|{
name|RandomHasherAction
operator|.
name|pickAtRandom
argument_list|(
name|random
argument_list|)
operator|.
name|performAction
argument_list|(
name|random
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|hasher
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hasher
operator|.
name|hash
argument_list|()
return|;
block|}
DECL|method|assertShortcutsAreEquivalent (HashFunction hashFunction, int trials)
specifier|private
specifier|static
name|void
name|assertShortcutsAreEquivalent
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|int
name|trials
parameter_list|)
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|42085L
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trials
condition|;
name|i
operator|++
control|)
block|{
name|assertHashBytesEquivalence
argument_list|(
name|hashFunction
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|assertHashIntEquivalence
argument_list|(
name|hashFunction
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|assertHashLongEquivalence
argument_list|(
name|hashFunction
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|assertHashStringEquivalence
argument_list|(
name|hashFunction
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertHashBytesEquivalence (HashFunction hashFunction, Random random)
specifier|private
specifier|static
name|void
name|assertHashBytesEquivalence
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|2048
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashBytes
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|(
name|size
argument_list|)
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|off
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|size
operator|-
name|off
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashBytes
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|(
name|size
argument_list|)
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHashIntEquivalence (HashFunction hashFunction, Random random)
specifier|private
specifier|static
name|void
name|assertHashIntEquivalence
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|int
name|i
init|=
name|random
operator|.
name|nextInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashInt
argument_list|(
name|i
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putInt
argument_list|(
name|i
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHashLongEquivalence (HashFunction hashFunction, Random random)
specifier|private
specifier|static
name|void
name|assertHashLongEquivalence
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|long
name|l
init|=
name|random
operator|.
name|nextLong
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashLong
argument_list|(
name|l
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putLong
argument_list|(
name|l
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|CHARSETS
specifier|private
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Charset
argument_list|>
name|CHARSETS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|,
name|Charsets
operator|.
name|US_ASCII
argument_list|,
name|Charsets
operator|.
name|UTF_16
argument_list|,
name|Charsets
operator|.
name|UTF_16BE
argument_list|,
name|Charsets
operator|.
name|UTF_16LE
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
DECL|method|assertHashStringEquivalence (HashFunction hashFunction, Random random)
specifier|private
specifier|static
name|void
name|assertHashStringEquivalence
parameter_list|(
name|HashFunction
name|hashFunction
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|2048
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|String
name|string
init|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashString
argument_list|(
name|string
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putString
argument_list|(
name|string
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Charset
name|charset
range|:
name|CHARSETS
control|)
block|{
name|assertEquals
argument_list|(
name|hashFunction
operator|.
name|hashString
argument_list|(
name|string
argument_list|,
name|charset
argument_list|)
argument_list|,
name|hashFunction
operator|.
name|newHasher
argument_list|()
operator|.
name|putString
argument_list|(
name|string
argument_list|,
name|charset
argument_list|)
operator|.
name|hash
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

