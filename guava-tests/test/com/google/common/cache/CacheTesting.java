begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|com.google.common.cache
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertNotSame
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertSame
import|;
end_import

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCache
operator|.
name|LocalLoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCache
operator|.
name|ReferenceEntry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCache
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LocalCache
operator|.
name|ValueReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|EqualsTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|FakeTicker
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A collection of utilities for {@link Cache} testing.  *  * @author mike nonemacher  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"GuardedBy"
argument_list|)
comment|// TODO(b/35466881): Fix or suppress.
DECL|class|CacheTesting
class|class
name|CacheTesting
block|{
comment|/**    * Poke into the Cache internals to simulate garbage collection of the value associated with the    * given key. This assumes that the associated entry is a WeakValueReference or a    * SoftValueReference (and not a LoadingValueReference), and throws an IllegalStateException    * if that assumption does not hold.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// the instanceof check and the cast generate this warning
DECL|method|simulateValueReclamation (Cache<K, V> cache, K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|simulateValueReclamation
parameter_list|(
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|K
name|key
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|getReferenceEntry
argument_list|(
name|cache
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|ValueReference
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|valueRef
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
decl_stmt|;
comment|// fail on strong/computing refs
name|Preconditions
operator|.
name|checkState
argument_list|(
name|valueRef
operator|instanceof
name|Reference
argument_list|)
expr_stmt|;
name|Reference
argument_list|<
name|V
argument_list|>
name|ref
init|=
operator|(
name|Reference
argument_list|<
name|V
argument_list|>
operator|)
name|valueRef
decl_stmt|;
if|if
condition|(
name|ref
operator|!=
literal|null
condition|)
block|{
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Poke into the Cache internals to simulate garbage collection of the given key. This assumes    * that the given entry is a weak or soft reference, and throws an IllegalStateException if that    * assumption does not hold.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// the instanceof check and the cast generate this warning
DECL|method|simulateKeyReclamation (Cache<K, V> cache, K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|simulateKeyReclamation
parameter_list|(
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|K
name|key
parameter_list|)
block|{
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|getReferenceEntry
argument_list|(
name|cache
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|entry
operator|instanceof
name|Reference
argument_list|)
expr_stmt|;
name|Reference
argument_list|<
name|?
argument_list|>
name|ref
init|=
operator|(
name|Reference
argument_list|<
name|?
argument_list|>
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|ref
operator|!=
literal|null
condition|)
block|{
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getReferenceEntry (Cache<K, V> cache, K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getReferenceEntry
parameter_list|(
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
return|return
name|map
operator|.
name|getEntry
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Forces the segment containing the given {@code key} to expand (see    * {@link Segment#expand()}.    */
DECL|method|forceExpandSegment (Cache<K, V> cache, K key)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|forceExpandSegment
parameter_list|(
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|K
name|key
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|int
name|hash
init|=
name|map
operator|.
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|map
operator|.
name|segmentFor
argument_list|(
name|hash
argument_list|)
decl_stmt|;
name|segment
operator|.
name|expand
argument_list|()
expr_stmt|;
block|}
comment|/**    * Gets the {@link LocalCache} used by the given {@link Cache}, if any, or throws an    * IllegalArgumentException if this is a Cache type that doesn't have a LocalCache.    */
DECL|method|toLocalCache (Cache<K, V> cache)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|LocalCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|toLocalCache
parameter_list|(
name|Cache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|instanceof
name|LocalLoadingCache
condition|)
block|{
return|return
operator|(
operator|(
name|LocalLoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|cache
operator|)
operator|.
name|localCache
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cache of type "
operator|+
name|cache
operator|.
name|getClass
argument_list|()
operator|+
literal|" doesn't have a LocalCache."
argument_list|)
throw|;
block|}
comment|/**    * Determines whether the given cache can be converted to a LocalCache by    * {@link #toLocalCache} without throwing an exception.    */
DECL|method|hasLocalCache (Cache<?, ?> cache)
specifier|static
name|boolean
name|hasLocalCache
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
return|return
operator|(
name|checkNotNull
argument_list|(
name|cache
argument_list|)
operator|instanceof
name|LocalLoadingCache
operator|)
return|;
block|}
DECL|method|drainRecencyQueues (Cache<?, ?> cache)
specifier|static
name|void
name|drainRecencyQueues
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|drainRecencyQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|drainRecencyQueue (Segment<?, ?> segment)
specifier|static
name|void
name|drainRecencyQueue
parameter_list|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|segment
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|drainReferenceQueues (Cache<?, ?> cache)
specifier|static
name|void
name|drainReferenceQueues
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|drainReferenceQueues
argument_list|(
name|toLocalCache
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|drainReferenceQueues (LocalCache<?, ?> cchm)
specifier|static
name|void
name|drainReferenceQueues
parameter_list|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
parameter_list|)
block|{
for|for
control|(
name|LocalCache
operator|.
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|drainReferenceQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|drainReferenceQueue (LocalCache.Segment<?, ?> segment)
specifier|static
name|void
name|drainReferenceQueue
parameter_list|(
name|LocalCache
operator|.
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|segment
operator|.
name|drainReferenceQueues
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getTotalSegmentSize (Cache<?, ?> cache)
specifier|static
name|int
name|getTotalSegmentSize
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|totalSize
operator|+=
name|segment
operator|.
name|maxSegmentWeight
expr_stmt|;
block|}
return|return
name|totalSize
return|;
block|}
comment|/**    * Peeks into the cache's internals to check its internal consistency. Verifies that each    * segment's count matches its #elements (after cleanup), each segment is unlocked, each entry    * contains a non-null key and value, and the eviction and expiration queues are consistent    * (see {@link #checkEviction}, {@link #checkExpiration}).    */
DECL|method|checkValidState (Cache<?, ?> cache)
specifier|static
name|void
name|checkValidState
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|checkValidState
argument_list|(
name|toLocalCache
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkValidState (LocalCache<?, ?> cchm)
specifier|static
name|void
name|checkValidState
parameter_list|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
parameter_list|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|segment
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|segment
operator|.
name|isLocked
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|table
init|=
name|segmentTable
argument_list|(
name|segment
argument_list|)
decl_stmt|;
comment|// cleanup and then check count after we have a strong reference to all entries
name|segment
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
comment|// under high memory pressure keys/values may be nulled out but not yet enqueued
name|assertThat
argument_list|(
name|table
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|isAtMost
argument_list|(
name|segment
operator|.
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|table
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|assertNotNull
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|cchm
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|checkEviction
argument_list|(
name|cchm
argument_list|)
expr_stmt|;
name|checkExpiration
argument_list|(
name|cchm
argument_list|)
expr_stmt|;
block|}
comment|/**    * Peeks into the cache's internals to verify that its expiration queue is consistent. Verifies    * that the next/prev links in the expiration queue are correct, and that the queue is ordered    * by expiration time.    */
DECL|method|checkExpiration (Cache<?, ?> cache)
specifier|static
name|void
name|checkExpiration
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|checkExpiration
argument_list|(
name|toLocalCache
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkExpiration (LocalCache<?, ?> cchm)
specifier|static
name|void
name|checkExpiration
parameter_list|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
parameter_list|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
if|if
condition|(
name|cchm
operator|.
name|usesWriteQueue
argument_list|()
condition|)
block|{
name|Set
argument_list|<
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|prev
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|current
range|:
name|segment
operator|.
name|writeQueue
control|)
block|{
name|assertTrue
argument_list|(
name|entries
operator|.
name|add
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|prev
argument_list|,
name|current
operator|.
name|getPreviousInWriteQueue
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|prev
operator|.
name|getNextInWriteQueue
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|prev
operator|.
name|getWriteTime
argument_list|()
argument_list|)
operator|.
name|isAtMost
argument_list|(
name|current
operator|.
name|getWriteTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Object
name|key
init|=
name|current
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|current
argument_list|,
name|segment
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|current
operator|.
name|getHash
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|current
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|segment
operator|.
name|count
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|segment
operator|.
name|writeQueue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cchm
operator|.
name|usesAccessQueue
argument_list|()
condition|)
block|{
name|Set
argument_list|<
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|entries
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|prev
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|current
range|:
name|segment
operator|.
name|accessQueue
control|)
block|{
name|assertTrue
argument_list|(
name|entries
operator|.
name|add
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|prev
argument_list|,
name|current
operator|.
name|getPreviousInAccessQueue
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|prev
operator|.
name|getNextInAccessQueue
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|// read accesses may be slightly misordered
name|assertTrue
argument_list|(
name|prev
operator|.
name|getAccessTime
argument_list|()
operator|<=
name|current
operator|.
name|getAccessTime
argument_list|()
operator|||
name|prev
operator|.
name|getAccessTime
argument_list|()
operator|-
name|current
operator|.
name|getAccessTime
argument_list|()
operator|<
literal|1000
argument_list|)
expr_stmt|;
block|}
name|Object
name|key
init|=
name|current
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|current
argument_list|,
name|segment
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|current
operator|.
name|getHash
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|current
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|segment
operator|.
name|count
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|segment
operator|.
name|accessQueue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Peeks into the cache's internals to verify that its eviction queue is consistent. Verifies    * that the prev/next links are correct, and that all items in each segment are also in that    * segment's eviction (recency) queue.    */
DECL|method|checkEviction (Cache<?, ?> cache)
specifier|static
name|void
name|checkEviction
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|checkEviction
argument_list|(
name|toLocalCache
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkEviction (LocalCache<?, ?> map)
specifier|static
name|void
name|checkEviction
parameter_list|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|.
name|evictsBySize
argument_list|()
condition|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|drainRecencyQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|segment
operator|.
name|recencyQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|segment
operator|.
name|readCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|prev
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|current
range|:
name|segment
operator|.
name|accessQueue
control|)
block|{
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|prev
argument_list|,
name|current
operator|.
name|getPreviousInAccessQueue
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|prev
operator|.
name|getNextInAccessQueue
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|Object
name|key
init|=
name|current
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|current
argument_list|,
name|segment
operator|.
name|getEntry
argument_list|(
name|key
argument_list|,
name|current
operator|.
name|getHash
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|current
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|map
operator|.
name|segments
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|segment
operator|.
name|recencyQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|segmentSize (Segment<?, ?> segment)
specifier|static
name|int
name|segmentSize
parameter_list|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|segmentTable
argument_list|(
name|segment
argument_list|)
decl_stmt|;
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|segmentTable (Segment<K, V> segment)
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentTable
parameter_list|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
parameter_list|)
block|{
name|AtomicReferenceArray
argument_list|<
name|?
extends|extends
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|table
init|=
name|segment
operator|.
name|table
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ReferenceEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|table
operator|.
name|get
argument_list|(
name|i
argument_list|)
init|;
name|entry
operator|!=
literal|null
condition|;
name|entry
operator|=
name|entry
operator|.
name|getNext
argument_list|()
control|)
block|{
name|K
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|entry
operator|.
name|getValueReference
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|map
return|;
block|}
DECL|method|writeQueueSize (Cache<?, ?> cache)
specifier|static
name|int
name|writeQueueSize
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|size
operator|+=
name|writeQueueSize
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
DECL|method|writeQueueSize (Segment<?, ?> segment)
specifier|static
name|int
name|writeQueueSize
parameter_list|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|)
block|{
return|return
name|segment
operator|.
name|writeQueue
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|accessQueueSize (Cache<?, ?> cache)
specifier|static
name|int
name|accessQueueSize
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|size
operator|+=
name|accessQueueSize
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
DECL|method|accessQueueSize (Segment<?, ?> segment)
specifier|static
name|int
name|accessQueueSize
parameter_list|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|)
block|{
return|return
name|segment
operator|.
name|accessQueue
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|expirationQueueSize (Cache<?, ?> cache)
specifier|static
name|int
name|expirationQueueSize
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|accessQueueSize
argument_list|(
name|cache
argument_list|)
argument_list|,
name|writeQueueSize
argument_list|(
name|cache
argument_list|)
argument_list|)
return|;
block|}
DECL|method|processPendingNotifications (Cache<?, ?> cache)
specifier|static
name|void
name|processPendingNotifications
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|cchm
operator|.
name|processPendingNotifications
argument_list|()
expr_stmt|;
block|}
block|}
DECL|interface|Receiver
interface|interface
name|Receiver
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|accept (@ullable T object)
name|void
name|accept
parameter_list|(
annotation|@
name|Nullable
name|T
name|object
parameter_list|)
function_decl|;
block|}
comment|/**    * Assuming the given cache has maximum size {@code maxSize}, this method populates the cache (by    * getting a bunch of different keys), then makes sure all the items in the cache are also in the    * eviction queue. It will invoke the given {@code operation} on the first element in the    * eviction queue, and then reverify that all items in the cache are in the eviction queue, and    * verify that the head of the eviction queue has changed as a result of the operation.    */
DECL|method|checkRecency (LoadingCache<Integer, Integer> cache, int maxSize, Receiver<ReferenceEntry<Integer, Integer>> operation)
specifier|static
name|void
name|checkRecency
parameter_list|(
name|LoadingCache
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|cache
parameter_list|,
name|int
name|maxSize
parameter_list|,
name|Receiver
argument_list|<
name|ReferenceEntry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|operation
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|operation
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasLocalCache
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|warmUp
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|maxSize
argument_list|)
expr_stmt|;
name|LocalCache
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|cchm
init|=
name|toLocalCache
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
init|=
name|cchm
operator|.
name|segments
index|[
literal|0
index|]
decl_stmt|;
name|drainRecencyQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|maxSize
argument_list|,
name|accessQueueSize
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|maxSize
argument_list|,
name|cache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ReferenceEntry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|originalHead
init|=
name|segment
operator|.
name|accessQueue
operator|.
name|peek
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReferenceEntry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
operator|(
name|ReferenceEntry
operator|)
name|originalHead
decl_stmt|;
name|operation
operator|.
name|accept
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|drainRecencyQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|originalHead
argument_list|,
name|segment
operator|.
name|accessQueue
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|cache
operator|.
name|size
argument_list|()
argument_list|,
name|accessQueueSize
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Warms the given cache by getting all values in {@code [start, end)}, in order.    */
DECL|method|warmUp (LoadingCache<Integer, Integer> map, int start, int end)
specifier|static
name|void
name|warmUp
parameter_list|(
name|LoadingCache
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|.
name|getUnchecked
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|expireEntries (Cache<?, ?> cache, long expiringTime, FakeTicker ticker)
specifier|static
name|void
name|expireEntries
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|,
name|long
name|expiringTime
parameter_list|,
name|FakeTicker
name|ticker
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
name|expireEntries
argument_list|(
name|toLocalCache
argument_list|(
name|cache
argument_list|)
argument_list|,
name|expiringTime
argument_list|,
name|ticker
argument_list|)
expr_stmt|;
block|}
DECL|method|expireEntries ( LocalCache<?, ?> cchm, long expiringTime, FakeTicker ticker)
specifier|static
name|void
name|expireEntries
parameter_list|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
parameter_list|,
name|long
name|expiringTime
parameter_list|,
name|FakeTicker
name|ticker
parameter_list|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|drainRecencyQueue
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
name|ticker
operator|.
name|advance
argument_list|(
literal|2
operator|*
name|expiringTime
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|ticker
operator|.
name|read
argument_list|()
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|expireEntries
argument_list|(
name|segment
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expiration queue must be empty by now"
argument_list|,
literal|0
argument_list|,
name|writeQueueSize
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expiration queue must be empty by now"
argument_list|,
literal|0
argument_list|,
name|accessQueueSize
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Segments must be empty by now"
argument_list|,
literal|0
argument_list|,
name|segmentSize
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cchm
operator|.
name|processPendingNotifications
argument_list|()
expr_stmt|;
block|}
DECL|method|expireEntries (Segment<?, ?> segment, long now)
specifier|static
name|void
name|expireEntries
parameter_list|(
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|segment
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|segment
operator|.
name|expireEntries
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|segment
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|segment
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkEmpty (Cache<?, ?> cache)
specifier|static
name|void
name|checkEmpty
parameter_list|(
name|Cache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cache
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|cache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cache
operator|.
name|asMap
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cache
operator|.
name|asMap
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cache
operator|.
name|asMap
argument_list|()
operator|.
name|containsValue
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|cache
operator|.
name|asMap
argument_list|()
operator|.
name|containsValue
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|checkEmpty
argument_list|(
name|cache
operator|.
name|asMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|checkEmpty (ConcurrentMap<?, ?> map)
specifier|static
name|void
name|checkEmpty
parameter_list|(
name|ConcurrentMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|checkEmpty
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|checkEmpty
argument_list|(
name|map
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|checkEmpty
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
operator|.
name|hashCode
argument_list|()
argument_list|,
name|map
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|map
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|instanceof
name|LocalCache
condition|)
block|{
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|cchm
init|=
operator|(
name|LocalCache
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|map
decl_stmt|;
name|checkValidState
argument_list|(
name|cchm
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cchm
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|cchm
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LocalCache
operator|.
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|segment
range|:
name|cchm
operator|.
name|segments
control|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|segment
operator|.
name|count
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|segmentSize
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|segment
operator|.
name|writeQueue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|segment
operator|.
name|accessQueue
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|checkEmpty (Collection<?> collection)
specifier|static
name|void
name|checkEmpty
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|collection
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|collection
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|collection
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collection
operator|.
name|toArray
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|collection
operator|.
name|toArray
argument_list|(
operator|new
name|Object
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|collection
operator|instanceof
name|Set
condition|)
block|{
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|collection
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|""
argument_list|)
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|instanceof
name|List
condition|)
block|{
operator|new
name|EqualsTester
argument_list|()
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|collection
argument_list|)
operator|.
name|addEqualityGroup
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|""
argument_list|)
argument_list|)
operator|.
name|testEquals
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

