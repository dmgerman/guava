begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.escape
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|testing
operator|.
name|EscaperAsserts
operator|.
name|assertEscaping
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|testing
operator|.
name|EscaperAsserts
operator|.
name|assertUnescaped
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_comment
comment|/**  * @author David Beaumont  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|SourceCodeEscapersTest
specifier|public
class|class
name|SourceCodeEscapersTest
extends|extends
name|TestCase
block|{
comment|// ASCII control characters.
DECL|field|ASCII_CONTROL_UNESCAPED
specifier|private
specifier|static
specifier|final
name|String
name|ASCII_CONTROL_UNESCAPED
init|=
literal|"\000\001\002\003\004\005\006\007"
operator|+
literal|"\010\011\012\013\014\015\016\017"
operator|+
literal|"\020\021\022\023\024\025\026\027"
operator|+
literal|"\030\031\032\033\034\035\036\037"
decl_stmt|;
DECL|field|ASCII_CONTROL_ESCAPED
specifier|private
specifier|static
specifier|final
name|String
name|ASCII_CONTROL_ESCAPED
init|=
literal|"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007"
operator|+
literal|"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f"
operator|+
literal|"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017"
operator|+
literal|"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f"
decl_stmt|;
DECL|field|ASCII_CONTROL_ESCAPED_WITH_OCTAL
specifier|private
specifier|static
specifier|final
name|String
name|ASCII_CONTROL_ESCAPED_WITH_OCTAL
init|=
literal|"\\000\\001\\002\\003\\004\\005\\006\\007"
operator|+
literal|"\\b\\t\\n\\013\\f\\r\\016\\017"
operator|+
literal|"\\020\\021\\022\\023\\024\\025\\026\\027"
operator|+
literal|"\\030\\031\\032\\033\\034\\035\\036\\037"
decl_stmt|;
comment|// This does not include single quotes, double quotes or backslash.
DECL|field|SAFE_ASCII
specifier|private
specifier|static
specifier|final
name|String
name|SAFE_ASCII
init|=
literal|" !#$%&()*+,-./0123456789:;<=>?@"
operator|+
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`"
operator|+
literal|"abcdefghijklmnopqrstuvwxyz{|}~"
decl_stmt|;
DECL|field|ABOVE_ASCII_UNESCAPED
specifier|private
specifier|static
specifier|final
name|String
name|ABOVE_ASCII_UNESCAPED
init|=
literal|"\200\377\u0100\u0800\u1000\u89AB\uCDEF\uFFFF"
decl_stmt|;
DECL|field|ABOVE_ASCII_ESCAPED
specifier|private
specifier|static
specifier|final
name|String
name|ABOVE_ASCII_ESCAPED
init|=
literal|"\\u0080\\u00ff\\u0100\\u0800\\u1000\\u89ab\\ucdef\\uffff"
decl_stmt|;
DECL|field|ABOVE_ASCII_ESCAPED_WITH_OCTAL
specifier|private
specifier|static
specifier|final
name|String
name|ABOVE_ASCII_ESCAPED_WITH_OCTAL
init|=
literal|"\\200\\377\\u0100\\u0800\\u1000\\u89ab\\ucdef\\uffff"
decl_stmt|;
DECL|method|testJavaCharEscaper ()
specifier|public
name|void
name|testJavaCharEscaper
parameter_list|()
block|{
name|CharEscaper
name|escaper
init|=
name|SourceCodeEscapers
operator|.
name|javaCharEscaper
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|ASCII_CONTROL_ESCAPED
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
name|ASCII_CONTROL_UNESCAPED
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SAFE_ASCII
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
name|SAFE_ASCII
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ABOVE_ASCII_ESCAPED
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
name|ABOVE_ASCII_UNESCAPED
argument_list|)
argument_list|)
expr_stmt|;
comment|// Single quotes, double quotes and backslash are escaped.
name|assertEquals
argument_list|(
literal|"\\'\\\"\\\\"
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
literal|"'\"\\"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testJavaStringUnicodeEscaper ()
specifier|public
name|void
name|testJavaStringUnicodeEscaper
parameter_list|()
block|{
name|CharEscaper
name|escaper
init|=
name|SourceCodeEscapers
operator|.
name|javaStringUnicodeEscaper
argument_list|()
decl_stmt|;
comment|// Test that 7-bit ASCII is never escaped.
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'\u0000'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|escaper
argument_list|,
literal|'\u007f'
argument_list|)
expr_stmt|;
comment|// Test hex escaping for UTF-16.
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u0080"
argument_list|,
literal|'\u0080'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u00bb"
argument_list|,
literal|'\u00bb'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u0100"
argument_list|,
literal|'\u0100'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u1000"
argument_list|,
literal|'\u1000'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\uffff"
argument_list|,
literal|'\uffff'
argument_list|)
expr_stmt|;
comment|// Make sure HEX_DIGITS are all correct.
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u0123"
argument_list|,
literal|'\u0123'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u4567"
argument_list|,
literal|'\u4567'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\u89ab"
argument_list|,
literal|'\u89ab'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|escaper
argument_list|,
literal|"\\ucdef"
argument_list|,
literal|'\ucdef'
argument_list|)
expr_stmt|;
comment|// Verify that input is treated as UTF-16 and _not_ Unicode.
name|assertEquals
argument_list|(
literal|"\\udbff\\udfff"
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
literal|"\uDBFF\uDFFF"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify the escaper does _not_ double escape (it is idempotent).
name|assertEquals
argument_list|(
literal|"\\uabcd"
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
literal|"\uABCD"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\uabcd"
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
name|escaper
operator|.
name|escape
argument_list|(
literal|"\uABCD"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Existing escape sequences are left completely unchanged (including case).
name|assertEquals
argument_list|(
literal|"\\uAbCd"
argument_list|,
name|escaper
operator|.
name|escape
argument_list|(
literal|"\\uAbCd"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testJavascriptEscaper ()
specifier|public
name|void
name|testJavascriptEscaper
parameter_list|()
block|{
name|CharEscaper
name|e
init|=
name|SourceCodeEscapers
operator|.
name|javascriptEscaper
argument_list|()
decl_stmt|;
comment|// Test chars that are specially escaped.
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x27"
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x22"
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x3c"
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x3d"
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x3e"
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x26"
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\b"
argument_list|,
literal|'\b'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\t"
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\n"
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\f"
argument_list|,
literal|'\f'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\r"
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\\\"
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
comment|// A sampling of chars that do not need to be escaped.
name|assertUnescaped
argument_list|(
name|e
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|e
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|e
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|e
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
name|assertUnescaped
argument_list|(
name|e
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
comment|// Test chars that can be 2 digit hex escaped.
comment|// Note that some sources will tell you that \u000b can be escaped to \v but
comment|// some versions of IE will handle this incorrectly
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x00"
argument_list|,
literal|'\u0000'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x0b"
argument_list|,
literal|'\u000b'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x19"
argument_list|,
literal|'\u0019'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\x7f"
argument_list|,
literal|'\u007f'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\xff"
argument_list|,
literal|'\u00ff'
argument_list|)
expr_stmt|;
comment|// Test chars that must be 4 digit hex escaped.
comment|// Specifically test \u200d as a Unicode Format-Control Character which we
comment|// *always* want to escape.
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\u0100"
argument_list|,
literal|'\u0100'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\u200d"
argument_list|,
literal|'\u200d'
argument_list|)
expr_stmt|;
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"\\uffff"
argument_list|,
literal|'\uffff'
argument_list|)
expr_stmt|;
comment|// Javascript is UTF-16 so surrogate pairs are not converted to code points.
name|assertEquals
argument_list|(
literal|"\\udbff\\udfff"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"\uDBFF\uDFFF"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testPythonEscaper ()
specifier|public
name|void
name|testPythonEscaper
parameter_list|()
throws|throws
name|Exception
block|{
name|UnicodeEscaper
name|e
init|=
name|SourceCodeEscapers
operator|.
name|pythonEscaper
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"a normal ascii string"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"a normal ascii string"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\\\"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"\\"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\'\\\"\\n\\r\\t"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"'\"\n\r\t"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\x08\\x0c"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"\b\f"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Test highest and lowest surrogate pairs
name|assertEquals
argument_list|(
literal|"\\U00010000"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"\uD800\uDC00"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\U0010ffff"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"\uDBFF\uDFFF"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

