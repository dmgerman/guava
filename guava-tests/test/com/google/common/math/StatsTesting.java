begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|NEGATIVE_INFINITY
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|NaN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Double
operator|.
name|POSITIVE_INFINITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Doubles
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|DoubleStream
import|;
end_import

begin_comment
comment|/**  * Inputs, expected outputs, and helper methods for tests of {@link StatsAccumulator}, {@link  * Stats}, {@link PairedStatsAccumulator}, and {@link PairedStats}.  *  * @author Pete Gillin  */
end_comment

begin_class
DECL|class|StatsTesting
class|class
name|StatsTesting
block|{
DECL|field|ALLOWED_ERROR
specifier|static
specifier|final
name|double
name|ALLOWED_ERROR
init|=
literal|1e-10
decl_stmt|;
comment|// Inputs and their statistics:
DECL|field|ONE_VALUE
specifier|static
specifier|final
name|double
name|ONE_VALUE
init|=
literal|12.34
decl_stmt|;
DECL|field|OTHER_ONE_VALUE
specifier|static
specifier|final
name|double
name|OTHER_ONE_VALUE
init|=
operator|-
literal|56.78
decl_stmt|;
DECL|field|TWO_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|TWO_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|12.34
argument_list|,
operator|-
literal|56.78
argument_list|)
decl_stmt|;
DECL|field|TWO_VALUES_MEAN
specifier|static
specifier|final
name|double
name|TWO_VALUES_MEAN
init|=
operator|(
literal|12.34
operator|-
literal|56.78
operator|)
operator|/
literal|2
decl_stmt|;
DECL|field|TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS
specifier|static
specifier|final
name|double
name|TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS
init|=
operator|(
literal|12.34
operator|-
name|TWO_VALUES_MEAN
operator|)
operator|*
operator|(
literal|12.34
operator|-
name|TWO_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|56.78
operator|-
name|TWO_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|56.78
operator|-
name|TWO_VALUES_MEAN
operator|)
decl_stmt|;
DECL|field|TWO_VALUES_MAX
specifier|static
specifier|final
name|double
name|TWO_VALUES_MAX
init|=
literal|12.34
decl_stmt|;
DECL|field|TWO_VALUES_MIN
specifier|static
specifier|final
name|double
name|TWO_VALUES_MIN
init|=
operator|-
literal|56.78
decl_stmt|;
DECL|field|OTHER_TWO_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|OTHER_TWO_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|123.456
argument_list|,
operator|-
literal|789.012
argument_list|)
decl_stmt|;
DECL|field|OTHER_TWO_VALUES_MEAN
specifier|static
specifier|final
name|double
name|OTHER_TWO_VALUES_MEAN
init|=
operator|(
literal|123.456
operator|-
literal|789.012
operator|)
operator|/
literal|2
decl_stmt|;
DECL|field|TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS
specifier|static
specifier|final
name|double
name|TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS
init|=
operator|(
literal|12.34
operator|-
name|TWO_VALUES_MEAN
operator|)
operator|*
operator|(
literal|123.456
operator|-
name|OTHER_TWO_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|56.78
operator|-
name|TWO_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|789.012
operator|-
name|OTHER_TWO_VALUES_MEAN
operator|)
decl_stmt|;
comment|/**    * Helper class for testing with non-finite values. {@link #ALL_MANY_VALUES} gives a number    * instances with many combinations of finite and non-finite values. All have {@link    * #MANY_VALUES_COUNT} values. If all the values are finite then the mean is {@link    * #MANY_VALUES_MEAN} and the sum-of-squares-of-deltas is {@link    * #MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS}. The smallest and largest finite values are always    * {@link #MANY_VALUES_MIN} and {@link #MANY_VALUES_MAX}, although setting non-finite values will    * change the true min and max.    */
DECL|class|ManyValues
specifier|static
class|class
name|ManyValues
block|{
DECL|field|values
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|values
decl_stmt|;
DECL|method|ManyValues (double[] values)
name|ManyValues
parameter_list|(
name|double
index|[]
name|values
parameter_list|)
block|{
name|this
operator|.
name|values
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|Doubles
operator|.
name|asList
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|asIterable ()
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|asIterable
parameter_list|()
block|{
return|return
name|values
return|;
block|}
DECL|method|asArray ()
name|double
index|[]
name|asArray
parameter_list|()
block|{
return|return
name|Doubles
operator|.
name|toArray
argument_list|(
name|values
argument_list|)
return|;
block|}
DECL|method|hasAnyPositiveInfinity ()
name|boolean
name|hasAnyPositiveInfinity
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|any
argument_list|(
name|values
argument_list|,
name|Predicates
operator|.
name|equalTo
argument_list|(
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
return|;
block|}
DECL|method|hasAnyNegativeInfinity ()
name|boolean
name|hasAnyNegativeInfinity
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|any
argument_list|(
name|values
argument_list|,
name|Predicates
operator|.
name|equalTo
argument_list|(
name|NEGATIVE_INFINITY
argument_list|)
argument_list|)
return|;
block|}
DECL|method|hasAnyNaN ()
name|boolean
name|hasAnyNaN
parameter_list|()
block|{
return|return
name|Iterables
operator|.
name|any
argument_list|(
name|values
argument_list|,
name|Predicates
operator|.
name|equalTo
argument_list|(
name|NaN
argument_list|)
argument_list|)
return|;
block|}
DECL|method|hasAnyNonFinite ()
name|boolean
name|hasAnyNonFinite
parameter_list|()
block|{
return|return
name|hasAnyPositiveInfinity
argument_list|()
operator|||
name|hasAnyNegativeInfinity
argument_list|()
operator|||
name|hasAnyNaN
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|values
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|createAll ()
specifier|private
specifier|static
name|ImmutableList
argument_list|<
name|ManyValues
argument_list|>
name|createAll
parameter_list|()
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ManyValues
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|double
index|[]
name|values
init|=
operator|new
name|double
index|[
literal|5
index|]
decl_stmt|;
for|for
control|(
name|double
name|first
range|:
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1.1
argument_list|,
name|POSITIVE_INFINITY
argument_list|,
name|NEGATIVE_INFINITY
argument_list|,
name|NaN
argument_list|)
control|)
block|{
name|values
index|[
literal|0
index|]
operator|=
name|first
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
operator|-
literal|44.44
expr_stmt|;
for|for
control|(
name|double
name|third
range|:
name|ImmutableList
operator|.
name|of
argument_list|(
literal|33.33
argument_list|,
name|POSITIVE_INFINITY
argument_list|,
name|NEGATIVE_INFINITY
argument_list|,
name|NaN
argument_list|)
control|)
block|{
name|values
index|[
literal|2
index|]
operator|=
name|third
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
literal|555.555
expr_stmt|;
for|for
control|(
name|double
name|fifth
range|:
name|ImmutableList
operator|.
name|of
argument_list|(
operator|-
literal|2.2
argument_list|,
name|POSITIVE_INFINITY
argument_list|,
name|NEGATIVE_INFINITY
argument_list|,
name|NaN
argument_list|)
control|)
block|{
name|values
index|[
literal|4
index|]
operator|=
name|fifth
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|ManyValues
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
DECL|field|ALL_MANY_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|ManyValues
argument_list|>
name|ALL_MANY_VALUES
init|=
name|ManyValues
operator|.
name|createAll
argument_list|()
decl_stmt|;
DECL|field|MANY_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|MANY_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1.1
argument_list|,
operator|-
literal|44.44
argument_list|,
literal|33.33
argument_list|,
literal|555.555
argument_list|,
operator|-
literal|2.2
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_COUNT
specifier|static
specifier|final
name|int
name|MANY_VALUES_COUNT
init|=
literal|5
decl_stmt|;
DECL|field|MANY_VALUES_MEAN
specifier|static
specifier|final
name|double
name|MANY_VALUES_MEAN
init|=
operator|(
literal|1.1
operator|-
literal|44.44
operator|+
literal|33.33
operator|+
literal|555.555
operator|-
literal|2.2
operator|)
operator|/
literal|5
decl_stmt|;
DECL|field|MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
specifier|static
specifier|final
name|double
name|MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
init|=
operator|(
literal|1.1
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|1.1
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|44.44
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|44.44
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|33.33
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|33.33
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|555.555
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|555.555
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|2.2
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|2.2
operator|-
name|MANY_VALUES_MEAN
operator|)
decl_stmt|;
DECL|field|MANY_VALUES_MAX
specifier|static
specifier|final
name|double
name|MANY_VALUES_MAX
init|=
literal|555.555
decl_stmt|;
DECL|field|MANY_VALUES_MIN
specifier|static
specifier|final
name|double
name|MANY_VALUES_MIN
init|=
operator|-
literal|44.44
decl_stmt|;
comment|// Doubles which will overflow if summed:
DECL|field|LARGE_VALUES
specifier|static
specifier|final
name|double
index|[]
name|LARGE_VALUES
init|=
block|{
name|Double
operator|.
name|MAX_VALUE
block|,
name|Double
operator|.
name|MAX_VALUE
operator|/
literal|2.0
block|}
decl_stmt|;
DECL|field|LARGE_VALUES_MEAN
specifier|static
specifier|final
name|double
name|LARGE_VALUES_MEAN
init|=
literal|0.75
operator|*
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|OTHER_MANY_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Double
argument_list|>
name|OTHER_MANY_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1.11
argument_list|,
operator|-
literal|2.22
argument_list|,
literal|33.3333
argument_list|,
operator|-
literal|44.4444
argument_list|,
literal|555.555555
argument_list|)
decl_stmt|;
DECL|field|OTHER_MANY_VALUES_COUNT
specifier|static
specifier|final
name|int
name|OTHER_MANY_VALUES_COUNT
init|=
literal|5
decl_stmt|;
DECL|field|OTHER_MANY_VALUES_MEAN
specifier|static
specifier|final
name|double
name|OTHER_MANY_VALUES_MEAN
init|=
operator|(
literal|1.11
operator|-
literal|2.22
operator|+
literal|33.3333
operator|-
literal|44.4444
operator|+
literal|555.555555
operator|)
operator|/
literal|5
decl_stmt|;
DECL|field|MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS
specifier|static
specifier|final
name|double
name|MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS
init|=
operator|(
literal|1.1
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|1.11
operator|-
name|OTHER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|44.44
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|2.22
operator|-
name|OTHER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|33.33
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|33.3333
operator|-
name|OTHER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|555.555
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|44.4444
operator|-
name|OTHER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|2.2
operator|-
name|MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|555.555555
operator|-
name|OTHER_MANY_VALUES_MEAN
operator|)
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Integer
argument_list|>
name|INTEGER_MANY_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|11
argument_list|,
operator|-
literal|22
argument_list|,
literal|3333
argument_list|,
operator|-
literal|4444
argument_list|,
literal|555555
argument_list|)
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_COUNT
specifier|static
specifier|final
name|int
name|INTEGER_MANY_VALUES_COUNT
init|=
literal|5
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_MEAN
specifier|static
specifier|final
name|double
name|INTEGER_MANY_VALUES_MEAN
init|=
operator|(
literal|11.0
operator|-
literal|22.0
operator|+
literal|3333.0
operator|-
literal|4444.0
operator|+
literal|555555.0
operator|)
operator|/
literal|5
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
specifier|static
specifier|final
name|double
name|INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
init|=
operator|(
literal|11.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|11.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|22.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|22.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|3333.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|3333.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|4444.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|4444.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|555555.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|555555.0
operator|-
name|INTEGER_MANY_VALUES_MEAN
operator|)
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_MAX
specifier|static
specifier|final
name|double
name|INTEGER_MANY_VALUES_MAX
init|=
literal|555555.0
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_MIN
specifier|static
specifier|final
name|double
name|INTEGER_MANY_VALUES_MIN
init|=
operator|-
literal|4444.0
decl_stmt|;
comment|// Integers which will overflow if summed (using integer arithmetic):
DECL|field|LARGE_INTEGER_VALUES
specifier|static
specifier|final
name|int
index|[]
name|LARGE_INTEGER_VALUES
init|=
block|{
name|Integer
operator|.
name|MAX_VALUE
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
block|}
decl_stmt|;
DECL|field|LARGE_INTEGER_VALUES_MEAN
specifier|static
specifier|final
name|double
name|LARGE_INTEGER_VALUES_MEAN
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|3L
argument_list|)
argument_list|)
operator|.
name|divide
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|4L
argument_list|)
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
DECL|field|LARGE_INTEGER_VALUES_POPULATION_VARIANCE
specifier|static
specifier|final
name|double
name|LARGE_INTEGER_VALUES_POPULATION_VARIANCE
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|.
name|divide
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|16L
argument_list|)
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
DECL|field|LONG_MANY_VALUES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Long
argument_list|>
name|LONG_MANY_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1111L
argument_list|,
operator|-
literal|2222L
argument_list|,
literal|33333333L
argument_list|,
operator|-
literal|44444444L
argument_list|,
literal|5555555555L
argument_list|)
decl_stmt|;
DECL|field|LONG_MANY_VALUES_COUNT
specifier|static
specifier|final
name|int
name|LONG_MANY_VALUES_COUNT
init|=
literal|5
decl_stmt|;
DECL|field|LONG_MANY_VALUES_MEAN
specifier|static
specifier|final
name|double
name|LONG_MANY_VALUES_MEAN
init|=
operator|(
literal|1111.0
operator|-
literal|2222.0
operator|+
literal|33333333.0
operator|-
literal|44444444.0
operator|+
literal|5555555555.0
operator|)
operator|/
literal|5
decl_stmt|;
DECL|field|LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
specifier|static
specifier|final
name|double
name|LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS
init|=
operator|(
literal|1111.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|1111.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|2222.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|2222.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|33333333.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|33333333.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
operator|-
literal|44444444.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
operator|-
literal|44444444.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|+
operator|(
literal|5555555555.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
operator|*
operator|(
literal|5555555555.0
operator|-
name|LONG_MANY_VALUES_MEAN
operator|)
decl_stmt|;
DECL|field|LONG_MANY_VALUES_MAX
specifier|static
specifier|final
name|double
name|LONG_MANY_VALUES_MAX
init|=
literal|5555555555.0
decl_stmt|;
DECL|field|LONG_MANY_VALUES_MIN
specifier|static
specifier|final
name|double
name|LONG_MANY_VALUES_MIN
init|=
operator|-
literal|44444444.0
decl_stmt|;
comment|// Longs which will overflow if summed (using long arithmetic):
DECL|field|LARGE_LONG_VALUES
specifier|static
specifier|final
name|long
index|[]
name|LARGE_LONG_VALUES
init|=
block|{
name|Long
operator|.
name|MAX_VALUE
block|,
name|Long
operator|.
name|MAX_VALUE
operator|/
literal|2
block|}
decl_stmt|;
DECL|field|LARGE_LONG_VALUES_MEAN
specifier|static
specifier|final
name|double
name|LARGE_LONG_VALUES_MEAN
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|3L
argument_list|)
argument_list|)
operator|.
name|divide
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|4L
argument_list|)
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
DECL|field|LARGE_LONG_VALUES_POPULATION_VARIANCE
specifier|static
specifier|final
name|double
name|LARGE_LONG_VALUES_POPULATION_VARIANCE
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|.
name|divide
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|16L
argument_list|)
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
comment|/**    * Returns a stream of a million primitive doubles. The stream is parallel, which should cause    * {@code collect} calls to run in multi-threaded mode, so testing the combiner as well as the    * supplier and accumulator.    */
DECL|method|megaPrimitiveDoubleStream ()
specifier|static
name|DoubleStream
name|megaPrimitiveDoubleStream
parameter_list|()
block|{
return|return
name|DoubleStream
operator|.
name|iterate
argument_list|(
literal|0.0
argument_list|,
name|x
lambda|->
name|x
operator|+
literal|1.0
argument_list|)
operator|.
name|limit
argument_list|(
name|MEGA_STREAM_COUNT
argument_list|)
operator|.
name|parallel
argument_list|()
return|;
block|}
comment|/** Returns a stream containing half the values from {@link #megaPrimitiveDoubleStream}. */
DECL|method|megaPrimitiveDoubleStreamPart1 ()
specifier|static
name|DoubleStream
name|megaPrimitiveDoubleStreamPart1
parameter_list|()
block|{
return|return
name|DoubleStream
operator|.
name|iterate
argument_list|(
literal|0.0
argument_list|,
name|x
lambda|->
name|x
operator|+
literal|2.0
argument_list|)
operator|.
name|limit
argument_list|(
name|MEGA_STREAM_COUNT
operator|/
literal|2
argument_list|)
operator|.
name|parallel
argument_list|()
return|;
block|}
comment|/**    * Returns a stream containing the values from {@link #megaPrimitiveDoubleStream} not in {@link    * #megaPrimitiveDoubleStreamPart1()}.    */
DECL|method|megaPrimitiveDoubleStreamPart2 ()
specifier|static
name|DoubleStream
name|megaPrimitiveDoubleStreamPart2
parameter_list|()
block|{
return|return
name|DoubleStream
operator|.
name|iterate
argument_list|(
literal|999_999.0
argument_list|,
name|x
lambda|->
name|x
operator|-
literal|2.0
argument_list|)
operator|.
name|limit
argument_list|(
name|MEGA_STREAM_COUNT
operator|/
literal|2
argument_list|)
operator|.
name|parallel
argument_list|()
return|;
block|}
DECL|field|MEGA_STREAM_COUNT
specifier|static
specifier|final
name|long
name|MEGA_STREAM_COUNT
init|=
literal|1_000_000
decl_stmt|;
DECL|field|MEGA_STREAM_MEAN
specifier|static
specifier|final
name|double
name|MEGA_STREAM_MEAN
init|=
literal|999_999.0
operator|/
literal|2
decl_stmt|;
DECL|field|MEGA_STREAM_POPULATION_VARIANCE
specifier|static
specifier|final
name|double
name|MEGA_STREAM_POPULATION_VARIANCE
init|=
literal|999_999.0
operator|*
literal|1_000_001.0
operator|/
literal|12
decl_stmt|;
DECL|field|MEGA_STREAM_MIN
specifier|static
specifier|final
name|double
name|MEGA_STREAM_MIN
init|=
literal|0.0
decl_stmt|;
DECL|field|MEGA_STREAM_MAX
specifier|static
specifier|final
name|double
name|MEGA_STREAM_MAX
init|=
literal|999_999.0
decl_stmt|;
comment|// Stats instances:
DECL|field|EMPTY_STATS_VARARGS
specifier|static
specifier|final
name|Stats
name|EMPTY_STATS_VARARGS
init|=
name|Stats
operator|.
name|of
argument_list|()
decl_stmt|;
DECL|field|EMPTY_STATS_ITERABLE
specifier|static
specifier|final
name|Stats
name|EMPTY_STATS_ITERABLE
init|=
name|Stats
operator|.
name|of
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Double
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|ONE_VALUE_STATS
specifier|static
specifier|final
name|Stats
name|ONE_VALUE_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|ONE_VALUE
argument_list|)
decl_stmt|;
DECL|field|OTHER_ONE_VALUE_STATS
specifier|static
specifier|final
name|Stats
name|OTHER_ONE_VALUE_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|OTHER_ONE_VALUE
argument_list|)
decl_stmt|;
DECL|field|TWO_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|TWO_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|TWO_VALUES
argument_list|)
decl_stmt|;
DECL|field|OTHER_TWO_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|OTHER_TWO_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|OTHER_TWO_VALUES
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_STATS_VARARGS
specifier|static
specifier|final
name|Stats
name|MANY_VALUES_STATS_VARARGS
init|=
name|Stats
operator|.
name|of
argument_list|(
literal|1.1
argument_list|,
operator|-
literal|44.44
argument_list|,
literal|33.33
argument_list|,
literal|555.555
argument_list|,
operator|-
literal|2.2
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_STATS_ITERABLE
specifier|static
specifier|final
name|Stats
name|MANY_VALUES_STATS_ITERABLE
init|=
name|Stats
operator|.
name|of
argument_list|(
name|MANY_VALUES
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_STATS_ITERATOR
specifier|static
specifier|final
name|Stats
name|MANY_VALUES_STATS_ITERATOR
init|=
name|Stats
operator|.
name|of
argument_list|(
name|MANY_VALUES
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_STATS_SNAPSHOT
specifier|static
specifier|final
name|Stats
name|MANY_VALUES_STATS_SNAPSHOT
init|=
name|buildManyValuesStatsSnapshot
argument_list|()
decl_stmt|;
DECL|field|LARGE_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|LARGE_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|LARGE_VALUES
argument_list|)
decl_stmt|;
DECL|field|OTHER_MANY_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|OTHER_MANY_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|OTHER_MANY_VALUES
argument_list|)
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_STATS_VARARGS
specifier|static
specifier|final
name|Stats
name|INTEGER_MANY_VALUES_STATS_VARARGS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|Ints
operator|.
name|toArray
argument_list|(
name|INTEGER_MANY_VALUES
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|INTEGER_MANY_VALUES_STATS_ITERABLE
specifier|static
specifier|final
name|Stats
name|INTEGER_MANY_VALUES_STATS_ITERABLE
init|=
name|Stats
operator|.
name|of
argument_list|(
name|INTEGER_MANY_VALUES
argument_list|)
decl_stmt|;
DECL|field|LARGE_INTEGER_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|LARGE_INTEGER_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|LARGE_INTEGER_VALUES
argument_list|)
decl_stmt|;
DECL|field|LONG_MANY_VALUES_STATS_ITERATOR
specifier|static
specifier|final
name|Stats
name|LONG_MANY_VALUES_STATS_ITERATOR
init|=
name|Stats
operator|.
name|of
argument_list|(
name|LONG_MANY_VALUES
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|LONG_MANY_VALUES_STATS_SNAPSHOT
specifier|static
specifier|final
name|Stats
name|LONG_MANY_VALUES_STATS_SNAPSHOT
init|=
name|buildLongManyValuesStatsSnapshot
argument_list|()
decl_stmt|;
DECL|field|LARGE_LONG_VALUES_STATS
specifier|static
specifier|final
name|Stats
name|LARGE_LONG_VALUES_STATS
init|=
name|Stats
operator|.
name|of
argument_list|(
name|LARGE_LONG_VALUES
argument_list|)
decl_stmt|;
DECL|method|buildManyValuesStatsSnapshot ()
specifier|private
specifier|static
name|Stats
name|buildManyValuesStatsSnapshot
parameter_list|()
block|{
name|StatsAccumulator
name|accumulator
init|=
operator|new
name|StatsAccumulator
argument_list|()
decl_stmt|;
name|accumulator
operator|.
name|addAll
argument_list|(
name|MANY_VALUES
argument_list|)
expr_stmt|;
name|Stats
name|stats
init|=
name|accumulator
operator|.
name|snapshot
argument_list|()
decl_stmt|;
name|accumulator
operator|.
name|add
argument_list|(
literal|999.999
argument_list|)
expr_stmt|;
comment|// should do nothing to the snapshot
return|return
name|stats
return|;
block|}
DECL|method|buildLongManyValuesStatsSnapshot ()
specifier|private
specifier|static
name|Stats
name|buildLongManyValuesStatsSnapshot
parameter_list|()
block|{
name|StatsAccumulator
name|accumulator
init|=
operator|new
name|StatsAccumulator
argument_list|()
decl_stmt|;
name|accumulator
operator|.
name|addAll
argument_list|(
name|LONG_MANY_VALUES
argument_list|)
expr_stmt|;
return|return
name|accumulator
operator|.
name|snapshot
argument_list|()
return|;
block|}
DECL|field|ALL_STATS
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Stats
argument_list|>
name|ALL_STATS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|EMPTY_STATS_VARARGS
argument_list|,
name|EMPTY_STATS_ITERABLE
argument_list|,
name|ONE_VALUE_STATS
argument_list|,
name|OTHER_ONE_VALUE_STATS
argument_list|,
name|TWO_VALUES_STATS
argument_list|,
name|OTHER_TWO_VALUES_STATS
argument_list|,
name|MANY_VALUES_STATS_VARARGS
argument_list|,
name|MANY_VALUES_STATS_ITERABLE
argument_list|,
name|MANY_VALUES_STATS_ITERATOR
argument_list|,
name|MANY_VALUES_STATS_SNAPSHOT
argument_list|,
name|LARGE_VALUES_STATS
argument_list|,
name|OTHER_MANY_VALUES_STATS
argument_list|,
name|INTEGER_MANY_VALUES_STATS_VARARGS
argument_list|,
name|INTEGER_MANY_VALUES_STATS_ITERABLE
argument_list|,
name|LARGE_INTEGER_VALUES_STATS
argument_list|,
name|LONG_MANY_VALUES_STATS_ITERATOR
argument_list|,
name|LONG_MANY_VALUES_STATS_SNAPSHOT
argument_list|,
name|LARGE_LONG_VALUES_STATS
argument_list|)
decl_stmt|;
comment|// PairedStats instances:
DECL|field|EMPTY_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|EMPTY_PAIRED_STATS
init|=
name|createPairedStatsOf
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Double
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|Double
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|ONE_VALUE_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|ONE_VALUE_PAIRED_STATS
init|=
name|createPairedStatsOf
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|ONE_VALUE
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|OTHER_ONE_VALUE
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|TWO_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|TWO_VALUES_PAIRED_STATS
init|=
name|createPairedStatsOf
argument_list|(
name|TWO_VALUES
argument_list|,
name|OTHER_TWO_VALUES
argument_list|)
decl_stmt|;
DECL|field|MANY_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|MANY_VALUES_PAIRED_STATS
init|=
name|buildManyValuesPairedStats
argument_list|()
decl_stmt|;
DECL|field|DUPLICATE_MANY_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|DUPLICATE_MANY_VALUES_PAIRED_STATS
init|=
name|createPairedStatsOf
argument_list|(
name|MANY_VALUES
argument_list|,
name|OTHER_MANY_VALUES
argument_list|)
decl_stmt|;
DECL|field|HORIZONTAL_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|HORIZONTAL_VALUES_PAIRED_STATS
init|=
name|buildHorizontalValuesPairedStats
argument_list|()
decl_stmt|;
DECL|field|VERTICAL_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|VERTICAL_VALUES_PAIRED_STATS
init|=
name|buildVerticalValuesPairedStats
argument_list|()
decl_stmt|;
DECL|field|CONSTANT_VALUES_PAIRED_STATS
specifier|static
specifier|final
name|PairedStats
name|CONSTANT_VALUES_PAIRED_STATS
init|=
name|buildConstantValuesPairedStats
argument_list|()
decl_stmt|;
DECL|method|buildManyValuesPairedStats ()
specifier|private
specifier|static
name|PairedStats
name|buildManyValuesPairedStats
parameter_list|()
block|{
name|PairedStatsAccumulator
name|accumulator
init|=
name|createFilledPairedStatsAccumulator
argument_list|(
name|MANY_VALUES
argument_list|,
name|OTHER_MANY_VALUES
argument_list|)
decl_stmt|;
name|PairedStats
name|stats
init|=
name|accumulator
operator|.
name|snapshot
argument_list|()
decl_stmt|;
name|accumulator
operator|.
name|add
argument_list|(
literal|99.99
argument_list|,
literal|9999.9999
argument_list|)
expr_stmt|;
comment|// should do nothing to the snapshot
return|return
name|stats
return|;
block|}
DECL|method|buildHorizontalValuesPairedStats ()
specifier|private
specifier|static
name|PairedStats
name|buildHorizontalValuesPairedStats
parameter_list|()
block|{
name|PairedStatsAccumulator
name|accumulator
init|=
operator|new
name|PairedStatsAccumulator
argument_list|()
decl_stmt|;
for|for
control|(
name|double
name|x
range|:
name|MANY_VALUES
control|)
block|{
name|accumulator
operator|.
name|add
argument_list|(
name|x
argument_list|,
name|OTHER_ONE_VALUE
argument_list|)
expr_stmt|;
block|}
return|return
name|accumulator
operator|.
name|snapshot
argument_list|()
return|;
block|}
DECL|method|buildVerticalValuesPairedStats ()
specifier|private
specifier|static
name|PairedStats
name|buildVerticalValuesPairedStats
parameter_list|()
block|{
name|PairedStatsAccumulator
name|accumulator
init|=
operator|new
name|PairedStatsAccumulator
argument_list|()
decl_stmt|;
for|for
control|(
name|double
name|y
range|:
name|OTHER_MANY_VALUES
control|)
block|{
name|accumulator
operator|.
name|add
argument_list|(
name|ONE_VALUE
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|accumulator
operator|.
name|snapshot
argument_list|()
return|;
block|}
DECL|method|buildConstantValuesPairedStats ()
specifier|private
specifier|static
name|PairedStats
name|buildConstantValuesPairedStats
parameter_list|()
block|{
name|PairedStatsAccumulator
name|accumulator
init|=
operator|new
name|PairedStatsAccumulator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MANY_VALUES_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|accumulator
operator|.
name|add
argument_list|(
name|ONE_VALUE
argument_list|,
name|OTHER_ONE_VALUE
argument_list|)
expr_stmt|;
block|}
return|return
name|accumulator
operator|.
name|snapshot
argument_list|()
return|;
block|}
DECL|field|ALL_PAIRED_STATS
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|PairedStats
argument_list|>
name|ALL_PAIRED_STATS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|EMPTY_PAIRED_STATS
argument_list|,
name|ONE_VALUE_PAIRED_STATS
argument_list|,
name|TWO_VALUES_PAIRED_STATS
argument_list|,
name|MANY_VALUES_PAIRED_STATS
argument_list|,
name|DUPLICATE_MANY_VALUES_PAIRED_STATS
argument_list|,
name|HORIZONTAL_VALUES_PAIRED_STATS
argument_list|,
name|VERTICAL_VALUES_PAIRED_STATS
argument_list|,
name|CONSTANT_VALUES_PAIRED_STATS
argument_list|)
decl_stmt|;
comment|// Helper methods:
DECL|method|assertStatsApproxEqual (Stats expectedStats, Stats actualStats)
specifier|static
name|void
name|assertStatsApproxEqual
parameter_list|(
name|Stats
name|expectedStats
parameter_list|,
name|Stats
name|actualStats
parameter_list|)
block|{
name|assertThat
argument_list|(
name|actualStats
operator|.
name|count
argument_list|()
argument_list|)
operator|.
name|isEqualTo
argument_list|(
name|expectedStats
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedStats
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|actualStats
operator|.
name|mean
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{       }
try|try
block|{
name|actualStats
operator|.
name|populationVariance
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{       }
try|try
block|{
name|actualStats
operator|.
name|min
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{       }
try|try
block|{
name|actualStats
operator|.
name|max
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{       }
block|}
elseif|else
if|if
condition|(
name|expectedStats
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|assertThat
argument_list|(
name|actualStats
operator|.
name|mean
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|mean
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|populationVariance
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
literal|0.0
argument_list|)
operator|.
name|of
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|min
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|min
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|max
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|max
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertThat
argument_list|(
name|actualStats
operator|.
name|mean
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|mean
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|populationVariance
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|populationVariance
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|min
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|min
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|actualStats
operator|.
name|max
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|expectedStats
operator|.
name|max
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Asserts that {@code transformation} is diagonal (i.e. neither horizontal or vertical) and    * passes through both {@code (x1, y1)} and {@code (x1 + xDelta, y1 + yDelta)}. Includes    * assertions about all the public instance methods of {@link LinearTransformation} (on both    * {@code transformation} and its inverse). Since the transformation is expected to be diagonal,    * neither {@code xDelta} nor {@code yDelta} may be zero.    */
DECL|method|assertDiagonalLinearTransformation ( LinearTransformation transformation, double x1, double y1, double xDelta, double yDelta)
specifier|static
name|void
name|assertDiagonalLinearTransformation
parameter_list|(
name|LinearTransformation
name|transformation
parameter_list|,
name|double
name|x1
parameter_list|,
name|double
name|y1
parameter_list|,
name|double
name|xDelta
parameter_list|,
name|double
name|yDelta
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|xDelta
operator|!=
literal|0.0
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|yDelta
operator|!=
literal|0.0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|transform
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|transform
argument_list|(
name|x1
operator|+
name|xDelta
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|y1
operator|+
name|yDelta
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|transform
argument_list|(
name|y1
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|transform
argument_list|(
name|y1
operator|+
name|yDelta
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|x1
operator|+
name|xDelta
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|slope
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|yDelta
operator|/
name|xDelta
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|slope
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|xDelta
operator|/
name|yDelta
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts that {@code transformation} is horizontal with the given value of {@code y}. Includes    * assertions about all the public instance methods of {@link LinearTransformation}, including an    * assertion that {@link LinearTransformation#transform} and {@link LinearTransformation#slope} on    * its inverse throws as expected.    */
DECL|method|assertHorizontalLinearTransformation (LinearTransformation transformation, double y)
specifier|static
name|void
name|assertHorizontalLinearTransformation
parameter_list|(
name|LinearTransformation
name|transformation
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|assertThat
argument_list|(
name|transformation
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isTrue
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isTrue
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|transform
argument_list|(
operator|-
literal|1.0
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|transform
argument_list|(
literal|1.0
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|y
argument_list|)
expr_stmt|;
try|try
block|{
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|transform
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertThat
argument_list|(
name|transformation
operator|.
name|slope
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
try|try
block|{
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|slope
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts that {@code transformation} is vertical with the given value of {@code x}. Includes    * assertions about all the public instance methods of {@link LinearTransformation}, including    * assertions that {@link LinearTransformation#slope} and {@link LinearTransformation#transform}    * throw as expected.    */
DECL|method|assertVerticalLinearTransformation (LinearTransformation transformation, double x)
specifier|static
name|void
name|assertVerticalLinearTransformation
parameter_list|(
name|LinearTransformation
name|transformation
parameter_list|,
name|double
name|x
parameter_list|)
block|{
name|assertThat
argument_list|(
name|transformation
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isTrue
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isTrue
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
try|try
block|{
name|transformation
operator|.
name|transform
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|transform
argument_list|(
operator|-
literal|1.0
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|transform
argument_list|(
literal|1.0
argument_list|)
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
name|x
argument_list|)
expr_stmt|;
try|try
block|{
name|transformation
operator|.
name|slope
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Expected IllegalStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|slope
argument_list|()
argument_list|)
operator|.
name|isWithin
argument_list|(
name|ALLOWED_ERROR
argument_list|)
operator|.
name|of
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts that {@code transformation} behaves as expected for {@link    * LinearTransformation#forNaN}.    */
DECL|method|assertLinearTransformationNaN (LinearTransformation transformation)
specifier|static
name|void
name|assertLinearTransformationNaN
parameter_list|(
name|LinearTransformation
name|transformation
parameter_list|)
block|{
name|assertThat
argument_list|(
name|transformation
operator|.
name|isHorizontal
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|isVertical
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|slope
argument_list|()
argument_list|)
operator|.
name|isNaN
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|transform
argument_list|(
literal|0.0
argument_list|)
argument_list|)
operator|.
name|isNaN
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|transformation
operator|.
name|inverse
argument_list|()
argument_list|)
operator|.
name|isSameInstanceAs
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a {@link PairedStats} from with the given lists of {@code x} and {@code y} values,    * which must be of the same size.    */
DECL|method|createPairedStatsOf (List<Double> xValues, List<Double> yValues)
specifier|static
name|PairedStats
name|createPairedStatsOf
parameter_list|(
name|List
argument_list|<
name|Double
argument_list|>
name|xValues
parameter_list|,
name|List
argument_list|<
name|Double
argument_list|>
name|yValues
parameter_list|)
block|{
return|return
name|createFilledPairedStatsAccumulator
argument_list|(
name|xValues
argument_list|,
name|yValues
argument_list|)
operator|.
name|snapshot
argument_list|()
return|;
block|}
comment|/**    * Creates a {@link PairedStatsAccumulator} filled with the given lists of {@code x} and {@code y}    * values, which must be of the same size.    */
DECL|method|createFilledPairedStatsAccumulator ( List<Double> xValues, List<Double> yValues)
specifier|static
name|PairedStatsAccumulator
name|createFilledPairedStatsAccumulator
parameter_list|(
name|List
argument_list|<
name|Double
argument_list|>
name|xValues
parameter_list|,
name|List
argument_list|<
name|Double
argument_list|>
name|yValues
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|xValues
operator|.
name|size
argument_list|()
operator|==
name|yValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|PairedStatsAccumulator
name|accumulator
init|=
operator|new
name|PairedStatsAccumulator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|xValues
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|accumulator
operator|.
name|add
argument_list|(
name|xValues
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|yValues
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|accumulator
return|;
block|}
comment|/**    * Creates a {@link PairedStatsAccumulator} filled with the given lists of {@code x} and {@code y}    * values, which must be of the same size, added in groups of {@code partitionSize} using {@link    * PairedStatsAccumulator#addAll(PairedStats)}.    */
DECL|method|createPartitionedFilledPairedStatsAccumulator ( List<Double> xValues, List<Double> yValues, int partitionSize)
specifier|static
name|PairedStatsAccumulator
name|createPartitionedFilledPairedStatsAccumulator
parameter_list|(
name|List
argument_list|<
name|Double
argument_list|>
name|xValues
parameter_list|,
name|List
argument_list|<
name|Double
argument_list|>
name|yValues
parameter_list|,
name|int
name|partitionSize
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|xValues
operator|.
name|size
argument_list|()
operator|==
name|yValues
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|checkArgument
argument_list|(
name|partitionSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PairedStatsAccumulator
name|accumulator
init|=
operator|new
name|PairedStatsAccumulator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Double
argument_list|>
argument_list|>
name|xPartitions
init|=
name|Lists
operator|.
name|partition
argument_list|(
name|xValues
argument_list|,
name|partitionSize
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Double
argument_list|>
argument_list|>
name|yPartitions
init|=
name|Lists
operator|.
name|partition
argument_list|(
name|yValues
argument_list|,
name|partitionSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|xPartitions
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|accumulator
operator|.
name|addAll
argument_list|(
name|createPairedStatsOf
argument_list|(
name|xPartitions
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|yPartitions
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|accumulator
return|;
block|}
DECL|method|StatsTesting ()
specifier|private
name|StatsTesting
parameter_list|()
block|{}
block|}
end_class

end_unit

