begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.math
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|math
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|BigInteger
operator|.
name|ONE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|BigInteger
operator|.
name|ZERO
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|CEILING
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|DOWN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|FLOOR
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|HALF_DOWN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|HALF_EVEN
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|HALF_UP
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|math
operator|.
name|RoundingMode
operator|.
name|UP
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Doubles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_comment
comment|/**  * Exhaustive input sets for every integral type.  *  * @author Louis Wasserman  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|MathTesting
specifier|public
class|class
name|MathTesting
block|{
DECL|field|ALL_ROUNDING_MODES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|RoundingMode
argument_list|>
name|ALL_ROUNDING_MODES
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|RoundingMode
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|ALL_SAFE_ROUNDING_MODES
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|RoundingMode
argument_list|>
name|ALL_SAFE_ROUNDING_MODES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|DOWN
argument_list|,
name|UP
argument_list|,
name|FLOOR
argument_list|,
name|CEILING
argument_list|,
name|HALF_EVEN
argument_list|,
name|HALF_UP
argument_list|,
name|HALF_DOWN
argument_list|)
decl_stmt|;
comment|// Exponents to test for the pow() function.
DECL|field|EXPONENTS
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|Integer
argument_list|>
name|EXPONENTS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|10
argument_list|,
literal|15
argument_list|,
literal|20
argument_list|,
literal|25
argument_list|,
literal|30
argument_list|,
literal|40
argument_list|,
literal|70
argument_list|)
decl_stmt|;
comment|/* Helper function to make a Long value from an Integer. */
DECL|field|TO_LONG
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|TO_LONG
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|apply
parameter_list|(
name|Integer
name|n
parameter_list|)
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|n
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/* Helper function to make a BigInteger value from a Long. */
DECL|field|TO_BIGINTEGER
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Long
argument_list|,
name|BigInteger
argument_list|>
name|TO_BIGINTEGER
init|=
operator|new
name|Function
argument_list|<
name|Long
argument_list|,
name|BigInteger
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BigInteger
name|apply
parameter_list|(
name|Long
name|n
parameter_list|)
block|{
return|return
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|n
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|NEGATE_INT
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|NEGATE_INT
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|x
parameter_list|)
block|{
return|return
operator|-
name|x
return|;
block|}
block|}
decl_stmt|;
DECL|field|NEGATE_LONG
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|NEGATE_LONG
init|=
operator|new
name|Function
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|apply
parameter_list|(
name|Long
name|x
parameter_list|)
block|{
return|return
operator|-
name|x
return|;
block|}
block|}
decl_stmt|;
DECL|field|NEGATE_BIGINT
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|BigInteger
argument_list|,
name|BigInteger
argument_list|>
name|NEGATE_BIGINT
init|=
operator|new
name|Function
argument_list|<
name|BigInteger
argument_list|,
name|BigInteger
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BigInteger
name|apply
parameter_list|(
name|BigInteger
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|negate
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/*    * This list contains values that attempt to provoke overflow in integer operations. It contains    * positive values on or near 2^N for N near multiples of 8 (near byte boundaries).    */
DECL|field|POSITIVE_INTEGER_CANDIDATES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|POSITIVE_INTEGER_CANDIDATES
decl_stmt|;
DECL|field|NEGATIVE_INTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|NEGATIVE_INTEGER_CANDIDATES
decl_stmt|;
DECL|field|NONZERO_INTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|NONZERO_INTEGER_CANDIDATES
decl_stmt|;
DECL|field|ALL_INTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|ALL_INTEGER_CANDIDATES
decl_stmt|;
static|static
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|>
name|intValues
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// Add boundary values manually to avoid over/under flow (this covers 2^N for 0 and 31).
name|intValues
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// Add values up to 64. This covers cases like "square of a prime" and such.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|intValues
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// Now add values near 2^N for lots of values of N.
for|for
control|(
name|int
name|exponent
range|:
name|asList
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|,
literal|15
argument_list|,
literal|16
argument_list|,
literal|17
argument_list|,
literal|23
argument_list|,
literal|24
argument_list|,
literal|25
argument_list|,
literal|30
argument_list|)
control|)
block|{
name|int
name|x
init|=
literal|1
operator|<<
name|exponent
decl_stmt|;
name|intValues
operator|.
name|add
argument_list|(
name|x
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|intValues
operator|.
name|add
argument_list|(
literal|9999
argument_list|)
operator|.
name|add
argument_list|(
literal|10000
argument_list|)
operator|.
name|add
argument_list|(
literal|10001
argument_list|)
operator|.
name|add
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|// near powers of 10
name|intValues
operator|.
name|add
argument_list|(
literal|5792
argument_list|)
operator|.
name|add
argument_list|(
literal|5793
argument_list|)
expr_stmt|;
comment|// sqrt(2^25) rounded up and down
name|POSITIVE_INTEGER_CANDIDATES
operator|=
name|intValues
operator|.
name|build
argument_list|()
expr_stmt|;
name|NEGATIVE_INTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|POSITIVE_INTEGER_CANDIDATES
argument_list|,
name|NEGATE_INT
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|NONZERO_INTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|POSITIVE_INTEGER_CANDIDATES
argument_list|,
name|NEGATIVE_INTEGER_CANDIDATES
argument_list|)
expr_stmt|;
name|ALL_INTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|NONZERO_INTEGER_CANDIDATES
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * This list contains values that attempt to provoke overflow in long operations. It contains    * positive values on or near 2^N for N near multiples of 8 (near byte boundaries). This list is    * a superset of POSITIVE_INTEGER_CANDIDATES.    */
DECL|field|POSITIVE_LONG_CANDIDATES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|Long
argument_list|>
name|POSITIVE_LONG_CANDIDATES
decl_stmt|;
DECL|field|NEGATIVE_LONG_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Long
argument_list|>
name|NEGATIVE_LONG_CANDIDATES
decl_stmt|;
DECL|field|NONZERO_LONG_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Long
argument_list|>
name|NONZERO_LONG_CANDIDATES
decl_stmt|;
DECL|field|ALL_LONG_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Long
argument_list|>
name|ALL_LONG_CANDIDATES
decl_stmt|;
static|static
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Long
argument_list|>
name|longValues
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// First of all add all the integer candidate values.
name|longValues
operator|.
name|addAll
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|POSITIVE_INTEGER_CANDIDATES
argument_list|,
name|TO_LONG
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add boundary values manually to avoid over/under flow (this covers 2^N for 31 and 63).
name|longValues
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|+
literal|1L
argument_list|,
name|Long
operator|.
name|MAX_VALUE
operator|-
literal|1L
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// Now add values near 2^N for lots of values of N.
for|for
control|(
name|int
name|exponent
range|:
name|asList
argument_list|(
literal|32
argument_list|,
literal|33
argument_list|,
literal|39
argument_list|,
literal|40
argument_list|,
literal|41
argument_list|,
literal|47
argument_list|,
literal|48
argument_list|,
literal|49
argument_list|,
literal|55
argument_list|,
literal|56
argument_list|,
literal|57
argument_list|)
control|)
block|{
name|long
name|x
init|=
literal|1L
operator|<<
name|exponent
decl_stmt|;
name|longValues
operator|.
name|add
argument_list|(
name|x
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|longValues
operator|.
name|add
argument_list|(
literal|194368031998L
argument_list|)
operator|.
name|add
argument_list|(
literal|194368031999L
argument_list|)
expr_stmt|;
comment|// sqrt(2^75) rounded up and down
name|POSITIVE_LONG_CANDIDATES
operator|=
name|longValues
operator|.
name|build
argument_list|()
expr_stmt|;
name|NEGATIVE_LONG_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|POSITIVE_LONG_CANDIDATES
argument_list|,
name|NEGATE_LONG
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|NONZERO_LONG_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|POSITIVE_LONG_CANDIDATES
argument_list|,
name|NEGATIVE_LONG_CANDIDATES
argument_list|)
expr_stmt|;
name|ALL_LONG_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|NONZERO_LONG_CANDIDATES
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * This list contains values that attempt to provoke overflow in big integer operations. It    * contains positive values on or near 2^N for N near multiples of 8 (near byte boundaries). This    * list is a superset of POSITIVE_LONG_CANDIDATES.    */
DECL|field|POSITIVE_BIGINTEGER_CANDIDATES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|BigInteger
argument_list|>
name|POSITIVE_BIGINTEGER_CANDIDATES
decl_stmt|;
DECL|field|NEGATIVE_BIGINTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|BigInteger
argument_list|>
name|NEGATIVE_BIGINTEGER_CANDIDATES
decl_stmt|;
DECL|field|NONZERO_BIGINTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|BigInteger
argument_list|>
name|NONZERO_BIGINTEGER_CANDIDATES
decl_stmt|;
DECL|field|ALL_BIGINTEGER_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|BigInteger
argument_list|>
name|ALL_BIGINTEGER_CANDIDATES
decl_stmt|;
static|static
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|BigInteger
argument_list|>
name|bigValues
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// First of all add all the long candidate values.
name|bigValues
operator|.
name|addAll
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|POSITIVE_LONG_CANDIDATES
argument_list|,
name|TO_BIGINTEGER
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add boundary values manually to avoid over/under flow.
name|bigValues
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|add
argument_list|(
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now add values near 2^N for lots of values of N.
for|for
control|(
name|int
name|exponent
range|:
name|asList
argument_list|(
literal|64
argument_list|,
literal|65
argument_list|,
literal|71
argument_list|,
literal|72
argument_list|,
literal|73
argument_list|,
literal|79
argument_list|,
literal|80
argument_list|,
literal|81
argument_list|,
literal|255
argument_list|,
literal|256
argument_list|,
literal|257
argument_list|,
literal|511
argument_list|,
literal|512
argument_list|,
literal|513
argument_list|,
name|Double
operator|.
name|MAX_EXPONENT
operator|-
literal|1
argument_list|,
name|Double
operator|.
name|MAX_EXPONENT
argument_list|,
name|Double
operator|.
name|MAX_EXPONENT
operator|+
literal|1
argument_list|)
control|)
block|{
name|BigInteger
name|x
init|=
name|ONE
operator|.
name|shiftLeft
argument_list|(
name|exponent
argument_list|)
decl_stmt|;
name|bigValues
operator|.
name|add
argument_list|(
name|x
argument_list|,
name|x
operator|.
name|add
argument_list|(
name|ONE
argument_list|)
argument_list|,
name|x
operator|.
name|subtract
argument_list|(
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bigValues
operator|.
name|add
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"218838949120258359057546633"
argument_list|)
argument_list|)
expr_stmt|;
comment|// sqrt(2^175) rounded up and
comment|// down
name|bigValues
operator|.
name|add
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"218838949120258359057546634"
argument_list|)
argument_list|)
expr_stmt|;
name|POSITIVE_BIGINTEGER_CANDIDATES
operator|=
name|bigValues
operator|.
name|build
argument_list|()
expr_stmt|;
name|NEGATIVE_BIGINTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|transform
argument_list|(
name|POSITIVE_BIGINTEGER_CANDIDATES
argument_list|,
name|NEGATE_BIGINT
argument_list|)
expr_stmt|;
name|NONZERO_BIGINTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|POSITIVE_BIGINTEGER_CANDIDATES
argument_list|,
name|NEGATIVE_BIGINTEGER_CANDIDATES
argument_list|)
expr_stmt|;
name|ALL_BIGINTEGER_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|NONZERO_BIGINTEGER_CANDIDATES
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|INTEGRAL_DOUBLE_CANDIDATES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|Double
argument_list|>
name|INTEGRAL_DOUBLE_CANDIDATES
decl_stmt|;
DECL|field|FRACTIONAL_DOUBLE_CANDIDATES
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|Double
argument_list|>
name|FRACTIONAL_DOUBLE_CANDIDATES
decl_stmt|;
DECL|field|INFINITIES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Double
argument_list|>
name|INFINITIES
init|=
name|Doubles
operator|.
name|asList
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|,
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|)
decl_stmt|;
DECL|field|FINITE_DOUBLE_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Double
argument_list|>
name|FINITE_DOUBLE_CANDIDATES
decl_stmt|;
DECL|field|POSITIVE_FINITE_DOUBLE_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Double
argument_list|>
name|POSITIVE_FINITE_DOUBLE_CANDIDATES
decl_stmt|;
DECL|field|ALL_DOUBLE_CANDIDATES
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Double
argument_list|>
name|ALL_DOUBLE_CANDIDATES
decl_stmt|;
DECL|field|DOUBLE_CANDIDATES_EXCEPT_NAN
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Double
argument_list|>
name|DOUBLE_CANDIDATES_EXCEPT_NAN
decl_stmt|;
static|static
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Double
argument_list|>
name|integralBuilder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|Double
argument_list|>
name|fractionalBuilder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|integralBuilder
operator|.
name|addAll
argument_list|(
name|Doubles
operator|.
name|asList
argument_list|(
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
name|Double
operator|.
name|MAX_VALUE
argument_list|,
operator|-
name|Double
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add small multiples of MIN_VALUE and MIN_NORMAL
for|for
control|(
name|int
name|scale
init|=
literal|1
init|;
name|scale
operator|<=
literal|4
condition|;
name|scale
operator|++
control|)
block|{
for|for
control|(
name|double
name|d
range|:
name|Doubles
operator|.
name|asList
argument_list|(
name|Double
operator|.
name|MIN_VALUE
argument_list|,
name|Double
operator|.
name|MIN_NORMAL
argument_list|)
control|)
block|{
name|fractionalBuilder
operator|.
name|add
argument_list|(
name|d
operator|*
name|scale
argument_list|)
operator|.
name|add
argument_list|(
operator|-
name|d
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|double
name|d
range|:
name|Doubles
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|,
literal|51
argument_list|,
literal|102
argument_list|,
name|Math
operator|.
name|scalb
argument_list|(
literal|1.0
argument_list|,
literal|53
argument_list|)
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
control|)
block|{
for|for
control|(
name|double
name|delta
range|:
name|Doubles
operator|.
name|asList
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|2.0
argument_list|)
control|)
block|{
name|integralBuilder
operator|.
name|addAll
argument_list|(
name|Doubles
operator|.
name|asList
argument_list|(
name|d
operator|+
name|delta
argument_list|,
name|d
operator|-
name|delta
argument_list|,
operator|-
name|d
operator|-
name|delta
argument_list|,
operator|-
name|d
operator|+
name|delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|double
name|delta
range|:
name|Doubles
operator|.
name|asList
argument_list|(
literal|0.01
argument_list|,
literal|0.1
argument_list|,
literal|0.25
argument_list|,
literal|0.499
argument_list|,
literal|0.5
argument_list|,
literal|0.501
argument_list|,
literal|0.7
argument_list|,
literal|0.8
argument_list|)
control|)
block|{
name|double
name|x
init|=
name|d
operator|+
name|delta
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|Math
operator|.
name|round
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fractionalBuilder
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|INTEGRAL_DOUBLE_CANDIDATES
operator|=
name|integralBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
name|fractionalBuilder
operator|.
name|add
argument_list|(
literal|1.414
argument_list|)
operator|.
name|add
argument_list|(
literal|1.415
argument_list|)
operator|.
name|add
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fractionalBuilder
operator|.
name|add
argument_list|(
literal|5.656
argument_list|)
operator|.
name|add
argument_list|(
literal|5.657
argument_list|)
operator|.
name|add
argument_list|(
literal|4
operator|*
name|Math
operator|.
name|sqrt
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|double
name|d
range|:
name|INTEGRAL_DOUBLE_CANDIDATES
control|)
block|{
name|double
name|x
init|=
literal|1
operator|/
name|d
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|Math
operator|.
name|rint
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fractionalBuilder
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|FRACTIONAL_DOUBLE_CANDIDATES
operator|=
name|fractionalBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
name|FINITE_DOUBLE_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|FRACTIONAL_DOUBLE_CANDIDATES
argument_list|,
name|INTEGRAL_DOUBLE_CANDIDATES
argument_list|)
expr_stmt|;
name|POSITIVE_FINITE_DOUBLE_CANDIDATES
operator|=
name|Iterables
operator|.
name|filter
argument_list|(
name|FINITE_DOUBLE_CANDIDATES
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Double
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Double
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|doubleValue
argument_list|()
operator|>
literal|0.0
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|DOUBLE_CANDIDATES_EXCEPT_NAN
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|FINITE_DOUBLE_CANDIDATES
argument_list|,
name|INFINITIES
argument_list|)
expr_stmt|;
name|ALL_DOUBLE_CANDIDATES
operator|=
name|Iterables
operator|.
name|concat
argument_list|(
name|DOUBLE_CANDIDATES_EXCEPT_NAN
argument_list|,
name|asList
argument_list|(
name|Double
operator|.
name|NaN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

