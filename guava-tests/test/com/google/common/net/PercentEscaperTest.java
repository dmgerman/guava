begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.net
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|net
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|testing
operator|.
name|EscaperAsserts
operator|.
name|assertEscaping
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|testing
operator|.
name|EscaperAsserts
operator|.
name|assertUnescaped
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|testing
operator|.
name|EscaperAsserts
operator|.
name|assertUnicodeEscaping
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|escape
operator|.
name|UnicodeEscaper
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_comment
comment|/**  * Tests for {@link PercentEscaper}.  *  * @author David Beaumont  */
end_comment

begin_class
annotation|@
name|GwtCompatible
DECL|class|PercentEscaperTest
specifier|public
class|class
name|PercentEscaperTest
extends|extends
name|TestCase
block|{
comment|/** Tests that the simple escaper treats 0-9, a-z and A-Z as safe */
DECL|method|testSimpleEscaper ()
specifier|public
name|void
name|testSimpleEscaper
parameter_list|()
block|{
name|UnicodeEscaper
name|e
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|char
name|c
init|=
literal|0
init|;
name|c
operator|<
literal|128
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|assertUnescaped
argument_list|(
name|e
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEscaping
argument_list|(
name|e
argument_list|,
name|escapeAscii
argument_list|(
name|c
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Testing mutlibyte escape sequences
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%00"
argument_list|,
literal|'\u0000'
argument_list|)
expr_stmt|;
comment|// nul
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%7F"
argument_list|,
literal|'\u007f'
argument_list|)
expr_stmt|;
comment|// del
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%C2%80"
argument_list|,
literal|'\u0080'
argument_list|)
expr_stmt|;
comment|// xx-00010,x-000000
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%DF%BF"
argument_list|,
literal|'\u07ff'
argument_list|)
expr_stmt|;
comment|// xx-11111,x-111111
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%E0%A0%80"
argument_list|,
literal|'\u0800'
argument_list|)
expr_stmt|;
comment|// xxx-0000,x-100000,x-00,0000
name|assertEscaping
argument_list|(
name|e
argument_list|,
literal|"%EF%BF%BF"
argument_list|,
literal|'\uffff'
argument_list|)
expr_stmt|;
comment|// xxx-1111,x-111111,x-11,1111
name|assertUnicodeEscaping
argument_list|(
name|e
argument_list|,
literal|"%F0%90%80%80"
argument_list|,
literal|'\uD800'
argument_list|,
literal|'\uDC00'
argument_list|)
expr_stmt|;
name|assertUnicodeEscaping
argument_list|(
name|e
argument_list|,
literal|"%F4%8F%BF%BF"
argument_list|,
literal|'\uDBFF'
argument_list|,
literal|'\uDFFF'
argument_list|)
expr_stmt|;
comment|// simple string tests
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"safestring"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"safestring"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"embedded%00null"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"embedded\0null"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"max%EF%BF%BFchar"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"max\uffffchar"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the various ways that the space character can be handled */
DECL|method|testPlusForSpace ()
specifier|public
name|void
name|testPlusForSpace
parameter_list|()
block|{
name|UnicodeEscaper
name|basicEscaper
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|UnicodeEscaper
name|plusForSpaceEscaper
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|""
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|UnicodeEscaper
name|spaceEscaper
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|" "
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"string%20with%20spaces"
argument_list|,
name|basicEscaper
operator|.
name|escape
argument_list|(
literal|"string with spaces"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"string+with+spaces"
argument_list|,
name|plusForSpaceEscaper
operator|.
name|escape
argument_list|(
literal|"string with spaces"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"string with spaces"
argument_list|,
name|spaceEscaper
operator|.
name|escape
argument_list|(
literal|"string with spaces"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that if we add extra 'safe' characters they remain unescaped */
DECL|method|testCustomEscaper ()
specifier|public
name|void
name|testCustomEscaper
parameter_list|()
block|{
name|UnicodeEscaper
name|e
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|"+*/-"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|char
name|c
init|=
literal|0
init|;
name|c
operator|<
literal|128
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
literal|"+*/-"
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|assertUnescaped
argument_list|(
name|e
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEscaping
argument_list|(
name|e
argument_list|,
name|escapeAscii
argument_list|(
name|c
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Tests that if specify '%' as safe the result is an idempotent escaper. */
DECL|method|testCustomEscaper_withpercent ()
specifier|public
name|void
name|testCustomEscaper_withpercent
parameter_list|()
block|{
name|UnicodeEscaper
name|e
init|=
operator|new
name|PercentEscaper
argument_list|(
literal|"%"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo%7Cbar"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"foo|bar"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo%7Cbar"
argument_list|,
name|e
operator|.
name|escape
argument_list|(
literal|"foo%7Cbar"
argument_list|)
argument_list|)
expr_stmt|;
comment|// idempotent
block|}
comment|/**    * Test that giving a null 'safeChars' string causes a    * {@link NullPointerException}.    */
DECL|method|testBadArguments_null ()
specifier|public
name|void
name|testBadArguments_null
parameter_list|()
block|{
try|try
block|{
operator|new
name|PercentEscaper
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected null pointer exception for null parameter"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{
comment|// pass
block|}
block|}
comment|/**    * Tests that specifying any alphanumeric characters as 'safe' causes an    * {@link IllegalArgumentException}.    */
DECL|method|testBadArguments_badchars ()
specifier|public
name|void
name|testBadArguments_badchars
parameter_list|()
block|{
name|String
name|msg
init|=
literal|"Alphanumeric characters are always 'safe' "
operator|+
literal|"and should not be explicitly specified"
decl_stmt|;
try|try
block|{
operator|new
name|PercentEscaper
argument_list|(
literal|"-+#abc.!"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expected
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests that if space is a safe character you cannot also specify    * 'plusForSpace' (throws {@link IllegalArgumentException}).    */
DECL|method|testBadArguments_plusforspace ()
specifier|public
name|void
name|testBadArguments_plusforspace
parameter_list|()
block|{
try|try
block|{
operator|new
name|PercentEscaper
argument_list|(
literal|" "
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Space can be a 'safe' character if plusForSpace is false"
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"plusForSpace cannot be specified when space is a 'safe' character"
decl_stmt|;
try|try
block|{
operator|new
name|PercentEscaper
argument_list|(
literal|" "
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expected
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Helper to manually escape a 7-bit ascii character */
DECL|method|escapeAscii (char c)
specifier|private
name|String
name|escapeAscii
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|c
operator|<
literal|128
argument_list|)
expr_stmt|;
name|String
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
return|return
literal|"%"
operator|+
name|hex
operator|.
name|charAt
argument_list|(
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
operator|+
name|hex
operator|.
name|charAt
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
return|;
block|}
block|}
end_class

end_unit

