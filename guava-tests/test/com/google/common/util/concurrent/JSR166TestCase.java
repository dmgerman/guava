begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  * Other contributors include Andrew Wright, Jeffrey Hayes,  * Pat Fisher, Mike Judd.  */
end_comment

begin_comment
comment|/*  * Source:  * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java?revision=1.90  * (We have made some trivial local modifications (commented out  * uncompilable code).)  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|NANOSECONDS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|CodeSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PermissionCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Permissions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Policy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|ProtectionDomain
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecurityPermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PropertyPermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CyclicBarrier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|AssertionFailedError
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_comment
comment|/**  * Base class for JSR166 Junit TCK tests. Defines some constants, utility methods and classes, as  * well as a simple framework for helping to make sure that assertions failing in generated threads  * cause the associated test that generated them to itself fail (which JUnit does not otherwise  * arrange). The rules for creating such tests are:  *  *<ol>  *<li>All assertions in code running in generated threads must use the forms {@link #threadFail},  *       {@link #threadAssertTrue}, {@link #threadAssertEquals}, or {@link #threadAssertNull}, (not  *       {@code fail}, {@code assertTrue}, etc.) It is OK (but not particularly recommended) for  *       other code to use these forms too. Only the most typically used JUnit assertion methods are  *       defined this way, but enough to live with.  *<li>If you override {@link #setUp} or {@link #tearDown}, make sure to invoke {@code  *       super.setUp} and {@code super.tearDown} within them. These methods are used to clear and  *       check for thread assertion failures.  *<li>All delays and timeouts must use one of the constants {@code SHORT_DELAY_MS}, {@code  *       SMALL_DELAY_MS}, {@code MEDIUM_DELAY_MS}, {@code LONG_DELAY_MS}. The idea here is that a  *       SHORT is always discriminable from zero time, and always allows enough time for the small  *       amounts of computation (creating a thread, calling a few methods, etc) needed to reach a  *       timeout point. Similarly, a SMALL is always discriminable as larger than SHORT and smaller  *       than MEDIUM. And so on. These constants are set to conservative values, but even so, if  *       there is ever any doubt, they can all be increased in one spot to rerun tests on slower  *       platforms.  *<li>All threads generated must be joined inside each test case method (or {@code fail} to do  *       so) before returning from the method. The {@code joinPool} method can be used to do this  *       when using Executors.  *</ol>  *  *<p><b>Other notes</b>  *  *<ul>  *<li>Usually, there is one testcase method per JSR166 method covering "normal" operation, and  *       then as many exception-testing methods as there are exceptions the method can throw.  *       Sometimes there are multiple tests per JSR166 method when the different "normal" behaviors  *       differ significantly. And sometimes testcases cover multiple methods when they cannot be  *       tested in isolation.  *<li>The documentation style for testcases is to provide as javadoc a simple sentence or two  *       describing the property that the testcase method purports to test. The javadocs do not say  *       anything about how the property is tested. To find out, read the code.  *<li>These tests are "conformance tests", and do not attempt to test throughput, latency,  *       scalability or other performance factors (see the separate "jtreg" tests for a set intended  *       to check these for the most central aspects of functionality.) So, most tests use the  *       smallest sensible numbers of threads, collection sizes, etc needed to check basic  *       conformance.  *<li>The test classes currently do not declare inclusion in any particular package to simplify  *       things for people integrating them in TCK test suites.  *<li>As a convenience, the {@code main} of this class (JSR166TestCase) runs all JSR166 unit  *       tests.  *</ul>  */
end_comment

begin_class
DECL|class|JSR166TestCase
specifier|abstract
class|class
name|JSR166TestCase
extends|extends
name|TestCase
block|{
DECL|field|useSecurityManager
specifier|private
specifier|static
specifier|final
name|boolean
name|useSecurityManager
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"jsr166.useSecurityManager"
argument_list|)
decl_stmt|;
DECL|field|expensiveTests
specifier|protected
specifier|static
specifier|final
name|boolean
name|expensiveTests
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"jsr166.expensiveTests"
argument_list|)
decl_stmt|;
comment|/**    * If true, report on stdout all "slow" tests, that is, ones that take more than profileThreshold    * milliseconds to execute.    */
DECL|field|profileTests
specifier|private
specifier|static
specifier|final
name|boolean
name|profileTests
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"jsr166.profileTests"
argument_list|)
decl_stmt|;
comment|/**    * The number of milliseconds that tests are permitted for execution without being reported, when    * profileTests is set.    */
DECL|field|profileThreshold
specifier|private
specifier|static
specifier|final
name|long
name|profileThreshold
init|=
name|Long
operator|.
name|getLong
argument_list|(
literal|"jsr166.profileThreshold"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
DECL|method|runTest ()
specifier|protected
name|void
name|runTest
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
name|profileTests
condition|)
name|runTestProfiled
argument_list|()
expr_stmt|;
else|else
name|super
operator|.
name|runTest
argument_list|()
expr_stmt|;
block|}
DECL|method|runTestProfiled ()
specifier|protected
name|void
name|runTestProfiled
parameter_list|()
throws|throws
name|Throwable
block|{
name|long
name|t0
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|super
operator|.
name|runTest
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|long
name|elapsedMillis
init|=
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|t0
operator|)
operator|/
operator|(
literal|1000L
operator|*
literal|1000L
operator|)
decl_stmt|;
if|if
condition|(
name|elapsedMillis
operator|>=
name|profileThreshold
condition|)
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%n%s: %d%n"
argument_list|,
name|toString
argument_list|()
argument_list|,
name|elapsedMillis
argument_list|)
expr_stmt|;
block|}
block|}
comment|//     /**
comment|//      * Runs all JSR166 unit tests using junit.textui.TestRunner
comment|//      */
comment|//     public static void main(String[] args) {
comment|//         if (useSecurityManager) {
comment|//             System.err.println("Setting a permissive security manager");
comment|//             Policy.setPolicy(permissivePolicy());
comment|//             System.setSecurityManager(new SecurityManager());
comment|//         }
comment|//         int iters = (args.length == 0) ? 1 : Integer.parseInt(args[0]);
comment|//         Test s = suite();
comment|//         for (int i = 0; i< iters; ++i) {
comment|//             junit.textui.TestRunner.run(s);
comment|//             System.gc();
comment|//             System.runFinalization();
comment|//         }
comment|//         System.exit(0);
comment|//     }
comment|//     public static TestSuite newTestSuite(Object... suiteOrClasses) {
comment|//         TestSuite suite = new TestSuite();
comment|//         for (Object suiteOrClass : suiteOrClasses) {
comment|//             if (suiteOrClass instanceof TestSuite)
comment|//                 suite.addTest((TestSuite) suiteOrClass);
comment|//             else if (suiteOrClass instanceof Class)
comment|//                 suite.addTest(new TestSuite((Class<?>) suiteOrClass));
comment|//             else
comment|//                 throw new ClassCastException("not a test suite or class");
comment|//         }
comment|//         return suite;
comment|//     }
comment|//     /**
comment|//      * Collects all JSR166 unit tests as one suite.
comment|//      */
comment|//     public static Test suite() {
comment|//         return newTestSuite(
comment|//             ForkJoinPoolTest.suite(),
comment|//             ForkJoinTaskTest.suite(),
comment|//             RecursiveActionTest.suite(),
comment|//             RecursiveTaskTest.suite(),
comment|//             LinkedTransferQueueTest.suite(),
comment|//             PhaserTest.suite(),
comment|//             ThreadLocalRandomTest.suite(),
comment|//             AbstractExecutorServiceTest.suite(),
comment|//             AbstractQueueTest.suite(),
comment|//             AbstractQueuedSynchronizerTest.suite(),
comment|//             AbstractQueuedLongSynchronizerTest.suite(),
comment|//             ArrayBlockingQueueTest.suite(),
comment|//             ArrayDequeTest.suite(),
comment|//             AtomicBooleanTest.suite(),
comment|//             AtomicIntegerArrayTest.suite(),
comment|//             AtomicIntegerFieldUpdaterTest.suite(),
comment|//             AtomicIntegerTest.suite(),
comment|//             AtomicLongArrayTest.suite(),
comment|//             AtomicLongFieldUpdaterTest.suite(),
comment|//             AtomicLongTest.suite(),
comment|//             AtomicMarkableReferenceTest.suite(),
comment|//             AtomicReferenceArrayTest.suite(),
comment|//             AtomicReferenceFieldUpdaterTest.suite(),
comment|//             AtomicReferenceTest.suite(),
comment|//             AtomicStampedReferenceTest.suite(),
comment|//             ConcurrentHashMapTest.suite(),
comment|//             ConcurrentLinkedDequeTest.suite(),
comment|//             ConcurrentLinkedQueueTest.suite(),
comment|//             ConcurrentSkipListMapTest.suite(),
comment|//             ConcurrentSkipListSubMapTest.suite(),
comment|//             ConcurrentSkipListSetTest.suite(),
comment|//             ConcurrentSkipListSubSetTest.suite(),
comment|//             CopyOnWriteArrayListTest.suite(),
comment|//             CopyOnWriteArraySetTest.suite(),
comment|//             CountDownLatchTest.suite(),
comment|//             CyclicBarrierTest.suite(),
comment|//             DelayQueueTest.suite(),
comment|//             EntryTest.suite(),
comment|//             ExchangerTest.suite(),
comment|//             ExecutorsTest.suite(),
comment|//             ExecutorCompletionServiceTest.suite(),
comment|//             FutureTaskTest.suite(),
comment|//             LinkedBlockingDequeTest.suite(),
comment|//             LinkedBlockingQueueTest.suite(),
comment|//             LinkedListTest.suite(),
comment|//             LockSupportTest.suite(),
comment|//             PriorityBlockingQueueTest.suite(),
comment|//             PriorityQueueTest.suite(),
comment|//             ReentrantLockTest.suite(),
comment|//             ReentrantReadWriteLockTest.suite(),
comment|//             ScheduledExecutorTest.suite(),
comment|//             ScheduledExecutorSubclassTest.suite(),
comment|//             SemaphoreTest.suite(),
comment|//             SynchronousQueueTest.suite(),
comment|//             SystemTest.suite(),
comment|//             ThreadLocalTest.suite(),
comment|//             ThreadPoolExecutorTest.suite(),
comment|//             ThreadPoolExecutorSubclassTest.suite(),
comment|//             ThreadTest.suite(),
comment|//             TimeUnitTest.suite(),
comment|//             TreeMapTest.suite(),
comment|//             TreeSetTest.suite(),
comment|//             TreeSubMapTest.suite(),
comment|//             TreeSubSetTest.suite());
comment|//     }
DECL|field|SHORT_DELAY_MS
specifier|public
specifier|static
name|long
name|SHORT_DELAY_MS
decl_stmt|;
DECL|field|SMALL_DELAY_MS
specifier|public
specifier|static
name|long
name|SMALL_DELAY_MS
decl_stmt|;
DECL|field|MEDIUM_DELAY_MS
specifier|public
specifier|static
name|long
name|MEDIUM_DELAY_MS
decl_stmt|;
DECL|field|LONG_DELAY_MS
specifier|public
specifier|static
name|long
name|LONG_DELAY_MS
decl_stmt|;
comment|/**    * Returns the shortest timed delay. This could be reimplemented to use for example a Property.    */
DECL|method|getShortDelay ()
specifier|protected
name|long
name|getShortDelay
parameter_list|()
block|{
return|return
literal|50
return|;
block|}
comment|/** Sets delays as multiples of SHORT_DELAY. */
DECL|method|setDelays ()
specifier|protected
name|void
name|setDelays
parameter_list|()
block|{
name|SHORT_DELAY_MS
operator|=
name|getShortDelay
argument_list|()
expr_stmt|;
name|SMALL_DELAY_MS
operator|=
name|SHORT_DELAY_MS
operator|*
literal|5
expr_stmt|;
name|MEDIUM_DELAY_MS
operator|=
name|SHORT_DELAY_MS
operator|*
literal|10
expr_stmt|;
name|LONG_DELAY_MS
operator|=
name|SHORT_DELAY_MS
operator|*
literal|200
expr_stmt|;
block|}
comment|/**    * Returns a timeout in milliseconds to be used in tests that verify that operations block or time    * out.    */
DECL|method|timeoutMillis ()
name|long
name|timeoutMillis
parameter_list|()
block|{
return|return
name|SHORT_DELAY_MS
operator|/
literal|4
return|;
block|}
comment|/** Returns a new Date instance representing a time delayMillis milliseconds in the future. */
DECL|method|delayedDate (long delayMillis)
name|Date
name|delayedDate
parameter_list|(
name|long
name|delayMillis
parameter_list|)
block|{
return|return
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|delayMillis
argument_list|)
return|;
block|}
comment|/** The first exception encountered if any threadAssertXXX method fails. */
DECL|field|threadFailure
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Throwable
argument_list|>
name|threadFailure
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**    * Records an exception so that it can be rethrown later in the test harness thread, triggering a    * test case failure. Only the first failure is recorded; subsequent calls to this method from    * within the same test have no effect.    */
DECL|method|threadRecordFailure (Throwable t)
specifier|public
name|void
name|threadRecordFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadFailure
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|setDelays
argument_list|()
expr_stmt|;
block|}
comment|/**    * Extra checks that get done for all test cases.    *    *<p>Triggers test case failure if any thread assertions have failed, by rethrowing, in the test    * harness thread, any exception recorded earlier by threadRecordFailure.    *    *<p>Triggers test case failure if interrupt status is set in the main thread.    */
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|Throwable
name|t
init|=
name|threadFailure
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|Error
condition|)
throw|throw
operator|(
name|Error
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|RuntimeException
condition|)
throw|throw
operator|(
name|RuntimeException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|Exception
condition|)
throw|throw
operator|(
name|Exception
operator|)
name|t
throw|;
else|else
block|{
name|AssertionFailedError
name|afe
init|=
operator|new
name|AssertionFailedError
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|afe
operator|.
name|initCause
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|afe
throw|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|AssertionFailedError
argument_list|(
literal|"interrupt status set in main thread"
argument_list|)
throw|;
block|}
comment|/**    * Just like fail(reason), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadFail (String reason)
specifier|public
name|void
name|threadFail
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|fail
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Just like assertTrue(b), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertTrue (boolean b)
specifier|public
name|void
name|threadAssertTrue
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
comment|/**    * Just like assertFalse(b), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertFalse (boolean b)
specifier|public
name|void
name|threadAssertFalse
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
try|try
block|{
name|assertFalse
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
comment|/**    * Just like assertNull(x), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertNull (Object x)
specifier|public
name|void
name|threadAssertNull
parameter_list|(
name|Object
name|x
parameter_list|)
block|{
try|try
block|{
name|assertNull
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
comment|/**    * Just like assertEquals(x, y), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertEquals (long x, long y)
specifier|public
name|void
name|threadAssertEquals
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
try|try
block|{
name|assertEquals
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
comment|/**    * Just like assertEquals(x, y), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertEquals (Object x, Object y)
specifier|public
name|void
name|threadAssertEquals
parameter_list|(
name|Object
name|x
parameter_list|,
name|Object
name|y
parameter_list|)
block|{
try|try
block|{
name|assertEquals
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Just like assertSame(x, y), but additionally recording (using threadRecordFailure) any    * AssertionFailedError thrown, so that the current testcase will fail.    */
DECL|method|threadAssertSame (Object x, Object y)
specifier|public
name|void
name|threadAssertSame
parameter_list|(
name|Object
name|x
parameter_list|,
name|Object
name|y
parameter_list|)
block|{
try|try
block|{
name|assertSame
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionFailedError
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
comment|/** Calls threadFail with message "should throw exception". */
DECL|method|threadShouldThrow ()
specifier|public
name|void
name|threadShouldThrow
parameter_list|()
block|{
name|threadFail
argument_list|(
literal|"should throw exception"
argument_list|)
expr_stmt|;
block|}
comment|/** Calls threadFail with message "should throw" + exceptionName. */
DECL|method|threadShouldThrow (String exceptionName)
specifier|public
name|void
name|threadShouldThrow
parameter_list|(
name|String
name|exceptionName
parameter_list|)
block|{
name|threadFail
argument_list|(
literal|"should throw "
operator|+
name|exceptionName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Records the given exception using {@link #threadRecordFailure}, then rethrows the exception,    * wrapping it in an AssertionFailedError if necessary.    */
DECL|method|threadUnexpectedException (Throwable t)
specifier|public
name|void
name|threadUnexpectedException
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadRecordFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|RuntimeException
condition|)
throw|throw
operator|(
name|RuntimeException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|Error
condition|)
throw|throw
operator|(
name|Error
operator|)
name|t
throw|;
else|else
block|{
name|AssertionFailedError
name|afe
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"unexpected exception: "
operator|+
name|t
argument_list|)
decl_stmt|;
name|afe
operator|.
name|initCause
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|afe
throw|;
block|}
block|}
comment|/**    * Delays, via Thread.sleep, for the given millisecond delay, but if the sleep is shorter than    * specified, may re-sleep or yield until time elapses.    */
DECL|method|delay (long millis)
specifier|static
name|void
name|delay
parameter_list|(
name|long
name|millis
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|long
name|ns
init|=
name|millis
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|millis
operator|>
literal|0L
condition|)
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
else|else
comment|// too short to sleep
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
name|long
name|d
init|=
name|ns
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|0L
condition|)
name|millis
operator|=
name|d
operator|/
operator|(
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/** Waits out termination of a thread pool or fails doing so. */
DECL|method|joinPool (ExecutorService exec)
name|void
name|joinPool
parameter_list|(
name|ExecutorService
name|exec
parameter_list|)
block|{
try|try
block|{
name|exec
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"ExecutorService did not terminate in a timely manner"
argument_list|,
name|exec
operator|.
name|awaitTermination
argument_list|(
literal|2
operator|*
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ok
parameter_list|)
block|{
comment|// Allowed in case test doesn't have privs
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Unexpected InterruptedException"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks that thread does not terminate within the default millisecond delay of {@code    * timeoutMillis()}.    */
DECL|method|assertThreadStaysAlive (Thread thread)
name|void
name|assertThreadStaysAlive
parameter_list|(
name|Thread
name|thread
parameter_list|)
block|{
name|assertThreadStaysAlive
argument_list|(
name|thread
argument_list|,
name|timeoutMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that thread does not terminate within the given millisecond delay. */
DECL|method|assertThreadStaysAlive (Thread thread, long millis)
name|void
name|assertThreadStaysAlive
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|long
name|millis
parameter_list|)
block|{
try|try
block|{
comment|// No need to optimize the failing case via Thread.join.
name|delay
argument_list|(
name|millis
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|thread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Unexpected InterruptedException"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks that the threads do not terminate within the default millisecond delay of {@code    * timeoutMillis()}.    */
DECL|method|assertThreadsStayAlive (Thread... threads)
name|void
name|assertThreadsStayAlive
parameter_list|(
name|Thread
modifier|...
name|threads
parameter_list|)
block|{
name|assertThreadsStayAlive
argument_list|(
name|timeoutMillis
argument_list|()
argument_list|,
name|threads
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that the threads do not terminate within the given millisecond delay. */
DECL|method|assertThreadsStayAlive (long millis, Thread... threads)
name|void
name|assertThreadsStayAlive
parameter_list|(
name|long
name|millis
parameter_list|,
name|Thread
modifier|...
name|threads
parameter_list|)
block|{
try|try
block|{
comment|// No need to optimize the failing case via Thread.join.
name|delay
argument_list|(
name|millis
argument_list|)
expr_stmt|;
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
name|assertTrue
argument_list|(
name|thread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Unexpected InterruptedException"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks that future.get times out, with the default timeout of {@code timeoutMillis()}. */
DECL|method|assertFutureTimesOut (Future future)
name|void
name|assertFutureTimesOut
parameter_list|(
name|Future
name|future
parameter_list|)
block|{
name|assertFutureTimesOut
argument_list|(
name|future
argument_list|,
name|timeoutMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that future.get times out, with the given millisecond timeout. */
DECL|method|assertFutureTimesOut (Future future, long timeoutMillis)
name|void
name|assertFutureTimesOut
parameter_list|(
name|Future
name|future
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|future
operator|.
name|get
argument_list|(
name|timeoutMillis
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|shouldThrow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|success
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|millisElapsedSince
argument_list|(
name|startTime
argument_list|)
operator|>=
name|timeoutMillis
argument_list|)
expr_stmt|;
block|}
comment|/** Fails with message "should throw exception". */
DECL|method|shouldThrow ()
specifier|public
name|void
name|shouldThrow
parameter_list|()
block|{
name|fail
argument_list|(
literal|"Should throw exception"
argument_list|)
expr_stmt|;
block|}
comment|/** Fails with message "should throw " + exceptionName. */
DECL|method|shouldThrow (String exceptionName)
specifier|public
name|void
name|shouldThrow
parameter_list|(
name|String
name|exceptionName
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Should throw "
operator|+
name|exceptionName
argument_list|)
expr_stmt|;
block|}
comment|/** The number of elements to place in collections, arrays, etc. */
DECL|field|SIZE
specifier|public
specifier|static
specifier|final
name|int
name|SIZE
init|=
literal|20
decl_stmt|;
comment|// Some convenient Integer constants
DECL|field|zero
specifier|public
specifier|static
specifier|final
name|Integer
name|zero
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|one
specifier|public
specifier|static
specifier|final
name|Integer
name|one
init|=
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|two
specifier|public
specifier|static
specifier|final
name|Integer
name|two
init|=
operator|new
name|Integer
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|three
specifier|public
specifier|static
specifier|final
name|Integer
name|three
init|=
operator|new
name|Integer
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|field|four
specifier|public
specifier|static
specifier|final
name|Integer
name|four
init|=
operator|new
name|Integer
argument_list|(
literal|4
argument_list|)
decl_stmt|;
DECL|field|five
specifier|public
specifier|static
specifier|final
name|Integer
name|five
init|=
operator|new
name|Integer
argument_list|(
literal|5
argument_list|)
decl_stmt|;
DECL|field|six
specifier|public
specifier|static
specifier|final
name|Integer
name|six
init|=
operator|new
name|Integer
argument_list|(
literal|6
argument_list|)
decl_stmt|;
DECL|field|seven
specifier|public
specifier|static
specifier|final
name|Integer
name|seven
init|=
operator|new
name|Integer
argument_list|(
literal|7
argument_list|)
decl_stmt|;
DECL|field|eight
specifier|public
specifier|static
specifier|final
name|Integer
name|eight
init|=
operator|new
name|Integer
argument_list|(
literal|8
argument_list|)
decl_stmt|;
DECL|field|nine
specifier|public
specifier|static
specifier|final
name|Integer
name|nine
init|=
operator|new
name|Integer
argument_list|(
literal|9
argument_list|)
decl_stmt|;
DECL|field|m1
specifier|public
specifier|static
specifier|final
name|Integer
name|m1
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
DECL|field|m2
specifier|public
specifier|static
specifier|final
name|Integer
name|m2
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
DECL|field|m3
specifier|public
specifier|static
specifier|final
name|Integer
name|m3
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|3
argument_list|)
decl_stmt|;
DECL|field|m4
specifier|public
specifier|static
specifier|final
name|Integer
name|m4
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|4
argument_list|)
decl_stmt|;
DECL|field|m5
specifier|public
specifier|static
specifier|final
name|Integer
name|m5
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|5
argument_list|)
decl_stmt|;
DECL|field|m6
specifier|public
specifier|static
specifier|final
name|Integer
name|m6
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|6
argument_list|)
decl_stmt|;
DECL|field|m10
specifier|public
specifier|static
specifier|final
name|Integer
name|m10
init|=
operator|new
name|Integer
argument_list|(
operator|-
literal|10
argument_list|)
decl_stmt|;
comment|/**    * Runs Runnable r with a security policy that permits precisely the specified permissions. If    * there is no current security manager, the runnable is run twice, both with and without a    * security manager. We require that any security manager permit getPolicy/setPolicy.    */
DECL|method|runWithPermissions (Runnable r, Permission... permissions)
specifier|public
name|void
name|runWithPermissions
parameter_list|(
name|Runnable
name|r
parameter_list|,
name|Permission
modifier|...
name|permissions
parameter_list|)
block|{
name|SecurityManager
name|sm
init|=
name|System
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|sm
operator|==
literal|null
condition|)
block|{
name|r
operator|.
name|run
argument_list|()
expr_stmt|;
name|Policy
name|savedPolicy
init|=
name|Policy
operator|.
name|getPolicy
argument_list|()
decl_stmt|;
try|try
block|{
name|Policy
operator|.
name|setPolicy
argument_list|(
name|permissivePolicy
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|setSecurityManager
argument_list|(
operator|new
name|SecurityManager
argument_list|()
argument_list|)
expr_stmt|;
name|runWithPermissions
argument_list|(
name|r
argument_list|,
name|permissions
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|System
operator|.
name|setSecurityManager
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Policy
operator|.
name|setPolicy
argument_list|(
name|savedPolicy
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Policy
name|savedPolicy
init|=
name|Policy
operator|.
name|getPolicy
argument_list|()
decl_stmt|;
name|AdjustablePolicy
name|policy
init|=
operator|new
name|AdjustablePolicy
argument_list|(
name|permissions
argument_list|)
decl_stmt|;
name|Policy
operator|.
name|setPolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
try|try
block|{
name|r
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|policy
operator|.
name|addPermission
argument_list|(
operator|new
name|SecurityPermission
argument_list|(
literal|"setPolicy"
argument_list|)
argument_list|)
expr_stmt|;
name|Policy
operator|.
name|setPolicy
argument_list|(
name|savedPolicy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Runs a runnable without any permissions. */
DECL|method|runWithoutPermissions (Runnable r)
specifier|public
name|void
name|runWithoutPermissions
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|runWithPermissions
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/** A security policy where new permissions can be dynamically added or all cleared. */
DECL|class|AdjustablePolicy
specifier|public
specifier|static
class|class
name|AdjustablePolicy
extends|extends
name|java
operator|.
name|security
operator|.
name|Policy
block|{
DECL|field|perms
name|Permissions
name|perms
init|=
operator|new
name|Permissions
argument_list|()
decl_stmt|;
DECL|method|AdjustablePolicy (Permission... permissions)
name|AdjustablePolicy
parameter_list|(
name|Permission
modifier|...
name|permissions
parameter_list|)
block|{
for|for
control|(
name|Permission
name|permission
range|:
name|permissions
control|)
name|perms
operator|.
name|add
argument_list|(
name|permission
argument_list|)
expr_stmt|;
block|}
DECL|method|addPermission (Permission perm)
name|void
name|addPermission
parameter_list|(
name|Permission
name|perm
parameter_list|)
block|{
name|perms
operator|.
name|add
argument_list|(
name|perm
argument_list|)
expr_stmt|;
block|}
DECL|method|clearPermissions ()
name|void
name|clearPermissions
parameter_list|()
block|{
name|perms
operator|=
operator|new
name|Permissions
argument_list|()
expr_stmt|;
block|}
DECL|method|getPermissions (CodeSource cs)
specifier|public
name|PermissionCollection
name|getPermissions
parameter_list|(
name|CodeSource
name|cs
parameter_list|)
block|{
return|return
name|perms
return|;
block|}
DECL|method|getPermissions (ProtectionDomain pd)
specifier|public
name|PermissionCollection
name|getPermissions
parameter_list|(
name|ProtectionDomain
name|pd
parameter_list|)
block|{
return|return
name|perms
return|;
block|}
DECL|method|implies (ProtectionDomain pd, Permission p)
specifier|public
name|boolean
name|implies
parameter_list|(
name|ProtectionDomain
name|pd
parameter_list|,
name|Permission
name|p
parameter_list|)
block|{
return|return
name|perms
operator|.
name|implies
argument_list|(
name|p
argument_list|)
return|;
block|}
DECL|method|refresh ()
specifier|public
name|void
name|refresh
parameter_list|()
block|{}
block|}
comment|/** Returns a policy containing all the permissions we ever need. */
DECL|method|permissivePolicy ()
specifier|public
specifier|static
name|Policy
name|permissivePolicy
parameter_list|()
block|{
return|return
operator|new
name|AdjustablePolicy
comment|// Permissions j.u.c. needs directly
argument_list|(
operator|new
name|RuntimePermission
argument_list|(
literal|"modifyThread"
argument_list|)
argument_list|,
operator|new
name|RuntimePermission
argument_list|(
literal|"getClassLoader"
argument_list|)
argument_list|,
operator|new
name|RuntimePermission
argument_list|(
literal|"setContextClassLoader"
argument_list|)
argument_list|,
comment|// Permissions needed to change permissions!
operator|new
name|SecurityPermission
argument_list|(
literal|"getPolicy"
argument_list|)
argument_list|,
operator|new
name|SecurityPermission
argument_list|(
literal|"setPolicy"
argument_list|)
argument_list|,
operator|new
name|RuntimePermission
argument_list|(
literal|"setSecurityManager"
argument_list|)
argument_list|,
comment|// Permissions needed by the junit test harness
operator|new
name|RuntimePermission
argument_list|(
literal|"accessDeclaredMembers"
argument_list|)
argument_list|,
operator|new
name|PropertyPermission
argument_list|(
literal|"*"
argument_list|,
literal|"read"
argument_list|)
argument_list|,
operator|new
name|java
operator|.
name|io
operator|.
name|FilePermission
argument_list|(
literal|"<<ALL FILES>>"
argument_list|,
literal|"read"
argument_list|)
argument_list|)
return|;
block|}
comment|/** Sleeps until the given time has elapsed. Throws AssertionFailedError if interrupted. */
DECL|method|sleep (long millis)
name|void
name|sleep
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
try|try
block|{
name|delay
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|AssertionFailedError
name|afe
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Unexpected InterruptedException"
argument_list|)
decl_stmt|;
name|afe
operator|.
name|initCause
argument_list|(
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|afe
throw|;
block|}
block|}
comment|/**    * Spin-waits up to the specified number of milliseconds for the given thread to enter a wait    * state: BLOCKED, WAITING, or TIMED_WAITING.    */
DECL|method|waitForThreadToEnterWaitState (Thread thread, long timeoutMillis)
name|void
name|waitForThreadToEnterWaitState
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Thread
operator|.
name|State
name|s
init|=
name|thread
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|Thread
operator|.
name|State
operator|.
name|BLOCKED
operator|||
name|s
operator|==
name|Thread
operator|.
name|State
operator|.
name|WAITING
operator|||
name|s
operator|==
name|Thread
operator|.
name|State
operator|.
name|TIMED_WAITING
condition|)
return|return;
elseif|else
if|if
condition|(
name|s
operator|==
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
condition|)
name|fail
argument_list|(
literal|"Unexpected thread termination"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|millisElapsedSince
argument_list|(
name|startTime
argument_list|)
operator|>
name|timeoutMillis
condition|)
block|{
name|threadAssertTrue
argument_list|(
name|thread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Waits up to LONG_DELAY_MS for the given thread to enter a wait state: BLOCKED, WAITING, or    * TIMED_WAITING.    */
DECL|method|waitForThreadToEnterWaitState (Thread thread)
name|void
name|waitForThreadToEnterWaitState
parameter_list|(
name|Thread
name|thread
parameter_list|)
block|{
name|waitForThreadToEnterWaitState
argument_list|(
name|thread
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the number of milliseconds since time given by startNanoTime, which must have been    * previously returned from a call to {@link System.nanoTime()}.    */
DECL|method|millisElapsedSince (long startNanoTime)
name|long
name|millisElapsedSince
parameter_list|(
name|long
name|startNanoTime
parameter_list|)
block|{
return|return
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startNanoTime
argument_list|)
return|;
block|}
comment|/** Returns a new started daemon Thread running the given runnable. */
DECL|method|newStartedThread (Runnable runnable)
name|Thread
name|newStartedThread
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|runnable
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/**    * Waits for the specified time (in milliseconds) for the thread to terminate (using {@link    * Thread#join(long)}), else interrupts the thread (in the hope that it may terminate later) and    * fails.    */
DECL|method|awaitTermination (Thread t, long timeoutMillis)
name|void
name|awaitTermination
parameter_list|(
name|Thread
name|t
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
try|try
block|{
name|t
operator|.
name|join
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|t
operator|.
name|getState
argument_list|()
operator|!=
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
condition|)
block|{
name|t
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Test timed out"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Waits for LONG_DELAY_MS milliseconds for the thread to terminate (using {@link    * Thread#join(long)}), else interrupts the thread (in the hope that it may terminate later) and    * fails.    */
DECL|method|awaitTermination (Thread t)
name|void
name|awaitTermination
parameter_list|(
name|Thread
name|t
parameter_list|)
block|{
name|awaitTermination
argument_list|(
name|t
argument_list|,
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
comment|// Some convenient Runnable classes
DECL|class|CheckedRunnable
specifier|public
specifier|abstract
class|class
name|CheckedRunnable
implements|implements
name|Runnable
block|{
DECL|method|realRun ()
specifier|protected
specifier|abstract
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|realRun
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|RunnableShouldThrow
specifier|public
specifier|abstract
class|class
name|RunnableShouldThrow
implements|implements
name|Runnable
block|{
DECL|method|realRun ()
specifier|protected
specifier|abstract
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|field|exceptionClass
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|exceptionClass
decl_stmt|;
DECL|method|RunnableShouldThrow (Class<T> exceptionClass)
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
name|RunnableShouldThrow
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|exceptionClass
parameter_list|)
block|{
name|this
operator|.
name|exceptionClass
operator|=
name|exceptionClass
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|realRun
argument_list|()
expr_stmt|;
name|threadShouldThrow
argument_list|(
name|exceptionClass
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|exceptionClass
operator|.
name|isInstance
argument_list|(
name|t
argument_list|)
condition|)
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|ThreadShouldThrow
specifier|public
specifier|abstract
class|class
name|ThreadShouldThrow
extends|extends
name|Thread
block|{
DECL|method|realRun ()
specifier|protected
specifier|abstract
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|field|exceptionClass
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|exceptionClass
decl_stmt|;
DECL|method|ThreadShouldThrow (Class<T> exceptionClass)
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
name|ThreadShouldThrow
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|exceptionClass
parameter_list|)
block|{
name|this
operator|.
name|exceptionClass
operator|=
name|exceptionClass
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|realRun
argument_list|()
expr_stmt|;
name|threadShouldThrow
argument_list|(
name|exceptionClass
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|exceptionClass
operator|.
name|isInstance
argument_list|(
name|t
argument_list|)
condition|)
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CheckedInterruptedRunnable
specifier|public
specifier|abstract
class|class
name|CheckedInterruptedRunnable
implements|implements
name|Runnable
block|{
DECL|method|realRun ()
specifier|protected
specifier|abstract
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|realRun
argument_list|()
expr_stmt|;
name|threadShouldThrow
argument_list|(
literal|"InterruptedException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|success
parameter_list|)
block|{
name|threadAssertFalse
argument_list|(
name|Thread
operator|.
name|interrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|CheckedCallable
specifier|public
specifier|abstract
class|class
name|CheckedCallable
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Callable
argument_list|<
name|T
argument_list|>
block|{
DECL|method|realCall ()
specifier|protected
specifier|abstract
name|T
name|realCall
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|method|call ()
specifier|public
specifier|final
name|T
name|call
parameter_list|()
block|{
try|try
block|{
return|return
name|realCall
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|class|CheckedInterruptedCallable
specifier|public
specifier|abstract
class|class
name|CheckedInterruptedCallable
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Callable
argument_list|<
name|T
argument_list|>
block|{
DECL|method|realCall ()
specifier|protected
specifier|abstract
name|T
name|realCall
parameter_list|()
throws|throws
name|Throwable
function_decl|;
DECL|method|call ()
specifier|public
specifier|final
name|T
name|call
parameter_list|()
block|{
try|try
block|{
name|T
name|result
init|=
name|realCall
argument_list|()
decl_stmt|;
name|threadShouldThrow
argument_list|(
literal|"InterruptedException"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|success
parameter_list|)
block|{
name|threadAssertFalse
argument_list|(
name|Thread
operator|.
name|interrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|class|NoOpRunnable
specifier|public
specifier|static
class|class
name|NoOpRunnable
implements|implements
name|Runnable
block|{
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{}
block|}
DECL|class|NoOpCallable
specifier|public
specifier|static
class|class
name|NoOpCallable
implements|implements
name|Callable
block|{
DECL|method|call ()
specifier|public
name|Object
name|call
parameter_list|()
block|{
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
block|}
DECL|field|TEST_STRING
specifier|public
specifier|static
specifier|final
name|String
name|TEST_STRING
init|=
literal|"a test string"
decl_stmt|;
DECL|class|StringTask
specifier|public
specifier|static
class|class
name|StringTask
implements|implements
name|Callable
argument_list|<
name|String
argument_list|>
block|{
DECL|method|call ()
specifier|public
name|String
name|call
parameter_list|()
block|{
return|return
name|TEST_STRING
return|;
block|}
block|}
DECL|method|latchAwaitingStringTask (final CountDownLatch latch)
specifier|public
name|Callable
argument_list|<
name|String
argument_list|>
name|latchAwaitingStringTask
parameter_list|(
specifier|final
name|CountDownLatch
name|latch
parameter_list|)
block|{
return|return
operator|new
name|CheckedCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|protected
name|String
name|realCall
parameter_list|()
block|{
try|try
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|quittingTime
parameter_list|)
block|{         }
return|return
name|TEST_STRING
return|;
block|}
block|}
return|;
block|}
DECL|method|awaiter (final CountDownLatch latch)
specifier|public
name|Runnable
name|awaiter
parameter_list|(
specifier|final
name|CountDownLatch
name|latch
parameter_list|)
block|{
return|return
operator|new
name|CheckedRunnable
argument_list|()
block|{
specifier|public
name|void
name|realRun
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|await
argument_list|(
name|latch
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|await (CountDownLatch latch)
specifier|public
name|void
name|await
parameter_list|(
name|CountDownLatch
name|latch
parameter_list|)
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|latch
operator|.
name|await
argument_list|(
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|await (Semaphore semaphore)
specifier|public
name|void
name|await
parameter_list|(
name|Semaphore
name|semaphore
parameter_list|)
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|semaphore
operator|.
name|tryAcquire
argument_list|(
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|//     /**
comment|//      * Spin-waits up to LONG_DELAY_MS until flag becomes true.
comment|//      */
comment|//     public void await(AtomicBoolean flag) {
comment|//         await(flag, LONG_DELAY_MS);
comment|//     }
comment|//     /**
comment|//      * Spin-waits up to the specified timeout until flag becomes true.
comment|//      */
comment|//     public void await(AtomicBoolean flag, long timeoutMillis) {
comment|//         long startTime = System.nanoTime();
comment|//         while (!flag.get()) {
comment|//             if (millisElapsedSince(startTime)> timeoutMillis)
comment|//                 throw new AssertionFailedError("timed out");
comment|//             Thread.yield();
comment|//         }
comment|//     }
DECL|class|NPETask
specifier|public
specifier|static
class|class
name|NPETask
implements|implements
name|Callable
argument_list|<
name|String
argument_list|>
block|{
DECL|method|call ()
specifier|public
name|String
name|call
parameter_list|()
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
block|}
DECL|class|CallableOne
specifier|public
specifier|static
class|class
name|CallableOne
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|method|call ()
specifier|public
name|Integer
name|call
parameter_list|()
block|{
return|return
name|one
return|;
block|}
block|}
DECL|class|ShortRunnable
specifier|public
class|class
name|ShortRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
block|{
name|delay
argument_list|(
name|SHORT_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ShortInterruptedRunnable
specifier|public
class|class
name|ShortInterruptedRunnable
extends|extends
name|CheckedInterruptedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|delay
argument_list|(
name|SHORT_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SmallRunnable
specifier|public
class|class
name|SmallRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
block|{
name|delay
argument_list|(
name|SMALL_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SmallPossiblyInterruptedRunnable
specifier|public
class|class
name|SmallPossiblyInterruptedRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|SMALL_DELAY_MS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|SmallCallable
specifier|public
class|class
name|SmallCallable
extends|extends
name|CheckedCallable
block|{
DECL|method|realCall ()
specifier|protected
name|Object
name|realCall
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|delay
argument_list|(
name|SMALL_DELAY_MS
argument_list|)
expr_stmt|;
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
block|}
DECL|class|MediumRunnable
specifier|public
class|class
name|MediumRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
throws|throws
name|Throwable
block|{
name|delay
argument_list|(
name|MEDIUM_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MediumInterruptedRunnable
specifier|public
class|class
name|MediumInterruptedRunnable
extends|extends
name|CheckedInterruptedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|delay
argument_list|(
name|MEDIUM_DELAY_MS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|possiblyInterruptedRunnable (final long timeoutMillis)
specifier|public
name|Runnable
name|possiblyInterruptedRunnable
parameter_list|(
specifier|final
name|long
name|timeoutMillis
parameter_list|)
block|{
return|return
operator|new
name|CheckedRunnable
argument_list|()
block|{
specifier|protected
name|void
name|realRun
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{         }
block|}
block|}
return|;
block|}
DECL|class|MediumPossiblyInterruptedRunnable
specifier|public
class|class
name|MediumPossiblyInterruptedRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|MEDIUM_DELAY_MS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|LongPossiblyInterruptedRunnable
specifier|public
class|class
name|LongPossiblyInterruptedRunnable
extends|extends
name|CheckedRunnable
block|{
DECL|method|realRun ()
specifier|protected
name|void
name|realRun
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
comment|/** For use as ThreadFactory in constructors */
DECL|class|SimpleThreadFactory
specifier|public
specifier|static
class|class
name|SimpleThreadFactory
implements|implements
name|ThreadFactory
block|{
DECL|method|newThread (Runnable r)
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
return|return
operator|new
name|Thread
argument_list|(
name|r
argument_list|)
return|;
block|}
block|}
DECL|interface|TrackedRunnable
specifier|public
interface|interface
name|TrackedRunnable
extends|extends
name|Runnable
block|{
DECL|method|isDone ()
name|boolean
name|isDone
parameter_list|()
function_decl|;
block|}
DECL|method|trackedRunnable (final long timeoutMillis)
specifier|public
specifier|static
name|TrackedRunnable
name|trackedRunnable
parameter_list|(
specifier|final
name|long
name|timeoutMillis
parameter_list|)
block|{
return|return
operator|new
name|TrackedRunnable
argument_list|()
block|{
specifier|private
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|timeoutMillis
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{         }
block|}
block|}
return|;
block|}
DECL|class|TrackedShortRunnable
specifier|public
specifier|static
class|class
name|TrackedShortRunnable
implements|implements
name|Runnable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|SHORT_DELAY_MS
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|TrackedSmallRunnable
specifier|public
specifier|static
class|class
name|TrackedSmallRunnable
implements|implements
name|Runnable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|SMALL_DELAY_MS
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|TrackedMediumRunnable
specifier|public
specifier|static
class|class
name|TrackedMediumRunnable
implements|implements
name|Runnable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|MEDIUM_DELAY_MS
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|TrackedLongRunnable
specifier|public
specifier|static
class|class
name|TrackedLongRunnable
implements|implements
name|Runnable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|LONG_DELAY_MS
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
block|}
block|}
DECL|class|TrackedNoOpRunnable
specifier|public
specifier|static
class|class
name|TrackedNoOpRunnable
implements|implements
name|Runnable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|class|TrackedCallable
specifier|public
specifier|static
class|class
name|TrackedCallable
implements|implements
name|Callable
block|{
DECL|field|done
specifier|public
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|call ()
specifier|public
name|Object
name|call
parameter_list|()
block|{
try|try
block|{
name|delay
argument_list|(
name|SMALL_DELAY_MS
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{       }
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
block|}
comment|//     /**
comment|//      * Analog of CheckedRunnable for RecursiveAction
comment|//      */
comment|//     public abstract class CheckedRecursiveAction extends RecursiveAction {
comment|//         protected abstract void realCompute() throws Throwable;
comment|//         public final void compute() {
comment|//             try {
comment|//                 realCompute();
comment|//             } catch (Throwable t) {
comment|//                 threadUnexpectedException(t);
comment|//             }
comment|//         }
comment|//     }
comment|//     /**
comment|//      * Analog of CheckedCallable for RecursiveTask
comment|//      */
comment|//     public abstract class CheckedRecursiveTask<T> extends RecursiveTask<T> {
comment|//         protected abstract T realCompute() throws Throwable;
comment|//         public final T compute() {
comment|//             try {
comment|//                 return realCompute();
comment|//             } catch (Throwable t) {
comment|//                 threadUnexpectedException(t);
comment|//                 return null;
comment|//             }
comment|//         }
comment|//     }
comment|/** For use as RejectedExecutionHandler in constructors */
DECL|class|NoOpREHandler
specifier|public
specifier|static
class|class
name|NoOpREHandler
implements|implements
name|RejectedExecutionHandler
block|{
DECL|method|rejectedExecution (Runnable r, ThreadPoolExecutor executor)
specifier|public
name|void
name|rejectedExecution
parameter_list|(
name|Runnable
name|r
parameter_list|,
name|ThreadPoolExecutor
name|executor
parameter_list|)
block|{}
block|}
comment|/**    * A CyclicBarrier that uses timed await and fails with AssertionFailedErrors instead of throwing    * checked exceptions.    */
DECL|class|CheckedBarrier
specifier|public
class|class
name|CheckedBarrier
extends|extends
name|CyclicBarrier
block|{
DECL|method|CheckedBarrier (int parties)
specifier|public
name|CheckedBarrier
parameter_list|(
name|int
name|parties
parameter_list|)
block|{
name|super
argument_list|(
name|parties
argument_list|)
expr_stmt|;
block|}
DECL|method|await ()
specifier|public
name|int
name|await
parameter_list|()
block|{
try|try
block|{
return|return
name|super
operator|.
name|await
argument_list|(
literal|2
operator|*
name|LONG_DELAY_MS
argument_list|,
name|MILLISECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionFailedError
argument_list|(
literal|"timed out"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|AssertionFailedError
name|afe
init|=
operator|new
name|AssertionFailedError
argument_list|(
literal|"Unexpected exception: "
operator|+
name|e
argument_list|)
decl_stmt|;
name|afe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|afe
throw|;
block|}
block|}
block|}
DECL|method|checkEmpty (BlockingQueue q)
name|void
name|checkEmpty
parameter_list|(
name|BlockingQueue
name|q
parameter_list|)
block|{
try|try
block|{
name|assertTrue
argument_list|(
name|q
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|q
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|q
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|q
operator|.
name|poll
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|q
operator|.
name|poll
argument_list|(
literal|0
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[]"
argument_list|,
name|q
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|q
operator|.
name|toArray
argument_list|()
argument_list|,
operator|new
name|Object
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|q
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|q
operator|.
name|element
argument_list|()
expr_stmt|;
name|shouldThrow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|success
parameter_list|)
block|{       }
try|try
block|{
name|q
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|shouldThrow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|success
parameter_list|)
block|{       }
try|try
block|{
name|q
operator|.
name|remove
argument_list|()
expr_stmt|;
name|shouldThrow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|success
parameter_list|)
block|{       }
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|serialClone (T o)
parameter_list|<
name|T
parameter_list|>
name|T
name|serialClone
parameter_list|(
name|T
name|o
parameter_list|)
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|ObjectOutputStream
name|oos
init|=
operator|new
name|ObjectOutputStream
argument_list|(
name|bos
argument_list|)
decl_stmt|;
name|oos
operator|.
name|writeObject
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|oos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|oos
operator|.
name|close
argument_list|()
expr_stmt|;
name|ObjectInputStream
name|ois
init|=
operator|new
name|ObjectInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bos
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|T
name|clone
init|=
operator|(
name|T
operator|)
name|ois
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|assertSame
argument_list|(
name|o
operator|.
name|getClass
argument_list|()
argument_list|,
name|clone
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|threadUnexpectedException
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

