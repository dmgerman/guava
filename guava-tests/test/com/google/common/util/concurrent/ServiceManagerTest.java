begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|NullPointerTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|TestLogHandler
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ServiceManager
operator|.
name|Listener
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|LogRecord
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * Tests for {@link ServiceManager}.  *  * @author Luke Sandberg  * @author Chris Nokleberg  */
end_comment

begin_class
DECL|class|ServiceManagerTest
specifier|public
class|class
name|ServiceManagerTest
extends|extends
name|TestCase
block|{
DECL|class|NoOpService
specifier|private
specifier|static
class|class
name|NoOpService
extends|extends
name|AbstractService
block|{
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
DECL|method|doStop ()
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * A NoOp service that will delay the startup and shutdown notification for a configurable amount    * of time.    */
DECL|class|NoOpDelayedSerivce
specifier|private
specifier|static
class|class
name|NoOpDelayedSerivce
extends|extends
name|NoOpService
block|{
DECL|field|delay
specifier|private
name|long
name|delay
decl_stmt|;
DECL|method|NoOpDelayedSerivce (long delay)
specifier|public
name|NoOpDelayedSerivce
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
name|this
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
block|}
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Uninterruptibles
operator|.
name|sleepUninterruptibly
argument_list|(
name|delay
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|notifyStarted
argument_list|()
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|doStop ()
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Uninterruptibles
operator|.
name|sleepUninterruptibly
argument_list|(
name|delay
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|FailStartService
specifier|private
specifier|static
class|class
name|FailStartService
extends|extends
name|NoOpService
block|{
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|notifyFailed
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FailRunService
specifier|private
specifier|static
class|class
name|FailRunService
extends|extends
name|NoOpService
block|{
DECL|method|doStart ()
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|super
operator|.
name|doStart
argument_list|()
expr_stmt|;
name|notifyFailed
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FailStopService
specifier|private
specifier|static
class|class
name|FailStopService
extends|extends
name|NoOpService
block|{
DECL|method|doStop ()
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyFailed
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testServiceStartupTimes ()
specifier|public
name|void
name|testServiceStartupTimes
parameter_list|()
block|{
name|Service
name|a
init|=
operator|new
name|NoOpDelayedSerivce
argument_list|(
literal|150
argument_list|)
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|NoOpDelayedSerivce
argument_list|(
literal|353
argument_list|)
decl_stmt|;
name|ServiceManager
name|serviceManager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|serviceManager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|ImmutableMap
argument_list|<
name|Service
argument_list|,
name|Long
argument_list|>
name|startupTimes
init|=
name|serviceManager
operator|.
name|startupTimes
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|startupTimes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|startupTimes
operator|.
name|get
argument_list|(
name|a
argument_list|)
operator|>=
literal|150
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|startupTimes
operator|.
name|get
argument_list|(
name|b
argument_list|)
operator|>=
literal|353
argument_list|)
expr_stmt|;
block|}
DECL|method|testServiceStartStop ()
specifier|public
name|void
name|testServiceStartStop
parameter_list|()
block|{
name|Service
name|a
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|NEW
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|RUNNING
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|failedServices
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|failedServices
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testFailStart ()
specifier|public
name|void
name|testFailStart
parameter_list|()
throws|throws
name|Exception
block|{
name|Service
name|a
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|Service
name|c
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|d
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|Service
name|e
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|NEW
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertFalse
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|RUNNING
argument_list|,
name|a
argument_list|,
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|b
argument_list|,
name|d
argument_list|)
argument_list|,
name|listener
operator|.
name|failedServices
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|b
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
block|}
DECL|method|testFailRun ()
specifier|public
name|void
name|testFailRun
parameter_list|()
throws|throws
name|Exception
block|{
name|Service
name|a
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|FailRunService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|NEW
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertTrue
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|b
argument_list|)
argument_list|,
name|listener
operator|.
name|failedServices
argument_list|)
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
block|}
DECL|method|testFailStop ()
specifier|public
name|void
name|testFailStop
parameter_list|()
throws|throws
name|Exception
block|{
name|Service
name|a
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|FailStopService
argument_list|()
decl_stmt|;
name|Service
name|c
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|b
argument_list|)
argument_list|,
name|listener
operator|.
name|failedServices
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertState
argument_list|(
name|manager
argument_list|,
name|Service
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|testToString ()
specifier|public
name|void
name|testToString
parameter_list|()
throws|throws
name|Exception
block|{
name|Service
name|a
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|toString
init|=
name|manager
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|toString
operator|.
name|contains
argument_list|(
literal|"NoOpService"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|toString
operator|.
name|contains
argument_list|(
literal|"FailStartService"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTimeouts ()
specifier|public
name|void
name|testTimeouts
parameter_list|()
throws|throws
name|Exception
block|{
name|Service
name|a
init|=
operator|new
name|NoOpDelayedSerivce
argument_list|(
literal|50
argument_list|)
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|awaitHealthy
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|expected
parameter_list|)
block|{     }
name|manager
operator|.
name|awaitHealthy
argument_list|(
literal|100
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
comment|// no exception thrown
name|manager
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|awaitStopped
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|expected
parameter_list|)
block|{     }
name|manager
operator|.
name|awaitStopped
argument_list|(
literal|100
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
comment|// no exception thrown
block|}
comment|/**    * This covers a case where if the last service to stop failed then the stopped callback would    * never be called.    */
DECL|method|testSingleFailedServiceCallsStopped ()
specifier|public
name|void
name|testSingleFailedServiceCallsStopped
parameter_list|()
block|{
name|Service
name|a
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
block|}
comment|/**    * This covers a bug where listener.healthy would get called when a single service failed during    * startup (it occurred in more complicated cases also).    */
DECL|method|testFailStart_singleServiceCallsHealthy ()
specifier|public
name|void
name|testFailStart_singleServiceCallsHealthy
parameter_list|()
block|{
name|Service
name|a
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|expected
parameter_list|)
block|{     }
name|assertFalse
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
block|}
comment|/**    * This covers a bug where if a listener was installed that would stop the manager if any service    * fails and something failed during startup before service.start was called on all the services,    * then awaitStopped would deadlock due to an IllegalStateException that was thrown when trying to    * stop the timer(!).    */
DECL|method|testFailStart_stopOthers ()
specifier|public
name|void
name|testFailStart_stopOthers
parameter_list|()
throws|throws
name|TimeoutException
block|{
name|Service
name|a
init|=
operator|new
name|FailStartService
argument_list|()
decl_stmt|;
name|Service
name|b
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
specifier|final
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|asList
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
operator|new
name|Listener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|manager
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
expr_stmt|;
name|manager
operator|.
name|awaitStopped
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
DECL|method|assertState ( ServiceManager manager, Service.State state, Service... services)
specifier|private
specifier|static
name|void
name|assertState
parameter_list|(
name|ServiceManager
name|manager
parameter_list|,
name|Service
operator|.
name|State
name|state
parameter_list|,
name|Service
modifier|...
name|services
parameter_list|)
block|{
name|Collection
argument_list|<
name|Service
argument_list|>
name|managerServices
init|=
name|manager
operator|.
name|servicesByState
argument_list|()
operator|.
name|get
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|Service
name|service
range|:
name|services
control|)
block|{
name|assertEquals
argument_list|(
name|service
operator|.
name|toString
argument_list|()
argument_list|,
name|state
argument_list|,
name|service
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|service
operator|.
name|toString
argument_list|()
argument_list|,
name|service
operator|.
name|isRunning
argument_list|()
argument_list|,
name|state
operator|==
name|Service
operator|.
name|State
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|managerServices
operator|+
literal|" should contain "
operator|+
name|service
argument_list|,
name|managerServices
operator|.
name|contains
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is for covering a case where the ServiceManager would behave strangely if constructed    * with no service under management.  Listeners would never fire because the ServiceManager was    * healthy and stopped at the same time.  This test ensures that listeners fire and isHealthy    * makes sense.    */
DECL|method|testEmptyServiceManager ()
specifier|public
name|void
name|testEmptyServiceManager
parameter_list|()
block|{
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ServiceManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|logger
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
expr_stmt|;
name|TestLogHandler
name|logHandler
init|=
operator|new
name|TestLogHandler
argument_list|()
decl_stmt|;
name|logger
operator|.
name|addHandler
argument_list|(
name|logHandler
argument_list|)
expr_stmt|;
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|Arrays
operator|.
expr|<
name|Service
operator|>
name|asList
argument_list|()
argument_list|)
decl_stmt|;
name|RecordingListener
name|listener
init|=
operator|new
name|RecordingListener
argument_list|()
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|healthyCalled
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|failedServices
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|stoppedCalled
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|failedServices
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// check that our NoOpService is not directly observable via any of the inspection methods or
comment|// via logging.
name|assertEquals
argument_list|(
literal|"ServiceManager{services=[]}"
argument_list|,
name|manager
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|servicesByState
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|startupTimes
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Formatter
name|logFormatter
init|=
operator|new
name|Formatter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|format
parameter_list|(
name|LogRecord
name|record
parameter_list|)
block|{
return|return
name|formatMessage
argument_list|(
name|record
argument_list|)
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|LogRecord
name|record
range|:
name|logHandler
operator|.
name|getStoredLogRecords
argument_list|()
control|)
block|{
name|assertFalse
argument_list|(
name|logFormatter
operator|.
name|format
argument_list|(
name|record
argument_list|)
operator|.
name|contains
argument_list|(
literal|"NoOpService"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests that a ServiceManager can be fully shut down if one of its failure listeners is slow or    * even permanently blocked.    */
DECL|method|testListenerDeadlock ()
specifier|public
name|void
name|testListenerDeadlock
parameter_list|()
throws|throws
name|InterruptedException
block|{
specifier|final
name|CountDownLatch
name|failEnter
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|failLeave
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|afterStarted
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Service
name|failRunService
init|=
operator|new
name|AbstractService
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|notifyStarted
argument_list|()
expr_stmt|;
comment|// We need to wait for the main thread to leave the ServiceManager.startAsync call to
comment|// ensure that the thread running the failure callbacks is not the main thread.
name|Uninterruptibles
operator|.
name|awaitUninterruptibly
argument_list|(
name|afterStarted
argument_list|)
expr_stmt|;
name|notifyFailed
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"boom"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|notifyStopped
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|final
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|failRunService
argument_list|,
operator|new
name|NoOpService
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addListener
argument_list|(
operator|new
name|ServiceManager
operator|.
name|Listener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|failEnter
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// block until after the service manager is shutdown
name|Uninterruptibles
operator|.
name|awaitUninterruptibly
argument_list|(
name|failLeave
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|MoreExecutors
operator|.
name|sameThreadExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
expr_stmt|;
name|afterStarted
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// We do not call awaitHealthy because, due to races, that method may throw an exception.  But
comment|// we really just want to wait for the thread to be in the failure callback so we wait for that
comment|// explicitly instead.
name|failEnter
operator|.
name|await
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
literal|"State should be updated before calling listeners"
argument_list|,
name|manager
operator|.
name|isHealthy
argument_list|()
argument_list|)
expr_stmt|;
comment|// now we want to stop the services.
name|Thread
name|stoppingThread
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
name|stoppingThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// this should be super fast since the only non stopped service is a NoOpService
name|stoppingThread
operator|.
name|join
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"stopAsync has deadlocked!."
argument_list|,
name|stoppingThread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
name|failLeave
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// release the background thread
block|}
comment|/**    * Catches a bug where when constructing a service manager failed, later interactions with the    * service could cause IllegalStateExceptions inside the partially constructed ServiceManager.    * This ISE wouldn't actually bubble up but would get logged by ExecutionQueue.  This obfuscated    * the original error (which was not constructing ServiceManager correctly).    */
DECL|method|testPartiallyConstructedManager ()
specifier|public
name|void
name|testPartiallyConstructedManager
parameter_list|()
block|{
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
literal|"global"
argument_list|)
decl_stmt|;
name|logger
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
expr_stmt|;
name|TestLogHandler
name|logHandler
init|=
operator|new
name|TestLogHandler
argument_list|()
decl_stmt|;
name|logger
operator|.
name|addHandler
argument_list|(
name|logHandler
argument_list|)
expr_stmt|;
name|NoOpService
name|service
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
name|service
operator|.
name|startAsync
argument_list|()
expr_stmt|;
try|try
block|{
operator|new
name|ServiceManager
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{}
name|service
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
comment|// Nothing was logged!
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|logHandler
operator|.
name|getStoredLogRecords
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testPartiallyConstructedManager_transitionAfterAddListenerBeforeStateIsReady ()
specifier|public
name|void
name|testPartiallyConstructedManager_transitionAfterAddListenerBeforeStateIsReady
parameter_list|()
block|{
comment|// The implementation of this test is pretty sensitive to the implementation :( but we want to
comment|// ensure that if weird things happen during construction then we get exceptions.
specifier|final
name|NoOpService
name|service1
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
comment|// This service will start service1 when addListener is called.  This simulates service1 being
comment|// started asynchronously.
name|Service
name|service2
init|=
operator|new
name|Service
argument_list|()
block|{
specifier|final
name|NoOpService
name|delegate
init|=
operator|new
name|NoOpService
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|addListener
parameter_list|(
name|Listener
name|listener
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|service1
operator|.
name|startAsync
argument_list|()
expr_stmt|;
name|delegate
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|// Delegates from here on down
annotation|@
name|Override
specifier|public
specifier|final
name|Service
name|startAsync
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|startAsync
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Service
name|stopAsync
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|stopAsync
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|awaitRunning
parameter_list|()
block|{
name|delegate
operator|.
name|awaitRunning
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|awaitRunning
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|delegate
operator|.
name|awaitRunning
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|awaitTerminated
parameter_list|()
block|{
name|delegate
operator|.
name|awaitTerminated
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|awaitTerminated
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|TimeoutException
block|{
name|delegate
operator|.
name|awaitTerminated
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|isRunning
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|State
name|state
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|state
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Throwable
name|failureCause
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|failureCause
argument_list|()
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
operator|new
name|ServiceManager
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|service1
argument_list|,
name|service2
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|expected
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|expected
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"started transitioning asynchronously"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This test is for a case where two Service.Listener callbacks for the same service would call    * transitionService in the wrong order due to a race.  Due to the fact that it is a race this    * test isn't guaranteed to expose the issue, but it is at least likely to become flaky if the    * race sneaks back in, and in this case flaky means something is definitely wrong.    *    *<p>Before the bug was fixed this test would fail at least 30% of the time.    */
DECL|method|testTransitionRace ()
specifier|public
name|void
name|testTransitionRace
parameter_list|()
throws|throws
name|TimeoutException
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|1000
condition|;
name|k
operator|++
control|)
block|{
name|List
argument_list|<
name|Service
argument_list|>
name|services
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|services
operator|.
name|add
argument_list|(
operator|new
name|SnappyShutdownService
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|services
argument_list|)
decl_stmt|;
name|manager
operator|.
name|startAsync
argument_list|()
operator|.
name|awaitHealthy
argument_list|()
expr_stmt|;
name|manager
operator|.
name|stopAsync
argument_list|()
operator|.
name|awaitStopped
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This service will shutdown very quickly after stopAsync is called and uses a background thread    * so that we know that the stopping() listeners will execute on a different thread than the    * terminated() listeners.    */
DECL|class|SnappyShutdownService
specifier|private
specifier|static
class|class
name|SnappyShutdownService
extends|extends
name|AbstractExecutionThreadService
block|{
DECL|field|index
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|latch
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|SnappyShutdownService (int index)
name|SnappyShutdownService
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
DECL|method|run ()
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
DECL|method|triggerShutdown ()
annotation|@
name|Override
specifier|protected
name|void
name|triggerShutdown
parameter_list|()
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
DECL|method|serviceName ()
annotation|@
name|Override
specifier|protected
name|String
name|serviceName
parameter_list|()
block|{
return|return
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|index
operator|+
literal|"]"
return|;
block|}
block|}
DECL|method|testNulls ()
specifier|public
name|void
name|testNulls
parameter_list|()
block|{
name|ServiceManager
name|manager
init|=
operator|new
name|ServiceManager
argument_list|(
name|Arrays
operator|.
expr|<
name|Service
operator|>
name|asList
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|NullPointerTester
argument_list|()
operator|.
name|setDefault
argument_list|(
name|ServiceManager
operator|.
name|Listener
operator|.
name|class
argument_list|,
operator|new
name|RecordingListener
argument_list|()
argument_list|)
operator|.
name|testAllPublicInstanceMethods
argument_list|(
name|manager
argument_list|)
expr_stmt|;
block|}
DECL|class|RecordingListener
specifier|private
specifier|static
specifier|final
class|class
name|RecordingListener
extends|extends
name|ServiceManager
operator|.
name|Listener
block|{
DECL|field|healthyCalled
specifier|volatile
name|boolean
name|healthyCalled
decl_stmt|;
DECL|field|stoppedCalled
specifier|volatile
name|boolean
name|stoppedCalled
decl_stmt|;
DECL|field|failedServices
specifier|final
name|Set
argument_list|<
name|Service
argument_list|>
name|failedServices
init|=
name|Sets
operator|.
name|newConcurrentHashSet
argument_list|()
decl_stmt|;
DECL|method|healthy ()
annotation|@
name|Override
specifier|public
name|void
name|healthy
parameter_list|()
block|{
name|healthyCalled
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|stopped ()
annotation|@
name|Override
specifier|public
name|void
name|stopped
parameter_list|()
block|{
name|stoppedCalled
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|failure (Service service)
annotation|@
name|Override
specifier|public
name|void
name|failure
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|failedServices
operator|.
name|add
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

