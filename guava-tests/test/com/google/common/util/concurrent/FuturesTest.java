begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
operator|.
name|constant
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
operator|.
name|identity
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
operator|.
name|propagateIfInstanceOf
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|getOnlyElement
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|intersection
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|truth
operator|.
name|Truth
operator|.
name|assertWithMessage
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|allAsList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|catching
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|catchingAsync
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|dereference
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|getDone
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateCancelledFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateCheckedFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateFailedCheckedFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateFailedFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|immediateFuture
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|inCompletionOrder
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|lazyTransform
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|makeChecked
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|nonCancellationPropagating
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|successfulAsList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|transform
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|transformAsync
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|whenAllComplete
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
operator|.
name|whenAllSucceed
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|MoreExecutors
operator|.
name|directExecutor
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TestPlatform
operator|.
name|clearInterrupt
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TestPlatform
operator|.
name|getDoneFromTimeoutOverload
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|awaitUninterruptibly
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|getUninterruptibly
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|currentThread
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
operator|.
name|newSingleThreadExecutor
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|SECONDS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtCompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|GwtIncompatible
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|ClassSanityTester
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|testing
operator|.
name|TestLogHandler
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CanIgnoreReturnValue
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|AssertionFailedError
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|LogRecord
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link Futures}.  *  * @author Nishant Thakkar  */
end_comment

begin_class
annotation|@
name|GwtCompatible
argument_list|(
name|emulated
operator|=
literal|true
argument_list|)
DECL|class|FuturesTest
specifier|public
class|class
name|FuturesTest
extends|extends
name|TestCase
block|{
DECL|field|aggregateFutureLogger
specifier|private
specifier|static
specifier|final
name|Logger
name|aggregateFutureLogger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|AggregateFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|aggregateFutureLogHandler
specifier|private
specifier|final
name|TestLogHandler
name|aggregateFutureLogHandler
init|=
operator|new
name|TestLogHandler
argument_list|()
decl_stmt|;
DECL|field|DATA1
specifier|private
specifier|static
specifier|final
name|String
name|DATA1
init|=
literal|"data"
decl_stmt|;
DECL|field|DATA2
specifier|private
specifier|static
specifier|final
name|String
name|DATA2
init|=
literal|"more data"
decl_stmt|;
DECL|field|DATA3
specifier|private
specifier|static
specifier|final
name|String
name|DATA3
init|=
literal|"most data"
decl_stmt|;
annotation|@
name|Override
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|aggregateFutureLogger
operator|.
name|addHandler
argument_list|(
name|aggregateFutureLogHandler
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Clear interrupt for future tests.      *      * (Ideally we would perform interrupts only in threads that we create, but      * it's hard to imagine that anything will break in practice.)      */
name|clearInterrupt
argument_list|()
expr_stmt|;
name|aggregateFutureLogger
operator|.
name|removeHandler
argument_list|(
name|aggregateFutureLogHandler
argument_list|)
expr_stmt|;
name|super
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
comment|/*    * TODO(cpovirk): Use FutureSubject once it's part of core Truth. But be wary of using it when I'm    * really testing a Future implementation (e.g., in the case of immediate*Future()). But it's OK    * to use in the case of the majority of Futures that are AbstractFutures.    */
DECL|method|testImmediateFuture ()
specifier|public
name|void
name|testImmediateFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|immediateFuture
argument_list|(
name|DATA1
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|getDone
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|getDoneFromTimeoutOverload
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testImmediateFailedFuture ()
specifier|public
name|void
name|testImmediateFailedFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|Exception
name|exception
init|=
operator|new
name|Exception
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|getDoneFromTimeoutOverload
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testImmediateFailedFuture_cancellationException ()
specifier|public
name|void
name|testImmediateFailedFuture_cancellationException
parameter_list|()
throws|throws
name|Exception
block|{
name|CancellationException
name|exception
init|=
operator|new
name|CancellationException
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|future
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|getDoneFromTimeoutOverload
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testImmediateCancelledFutureBasic ()
specifier|public
name|void
name|testImmediateCancelledFutureBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|CallerClass1
operator|.
name|makeImmediateCancelledFuture
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|future
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
DECL|method|testImmediateCancelledFutureStack ()
specifier|public
name|void
name|testImmediateCancelledFutureStack
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|CallerClass1
operator|.
name|makeImmediateCancelledFuture
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|future
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|CallerClass2
operator|.
name|get
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{
comment|// There should be two CancellationException chained together.  The outer one should have the
comment|// stack trace of where the get() call was made, and the inner should have the stack trace of
comment|// where the immediateCancelledFuture() call was made.
name|List
argument_list|<
name|StackTraceElement
argument_list|>
name|stackTrace
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|expected
operator|.
name|getStackTrace
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|Iterables
operator|.
name|any
argument_list|(
name|stackTrace
argument_list|,
name|hasClassName
argument_list|(
name|CallerClass1
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Iterables
operator|.
name|any
argument_list|(
name|stackTrace
argument_list|,
name|hasClassName
argument_list|(
name|CallerClass2
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// See AbstractFutureCancellationCauseTest for how to set causes.
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isNull
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|method|hasClassName (final Class<?> clazz)
specifier|private
specifier|static
name|Predicate
argument_list|<
name|StackTraceElement
argument_list|>
name|hasClassName
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|Predicate
argument_list|<
name|StackTraceElement
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|StackTraceElement
name|element
parameter_list|)
block|{
return|return
name|element
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|class|CallerClass1
specifier|private
specifier|static
specifier|final
class|class
name|CallerClass1
block|{
DECL|method|makeImmediateCancelledFuture ()
specifier|static
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|makeImmediateCancelledFuture
parameter_list|()
block|{
return|return
name|immediateCancelledFuture
argument_list|()
return|;
block|}
block|}
DECL|class|CallerClass2
specifier|private
specifier|static
specifier|final
class|class
name|CallerClass2
block|{
annotation|@
name|CanIgnoreReturnValue
DECL|method|get (ListenableFuture<V> future)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|get
parameter_list|(
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
return|return
name|getDone
argument_list|(
name|future
argument_list|)
return|;
block|}
block|}
DECL|class|MyException
specifier|private
specifier|static
class|class
name|MyException
extends|extends
name|Exception
block|{   }
annotation|@
name|GwtIncompatible
comment|// immediateCheckedFuture
DECL|method|testImmediateCheckedFuture ()
specifier|public
name|void
name|testImmediateCheckedFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|MyException
argument_list|>
name|future
init|=
name|immediateCheckedFuture
argument_list|(
name|DATA1
argument_list|)
decl_stmt|;
comment|// Verify that the proper object is returned without waiting
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|future
operator|.
name|get
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|future
operator|.
name|checkedGet
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// immediateCheckedFuture
DECL|method|testMultipleImmediateCheckedFutures ()
specifier|public
name|void
name|testMultipleImmediateCheckedFutures
parameter_list|()
throws|throws
name|Exception
block|{
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|MyException
argument_list|>
name|future1
init|=
name|immediateCheckedFuture
argument_list|(
name|DATA1
argument_list|)
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|MyException
argument_list|>
name|future2
init|=
name|immediateCheckedFuture
argument_list|(
name|DATA2
argument_list|)
decl_stmt|;
comment|// Verify that the proper objects are returned without waiting
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|future1
operator|.
name|get
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|DATA1
argument_list|,
name|future1
operator|.
name|checkedGet
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|DATA2
argument_list|,
name|future2
operator|.
name|get
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|DATA2
argument_list|,
name|future2
operator|.
name|checkedGet
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// immediateFailedCheckedFuture
DECL|method|testImmediateFailedCheckedFuture ()
specifier|public
name|void
name|testImmediateFailedCheckedFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|MyException
name|exception
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|MyException
argument_list|>
name|future
init|=
name|immediateFailedCheckedFuture
argument_list|(
name|exception
argument_list|)
decl_stmt|;
try|try
block|{
name|future
operator|.
name|get
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|future
operator|.
name|checkedGet
argument_list|(
literal|0L
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MyException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Class hierarchy for generics sanity checks
DECL|class|Foo
specifier|private
specifier|static
class|class
name|Foo
block|{    }
DECL|class|FooChild
specifier|private
specifier|static
class|class
name|FooChild
extends|extends
name|Foo
block|{    }
DECL|class|Bar
specifier|private
specifier|static
class|class
name|Bar
block|{    }
DECL|class|BarChild
specifier|private
specifier|static
class|class
name|BarChild
extends|extends
name|Bar
block|{    }
DECL|method|testTransform_genericsNull ()
specifier|public
name|void
name|testTransform_genericsNull
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|nullFuture
init|=
name|immediateFuture
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|transformedFuture
init|=
name|transform
argument_list|(
name|nullFuture
argument_list|,
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|getDone
argument_list|(
name|transformedFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransform_genericsHierarchy ()
specifier|public
name|void
name|testTransform_genericsHierarchy
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|FooChild
argument_list|>
name|future
init|=
name|immediateFuture
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|BarChild
name|barChild
init|=
operator|new
name|BarChild
argument_list|()
decl_stmt|;
name|Function
argument_list|<
name|Foo
argument_list|,
name|BarChild
argument_list|>
name|function
init|=
operator|new
name|Function
argument_list|<
name|Foo
argument_list|,
name|BarChild
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BarChild
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
return|return
name|barChild
return|;
block|}
block|}
decl_stmt|;
name|Bar
name|bar
init|=
name|getDone
argument_list|(
name|transform
argument_list|(
name|future
argument_list|,
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|barChild
argument_list|,
name|bar
argument_list|)
expr_stmt|;
block|}
comment|/*    * Android does not handle this stack overflow gracefully... though somehow some other    * stack-overflow tests work. It must depend on the exact place the error occurs.    */
annotation|@
name|AndroidIncompatible
annotation|@
name|GwtIncompatible
comment|// StackOverflowError
DECL|method|testTransform_StackOverflow ()
specifier|public
name|void
name|testTransform_StackOverflow
parameter_list|()
throws|throws
name|Exception
block|{
block|{
comment|/*        * Initialize all relevant classes before running the test, which may otherwise poison any        * classes it is trying to load during its stack overflow.        */
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|unused
init|=
name|transform
argument_list|(
name|root
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|root
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|=
name|transform
argument_list|(
name|output
argument_list|,
name|identity
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|root
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StackOverflowError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testTransform_ErrorAfterCancellation ()
specifier|public
name|void
name|testTransform_ErrorAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Transformer
implements|implements
name|Function
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|apply
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
name|Transformer
name|transformer
init|=
operator|new
name|Transformer
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
name|transformer
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransform_ExceptionAfterCancellation ()
specifier|public
name|void
name|testTransform_ExceptionAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Transformer
implements|implements
name|Function
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|apply
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyRuntimeException
argument_list|()
throw|;
block|}
block|}
name|Transformer
name|transformer
init|=
operator|new
name|Transformer
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
name|transformer
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransform_getThrowsRuntimeException ()
specifier|public
name|void
name|testTransform_getThrowsRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingRuntimeException
argument_list|(
operator|new
name|MyRuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransform_getThrowsError ()
specifier|public
name|void
name|testTransform_getThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingError
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransform_listenerThrowsError ()
specifier|public
name|void
name|testTransform_listenerThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MyError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testTransformAsync_cancelPropagatesToInput ()
specifier|public
name|void
name|testTransformAsync_cancelPropagatesToInput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionFailedError
argument_list|(
literal|"Unexpeted call to apply."
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|assertTrue
argument_list|(
name|transformAsync
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|input
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|input
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_interruptPropagatesToInput ()
specifier|public
name|void
name|testTransformAsync_interruptPropagatesToInput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionFailedError
argument_list|(
literal|"Unexpeted call to apply."
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|assertTrue
argument_list|(
name|transformAsync
argument_list|(
name|input
argument_list|,
name|function
argument_list|)
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|input
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|input
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testTransformAsync_interruptPropagatesToTransformingThread ()
specifier|public
name|void
name|testTransformAsync_interruptPropagatesToTransformingThread
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|CountDownLatch
name|inFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|shouldCompleteFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|gotException
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|apply
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
name|inFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|shouldCompleteFunction
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{
name|gotException
operator|.
name|countDown
argument_list|()
expr_stmt|;
throw|throw
name|expected
throw|;
block|}
return|return
name|immediateFuture
argument_list|(
literal|"a"
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|function
argument_list|,
name|newSingleThreadExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|input
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|inFunction
operator|.
name|await
argument_list|()
expr_stmt|;
name|futureResult
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|shouldCompleteFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|futureResult
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{}
comment|// TODO(cpovirk): implement interruption, updating this test:
comment|// https://github.com/google/guava/issues/1989
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|gotException
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// gotException.await();
block|}
DECL|method|testTransformAsync_cancelPropagatesToAsyncOutput ()
specifier|public
name|void
name|testTransformAsync_cancelPropagatesToAsyncOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|immediate
init|=
name|immediateFuture
argument_list|(
operator|new
name|Foo
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Bar
argument_list|>
name|secondary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
return|return
name|secondary
return|;
block|}
block|}
decl_stmt|;
name|assertTrue
argument_list|(
name|transformAsync
argument_list|(
name|immediate
argument_list|,
name|function
argument_list|)
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|secondary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_interruptPropagatesToAsyncOutput ()
specifier|public
name|void
name|testTransformAsync_interruptPropagatesToAsyncOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|immediate
init|=
name|immediateFuture
argument_list|(
operator|new
name|Foo
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Bar
argument_list|>
name|secondary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
return|return
name|secondary
return|;
block|}
block|}
decl_stmt|;
name|assertTrue
argument_list|(
name|transformAsync
argument_list|(
name|immediate
argument_list|,
name|function
argument_list|)
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_inputCancelButNotInterruptPropagatesToOutput ()
specifier|public
name|void
name|testTransformAsync_inputCancelButNotInterruptPropagatesToOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|f1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Bar
argument_list|>
name|secondary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Bar
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
return|return
name|secondary
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Bar
argument_list|>
name|f2
init|=
name|transformAsync
argument_list|(
name|f1
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|f1
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|f2
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
comment|/*      * We might like to propagate interruption, too, but it's not clear that it matters. For now, we      * test for the behavior that we have today.      */
name|assertFalse
argument_list|(
operator|(
operator|(
name|AbstractFuture
argument_list|<
name|?
argument_list|>
operator|)
name|f2
operator|)
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*    * Android does not handle this stack overflow gracefully... though somehow some other    * stack-overflow tests work. It must depend on the exact place the error occurs.    */
annotation|@
name|AndroidIncompatible
annotation|@
name|GwtIncompatible
comment|// StackOverflowError
DECL|method|testTransformAsync_StackOverflow ()
specifier|public
name|void
name|testTransformAsync_StackOverflow
parameter_list|()
throws|throws
name|Exception
block|{
block|{
comment|/*        * Initialize all relevant classes before running the test, which may otherwise poison any        * classes it is trying to load during its stack overflow.        */
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|unused
init|=
name|transformAsync
argument_list|(
name|root
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|root
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|=
name|transformAsync
argument_list|(
name|output
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|root
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StackOverflowError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testTransformAsync_ErrorAfterCancellation ()
specifier|public
name|void
name|testTransformAsync_ErrorAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Transformer
implements|implements
name|AsyncFunction
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
name|Transformer
name|transformer
init|=
operator|new
name|Transformer
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
name|transformer
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_ExceptionAfterCancellation ()
specifier|public
name|void
name|testTransformAsync_ExceptionAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Transformer
implements|implements
name|AsyncFunction
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyRuntimeException
argument_list|()
throw|;
block|}
block|}
name|Transformer
name|transformer
init|=
operator|new
name|Transformer
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|transformer
argument_list|)
decl_stmt|;
name|transformer
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_getThrowsRuntimeException ()
specifier|public
name|void
name|testTransformAsync_getThrowsRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingRuntimeException
argument_list|(
operator|new
name|MyRuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransformAsync_getThrowsError ()
specifier|public
name|void
name|testTransformAsync_getThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingError
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransformAsync_listenerThrowsError ()
specifier|public
name|void
name|testTransformAsync_listenerThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|input
operator|.
name|set
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MyError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testTransform_rejectionPropagatesToOutput ()
specifier|public
name|void
name|testTransform_rejectionPropagatesToOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|Function
argument_list|<
name|Foo
argument_list|,
name|Foo
argument_list|>
name|identity
init|=
name|identity
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|transformed
init|=
name|transform
argument_list|(
name|input
argument_list|,
name|identity
argument_list|,
name|REJECTING_EXECUTOR
argument_list|)
decl_stmt|;
name|input
operator|.
name|set
argument_list|(
operator|new
name|Foo
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RejectedExecutionException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransformAsync_rejectionPropagatesToOutput ()
specifier|public
name|void
name|testTransformAsync_rejectionPropagatesToOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|Foo
argument_list|>
name|asyncIdentity
init|=
name|asyncIdentity
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|transformed
init|=
name|transformAsync
argument_list|(
name|input
argument_list|,
name|asyncIdentity
argument_list|,
name|REJECTING_EXECUTOR
argument_list|)
decl_stmt|;
name|input
operator|.
name|set
argument_list|(
operator|new
name|Foo
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RejectedExecutionException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests that the function is invoked only once, even if it throws an exception.    */
DECL|method|testTransformValueRemainsMemoized ()
specifier|public
name|void
name|testTransformValueRemainsMemoized
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Holder
block|{
name|int
name|value
init|=
literal|2
decl_stmt|;
block|}
specifier|final
name|Holder
name|holder
init|=
operator|new
name|Holder
argument_list|()
decl_stmt|;
comment|// This function adds the holder's value to the input value.
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|adder
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|from
parameter_list|)
block|{
return|return
name|from
operator|+
name|holder
operator|.
name|value
return|;
block|}
block|}
decl_stmt|;
comment|// Since holder.value is 2, applying 4 should yield 6.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|adder
operator|.
name|apply
argument_list|(
literal|4
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|immediateFuture
init|=
name|immediateFuture
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Integer
argument_list|>
name|transformedFuture
init|=
name|transform
argument_list|(
name|immediateFuture
argument_list|,
name|adder
argument_list|)
decl_stmt|;
comment|// The composed future also yields 6.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|getDone
argument_list|(
name|transformedFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Repeated calls yield the same value even though the function's behavior
comment|// changes
name|holder
operator|.
name|value
operator|=
literal|3
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|getDone
argument_list|(
name|transformedFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|adder
operator|.
name|apply
argument_list|(
literal|4
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Once more, with feeling.
name|holder
operator|.
name|value
operator|=
literal|4
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|getDone
argument_list|(
name|transformedFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|adder
operator|.
name|apply
argument_list|(
literal|4
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Memoized get also retains the value.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|getDoneFromTimeoutOverload
argument_list|(
name|transformedFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Unsurprisingly, recomposing the future will return an updated value.
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|getDone
argument_list|(
name|transform
argument_list|(
name|immediateFuture
argument_list|,
name|adder
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Repeating, with the timeout version
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|getDoneFromTimeoutOverload
argument_list|(
name|transform
argument_list|(
name|immediateFuture
argument_list|,
name|adder
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|MyError
specifier|static
class|class
name|MyError
extends|extends
name|Error
block|{    }
DECL|class|MyRuntimeException
specifier|static
class|class
name|MyRuntimeException
extends|extends
name|RuntimeException
block|{    }
comment|/**    * Test that the function is invoked only once, even if it throws an exception. Also, test that    * that function's result is wrapped in an ExecutionException.    */
annotation|@
name|GwtIncompatible
comment|// reflection
DECL|method|testTransformExceptionRemainsMemoized ()
specifier|public
name|void
name|testTransformExceptionRemainsMemoized
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// We need to test with two input futures since ExecutionList.execute
comment|// doesn't catch Errors and we cannot depend on the order that our
comment|// transformations run. (So it is possible that the Error being thrown
comment|// could prevent our second transformations from running).
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|exceptionInput
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|exceptionComposedFuture
init|=
name|transform
argument_list|(
name|exceptionInput
argument_list|,
name|newOneTimeExceptionThrower
argument_list|()
argument_list|)
decl_stmt|;
name|exceptionInput
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|runGetIdempotencyTest
argument_list|(
name|exceptionComposedFuture
argument_list|,
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|errorInput
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|errorComposedFuture
init|=
name|transform
argument_list|(
name|errorInput
argument_list|,
name|newOneTimeErrorThrower
argument_list|()
argument_list|)
decl_stmt|;
name|errorInput
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|runGetIdempotencyTest
argument_list|(
name|errorComposedFuture
argument_list|,
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
comment|/*      * Try again when the input's value is already filled in, since the flow is      * slightly different in that case.      */
name|exceptionComposedFuture
operator|=
name|transform
argument_list|(
name|exceptionInput
argument_list|,
name|newOneTimeExceptionThrower
argument_list|()
argument_list|)
expr_stmt|;
name|runGetIdempotencyTest
argument_list|(
name|exceptionComposedFuture
argument_list|,
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
name|runGetIdempotencyTest
argument_list|(
name|transform
argument_list|(
name|errorInput
argument_list|,
name|newOneTimeErrorThrower
argument_list|()
argument_list|)
argument_list|,
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
name|runGetIdempotencyTest
argument_list|(
name|errorComposedFuture
argument_list|,
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// reflection
DECL|method|runGetIdempotencyTest ( Future<Integer> transformedFuture, Class<? extends Throwable> expectedExceptionClass)
specifier|private
specifier|static
name|void
name|runGetIdempotencyTest
parameter_list|(
name|Future
argument_list|<
name|Integer
argument_list|>
name|transformedFuture
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Throwable
argument_list|>
name|expectedExceptionClass
parameter_list|)
throws|throws
name|Throwable
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|getDone
argument_list|(
name|transformedFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expectedExceptionClass
operator|.
name|isInstance
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|expected
operator|.
name|getCause
argument_list|()
throw|;
block|}
block|}
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|method|newOneTimeExceptionThrower ()
specifier|private
specifier|static
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|newOneTimeExceptionThrower
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|calls
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|from
parameter_list|)
block|{
if|if
condition|(
operator|++
name|calls
operator|>
literal|1
condition|)
block|{
name|fail
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|MyRuntimeException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|method|newOneTimeErrorThrower ()
specifier|private
specifier|static
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|newOneTimeErrorThrower
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|calls
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|from
parameter_list|)
block|{
if|if
condition|(
operator|++
name|calls
operator|>
literal|1
condition|)
block|{
name|fail
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|// TODO(cpovirk): top-level class?
DECL|class|ExecutorSpy
specifier|static
class|class
name|ExecutorSpy
implements|implements
name|Executor
block|{
DECL|field|delegate
name|Executor
name|delegate
decl_stmt|;
DECL|field|wasExecuted
name|boolean
name|wasExecuted
decl_stmt|;
DECL|method|ExecutorSpy (Executor delegate)
specifier|public
name|ExecutorSpy
parameter_list|(
name|Executor
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|execute (Runnable command)
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|command
parameter_list|)
block|{
name|delegate
operator|.
name|execute
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|wasExecuted
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|testTransform_Executor ()
specifier|public
name|void
name|testTransform_Executor
parameter_list|()
throws|throws
name|Exception
block|{
name|Object
name|value
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
name|ExecutorSpy
name|spy
init|=
operator|new
name|ExecutorSpy
argument_list|(
name|directExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|spy
operator|.
name|wasExecuted
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|future
init|=
name|transform
argument_list|(
name|immediateFuture
argument_list|(
name|value
argument_list|)
argument_list|,
name|identity
argument_list|()
argument_list|,
name|spy
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|value
argument_list|,
name|getDone
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|spy
operator|.
name|wasExecuted
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// lazyTransform
DECL|method|testLazyTransform ()
specifier|public
name|void
name|testLazyTransform
parameter_list|()
throws|throws
name|Exception
block|{
name|FunctionSpy
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|spy
init|=
operator|new
name|FunctionSpy
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
argument_list|(
name|constant
argument_list|(
literal|"bar"
argument_list|)
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|String
argument_list|>
name|input
init|=
name|immediateFuture
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|String
argument_list|>
name|transformed
init|=
name|lazyTransform
argument_list|(
name|input
argument_list|,
name|spy
argument_list|)
decl_stmt|;
name|spy
operator|.
name|verifyCallCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|getDone
argument_list|(
name|transformed
argument_list|)
argument_list|)
expr_stmt|;
name|spy
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|getDone
argument_list|(
name|transformed
argument_list|)
argument_list|)
expr_stmt|;
name|spy
operator|.
name|verifyCallCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// lazyTransform
DECL|method|testLazyTransform_exception ()
specifier|public
name|void
name|testLazyTransform_exception
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|RuntimeException
name|exception
init|=
operator|new
name|RuntimeException
argument_list|(
literal|"deliberate"
argument_list|)
decl_stmt|;
name|Function
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|function
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|Integer
name|input
parameter_list|)
block|{
throw|throw
name|exception
throw|;
block|}
block|}
decl_stmt|;
name|Future
argument_list|<
name|String
argument_list|>
name|transformed
init|=
name|lazyTransform
argument_list|(
name|immediateFuture
argument_list|(
literal|1
argument_list|)
argument_list|,
name|function
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|getDoneFromTimeoutOverload
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FunctionSpy
specifier|private
specifier|static
class|class
name|FunctionSpy
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
implements|implements
name|Function
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
block|{
DECL|field|applyCount
specifier|private
name|int
name|applyCount
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|Function
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|delegate
decl_stmt|;
DECL|method|FunctionSpy (Function<I, O> delegate)
specifier|public
name|FunctionSpy
parameter_list|(
name|Function
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|apply (I input)
specifier|public
name|O
name|apply
parameter_list|(
name|I
name|input
parameter_list|)
block|{
name|applyCount
operator|++
expr_stmt|;
return|return
name|delegate
operator|.
name|apply
argument_list|(
name|input
argument_list|)
return|;
block|}
DECL|method|verifyCallCount (int expected)
name|void
name|verifyCallCount
parameter_list|(
name|int
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|applyCount
argument_list|)
operator|.
name|isEqualTo
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|spy (Function<I, O> delegate)
specifier|private
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|FunctionSpy
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|spy
parameter_list|(
name|Function
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|FunctionSpy
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
DECL|method|unexpectedFunction ()
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|V
parameter_list|>
name|Function
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|unexpectedFunction
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|apply
parameter_list|(
name|X
name|t
parameter_list|)
block|{
throw|throw
name|newAssertionError
argument_list|(
literal|"Unexpected fallback"
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
return|;
block|}
DECL|class|AsyncFunctionSpy
specifier|private
specifier|static
class|class
name|AsyncFunctionSpy
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|V
parameter_list|>
implements|implements
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
block|{
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|AsyncFunctionSpy (AsyncFunction<X, V> delegate)
specifier|public
name|AsyncFunctionSpy
parameter_list|(
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|apply (X t)
specifier|public
specifier|final
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
name|X
name|t
parameter_list|)
throws|throws
name|Exception
block|{
name|count
operator|++
expr_stmt|;
return|return
name|delegate
operator|.
name|apply
argument_list|(
name|t
argument_list|)
return|;
block|}
DECL|method|verifyCallCount (int expected)
name|void
name|verifyCallCount
parameter_list|(
name|int
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|count
argument_list|)
operator|.
name|isEqualTo
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|spy (AsyncFunction<X, V> delegate)
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|V
parameter_list|>
name|AsyncFunctionSpy
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|spy
parameter_list|(
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|AsyncFunctionSpy
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
DECL|method|unexpectedAsyncFunction ()
specifier|private
specifier|static
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|,
name|V
parameter_list|>
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
name|unexpectedAsyncFunction
parameter_list|()
block|{
return|return
operator|new
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
name|X
name|t
parameter_list|)
block|{
throw|throw
name|newAssertionError
argument_list|(
literal|"Unexpected fallback"
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/** Alternative to AssertionError(String, Throwable), which doesn't exist in GWT 2.6.1. */
DECL|method|newAssertionError (String message, Throwable cause)
specifier|private
specifier|static
name|AssertionError
name|newAssertionError
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|AssertionError
name|e
init|=
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|e
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
comment|// catchingAsync tests cloned from the old withFallback tests:
DECL|method|testCatchingAsync_inputDoesNotRaiseException ()
specifier|public
name|void
name|testCatchingAsync_inputDoesNotRaiseException
parameter_list|()
throws|throws
name|Exception
block|{
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedAsyncFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFuture
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|originalFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_inputRaisesException ()
specifier|public
name|void
name|testCatchingAsync_inputRaisesException
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|RuntimeException
name|raisedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|AsyncFunctionSpy
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|spy
argument_list|(
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
name|assertThat
argument_list|(
name|t
argument_list|)
operator|.
name|isSameAs
argument_list|(
name|raisedException
argument_list|)
expr_stmt|;
return|return
name|immediateFuture
argument_list|(
literal|20
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
name|raisedException
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|fallback
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_fallbackGeneratesRuntimeException ()
specifier|public
name|void
name|testCatchingAsync_fallbackGeneratesRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|RuntimeException
name|expectedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|runExpectedExceptionCatchingAsyncTest
argument_list|(
name|expectedException
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_fallbackGeneratesCheckedException ()
specifier|public
name|void
name|testCatchingAsync_fallbackGeneratesCheckedException
parameter_list|()
throws|throws
name|Exception
block|{
name|Exception
name|expectedException
init|=
operator|new
name|Exception
argument_list|()
block|{     }
decl_stmt|;
name|runExpectedExceptionCatchingAsyncTest
argument_list|(
name|expectedException
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_fallbackGeneratesError ()
specifier|public
name|void
name|testCatchingAsync_fallbackGeneratesError
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Error
name|error
init|=
operator|new
name|Error
argument_list|(
literal|"deliberate"
argument_list|)
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
throw|throw
name|error
throw|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|catchingAsync
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|error
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testCatchingAsync_fallbackReturnsRuntimeException ()
specifier|public
name|void
name|testCatchingAsync_fallbackReturnsRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|RuntimeException
name|expectedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|runExpectedExceptionCatchingAsyncTest
argument_list|(
name|expectedException
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_fallbackReturnsCheckedException ()
specifier|public
name|void
name|testCatchingAsync_fallbackReturnsCheckedException
parameter_list|()
throws|throws
name|Exception
block|{
name|Exception
name|expectedException
init|=
operator|new
name|Exception
argument_list|()
block|{     }
decl_stmt|;
name|runExpectedExceptionCatchingAsyncTest
argument_list|(
name|expectedException
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|runExpectedExceptionCatchingAsyncTest ( final Exception expectedException, final boolean wrapInFuture)
specifier|private
name|void
name|runExpectedExceptionCatchingAsyncTest
parameter_list|(
specifier|final
name|Exception
name|expectedException
parameter_list|,
specifier|final
name|boolean
name|wrapInFuture
parameter_list|)
throws|throws
name|Exception
block|{
name|AsyncFunctionSpy
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|spy
argument_list|(
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|wrapInFuture
condition|)
block|{
throw|throw
name|expectedException
throw|;
block|}
else|else
block|{
return|return
name|immediateFailedFuture
argument_list|(
name|expectedException
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|expectedException
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fallback
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_fallbackNotReady ()
specifier|public
name|void
name|testCatchingAsync_fallbackNotReady
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|primary
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|secondary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|secondary
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catchingAsync
argument_list|(
name|primary
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|getDone
argument_list|(
name|derived
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_resultInterruptedBeforeFallback ()
specifier|public
name|void
name|testCatchingAsync_resultInterruptedBeforeFallback
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|primary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedAsyncFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catchingAsync
argument_list|(
name|primary
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|derived
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_resultCancelledBeforeFallback ()
specifier|public
name|void
name|testCatchingAsync_resultCancelledBeforeFallback
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|primary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedAsyncFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catchingAsync
argument_list|(
name|primary
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|derived
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|primary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// mocks
comment|// TODO(cpovirk): eliminate use of mocks
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testCatchingAsync_resultCancelledAfterFallback ()
specifier|public
name|void
name|testCatchingAsync_resultCancelledAfterFallback
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|secondary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|RuntimeException
name|raisedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|AsyncFunctionSpy
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|spy
argument_list|(
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
name|assertThat
argument_list|(
name|t
argument_list|)
operator|.
name|isSameAs
argument_list|(
name|raisedException
argument_list|)
expr_stmt|;
return|return
name|secondary
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
name|raisedException
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catchingAsync
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|derived
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|secondary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|fallback
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_nullInsteadOfFuture ()
specifier|public
name|void
name|testCatchingAsync_nullInsteadOfFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|inputFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|chainedFuture
init|=
name|catchingAsync
argument_list|(
name|inputFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"AsyncFunctionReturnsNull"
argument_list|)
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|chainedFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|NullPointerException
name|cause
init|=
operator|(
name|NullPointerException
operator|)
name|expected
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|cause
argument_list|)
operator|.
name|hasMessage
argument_list|(
literal|"AsyncFunction.apply returned null instead of a Future. "
operator|+
literal|"Did you mean to return immediateFuture(null)?"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testCatchingAsync_interruptPropagatesToTransformingThread ()
specifier|public
name|void
name|testCatchingAsync_interruptPropagatesToTransformingThread
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|CountDownLatch
name|inFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|shouldCompleteFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|gotException
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|String
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|Exception
block|{
name|inFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|shouldCompleteFunction
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{
name|gotException
operator|.
name|countDown
argument_list|()
expr_stmt|;
throw|throw
name|expected
throw|;
block|}
return|return
name|immediateFuture
argument_list|(
literal|"a"
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Exception
operator|.
name|class
argument_list|,
name|function
argument_list|,
name|newSingleThreadExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
name|inFunction
operator|.
name|await
argument_list|()
expr_stmt|;
name|futureResult
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|shouldCompleteFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|futureResult
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{}
comment|// TODO(cpovirk): implement interruption, updating this test:
comment|// https://github.com/google/guava/issues/1989
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|gotException
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// gotException.await();
block|}
comment|// catching tests cloned from the old withFallback tests:
DECL|method|testCatching_inputDoesNotRaiseException ()
specifier|public
name|void
name|testCatching_inputDoesNotRaiseException
parameter_list|()
throws|throws
name|Exception
block|{
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFuture
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|originalFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_inputRaisesException ()
specifier|public
name|void
name|testCatching_inputRaisesException
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|RuntimeException
name|raisedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|FunctionSpy
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|spy
argument_list|(
operator|new
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|assertThat
argument_list|(
name|t
argument_list|)
operator|.
name|isSameAs
argument_list|(
name|raisedException
argument_list|)
expr_stmt|;
return|return
literal|20
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
name|raisedException
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|fallback
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_fallbackGeneratesRuntimeException ()
specifier|public
name|void
name|testCatching_fallbackGeneratesRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|RuntimeException
name|expectedException
init|=
operator|new
name|RuntimeException
argument_list|()
decl_stmt|;
name|runExpectedExceptionCatchingTest
argument_list|(
name|expectedException
argument_list|)
expr_stmt|;
block|}
comment|/*    * catching() uses a plain Function, so there's no    * testCatching_fallbackGeneratesCheckedException().    */
DECL|method|testCatching_fallbackGeneratesError ()
specifier|public
name|void
name|testCatching_fallbackGeneratesError
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Error
name|error
init|=
operator|new
name|Error
argument_list|(
literal|"deliberate"
argument_list|)
decl_stmt|;
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
operator|new
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|error
throw|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|catching
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|error
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * catching() uses a plain Function, so there's no testCatching_fallbackReturnsRuntimeException()    * or testCatching_fallbackReturnsCheckedException().    */
DECL|method|runExpectedExceptionCatchingTest (final RuntimeException expectedException)
specifier|private
name|void
name|runExpectedExceptionCatchingTest
parameter_list|(
specifier|final
name|RuntimeException
name|expectedException
parameter_list|)
throws|throws
name|Exception
block|{
name|FunctionSpy
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|spy
argument_list|(
operator|new
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|expectedException
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|failingFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|failingFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|expectedException
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fallback
operator|.
name|verifyCallCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// catching() uses a plain Function, so there's no testCatching_fallbackNotReady().
DECL|method|testCatching_resultInterruptedBeforeFallback ()
specifier|public
name|void
name|testCatching_resultInterruptedBeforeFallback
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|primary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catching
argument_list|(
name|primary
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|derived
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_resultCancelledBeforeFallback ()
specifier|public
name|void
name|testCatching_resultCancelledBeforeFallback
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|primary
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|unexpectedFunction
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|derived
init|=
name|catching
argument_list|(
name|primary
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|derived
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|primary
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|primary
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// catching() uses a plain Function, so there's no testCatching_resultCancelledAfterFallback().
comment|// catching() uses a plain Function, so there's no testCatching_nullInsteadOfFuture().
comment|// Some tests of the exceptionType parameter:
DECL|method|testCatching_Throwable ()
specifier|public
name|void
name|testCatching_Throwable
parameter_list|()
throws|throws
name|Exception
block|{
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|functionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|IOException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|originalFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// non-Throwable exceptionType
DECL|method|testCatching_customTypeMatch ()
specifier|public
name|void
name|testCatching_customTypeMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|Function
argument_list|<
name|IOException
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|functionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|FileNotFoundException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|originalFuture
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// non-Throwable exceptionType
DECL|method|testCatching_customTypeNoMatch ()
specifier|public
name|void
name|testCatching_customTypeNoMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|Function
argument_list|<
name|IOException
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|functionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catching
argument_list|(
name|originalFuture
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// StackOverflowError
DECL|method|testCatching_StackOverflow ()
specifier|public
name|void
name|testCatching_StackOverflow
parameter_list|()
throws|throws
name|Exception
block|{
block|{
comment|/*        * Initialize all relevant classes before running the test, which may otherwise poison any        * classes it is trying to load during its stack overflow.        */
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|unused
init|=
name|catching
argument_list|(
name|root
argument_list|,
name|MyException
operator|.
name|class
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|root
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|=
name|catching
argument_list|(
name|output
argument_list|,
name|MyException
operator|.
name|class
argument_list|,
name|identity
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|root
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StackOverflowError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCatching_ErrorAfterCancellation ()
specifier|public
name|void
name|testCatching_ErrorAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Fallback
implements|implements
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|apply
parameter_list|(
name|Throwable
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
name|Fallback
name|fallback
init|=
operator|new
name|Fallback
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|fallback
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_ExceptionAfterCancellation ()
specifier|public
name|void
name|testCatching_ExceptionAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Fallback
implements|implements
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|apply
parameter_list|(
name|Throwable
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyRuntimeException
argument_list|()
throw|;
block|}
block|}
name|Fallback
name|fallback
init|=
operator|new
name|Fallback
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|fallback
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_getThrowsRuntimeException ()
specifier|public
name|void
name|testCatching_getThrowsRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingRuntimeException
argument_list|(
operator|new
name|MyRuntimeException
argument_list|()
argument_list|)
decl_stmt|;
comment|// We'd catch only MyRuntimeException.class here, but then the test won't compile under GWT.
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|output
argument_list|)
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_getThrowsError ()
specifier|public
name|void
name|testCatching_getThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingError
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
decl_stmt|;
comment|// We'd catch only MyError.class here, but then the test won't compile under GWT.
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|output
argument_list|)
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatching_listenerThrowsError ()
specifier|public
name|void
name|testCatching_listenerThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MyError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCatchingAsync_Throwable ()
specifier|public
name|void
name|testCatchingAsync_Throwable
parameter_list|()
throws|throws
name|Exception
block|{
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|asyncFunctionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|IOException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|originalFuture
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// non-Throwable exceptionType
DECL|method|testCatchingAsync_customTypeMatch ()
specifier|public
name|void
name|testCatchingAsync_customTypeMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|AsyncFunction
argument_list|<
name|IOException
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|asyncFunctionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|FileNotFoundException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|originalFuture
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// non-Throwable exceptionType
DECL|method|testCatchingAsync_customTypeNoMatch ()
specifier|public
name|void
name|testCatchingAsync_customTypeNoMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|AsyncFunction
argument_list|<
name|IOException
argument_list|,
name|Integer
argument_list|>
name|fallback
init|=
name|asyncFunctionReturningOne
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|originalFuture
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|RuntimeException
argument_list|()
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|faultTolerantFuture
init|=
name|catchingAsync
argument_list|(
name|originalFuture
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|faultTolerantFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// StackOverflowError
DECL|method|testCatchingAsync_StackOverflow ()
specifier|public
name|void
name|testCatchingAsync_StackOverflow
parameter_list|()
throws|throws
name|Exception
block|{
block|{
comment|/*        * Initialize all relevant classes before running the test, which may otherwise poison any        * classes it is trying to load during its stack overflow.        */
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|unused
init|=
name|catchingAsync
argument_list|(
name|root
argument_list|,
name|MyException
operator|.
name|class
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|root
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|root
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|=
name|catchingAsync
argument_list|(
name|output
argument_list|,
name|MyException
operator|.
name|class
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|root
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StackOverflowError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCatchingAsync_ErrorAfterCancellation ()
specifier|public
name|void
name|testCatchingAsync_ErrorAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Fallback
implements|implements
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
name|Fallback
name|fallback
init|=
operator|new
name|Fallback
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|fallback
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_ExceptionAfterCancellation ()
specifier|public
name|void
name|testCatchingAsync_ExceptionAfterCancellation
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|Fallback
implements|implements
name|AsyncFunction
argument_list|<
name|Throwable
argument_list|,
name|Object
argument_list|>
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|Throwable
name|input
parameter_list|)
block|{
name|output
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MyRuntimeException
argument_list|()
throw|;
block|}
block|}
name|Fallback
name|fallback
init|=
operator|new
name|Fallback
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|fallback
argument_list|)
decl_stmt|;
name|fallback
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_getThrowsRuntimeException ()
specifier|public
name|void
name|testCatchingAsync_getThrowsRuntimeException
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingRuntimeException
argument_list|(
operator|new
name|MyRuntimeException
argument_list|()
argument_list|)
decl_stmt|;
comment|// We'd catch only MyRuntimeException.class here, but then the test won't compile under GWT.
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|output
argument_list|)
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyRuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_getThrowsError ()
specifier|public
name|void
name|testCatchingAsync_getThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|UncheckedThrowingFuture
operator|.
name|throwingError
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
decl_stmt|;
comment|// We'd catch only MyError.class here, but then the test won't compile under GWT.
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|output
argument_list|)
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|testCatchingAsync_listenerThrowsError ()
specifier|public
name|void
name|testCatchingAsync_listenerThrowsError
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
name|output
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|asyncIdentity
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
throw|throw
operator|new
name|MyError
argument_list|()
throw|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|input
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MyError
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testCatching_rejectionPropagatesToOutput ()
specifier|public
name|void
name|testCatching_rejectionPropagatesToOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|transformed
init|=
name|catching
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|constant
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
name|REJECTING_EXECUTOR
argument_list|)
decl_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RejectedExecutionException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testCatchingAsync_rejectionPropagatesToOutput ()
specifier|public
name|void
name|testCatchingAsync_rejectionPropagatesToOutput
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|transformed
init|=
name|catchingAsync
argument_list|(
name|input
argument_list|,
name|Throwable
operator|.
name|class
argument_list|,
name|constantAsyncFunction
argument_list|(
name|immediateFuture
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
argument_list|,
name|REJECTING_EXECUTOR
argument_list|)
decl_stmt|;
name|input
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|transformed
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|RejectedExecutionException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|functionReturningOne ()
specifier|private
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|>
name|Function
argument_list|<
name|X
argument_list|,
name|Integer
argument_list|>
name|functionReturningOne
parameter_list|()
block|{
return|return
operator|new
name|Function
argument_list|<
name|X
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|X
name|t
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|;
block|}
DECL|method|asyncFunctionReturningOne ()
specifier|private
parameter_list|<
name|X
extends|extends
name|Throwable
parameter_list|>
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|Integer
argument_list|>
name|asyncFunctionReturningOne
parameter_list|()
block|{
return|return
operator|new
name|AsyncFunction
argument_list|<
name|X
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|X
name|t
parameter_list|)
block|{
return|return
name|immediateFuture
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|constantAsyncFunction ( final ListenableFuture<O> output)
specifier|private
specifier|static
parameter_list|<
name|I
parameter_list|,
name|O
parameter_list|>
name|AsyncFunction
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
name|constantAsyncFunction
parameter_list|(
specifier|final
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|output
parameter_list|)
block|{
return|return
operator|new
name|AsyncFunction
argument_list|<
name|I
argument_list|,
name|O
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|O
argument_list|>
name|apply
parameter_list|(
name|I
name|input
parameter_list|)
block|{
return|return
name|output
return|;
block|}
block|}
return|;
block|}
DECL|method|testTransformAsync_genericsWildcard_AsyncFunction ()
specifier|public
name|void
name|testTransformAsync_genericsWildcard_AsyncFunction
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|nullFuture
init|=
name|immediateFuture
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|chainedFuture
init|=
name|transformAsync
argument_list|(
name|nullFuture
argument_list|,
name|constantAsyncFunction
argument_list|(
name|nullFuture
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|getDone
argument_list|(
name|chainedFuture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransformAsync_genericsHierarchy_AsyncFunction ()
specifier|public
name|void
name|testTransformAsync_genericsHierarchy_AsyncFunction
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|FooChild
argument_list|>
name|future
init|=
name|immediateFuture
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|BarChild
name|barChild
init|=
operator|new
name|BarChild
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|BarChild
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|Foo
argument_list|,
name|BarChild
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AbstractFuture
argument_list|<
name|BarChild
argument_list|>
name|apply
parameter_list|(
name|Foo
name|unused
parameter_list|)
block|{
name|AbstractFuture
argument_list|<
name|BarChild
argument_list|>
name|future
init|=
operator|new
name|AbstractFuture
argument_list|<
name|BarChild
argument_list|>
argument_list|()
block|{             }
decl_stmt|;
name|future
operator|.
name|set
argument_list|(
name|barChild
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
block|}
decl_stmt|;
name|Bar
name|bar
init|=
name|getDone
argument_list|(
name|transformAsync
argument_list|(
name|future
argument_list|,
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|barChild
argument_list|,
name|bar
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// get() timeout
DECL|method|testTransformAsync_asyncFunction_timeout ()
specifier|public
name|void
name|testTransformAsync_asyncFunction_timeout
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|function
init|=
name|constantAsyncFunction
argument_list|(
name|immediateFuture
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|future
init|=
name|transformAsync
argument_list|(
name|SettableFuture
operator|.
expr|<
name|String
operator|>
name|create
argument_list|()
argument_list|,
name|function
argument_list|)
decl_stmt|;
try|try
block|{
name|future
operator|.
name|get
argument_list|(
literal|1
argument_list|,
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testTransformAsync_asyncFunction_error ()
specifier|public
name|void
name|testTransformAsync_asyncFunction_error
parameter_list|()
throws|throws
name|InterruptedException
block|{
specifier|final
name|Error
name|error
init|=
operator|new
name|Error
argument_list|(
literal|"deliberate"
argument_list|)
decl_stmt|;
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
throw|throw
name|error
throw|;
block|}
block|}
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|inputFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|outputFuture
init|=
name|transformAsync
argument_list|(
name|inputFuture
argument_list|,
name|function
argument_list|)
decl_stmt|;
name|inputFuture
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|outputFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|error
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransformAsync_asyncFunction_nullInsteadOfFuture ()
specifier|public
name|void
name|testTransformAsync_asyncFunction_nullInsteadOfFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|inputFuture
init|=
name|immediateFuture
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|chainedFuture
init|=
name|transformAsync
argument_list|(
name|inputFuture
argument_list|,
name|constantAsyncFunction
argument_list|(
literal|null
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|chainedFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|NullPointerException
name|cause
init|=
operator|(
name|NullPointerException
operator|)
name|expected
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|cause
argument_list|)
operator|.
name|hasMessage
argument_list|(
literal|"AsyncFunction.apply returned null instead of a Future. "
operator|+
literal|"Did you mean to return immediateFuture(null)?"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testTransformAsync_asyncFunction_cancelledWhileApplyingFunction ()
specifier|public
name|void
name|testTransformAsync_asyncFunction_cancelledWhileApplyingFunction
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
specifier|final
name|CountDownLatch
name|inFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|functionDone
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|resultFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
throws|throws
name|Exception
block|{
name|inFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|functionDone
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|resultFuture
return|;
block|}
block|}
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|inputFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|future
init|=
name|transformAsync
argument_list|(
name|inputFuture
argument_list|,
name|function
argument_list|,
name|newSingleThreadExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|inputFuture
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|inFunction
operator|.
name|await
argument_list|()
expr_stmt|;
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|functionDone
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|resultFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction ()
specifier|public
name|void
name|testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction
parameter_list|()
throws|throws
name|InterruptedException
block|{
specifier|final
name|AtomicBoolean
name|functionCalled
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|function
init|=
operator|new
name|AsyncFunction
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
throws|throws
name|Exception
block|{
name|functionCalled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|immediateFuture
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|inputFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ExecutorService
name|executor
init|=
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Integer
argument_list|>
name|future
init|=
name|transformAsync
argument_list|(
name|inputFuture
argument_list|,
name|function
argument_list|,
name|executor
argument_list|)
decl_stmt|;
comment|// Pause the executor.
specifier|final
name|CountDownLatch
name|beforeFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|awaitUninterruptibly
argument_list|(
name|beforeFunction
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Cancel the future after making input available.
name|inputFuture
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Unpause the executor.
name|beforeFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|executor
operator|.
name|awaitTermination
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|functionCalled
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_genericsWildcard ()
specifier|public
name|void
name|testDereference_genericsWildcard
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|inner
init|=
name|immediateFuture
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|outer
init|=
name|Futures
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|?
argument_list|>
operator|>
name|immediateFuture
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|dereferenced
init|=
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|getDone
argument_list|(
name|dereferenced
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_genericsHierarchy ()
specifier|public
name|void
name|testDereference_genericsHierarchy
parameter_list|()
throws|throws
name|Exception
block|{
name|FooChild
name|fooChild
init|=
operator|new
name|FooChild
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|FooChild
argument_list|>
name|inner
init|=
name|immediateFuture
argument_list|(
name|fooChild
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|FooChild
argument_list|>
argument_list|>
name|outer
init|=
name|immediateFuture
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|dereferenced
init|=
name|Futures
operator|.
expr|<
name|Foo
operator|>
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|fooChild
argument_list|,
name|getDone
argument_list|(
name|dereferenced
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_resultCancelsOuter ()
specifier|public
name|void
name|testDereference_resultCancelsOuter
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
argument_list|>
name|outer
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|dereferenced
init|=
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|dereferenced
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outer
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_resultCancelsInner ()
specifier|public
name|void
name|testDereference_resultCancelsInner
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|inner
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
argument_list|>
name|outer
init|=
name|immediateFuture
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|dereferenced
init|=
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|dereferenced
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inner
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_outerCancelsResult ()
specifier|public
name|void
name|testDereference_outerCancelsResult
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
argument_list|>
name|outer
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|dereferenced
init|=
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|outer
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dereferenced
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testDereference_innerCancelsResult ()
specifier|public
name|void
name|testDereference_innerCancelsResult
parameter_list|()
throws|throws
name|Exception
block|{
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|inner
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
argument_list|>
name|outer
init|=
name|immediateFuture
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|dereferenced
init|=
name|dereference
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|inner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dereferenced
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Runnable which can be called a single time, and only after {@link #expectCall} is called.    */
comment|// TODO(cpovirk): top-level class?
DECL|class|SingleCallListener
specifier|static
class|class
name|SingleCallListener
implements|implements
name|Runnable
block|{
DECL|field|expectCall
specifier|private
name|boolean
name|expectCall
init|=
literal|false
decl_stmt|;
DECL|field|calledCountDown
specifier|private
specifier|final
name|CountDownLatch
name|calledCountDown
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|assertTrue
argument_list|(
literal|"Listener called before it was expected"
argument_list|,
name|expectCall
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Listener called more than once"
argument_list|,
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|calledCountDown
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
DECL|method|expectCall ()
specifier|public
name|void
name|expectCall
parameter_list|()
block|{
name|assertFalse
argument_list|(
literal|"expectCall is already true"
argument_list|,
name|expectCall
argument_list|)
expr_stmt|;
name|expectCall
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|wasCalled ()
specifier|public
name|boolean
name|wasCalled
parameter_list|()
block|{
return|return
name|calledCountDown
operator|.
name|getCount
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|waitForCall ()
specifier|public
name|void
name|waitForCall
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|assertTrue
argument_list|(
literal|"expectCall is false"
argument_list|,
name|expectCall
argument_list|)
expr_stmt|;
name|calledCountDown
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList ()
specifier|public
name|void
name|testAllAsList
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create input and output
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
comment|// Attach a listener
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Satisfy each input and check the output
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
name|DATA1
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
name|DATA3
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|DATA1
argument_list|,
name|DATA2
argument_list|,
name|DATA3
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testAllAsList_emptyList ()
specifier|public
name|void
name|testAllAsList_emptyList
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|futures
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|futures
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|compound
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllAsList_emptyArray ()
specifier|public
name|void
name|testAllAsList_emptyArray
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|()
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|compound
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllAsList_failure ()
specifier|public
name|void
name|testAllAsList_failure
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|Throwable
name|exception
init|=
operator|new
name|Throwable
argument_list|(
literal|"failed1"
argument_list|)
decl_stmt|;
name|future1
operator|.
name|setException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
literal|"result2"
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_singleFailure ()
specifier|public
name|void
name|testAllAsList_singleFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|Throwable
name|exception
init|=
operator|new
name|Throwable
argument_list|(
literal|"failed"
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|future
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_immediateFailure ()
specifier|public
name|void
name|testAllAsList_immediateFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|Throwable
name|exception
init|=
operator|new
name|Throwable
argument_list|(
literal|"failed"
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|immediateFailedFuture
argument_list|(
name|exception
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|immediateFuture
argument_list|(
literal|"results"
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|exception
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_error ()
specifier|public
name|void
name|testAllAsList_error
parameter_list|()
throws|throws
name|Exception
block|{
name|Error
name|error
init|=
operator|new
name|Error
argument_list|(
literal|"deliberate"
argument_list|)
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|immediateFuture
argument_list|(
literal|"results"
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
argument_list|)
decl_stmt|;
name|future1
operator|.
name|setException
argument_list|(
name|error
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|error
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_cancelled ()
specifier|public
name|void
name|testAllAsList_cancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future1
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|setException
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"failed2"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testAllAsList_resultCancelled ()
specifier|public
name|void
name|testAllAsList_resultCancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllAsList_resultCancelledInterrupted_withSecondaryListFuture ()
specifier|public
name|void
name|testAllAsList_resultCancelledInterrupted_withSecondaryListFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
comment|// There was a bug where the event listener for the combined future would
comment|// result in the sub-futures being cancelled without being interrupted.
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|otherCompound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future2
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future2
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|otherCompound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllAsList_resultCancelled_withSecondaryListFuture ()
specifier|public
name|void
name|testAllAsList_resultCancelled_withSecondaryListFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
comment|// This next call is "unused," but it is an important part of the test. Don't remove it!
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|unused
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future2
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|future2
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testAllAsList_resultInterrupted ()
specifier|public
name|void
name|testAllAsList_resultInterrupted
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case where the futures are fulfilled prior to constructing the ListFuture.  There was    * a bug where the loop that connects a Listener to each of the futures would die on the last    * loop-check as done() on ListFuture nulled out the variable being looped over (the list of    * futures).    */
DECL|method|testAllAsList_doneFutures ()
specifier|public
name|void
name|testAllAsList_doneFutures
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create input and output
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Satisfy each input prior to creating compound and check the output
name|future1
operator|.
name|set
argument_list|(
name|DATA1
argument_list|)
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
name|DATA3
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
comment|// Attach a listener
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|DATA1
argument_list|,
name|DATA2
argument_list|,
name|DATA3
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
comment|/**    * A single non-error failure is not logged because it is reported via the output future.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_exception ()
specifier|public
name|void
name|testAllAsList_logging_exception
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|getDone
argument_list|(
name|allAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Nothing should be logged"
argument_list|,
literal|0
argument_list|,
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Ensure that errors are always logged.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_error ()
specifier|public
name|void
name|testAllAsList_logging_error
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|getDone
argument_list|(
name|allAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LogRecord
argument_list|>
name|logged
init|=
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|logged
argument_list|)
operator|.
name|hasSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// errors are always logged
name|assertThat
argument_list|(
name|logged
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * All as list will log extra exceptions that have already occurred.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_multipleExceptions_alreadyDone ()
specifier|public
name|void
name|testAllAsList_logging_multipleExceptions_alreadyDone
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|getDone
argument_list|(
name|allAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|,
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LogRecord
argument_list|>
name|logged
init|=
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|logged
argument_list|)
operator|.
name|hasSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// the second failure is logged
name|assertThat
argument_list|(
name|logged
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * All as list will log extra exceptions that occur later.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_multipleExceptions_doneLater ()
specifier|public
name|void
name|testAllAsList_logging_multipleExceptions_doneLater
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|all
init|=
name|allAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
name|future1
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
name|future3
operator|.
name|setException
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|all
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|List
argument_list|<
name|LogRecord
argument_list|>
name|logged
init|=
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|logged
argument_list|)
operator|.
name|hasSize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// failures after the first are logged
name|assertThat
argument_list|(
name|logged
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|logged
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The same exception happening on multiple futures should not be logged.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_same_exception ()
specifier|public
name|void
name|testAllAsList_logging_same_exception
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|MyException
name|sameInstance
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|getDone
argument_list|(
name|allAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
name|sameInstance
argument_list|)
argument_list|,
name|immediateFailedFuture
argument_list|(
name|sameInstance
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Nothing should be logged"
argument_list|,
literal|0
argument_list|,
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_logging_seenExceptionUpdateRace ()
specifier|public
name|void
name|testAllAsList_logging_seenExceptionUpdateRace
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|MyException
name|sameInstance
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|firstFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|secondFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|bulkFuture
init|=
name|allAsList
argument_list|(
name|firstFuture
argument_list|,
name|secondFuture
argument_list|)
decl_stmt|;
name|bulkFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|/*          * firstFuture just completed, but AggregateFuture hasn't yet had time to record the          * exception in seenExceptions. When we complete secondFuture with the same exception,          * we want for AggregateFuture to still detect that it's been previously seen.          */
name|secondFuture
operator|.
name|setException
argument_list|(
name|sameInstance
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|firstFuture
operator|.
name|setException
argument_list|(
name|sameInstance
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|bulkFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testAllAsList_logging_seenExceptionUpdateCancelRace ()
specifier|public
name|void
name|testAllAsList_logging_seenExceptionUpdateCancelRace
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|MyException
name|subsequentFailure
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|firstFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|secondFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|bulkFuture
init|=
name|allAsList
argument_list|(
name|firstFuture
argument_list|,
name|secondFuture
argument_list|)
decl_stmt|;
name|bulkFuture
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|/*          * This is similar to the above test, but this time we're making sure that we recognize that          * the output Future is done early not because of an exception but because of a          * cancellation.          */
name|secondFuture
operator|.
name|setException
argument_list|(
name|subsequentFailure
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|firstFuture
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|bulkFuture
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|getOnlyElement
argument_list|(
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isSameAs
argument_list|(
name|subsequentFailure
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Different exceptions happening on multiple futures with the same cause should not be logged.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testAllAsList_logging_same_cause ()
specifier|public
name|void
name|testAllAsList_logging_same_cause
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|MyException
name|exception1
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|MyException
name|exception2
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|MyException
name|exception3
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|MyException
name|sameInstance
init|=
operator|new
name|MyException
argument_list|()
decl_stmt|;
name|exception1
operator|.
name|initCause
argument_list|(
name|sameInstance
argument_list|)
expr_stmt|;
name|exception2
operator|.
name|initCause
argument_list|(
name|sameInstance
argument_list|)
expr_stmt|;
name|exception3
operator|.
name|initCause
argument_list|(
name|exception2
argument_list|)
expr_stmt|;
name|getDone
argument_list|(
name|allAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
name|exception1
argument_list|)
argument_list|,
name|immediateFailedFuture
argument_list|(
name|exception3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyException
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Nothing should be logged"
argument_list|,
literal|0
argument_list|,
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createCombinedResult (Integer i, Boolean b)
specifier|private
specifier|static
name|String
name|createCombinedResult
parameter_list|(
name|Integer
name|i
parameter_list|,
name|Boolean
name|b
parameter_list|)
block|{
return|return
literal|"-"
operator|+
name|i
operator|+
literal|"-"
operator|+
name|b
return|;
block|}
DECL|method|testWhenAllComplete_asyncResult ()
specifier|public
name|void
name|testWhenAllComplete_asyncResult
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|futureInteger
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|futureBoolean
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncCallable
argument_list|<
name|String
argument_list|>
name|combiner
init|=
operator|new
name|AsyncCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|assertTrue
argument_list|(
name|futureInteger
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|futureBoolean
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|immediateFuture
argument_list|(
name|createCombinedResult
argument_list|(
name|getDone
argument_list|(
name|futureInteger
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|futureBoolean
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|whenAllComplete
argument_list|(
name|futureInteger
argument_list|,
name|futureBoolean
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiner
argument_list|)
decl_stmt|;
name|Integer
name|integerPartial
init|=
literal|1
decl_stmt|;
name|futureInteger
operator|.
name|set
argument_list|(
name|integerPartial
argument_list|)
expr_stmt|;
name|Boolean
name|booleanPartial
init|=
literal|true
decl_stmt|;
name|futureBoolean
operator|.
name|set
argument_list|(
name|booleanPartial
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|createCombinedResult
argument_list|(
name|integerPartial
argument_list|,
name|booleanPartial
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|futureResult
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testWhenAllComplete_asyncError ()
specifier|public
name|void
name|testWhenAllComplete_asyncError
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Exception
name|thrown
init|=
operator|new
name|RuntimeException
argument_list|(
literal|"test"
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|futureInteger
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|futureBoolean
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncCallable
argument_list|<
name|String
argument_list|>
name|combiner
init|=
operator|new
name|AsyncCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|assertTrue
argument_list|(
name|futureInteger
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|futureBoolean
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|immediateFailedFuture
argument_list|(
name|thrown
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|whenAllComplete
argument_list|(
name|futureInteger
argument_list|,
name|futureBoolean
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiner
argument_list|)
decl_stmt|;
name|Integer
name|integerPartial
init|=
literal|1
decl_stmt|;
name|futureInteger
operator|.
name|set
argument_list|(
name|integerPartial
argument_list|)
expr_stmt|;
name|Boolean
name|booleanPartial
init|=
literal|true
decl_stmt|;
name|futureBoolean
operator|.
name|set
argument_list|(
name|booleanPartial
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|futureResult
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|thrown
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testWhenAllComplete_cancelledNotInterrupted ()
specifier|public
name|void
name|testWhenAllComplete_cancelledNotInterrupted
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|stringFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|booleanFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|CountDownLatch
name|inFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|shouldCompleteFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|resultFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncCallable
argument_list|<
name|String
argument_list|>
name|combiner
init|=
operator|new
name|AsyncCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|inFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|shouldCompleteFunction
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|resultFuture
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|whenAllComplete
argument_list|(
name|stringFuture
argument_list|,
name|booleanFuture
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiner
argument_list|,
name|newSingleThreadExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|stringFuture
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|booleanFuture
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|inFunction
operator|.
name|await
argument_list|()
expr_stmt|;
name|futureResult
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|shouldCompleteFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|futureResult
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{}
try|try
block|{
name|resultFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{}
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testWhenAllComplete_interrupted ()
specifier|public
name|void
name|testWhenAllComplete_interrupted
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|stringFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|booleanFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|CountDownLatch
name|inFunction
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|gotException
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AsyncCallable
argument_list|<
name|String
argument_list|>
name|combiner
init|=
operator|new
name|AsyncCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|inFunction
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// wait for interrupt
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{
name|gotException
operator|.
name|countDown
argument_list|()
expr_stmt|;
throw|throw
name|expected
throw|;
block|}
return|return
name|immediateFuture
argument_list|(
literal|"a"
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|whenAllComplete
argument_list|(
name|stringFuture
argument_list|,
name|booleanFuture
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiner
argument_list|,
name|newSingleThreadExecutor
argument_list|()
argument_list|)
decl_stmt|;
name|stringFuture
operator|.
name|set
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|booleanFuture
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|inFunction
operator|.
name|await
argument_list|()
expr_stmt|;
name|futureResult
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|futureResult
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{}
name|gotException
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
DECL|method|testWhenAllSucceed ()
specifier|public
name|void
name|testWhenAllSucceed
parameter_list|()
throws|throws
name|Exception
block|{
class|class
name|PartialResultException
extends|extends
name|Exception
block|{      }
specifier|final
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|futureInteger
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|futureBoolean
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|AsyncCallable
argument_list|<
name|String
argument_list|>
name|combiner
init|=
operator|new
name|AsyncCallable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
throw|throw
operator|new
name|AssertionFailedError
argument_list|(
literal|"AsyncCallable should not have been called."
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|futureResult
init|=
name|whenAllSucceed
argument_list|(
name|futureInteger
argument_list|,
name|futureBoolean
argument_list|)
operator|.
name|callAsync
argument_list|(
name|combiner
argument_list|)
decl_stmt|;
name|PartialResultException
name|partialResultException
init|=
operator|new
name|PartialResultException
argument_list|()
decl_stmt|;
name|futureInteger
operator|.
name|setException
argument_list|(
name|partialResultException
argument_list|)
expr_stmt|;
name|Boolean
name|booleanPartial
init|=
literal|true
decl_stmt|;
name|futureBoolean
operator|.
name|set
argument_list|(
name|booleanPartial
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|futureResult
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|partialResultException
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * TODO(cpovirk): maybe pass around TestFuture instances instead of    * ListenableFuture instances    */
comment|/**    * A future in {@link TestFutureBatch} that also has a name for debugging purposes and a {@code    * finisher}, a task that will complete the future in some fashion when it is called, allowing for    * testing both before and after the completion of the future.    */
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|class|TestFuture
specifier|private
specifier|static
specifier|final
class|class
name|TestFuture
block|{
DECL|field|future
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
decl_stmt|;
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|finisher
specifier|final
name|Runnable
name|finisher
decl_stmt|;
DECL|method|TestFuture ( ListenableFuture<String> future, String name, Runnable finisher)
name|TestFuture
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|future
parameter_list|,
name|String
name|name
parameter_list|,
name|Runnable
name|finisher
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|finisher
operator|=
name|finisher
expr_stmt|;
block|}
block|}
comment|/**    * A collection of several futures, covering cancellation, success, and failure (both {@link    * ExecutionException} and {@link RuntimeException}), both immediate and delayed. We use each    * possible pair of these futures in {@link FuturesTest#runExtensiveMergerTest}.    *    *<p>Each test requires a new {@link TestFutureBatch} because we need new delayed futures each    * time, as the old delayed futures were completed as part of the old test.    */
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|class|TestFutureBatch
specifier|private
specifier|static
specifier|final
class|class
name|TestFutureBatch
block|{
DECL|field|doneSuccess
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|doneSuccess
init|=
name|immediateFuture
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
DECL|field|doneFailed
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|doneFailed
init|=
name|immediateFailedFuture
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|doneCancelled
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|doneCancelled
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
block|{
name|doneCancelled
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|doneRuntimeException
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|doneRuntimeException
init|=
operator|new
name|ForwardingListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|delegate
init|=
name|immediateFuture
argument_list|(
literal|"Should never be seen"
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
DECL|field|delayedSuccess
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|delayedSuccess
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|delayedFailed
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|delayedFailed
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|delayedCancelled
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|delayedCancelled
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|delegateForDelayedRuntimeException
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|delegateForDelayedRuntimeException
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|delayedRuntimeException
specifier|final
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|delayedRuntimeException
init|=
operator|new
name|ForwardingListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|delegate
parameter_list|()
block|{
return|return
name|delegateForDelayedRuntimeException
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
name|delegateForDelayedRuntimeException
operator|.
name|get
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|delegateForDelayedRuntimeException
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
DECL|field|doNothing
specifier|final
name|Runnable
name|doNothing
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{       }
block|}
decl_stmt|;
DECL|field|finishSuccess
specifier|final
name|Runnable
name|finishSuccess
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|delayedSuccess
operator|.
name|set
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|finishFailure
specifier|final
name|Runnable
name|finishFailure
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|delayedFailed
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|finishCancelled
specifier|final
name|Runnable
name|finishCancelled
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|delayedCancelled
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
DECL|field|finishRuntimeException
specifier|final
name|Runnable
name|finishRuntimeException
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|delegateForDelayedRuntimeException
operator|.
name|set
argument_list|(
literal|"Should never be seen"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/**      * All the futures, together with human-readable names for use by {@link #smartToString}.      */
DECL|field|allFutures
specifier|final
name|ImmutableList
argument_list|<
name|TestFuture
argument_list|>
name|allFutures
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
operator|new
name|TestFuture
argument_list|(
name|doneSuccess
argument_list|,
literal|"doneSuccess"
argument_list|,
name|doNothing
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|doneFailed
argument_list|,
literal|"doneFailed"
argument_list|,
name|doNothing
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|doneCancelled
argument_list|,
literal|"doneCancelled"
argument_list|,
name|doNothing
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|doneRuntimeException
argument_list|,
literal|"doneRuntimeException"
argument_list|,
name|doNothing
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|delayedSuccess
argument_list|,
literal|"delayedSuccess"
argument_list|,
name|finishSuccess
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|delayedFailed
argument_list|,
literal|"delayedFailed"
argument_list|,
name|finishFailure
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|delayedCancelled
argument_list|,
literal|"delayedCancelled"
argument_list|,
name|finishCancelled
argument_list|)
argument_list|,
operator|new
name|TestFuture
argument_list|(
name|delayedRuntimeException
argument_list|,
literal|"delayedRuntimeException"
argument_list|,
name|finishRuntimeException
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|nameGetter
specifier|final
name|Function
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|nameGetter
init|=
operator|new
name|Function
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|input
parameter_list|)
block|{
for|for
control|(
name|TestFuture
name|future
range|:
name|allFutures
control|)
block|{
if|if
condition|(
name|future
operator|.
name|future
operator|==
name|input
condition|)
block|{
return|return
name|future
operator|.
name|name
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|input
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
DECL|method|intersect (Set<?> a, Set<?> b)
specifier|static
name|boolean
name|intersect
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|a
parameter_list|,
name|Set
argument_list|<
name|?
argument_list|>
name|b
parameter_list|)
block|{
return|return
operator|!
name|intersection
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Like {@code inputs.toString()}, but with the nonsense {@code toString} representations      * replaced with the name of each future from {@link #allFutures}.      */
DECL|method|smartToString (ImmutableSet<ListenableFuture<String>> inputs)
name|String
name|smartToString
parameter_list|(
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
parameter_list|)
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|inputNames
init|=
name|Iterables
operator|.
name|transform
argument_list|(
name|inputs
argument_list|,
name|nameGetter
argument_list|)
decl_stmt|;
return|return
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|inputNames
argument_list|)
return|;
block|}
DECL|method|smartAssertTrue (ImmutableSet<ListenableFuture<String>> inputs, Exception cause, boolean expression)
name|void
name|smartAssertTrue
parameter_list|(
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
parameter_list|,
name|Exception
name|cause
parameter_list|,
name|boolean
name|expression
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expression
condition|)
block|{
throw|throw
name|failureWithCause
argument_list|(
name|cause
argument_list|,
name|smartToString
argument_list|(
name|inputs
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|hasDelayed (ListenableFuture<String> a, ListenableFuture<String> b)
name|boolean
name|hasDelayed
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
return|return
name|intersect
argument_list|(
name|inputs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|delayedSuccess
argument_list|,
name|delayedFailed
argument_list|,
name|delayedCancelled
argument_list|,
name|delayedRuntimeException
argument_list|)
argument_list|)
return|;
block|}
DECL|method|assertHasDelayed ( ListenableFuture<String> a, ListenableFuture<String> b, Exception e)
name|void
name|assertHasDelayed
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|smartAssertTrue
argument_list|(
name|inputs
argument_list|,
name|e
argument_list|,
name|hasDelayed
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHasFailure ( ListenableFuture<String> a, ListenableFuture<String> b, Exception e)
name|void
name|assertHasFailure
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|smartAssertTrue
argument_list|(
name|inputs
argument_list|,
name|e
argument_list|,
name|intersect
argument_list|(
name|inputs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|doneFailed
argument_list|,
name|doneRuntimeException
argument_list|,
name|delayedFailed
argument_list|,
name|delayedRuntimeException
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHasCancel ( ListenableFuture<String> a, ListenableFuture<String> b, Exception e)
name|void
name|assertHasCancel
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|smartAssertTrue
argument_list|(
name|inputs
argument_list|,
name|e
argument_list|,
name|intersect
argument_list|(
name|inputs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|doneCancelled
argument_list|,
name|delayedCancelled
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHasImmediateFailure ( ListenableFuture<String> a, ListenableFuture<String> b, Exception e)
name|void
name|assertHasImmediateFailure
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|smartAssertTrue
argument_list|(
name|inputs
argument_list|,
name|e
argument_list|,
name|intersect
argument_list|(
name|inputs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|doneFailed
argument_list|,
name|doneRuntimeException
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertHasImmediateCancel ( ListenableFuture<String> a, ListenableFuture<String> b, Exception e)
name|void
name|assertHasImmediateCancel
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|ImmutableSet
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|smartAssertTrue
argument_list|(
name|inputs
argument_list|,
name|e
argument_list|,
name|intersect
argument_list|(
name|inputs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|doneCancelled
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@link allAsList(Iterable)} or {@link successfulAsList(Iterable)}, hidden    * behind a common interface for testing.    */
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|interface|Merger
specifier|private
interface|interface
name|Merger
block|{
DECL|method|merged ( ListenableFuture<String> a, ListenableFuture<String> b)
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|merged
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|)
function_decl|;
DECL|field|allMerger
name|Merger
name|allMerger
init|=
operator|new
name|Merger
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|merged
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|allAsList
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|successMerger
name|Merger
name|successMerger
init|=
operator|new
name|Merger
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|merged
parameter_list|(
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|a
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|successfulAsList
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
block|}
comment|/**    * Very rough equivalent of a timed get, produced by calling the no-arg get method in another    * thread and waiting a short time for it.    *    *<p>We need this to test the behavior of no-arg get methods without hanging the main test thread    * forever in the case of failure.    */
annotation|@
name|CanIgnoreReturnValue
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|pseudoTimedGetUninterruptibly (final Future<V> input, long timeout, TimeUnit unit)
specifier|static
parameter_list|<
name|V
parameter_list|>
name|V
name|pseudoTimedGetUninterruptibly
parameter_list|(
specifier|final
name|Future
argument_list|<
name|V
argument_list|>
name|input
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|TimeoutException
block|{
name|ExecutorService
name|executor
init|=
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|V
argument_list|>
name|waiter
init|=
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|V
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|input
operator|.
name|get
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|getUninterruptibly
argument_list|(
name|waiter
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|propagateIfInstanceOf
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|,
name|ExecutionException
operator|.
name|class
argument_list|)
expr_stmt|;
name|propagateIfInstanceOf
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|,
name|CancellationException
operator|.
name|class
argument_list|)
expr_stmt|;
throw|throw
name|failureWithCause
argument_list|(
name|e
argument_list|,
literal|"Unexpected exception"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
comment|// TODO(cpovirk: assertTrue(awaitTerminationUninterruptibly(executor, 10, SECONDS));
block|}
block|}
comment|/**    * For each possible pair of futures from {@link TestFutureBatch}, for each possible completion    * order of those futures, test that various get calls (timed before future completion, untimed    * before future completion, and untimed after future completion) return or throw the proper    * values.    */
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|method|runExtensiveMergerTest (Merger merger)
specifier|private
specifier|static
name|void
name|runExtensiveMergerTest
parameter_list|(
name|Merger
name|merger
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|inputCount
init|=
operator|new
name|TestFutureBatch
argument_list|()
operator|.
name|allFutures
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputCount
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|inputCount
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|boolean
name|iBeforeJ
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
name|TestFutureBatch
name|inputs
init|=
operator|new
name|TestFutureBatch
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|iFuture
init|=
name|inputs
operator|.
name|allFutures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|future
decl_stmt|;
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|jFuture
init|=
name|inputs
operator|.
name|allFutures
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|future
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|future
init|=
name|merger
operator|.
name|merged
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|)
decl_stmt|;
comment|// Test timed get before we've completed any delayed futures.
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|future
operator|.
name|get
argument_list|(
literal|0
argument_list|,
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Got "
operator|+
name|result
argument_list|,
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|)
operator|.
name|containsAll
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasImmediateCancel
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasImmediateFailure
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|inputs
operator|.
name|assertHasDelayed
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Same tests with pseudoTimedGet.
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|conditionalPseudoTimedGetUninterruptibly
argument_list|(
name|inputs
argument_list|,
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|future
argument_list|,
literal|20
argument_list|,
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Got "
operator|+
name|result
argument_list|,
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|null
argument_list|)
operator|.
name|containsAll
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasImmediateCancel
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasImmediateFailure
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|inputs
operator|.
name|assertHasDelayed
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Finish the two futures in the currently specified order:
name|inputs
operator|.
name|allFutures
operator|.
name|get
argument_list|(
name|iBeforeJ
condition|?
name|i
else|:
name|j
argument_list|)
operator|.
name|finisher
operator|.
name|run
argument_list|()
expr_stmt|;
name|inputs
operator|.
name|allFutures
operator|.
name|get
argument_list|(
name|iBeforeJ
condition|?
name|j
else|:
name|i
argument_list|)
operator|.
name|finisher
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Test untimed get now that we've completed any delayed futures.
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|getDone
argument_list|(
name|future
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Got "
operator|+
name|result
argument_list|,
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|null
argument_list|)
operator|.
name|containsAll
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasCancel
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|merger
operator|==
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|assertHasFailure
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Call the non-timed {@link Future#get()} in a way that allows us to abort if it's expected to    * hang forever. More precisely, if it's expected to return, we simply call it[*], but if it's    * expected to hang (because one of the input futures that we know makes it up isn't done yet),    * then we call it in a separate thread (using pseudoTimedGet). The result is that we wait as long    * as necessary when the method is expected to return (at the cost of hanging forever if there is    * a bug in the class under test) but that we time out fairly promptly when the method is expected    * to hang (possibly too quickly, but too-quick failures should be very unlikely, given that we    * used to bail after 20ms during the expected-successful tests, and there we saw a failure rate    * of ~1/5000, meaning that the other thread's get() call nearly always completes within 20ms if    * it's going to complete at all).    *    * [*] To avoid hangs, I've disabled the in-thread calls. This makes the test take (very roughly)    * 2.5s longer. (2.5s is also the maximum length of time we will wait for a timed get that is    * expected to succeed; the fact that the numbers match is only a coincidence.) See the comment    * below for how to restore the fast but hang-y version.    */
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|method|conditionalPseudoTimedGetUninterruptibly ( TestFutureBatch inputs, ListenableFuture<String> iFuture, ListenableFuture<String> jFuture, ListenableFuture<List<String>> future, int timeout, TimeUnit unit)
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|conditionalPseudoTimedGetUninterruptibly
parameter_list|(
name|TestFutureBatch
name|inputs
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|iFuture
parameter_list|,
name|ListenableFuture
argument_list|<
name|String
argument_list|>
name|jFuture
parameter_list|,
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|future
parameter_list|,
name|int
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|TimeoutException
block|{
comment|/*      * For faster tests (that may hang indefinitely if the class under test has      * a bug!), switch the second branch to call untimed future.get() instead of      * pseudoTimedGet.      */
return|return
operator|(
name|inputs
operator|.
name|hasDelayed
argument_list|(
name|iFuture
argument_list|,
name|jFuture
argument_list|)
operator|)
condition|?
name|pseudoTimedGetUninterruptibly
argument_list|(
name|future
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
else|:
name|pseudoTimedGetUninterruptibly
argument_list|(
name|future
argument_list|,
literal|2500
argument_list|,
name|MILLISECONDS
argument_list|)
return|;
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testAllAsList_extensive ()
specifier|public
name|void
name|testAllAsList_extensive
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|runExtensiveMergerTest
argument_list|(
name|Merger
operator|.
name|allMerger
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// threads
DECL|method|testSuccessfulAsList_extensive ()
specifier|public
name|void
name|testSuccessfulAsList_extensive
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|runExtensiveMergerTest
argument_list|(
name|Merger
operator|.
name|successMerger
argument_list|)
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList ()
specifier|public
name|void
name|testSuccessfulAsList
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create input and output
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
comment|// Attach a listener
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Satisfy each input and check the output
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
name|DATA1
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
name|DATA3
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|DATA1
argument_list|,
name|DATA2
argument_list|,
name|DATA3
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_emptyList ()
specifier|public
name|void
name|testSuccessfulAsList_emptyList
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ListenableFuture
argument_list|<
name|String
argument_list|>
argument_list|>
name|futures
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|futures
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|compound
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_emptyArray ()
specifier|public
name|void
name|testSuccessfulAsList_emptyArray
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|()
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|getDone
argument_list|(
name|compound
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_partialFailure ()
specifier|public
name|void
name|testSuccessfulAsList_partialFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|setException
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"failed1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|null
argument_list|,
name|DATA2
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_totalFailure ()
specifier|public
name|void
name|testSuccessfulAsList_totalFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|setException
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"failed1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future2
operator|.
name|setException
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"failed2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_cancelled ()
specifier|public
name|void
name|testSuccessfulAsList_cancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|null
argument_list|,
name|DATA2
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_resultCancelled ()
specifier|public
name|void
name|testSuccessfulAsList_resultCancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_resultCancelledRacingInputDone ()
specifier|public
name|void
name|testSuccessfulAsList_resultCancelledRacingInputDone
parameter_list|()
throws|throws
name|Exception
block|{
name|TestLogHandler
name|listenerLoggerHandler
init|=
operator|new
name|TestLogHandler
argument_list|()
decl_stmt|;
name|Logger
name|exceptionLogger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|AbstractFuture
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|exceptionLogger
operator|.
name|addHandler
argument_list|(
name|listenerLoggerHandler
argument_list|)
expr_stmt|;
try|try
block|{
name|doTestSuccessfulAsList_resultCancelledRacingInputDone
argument_list|()
expr_stmt|;
name|assertWithMessage
argument_list|(
literal|"Nothing should be logged"
argument_list|)
operator|.
name|that
argument_list|(
name|listenerLoggerHandler
operator|.
name|getStoredLogRecords
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|exceptionLogger
operator|.
name|removeHandler
argument_list|(
name|listenerLoggerHandler
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestSuccessfulAsList_resultCancelledRacingInputDone ()
specifier|private
specifier|static
name|void
name|doTestSuccessfulAsList_resultCancelledRacingInputDone
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Simple (combined.cancel -> input.cancel -> setOneValue):
name|successfulAsList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|SettableFuture
operator|.
name|create
argument_list|()
argument_list|)
argument_list|)
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|/*      * Complex (combined.cancel -> input.cancel -> other.set -> setOneValue),      * to show that this isn't just about problems with the input future we just      * cancelled:      */
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|future1
operator|.
name|addListener
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * This test relies on behavior that's unspecified but currently          * guaranteed by the implementation: Cancellation of inputs is          * performed in the order they were provided to the constructor. Verify          * that as a sanity check:          */
name|assertFalse
argument_list|(
name|future2
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now attempt to trigger the exception:
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|future2
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|compound
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
block|}
DECL|method|testSuccessfulAsList_resultInterrupted ()
specifier|public
name|void
name|testSuccessfulAsList_resultInterrupted
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
name|DATA2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|compound
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|future1
operator|.
name|wasInterrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testSuccessfulAsList_mixed ()
specifier|public
name|void
name|testSuccessfulAsList_mixed
parameter_list|()
throws|throws
name|Exception
block|{
name|SingleCallListener
name|listener
init|=
operator|new
name|SingleCallListener
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// array is never modified
name|ListenableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|compound
init|=
name|successfulAsList
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
name|compound
operator|.
name|addListener
argument_list|(
name|listener
argument_list|,
name|directExecutor
argument_list|()
argument_list|)
expr_stmt|;
comment|// First is cancelled, second fails, third succeeds
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future1
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|future2
operator|.
name|setException
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"failed2"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|compound
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|listener
operator|.
name|expectCall
argument_list|()
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
name|DATA3
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listener
operator|.
name|wasCalled
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
name|getDone
argument_list|(
name|compound
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|results
argument_list|)
operator|.
name|containsExactly
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|DATA3
argument_list|)
operator|.
name|inOrder
argument_list|()
expr_stmt|;
block|}
comment|/**    * Non-Error exceptions are never logged.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testSuccessfulAsList_logging_exception ()
specifier|public
name|void
name|testSuccessfulAsList_logging_exception
parameter_list|()
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
name|newArrayList
argument_list|(
operator|(
name|Object
operator|)
literal|null
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|successfulAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertWithMessage
argument_list|(
literal|"Nothing should be logged"
argument_list|)
operator|.
name|that
argument_list|(
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
comment|// Not even if there are a bunch of failures.
name|assertEquals
argument_list|(
name|newArrayList
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|successfulAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|,
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|,
name|immediateFailedFuture
argument_list|(
operator|new
name|MyException
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertWithMessage
argument_list|(
literal|"Nothing should be logged"
argument_list|)
operator|.
name|that
argument_list|(
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
comment|/**    * Ensure that errors are always logged.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testSuccessfulAsList_logging_error ()
specifier|public
name|void
name|testSuccessfulAsList_logging_error
parameter_list|()
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
name|newArrayList
argument_list|(
operator|(
name|Object
operator|)
literal|null
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|successfulAsList
argument_list|(
name|immediateFailedFuture
argument_list|(
operator|new
name|MyError
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LogRecord
argument_list|>
name|logged
init|=
name|aggregateFutureLogHandler
operator|.
name|getStoredLogRecords
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|logged
argument_list|)
operator|.
name|hasSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// errors are always logged
name|assertThat
argument_list|(
name|logged
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getThrown
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|MyError
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// nonCancellationPropagating
DECL|method|testNonCancellationPropagating_successful ()
specifier|public
name|void
name|testNonCancellationPropagating_successful
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|wrapper
init|=
name|nonCancellationPropagating
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|Foo
name|foo
init|=
operator|new
name|Foo
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
name|wrapper
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|set
argument_list|(
name|foo
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wrapper
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|foo
argument_list|,
name|getDone
argument_list|(
name|wrapper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// nonCancellationPropagating
DECL|method|testNonCancellationPropagating_failure ()
specifier|public
name|void
name|testNonCancellationPropagating_failure
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|wrapper
init|=
name|nonCancellationPropagating
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|Throwable
name|failure
init|=
operator|new
name|Throwable
argument_list|(
literal|"thrown"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|wrapper
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|setException
argument_list|(
name|failure
argument_list|)
expr_stmt|;
try|try
block|{
name|getDone
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertSame
argument_list|(
name|failure
argument_list|,
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// nonCancellationPropagating
DECL|method|testNonCancellationPropagating_delegateCancelled ()
specifier|public
name|void
name|testNonCancellationPropagating_delegateCancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|wrapper
init|=
name|nonCancellationPropagating
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|wrapper
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|input
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wrapper
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// nonCancellationPropagating
DECL|method|testNonCancellationPropagating_doesNotPropagate ()
specifier|public
name|void
name|testNonCancellationPropagating_doesNotPropagate
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Foo
argument_list|>
name|input
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ListenableFuture
argument_list|<
name|Foo
argument_list|>
name|wrapper
init|=
name|nonCancellationPropagating
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|wrapper
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wrapper
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wrapper
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|input
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|input
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|class|TestException
specifier|private
specifier|static
class|class
name|TestException
extends|extends
name|Exception
block|{
DECL|method|TestException (@ullable Throwable cause)
name|TestException
parameter_list|(
annotation|@
name|Nullable
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|field|mapper
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
name|mapper
init|=
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TestException
name|apply
parameter_list|(
name|Exception
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|instanceof
name|ExecutionException
condition|)
block|{
return|return
operator|new
name|TestException
argument_list|(
name|from
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
literal|"got "
operator|+
name|from
operator|.
name|getClass
argument_list|()
argument_list|,
name|from
operator|instanceof
name|InterruptedException
operator|||
name|from
operator|instanceof
name|CancellationException
argument_list|)
expr_stmt|;
return|return
operator|new
name|TestException
argument_list|(
name|from
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_mapsExecutionExceptions ()
specifier|public
name|void
name|testMakeChecked_mapsExecutionExceptions
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"checked"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|checked
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|checked
operator|.
name|isCancelled
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checked
operator|.
name|get
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_mapsInterruption ()
specifier|public
name|void
name|testMakeChecked_mapsInterruption
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{     }
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|get
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|expected
parameter_list|)
block|{     }
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|InterruptedException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|InterruptedException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_mapsCancellation ()
specifier|public
name|void
name|testMakeChecked_mapsCancellation
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// argument is ignored
try|try
block|{
name|checked
operator|.
name|get
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|checked
operator|.
name|get
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|CancellationException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TestException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|CancellationException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_propagatesFailedMappers ()
specifier|public
name|void
name|testMakeChecked_propagatesFailedMappers
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TestException
name|apply
parameter_list|(
name|Exception
name|from
parameter_list|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
try|try
block|{
name|checked
operator|.
name|checkedGet
argument_list|(
literal|5
argument_list|,
name|SECONDS
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|expected
parameter_list|)
block|{     }
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_listenersRunOnceCompleted ()
specifier|public
name|void
name|testMakeChecked_listenersRunOnceCompleted
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TestException
name|apply
parameter_list|(
name|Exception
name|from
parameter_list|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFutureTester
name|tester
init|=
operator|new
name|ListenableFutureTester
argument_list|(
name|checked
argument_list|)
decl_stmt|;
name|tester
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|future
operator|.
name|set
argument_list|(
name|DATA1
argument_list|)
expr_stmt|;
name|tester
operator|.
name|testCompletedFuture
argument_list|(
name|DATA1
argument_list|)
expr_stmt|;
name|tester
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_listenersRunOnCancel ()
specifier|public
name|void
name|testMakeChecked_listenersRunOnCancel
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TestException
name|apply
parameter_list|(
name|Exception
name|from
parameter_list|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFutureTester
name|tester
init|=
operator|new
name|ListenableFutureTester
argument_list|(
name|checked
argument_list|)
decl_stmt|;
name|tester
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// argument is ignored
name|tester
operator|.
name|testCancelledFuture
argument_list|()
expr_stmt|;
name|tester
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// makeChecked
DECL|method|testMakeChecked_listenersRunOnFailure ()
specifier|public
name|void
name|testMakeChecked_listenersRunOnFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|CheckedFuture
argument_list|<
name|String
argument_list|,
name|TestException
argument_list|>
name|checked
init|=
name|makeChecked
argument_list|(
name|future
argument_list|,
operator|new
name|Function
argument_list|<
name|Exception
argument_list|,
name|TestException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TestException
name|apply
parameter_list|(
name|Exception
name|from
parameter_list|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
name|ListenableFutureTester
name|tester
init|=
operator|new
name|ListenableFutureTester
argument_list|(
name|checked
argument_list|)
decl_stmt|;
name|tester
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|future
operator|.
name|setException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|tester
operator|.
name|testFailedFuture
argument_list|(
literal|"failed"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|GwtIncompatible
comment|// used only in GwtIncompatible tests
DECL|interface|MapperFunction
specifier|private
interface|interface
name|MapperFunction
extends|extends
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Exception
argument_list|>
block|{}
annotation|@
name|GwtIncompatible
comment|// inCompletionOrder
DECL|method|testCompletionOrder ()
specifier|public
name|void
name|testCompletionOrder
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future4
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future5
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
argument_list|>
name|futures
init|=
name|inCompletionOrder
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
operator|>
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|)
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|future5
operator|.
name|set
argument_list|(
literal|2L
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
literal|3L
argument_list|)
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
literal|4L
argument_list|)
expr_stmt|;
name|future4
operator|.
name|set
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|long
name|expectedResult
init|=
literal|1L
decl_stmt|;
for|for
control|(
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
name|future
range|:
name|futures
control|)
block|{
name|assertEquals
argument_list|(
operator|(
name|Long
operator|)
name|expectedResult
argument_list|,
name|getDone
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
name|expectedResult
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// inCompletionOrder
DECL|method|testCompletionOrderExceptionThrown ()
specifier|public
name|void
name|testCompletionOrderExceptionThrown
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future4
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future5
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
argument_list|>
name|futures
init|=
name|inCompletionOrder
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
operator|>
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|)
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|future5
operator|.
name|setException
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"2L"
argument_list|)
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
literal|3L
argument_list|)
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
literal|4L
argument_list|)
expr_stmt|;
name|future4
operator|.
name|set
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|long
name|expectedResult
init|=
literal|1L
decl_stmt|;
for|for
control|(
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
name|future
range|:
name|futures
control|)
block|{
if|if
condition|(
name|expectedResult
operator|!=
literal|2
condition|)
block|{
name|assertEquals
argument_list|(
operator|(
name|Long
operator|)
name|expectedResult
argument_list|,
name|getDone
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|getDone
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|expected
operator|.
name|getCause
argument_list|()
argument_list|)
operator|.
name|hasMessage
argument_list|(
literal|"2L"
argument_list|)
expr_stmt|;
block|}
block|}
name|expectedResult
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// inCompletionOrder
DECL|method|testCompletionOrderFutureCancelled ()
specifier|public
name|void
name|testCompletionOrderFutureCancelled
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future4
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future5
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
argument_list|>
name|futures
init|=
name|inCompletionOrder
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
operator|>
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|,
name|future4
argument_list|,
name|future5
argument_list|)
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|future5
operator|.
name|set
argument_list|(
literal|2L
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
literal|3L
argument_list|)
expr_stmt|;
name|future3
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|future4
operator|.
name|set
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|long
name|expectedResult
init|=
literal|1L
decl_stmt|;
for|for
control|(
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
name|future
range|:
name|futures
control|)
block|{
if|if
condition|(
name|expectedResult
operator|!=
literal|4
condition|)
block|{
name|assertEquals
argument_list|(
operator|(
name|Long
operator|)
name|expectedResult
argument_list|,
name|getDone
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|getDone
argument_list|(
name|future
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|expected
parameter_list|)
block|{         }
block|}
name|expectedResult
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// inCompletionOrder
DECL|method|testCancellingADelegateDoesNotPropagate ()
specifier|public
name|void
name|testCancellingADelegateDoesNotPropagate
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
argument_list|>
name|delegates
init|=
name|inCompletionOrder
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|Long
argument_list|>
operator|>
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|)
argument_list|)
decl_stmt|;
name|future1
operator|.
name|set
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|// Cannot cancel a complete delegate
name|assertFalse
argument_list|(
name|delegates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Cancel the delegate before the input future is done
name|assertTrue
argument_list|(
name|delegates
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Setting the future still works since cancellation didn't propagate
name|assertTrue
argument_list|(
name|future2
operator|.
name|set
argument_list|(
literal|2L
argument_list|)
argument_list|)
expr_stmt|;
comment|// Second check to ensure the input future was not cancelled
name|assertEquals
argument_list|(
operator|(
name|Long
operator|)
literal|2L
argument_list|,
name|getDone
argument_list|(
name|future2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Mostly an example of how it would look like to use a list of mixed types
annotation|@
name|GwtIncompatible
comment|// inCompletionOrder
DECL|method|testCompletionOrderMixedBagOTypes ()
specifier|public
name|void
name|testCompletionOrderMixedBagOTypes
parameter_list|()
throws|throws
name|Exception
block|{
name|SettableFuture
argument_list|<
name|Long
argument_list|>
name|future1
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|String
argument_list|>
name|future2
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|SettableFuture
argument_list|<
name|Integer
argument_list|>
name|future3
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|ImmutableList
argument_list|<
name|?
extends|extends
name|ListenableFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|inputs
init|=
name|ImmutableList
operator|.
expr|<
name|ListenableFuture
argument_list|<
name|?
argument_list|>
operator|>
name|of
argument_list|(
name|future1
argument_list|,
name|future2
argument_list|,
name|future3
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|ListenableFuture
argument_list|<
name|Object
argument_list|>
argument_list|>
name|futures
init|=
name|inCompletionOrder
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|future2
operator|.
name|set
argument_list|(
literal|"1L"
argument_list|)
expr_stmt|;
name|future1
operator|.
name|set
argument_list|(
literal|2L
argument_list|)
expr_stmt|;
name|future3
operator|.
name|set
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ImmutableList
argument_list|<
name|?
argument_list|>
name|expected
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"1L"
argument_list|,
literal|2L
argument_list|,
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|expected
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|getDone
argument_list|(
name|futures
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|GwtIncompatible
comment|// ClassSanityTester
DECL|method|testFutures_nullChecks ()
specifier|public
name|void
name|testFutures_nullChecks
parameter_list|()
throws|throws
name|Exception
block|{
operator|new
name|ClassSanityTester
argument_list|()
operator|.
name|forAllPublicStaticMethods
argument_list|(
name|Futures
operator|.
name|class
argument_list|)
operator|.
name|thatReturn
argument_list|(
name|Future
operator|.
name|class
argument_list|)
operator|.
name|testNulls
argument_list|()
expr_stmt|;
block|}
DECL|method|failureWithCause (Throwable cause, String message)
specifier|static
name|AssertionFailedError
name|failureWithCause
parameter_list|(
name|Throwable
name|cause
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|AssertionFailedError
name|failure
init|=
operator|new
name|AssertionFailedError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|failure
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return
name|failure
return|;
block|}
comment|// This test covers a bug where an Error thrown from a callback could cause the TimeoutFuture to
comment|// never complete when timing out.  Notably, nothing would get logged since the Error would get
comment|// stuck in the ScheduledFuture inside of TimeoutFuture and nothing ever calls get on it.
comment|// Simulate a timeout that fires before the call the SES.schedule returns but the future is
comment|// already completed.
DECL|field|REJECTING_EXECUTOR
specifier|private
specifier|static
specifier|final
name|Executor
name|REJECTING_EXECUTOR
init|=
operator|new
name|Executor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
throw|throw
operator|new
name|RejectedExecutionException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
DECL|method|asyncIdentity ()
specifier|private
specifier|static
parameter_list|<
name|V
parameter_list|>
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|V
argument_list|>
name|asyncIdentity
parameter_list|()
block|{
return|return
operator|new
name|AsyncFunction
argument_list|<
name|V
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|apply
parameter_list|(
name|V
name|input
parameter_list|)
block|{
return|return
name|immediateFuture
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

