begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2014 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Uninterruptibles
operator|.
name|awaitUninterruptibly
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CaseFormat
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestSuite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * Generated tests for {@link Monitor}.  *  *<p>This test class generates all of its own test cases in the {@link #suite()} method. Every  * {@code enterXxx}, {@code tryEnterXxx}, and {@code waitForXxx} method of the {@code Monitor} class  * is analyzed reflectively to determine appropriate test cases based on its signature. Additional  * ad hoc test cases can be found in {@link SupplementalMonitorTest}.  *  * @author Justin T. Sampson  */
end_comment

begin_class
DECL|class|GeneratedMonitorTest
specifier|public
class|class
name|GeneratedMonitorTest
extends|extends
name|TestCase
block|{
DECL|method|suite ()
specifier|public
specifier|static
name|TestSuite
name|suite
parameter_list|()
block|{
name|TestSuite
name|suite
init|=
operator|new
name|TestSuite
argument_list|()
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|Monitor
operator|.
name|class
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|sortMethods
argument_list|(
name|methods
argument_list|)
expr_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|methods
control|)
block|{
if|if
condition|(
name|isAnyEnter
argument_list|(
name|method
argument_list|)
operator|||
name|isWaitFor
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|validateMethod
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|548
argument_list|,
name|suite
operator|.
name|testCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|suite
return|;
block|}
comment|/**    * A typical timeout value we'll use in the tests.    */
DECL|field|SMALL_TIMEOUT_MILLIS
specifier|private
specifier|static
specifier|final
name|long
name|SMALL_TIMEOUT_MILLIS
init|=
literal|10
decl_stmt|;
comment|/**    * How long to wait when determining that a thread is blocked if we expect it to be blocked.    */
DECL|field|EXPECTED_HANG_DELAY_MILLIS
specifier|private
specifier|static
specifier|final
name|long
name|EXPECTED_HANG_DELAY_MILLIS
init|=
literal|75
decl_stmt|;
comment|/**    * How long to wait when determining that a thread is blocked if we DON'T expect it to be blocked.    */
DECL|field|UNEXPECTED_HANG_DELAY_MILLIS
specifier|private
specifier|static
specifier|final
name|long
name|UNEXPECTED_HANG_DELAY_MILLIS
init|=
literal|10000
decl_stmt|;
comment|/**    * Various scenarios to be generated for each method under test. The actual scenario generation    * (determining which scenarios are applicable to which methods and what the outcome should be)    * takes place in {@link #addTests(TestSuite, Method)}.    */
DECL|enum|Scenario
specifier|private
enum|enum
name|Scenario
block|{
DECL|enumConstant|SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
name|SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
block|,
DECL|enumConstant|UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
name|UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
block|,
DECL|enumConstant|SATISFIED_AND_OCCUPIED_BEFORE_ENTERING
name|SATISFIED_AND_OCCUPIED_BEFORE_ENTERING
block|,
DECL|enumConstant|SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING
name|SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING
block|,
DECL|enumConstant|SATISFIED_BEFORE_WAITING
name|SATISFIED_BEFORE_WAITING
block|,
DECL|enumConstant|SATISFIED_WHILE_WAITING
name|SATISFIED_WHILE_WAITING
block|,
DECL|enumConstant|SATISFIED_AND_INTERRUPTED_BEFORE_WAITING
name|SATISFIED_AND_INTERRUPTED_BEFORE_WAITING
block|,
DECL|enumConstant|UNSATISFIED_BEFORE_AND_WHILE_WAITING
name|UNSATISFIED_BEFORE_AND_WHILE_WAITING
block|,
DECL|enumConstant|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
name|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
block|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|CaseFormat
operator|.
name|UPPER_UNDERSCORE
operator|.
name|to
argument_list|(
name|CaseFormat
operator|.
name|UPPER_CAMEL
argument_list|,
name|name
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Timeout values to combine with each {@link Scenario}.    */
DECL|enum|Timeout
specifier|private
enum|enum
name|Timeout
block|{
DECL|enumConstant|MIN
name|MIN
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|,
literal|"-oo"
argument_list|)
block|,
DECL|enumConstant|MINUS_SMALL
name|MINUS_SMALL
argument_list|(
operator|-
name|SMALL_TIMEOUT_MILLIS
argument_list|,
literal|"-"
operator|+
name|SMALL_TIMEOUT_MILLIS
operator|+
literal|"ms"
argument_list|)
block|,
DECL|enumConstant|ZERO
name|ZERO
argument_list|(
literal|0L
argument_list|,
literal|"0ms"
argument_list|)
block|,
DECL|enumConstant|SMALL
name|SMALL
argument_list|(
name|SMALL_TIMEOUT_MILLIS
argument_list|,
name|SMALL_TIMEOUT_MILLIS
operator|+
literal|"ms"
argument_list|)
block|,
DECL|enumConstant|LARGE
name|LARGE
argument_list|(
name|UNEXPECTED_HANG_DELAY_MILLIS
operator|*
literal|2
argument_list|,
operator|(
literal|2
operator|*
name|UNEXPECTED_HANG_DELAY_MILLIS
operator|)
operator|+
literal|"ms"
argument_list|)
block|,
DECL|enumConstant|MAX
name|MAX
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
literal|"+oo"
argument_list|)
block|;
DECL|field|millis
specifier|final
name|long
name|millis
decl_stmt|;
DECL|field|label
specifier|final
name|String
name|label
decl_stmt|;
DECL|method|Timeout (long millis, String label)
specifier|private
name|Timeout
parameter_list|(
name|long
name|millis
parameter_list|,
name|String
name|label
parameter_list|)
block|{
name|this
operator|.
name|millis
operator|=
name|millis
expr_stmt|;
name|this
operator|.
name|label
operator|=
name|label
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|label
return|;
block|}
block|}
comment|/**    * Convenient subsets of the {@link Timeout} enumeration for specifying scenario outcomes.    */
DECL|enum|TimeoutsToUse
specifier|private
enum|enum
name|TimeoutsToUse
block|{
DECL|enumConstant|ANY
DECL|enumConstant|Timeout.values
name|ANY
argument_list|(
name|Timeout
operator|.
name|values
argument_list|()
argument_list|)
block|,
DECL|enumConstant|PAST
name|PAST
parameter_list|(
name|Timeout
operator|.
name|MIN
parameter_list|,
name|Timeout
operator|.
name|MINUS_SMALL
parameter_list|,
name|Timeout
operator|.
name|ZERO
parameter_list|)
operator|,
DECL|enumConstant|FUTURE
constructor|FUTURE(Timeout.SMALL
operator|,
constructor|Timeout.MAX
block|)
enum|,
DECL|enumConstant|SMALL
name|SMALL
parameter_list|(
name|Timeout
operator|.
name|SMALL
parameter_list|)
operator|,
DECL|enumConstant|FINITE
constructor|FINITE(Timeout.MIN
operator|,
constructor|Timeout.MINUS_SMALL
operator|,
constructor|Timeout.ZERO
operator|,
constructor|Timeout.SMALL
block|)
operator|,
DECL|enumConstant|INFINITE
name|INFINITE
argument_list|(
name|Timeout
operator|.
name|LARGE
argument_list|,
name|Timeout
operator|.
name|MAX
argument_list|)
expr_stmt|;
end_class

begin_decl_stmt
DECL|field|timeouts
specifier|final
name|ImmutableList
argument_list|<
name|Timeout
argument_list|>
name|timeouts
decl_stmt|;
end_decl_stmt

begin_constructor
DECL|method|TimeoutsToUse (Timeout... timeouts)
specifier|private
name|TimeoutsToUse
parameter_list|(
name|Timeout
modifier|...
name|timeouts
parameter_list|)
block|{
name|this
operator|.
name|timeouts
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|timeouts
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_comment
unit|}
comment|/**    * Possible outcomes of calling any of the methods under test.    */
end_comment

begin_enum
DECL|enum|Outcome
unit|private
enum|enum
name|Outcome
block|{
comment|/**      * The method returned normally and is either void or returned true.      */
DECL|enumConstant|SUCCESS
name|SUCCESS
block|,
comment|/**      * The method returned false.      */
DECL|enumConstant|FAILURE
name|FAILURE
block|,
comment|/**      * The method threw an InterruptedException.      */
DECL|enumConstant|INTERRUPT
name|INTERRUPT
block|,
comment|/**      * The method did not return or throw anything.      */
DECL|enumConstant|HANG
name|HANG
block|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|CaseFormat
operator|.
name|UPPER_UNDERSCORE
operator|.
name|to
argument_list|(
name|CaseFormat
operator|.
name|UPPER_CAMEL
argument_list|,
name|name
argument_list|()
argument_list|)
return|;
block|}
block|}
end_enum

begin_comment
comment|/**    * Identifies all enterXxx and tryEnterXxx methods.    */
end_comment

begin_function
DECL|method|isAnyEnter (Method method)
specifier|private
specifier|static
name|boolean
name|isAnyEnter
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"enter"
argument_list|)
operator|||
name|method
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"tryEnter"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Identifies just tryEnterXxx methods (a subset of {@link #isAnyEnter}), which never block.    */
end_comment

begin_function
DECL|method|isTryEnter (Method method)
specifier|private
specifier|static
name|boolean
name|isTryEnter
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"tryEnter"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Identifies just enterIfXxx methods (a subset of {@link #isAnyEnter}), which are mostly like the    * enterXxx methods but behave like tryEnterXxx in some scenarios.    */
end_comment

begin_function
DECL|method|isEnterIf (Method method)
specifier|private
specifier|static
name|boolean
name|isEnterIf
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"enterIf"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Identifies all waitForXxx methods, which must be called while occupying the monitor.    */
end_comment

begin_function
DECL|method|isWaitFor (Method method)
specifier|private
specifier|static
name|boolean
name|isWaitFor
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"waitFor"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether the given method takes a Guard as its first parameter.    */
end_comment

begin_function
DECL|method|isGuarded (Method method)
specifier|private
specifier|static
name|boolean
name|isGuarded
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
return|return
name|parameterTypes
operator|.
name|length
operator|>=
literal|1
operator|&&
name|parameterTypes
index|[
literal|0
index|]
operator|==
name|Monitor
operator|.
name|Guard
operator|.
name|class
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether the given method takes a time and unit as its last two parameters.    */
end_comment

begin_function
DECL|method|isTimed (Method method)
specifier|private
specifier|static
name|boolean
name|isTimed
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
return|return
name|parameterTypes
operator|.
name|length
operator|>=
literal|2
operator|&&
name|parameterTypes
index|[
name|parameterTypes
operator|.
name|length
operator|-
literal|2
index|]
operator|==
name|long
operator|.
name|class
operator|&&
name|parameterTypes
index|[
name|parameterTypes
operator|.
name|length
operator|-
literal|1
index|]
operator|==
name|TimeUnit
operator|.
name|class
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether the given method returns a boolean value.    */
end_comment

begin_function
DECL|method|isBoolean (Method method)
specifier|private
specifier|static
name|boolean
name|isBoolean
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|getReturnType
argument_list|()
operator|==
name|boolean
operator|.
name|class
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether the given method can throw InterruptedException.    */
end_comment

begin_function
DECL|method|isInterruptible (Method method)
specifier|private
specifier|static
name|boolean
name|isInterruptible
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|method
operator|.
name|getExceptionTypes
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|InterruptedException
operator|.
name|class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Sorts the given methods primarily by name and secondarily by number of parameters.    */
end_comment

begin_function
DECL|method|sortMethods (Method[] methods)
specifier|private
specifier|static
name|void
name|sortMethods
parameter_list|(
name|Method
index|[]
name|methods
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|methods
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Method
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Method
name|m1
parameter_list|,
name|Method
name|m2
parameter_list|)
block|{
name|int
name|nameComparison
init|=
name|m1
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|m2
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameComparison
operator|!=
literal|0
condition|)
block|{
return|return
name|nameComparison
return|;
block|}
else|else
block|{
return|return
name|Ints
operator|.
name|compare
argument_list|(
name|m1
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
argument_list|,
name|m2
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Validates that the given method's signature meets all of our assumptions.    */
end_comment

begin_function
DECL|method|validateMethod (Method method)
specifier|private
specifier|static
name|void
name|validateMethod
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
name|String
name|desc
init|=
name|method
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isAnyEnter
argument_list|(
name|method
argument_list|)
operator|||
name|isWaitFor
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
condition|)
block|{
case|case
literal|0
case|:
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|method
operator|.
name|getReturnType
argument_list|()
operator|==
name|void
operator|.
name|class
condition|)
block|{
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|method
operator|.
name|getExceptionTypes
argument_list|()
operator|.
name|length
condition|)
block|{
case|case
literal|0
case|:
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEnterIf
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTryEnter
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|desc
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isWaitFor
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|desc
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// any other enterXxx method
name|assertEquals
argument_list|(
name|desc
argument_list|,
name|isTimed
argument_list|(
name|method
argument_list|)
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Generates all test cases appropriate for the given method.    */
end_comment

begin_function
DECL|method|addTests (TestSuite suite, Method method)
specifier|private
specifier|static
name|void
name|addTests
parameter_list|(
name|TestSuite
name|suite
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
if|if
condition|(
name|isGuarded
argument_list|(
name|method
argument_list|)
condition|)
block|{
for|for
control|(
name|boolean
name|fair1
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
for|for
control|(
name|boolean
name|fair2
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
name|suite
operator|.
name|addTest
argument_list|(
name|generateGuardWithWrongMonitorTestCase
argument_list|(
name|method
argument_list|,
name|fair1
argument_list|,
name|fair2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isAnyEnter
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|ANY
argument_list|,
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|FINITE
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
condition|?
operator|(
name|isBoolean
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|FAILURE
else|:
name|Outcome
operator|.
name|HANG
operator|)
else|:
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|INFINITE
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
condition|?
operator|(
name|isTryEnter
argument_list|(
name|method
argument_list|)
operator|||
name|isEnterIf
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|FAILURE
else|:
name|Outcome
operator|.
name|HANG
operator|)
else|:
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_AND_OCCUPIED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|FINITE
argument_list|,
name|isBoolean
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|FAILURE
else|:
name|Outcome
operator|.
name|HANG
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_AND_OCCUPIED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|INFINITE
argument_list|,
name|isGuarded
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|HANG
else|:
operator|(
name|isTryEnter
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|FAILURE
else|:
name|Outcome
operator|.
name|HANG
operator|)
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING
argument_list|,
name|TimeoutsToUse
operator|.
name|ANY
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|INTERRUPT
else|:
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// any waitForXxx method
name|suite
operator|.
name|addTest
argument_list|(
name|generateWaitForWhenNotOccupyingTestCase
argument_list|(
name|method
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|suite
operator|.
name|addTest
argument_list|(
name|generateWaitForWhenNotOccupyingTestCase
argument_list|(
name|method
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_BEFORE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|ANY
argument_list|,
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_WHILE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|INFINITE
argument_list|,
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_WHILE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|PAST
argument_list|,
name|Outcome
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|SATISFIED_AND_INTERRUPTED_BEFORE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|ANY
argument_list|,
name|Outcome
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_BEFORE_AND_WHILE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|FINITE
argument_list|,
name|Outcome
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_BEFORE_AND_WHILE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|INFINITE
argument_list|,
name|Outcome
operator|.
name|HANG
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|PAST
argument_list|,
comment|// prefer responding to interrupt over timing out
name|isInterruptible
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|INTERRUPT
else|:
name|Outcome
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|SMALL
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|INTERRUPT
else|:
name|Outcome
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|addTests
argument_list|(
name|suite
argument_list|,
name|method
argument_list|,
name|Scenario
operator|.
name|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
argument_list|,
name|TimeoutsToUse
operator|.
name|INFINITE
argument_list|,
name|isInterruptible
argument_list|(
name|method
argument_list|)
condition|?
name|Outcome
operator|.
name|INTERRUPT
else|:
name|Outcome
operator|.
name|HANG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Generates test cases for the given combination of scenario and timeouts. For methods that take    * an explicit timeout value, all of the given timeoutsToUse result in individual test cases. For    * methods that do not take an explicit timeout value, a single test case is generated only if the    * implicit timeout of that method matches the given timeoutsToUse. For example, enter() is    * treated like enter(MAX, MILLIS) and tryEnter() is treated like enter(0, MILLIS).    */
end_comment

begin_function
DECL|method|addTests (TestSuite suite, Method method, Scenario scenario, TimeoutsToUse timeoutsToUse, Outcome expectedOutcome)
specifier|private
specifier|static
name|void
name|addTests
parameter_list|(
name|TestSuite
name|suite
parameter_list|,
name|Method
name|method
parameter_list|,
name|Scenario
name|scenario
parameter_list|,
name|TimeoutsToUse
name|timeoutsToUse
parameter_list|,
name|Outcome
name|expectedOutcome
parameter_list|)
block|{
for|for
control|(
name|boolean
name|fair
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
if|if
condition|(
name|isTimed
argument_list|(
name|method
argument_list|)
condition|)
block|{
for|for
control|(
name|Timeout
name|timeout
range|:
name|timeoutsToUse
operator|.
name|timeouts
control|)
block|{
name|suite
operator|.
name|addTest
argument_list|(
operator|new
name|GeneratedMonitorTest
argument_list|(
name|method
argument_list|,
name|scenario
argument_list|,
name|fair
argument_list|,
name|timeout
argument_list|,
name|expectedOutcome
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Timeout
name|implicitTimeout
init|=
operator|(
name|isTryEnter
argument_list|(
name|method
argument_list|)
condition|?
name|Timeout
operator|.
name|ZERO
else|:
name|Timeout
operator|.
name|MAX
operator|)
decl_stmt|;
if|if
condition|(
name|timeoutsToUse
operator|.
name|timeouts
operator|.
name|contains
argument_list|(
name|implicitTimeout
argument_list|)
condition|)
block|{
name|suite
operator|.
name|addTest
argument_list|(
operator|new
name|GeneratedMonitorTest
argument_list|(
name|method
argument_list|,
name|scenario
argument_list|,
name|fair
argument_list|,
literal|null
argument_list|,
name|expectedOutcome
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * A guard that encapsulates a simple, mutable boolean flag.    */
end_comment

begin_class
DECL|class|FlagGuard
specifier|static
class|class
name|FlagGuard
extends|extends
name|Monitor
operator|.
name|Guard
block|{
DECL|field|satisfied
specifier|private
name|boolean
name|satisfied
decl_stmt|;
DECL|method|FlagGuard (Monitor monitor)
specifier|protected
name|FlagGuard
parameter_list|(
name|Monitor
name|monitor
parameter_list|)
block|{
name|super
argument_list|(
name|monitor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isSatisfied ()
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|satisfied
return|;
block|}
DECL|method|setSatisfied (boolean satisfied)
specifier|public
name|void
name|setSatisfied
parameter_list|(
name|boolean
name|satisfied
parameter_list|)
block|{
name|this
operator|.
name|satisfied
operator|=
name|satisfied
expr_stmt|;
block|}
block|}
end_class

begin_decl_stmt
DECL|field|method
specifier|private
specifier|final
name|Method
name|method
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|scenario
specifier|private
specifier|final
name|Scenario
name|scenario
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|timeout
specifier|private
specifier|final
name|Timeout
name|timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|expectedOutcome
specifier|private
specifier|final
name|Outcome
name|expectedOutcome
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|monitor
specifier|private
specifier|final
name|Monitor
name|monitor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|guard
specifier|private
specifier|final
name|FlagGuard
name|guard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|tearDownLatch
specifier|private
specifier|final
name|CountDownLatch
name|tearDownLatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|doingCallLatch
specifier|private
specifier|final
name|CountDownLatch
name|doingCallLatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|callCompletedLatch
specifier|private
specifier|final
name|CountDownLatch
name|callCompletedLatch
decl_stmt|;
end_decl_stmt

begin_constructor
DECL|method|GeneratedMonitorTest ( Method method, Scenario scenario, boolean fair, Timeout timeout, Outcome expectedOutcome)
specifier|private
name|GeneratedMonitorTest
parameter_list|(
name|Method
name|method
parameter_list|,
name|Scenario
name|scenario
parameter_list|,
name|boolean
name|fair
parameter_list|,
name|Timeout
name|timeout
parameter_list|,
name|Outcome
name|expectedOutcome
parameter_list|)
block|{
name|super
argument_list|(
name|nameFor
argument_list|(
name|method
argument_list|,
name|scenario
argument_list|,
name|fair
argument_list|,
name|timeout
argument_list|,
name|expectedOutcome
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
name|this
operator|.
name|scenario
operator|=
name|scenario
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|expectedOutcome
operator|=
name|expectedOutcome
expr_stmt|;
name|this
operator|.
name|monitor
operator|=
operator|new
name|Monitor
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|this
operator|.
name|guard
operator|=
operator|new
name|FlagGuard
argument_list|(
name|monitor
argument_list|)
expr_stmt|;
name|this
operator|.
name|tearDownLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|doingCallLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|callCompletedLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_function
DECL|method|nameFor ( Method method, Scenario scenario, boolean fair, Timeout timeout, Outcome expectedOutcome)
specifier|private
specifier|static
name|String
name|nameFor
parameter_list|(
name|Method
name|method
parameter_list|,
name|Scenario
name|scenario
parameter_list|,
name|boolean
name|fair
parameter_list|,
name|Timeout
name|timeout
parameter_list|,
name|Outcome
name|expectedOutcome
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s%s(%s)/%s->%s"
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|fair
condition|?
literal|"(fair)"
else|:
literal|"(nonfair)"
argument_list|,
operator|(
name|timeout
operator|==
literal|null
operator|)
condition|?
literal|"untimed"
else|:
name|timeout
argument_list|,
name|scenario
argument_list|,
name|expectedOutcome
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|runTest ()
specifier|protected
name|void
name|runTest
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Runnable
name|runChosenTest
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|runChosenTest
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|final
name|FutureTask
argument_list|<
name|Void
argument_list|>
name|task
init|=
operator|new
name|FutureTask
argument_list|<
name|Void
argument_list|>
argument_list|(
name|runChosenTest
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|startThread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|task
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|awaitUninterruptibly
argument_list|(
name|doingCallLatch
argument_list|)
expr_stmt|;
name|long
name|hangDelayMillis
init|=
operator|(
name|expectedOutcome
operator|==
name|Outcome
operator|.
name|HANG
operator|)
condition|?
name|EXPECTED_HANG_DELAY_MILLIS
else|:
name|UNEXPECTED_HANG_DELAY_MILLIS
decl_stmt|;
name|boolean
name|hung
init|=
operator|!
name|awaitUninterruptibly
argument_list|(
name|callCompletedLatch
argument_list|,
name|hangDelayMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|hung
condition|)
block|{
name|assertEquals
argument_list|(
name|expectedOutcome
argument_list|,
name|Outcome
operator|.
name|HANG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|task
operator|.
name|get
argument_list|(
name|UNEXPECTED_HANG_DELAY_MILLIS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|tearDown ()
specifier|protected
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// We don't want to leave stray threads running after each test. At this point, every thread
comment|// launched by this test is either:
comment|//
comment|// (a) Blocked attempting to enter the monitor.
comment|// (b) Waiting for the single guard to become satisfied.
comment|// (c) Occupying the monitor and awaiting the tearDownLatch.
comment|//
comment|// Except for (c), every thread should occupy the monitor very briefly, and every thread leaves
comment|// the monitor with the guard satisfied. Therefore as soon as tearDownLatch is triggered, we
comment|// should be able to enter the monitor, and then we set the guard to satisfied for the benefit
comment|// of any remaining waiting threads.
name|tearDownLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Monitor still occupied in tearDown()"
argument_list|,
name|monitor
operator|.
name|enter
argument_list|(
name|UNEXPECTED_HANG_DELAY_MILLIS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|runChosenTest ()
specifier|private
name|void
name|runChosenTest
parameter_list|()
block|{
if|if
condition|(
name|isAnyEnter
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|runEnterTest
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|runWaitTest
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|runEnterTest ()
specifier|private
name|void
name|runEnterTest
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|doEnterScenarioSetUp
argument_list|()
expr_stmt|;
name|boolean
name|interruptedBeforeCall
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
decl_stmt|;
name|Outcome
name|actualOutcome
init|=
name|doCall
argument_list|()
decl_stmt|;
name|boolean
name|occupiedAfterCall
init|=
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
decl_stmt|;
name|boolean
name|interruptedAfterCall
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
decl_stmt|;
if|if
condition|(
name|occupiedAfterCall
condition|)
block|{
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedOutcome
argument_list|,
name|actualOutcome
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedOutcome
operator|==
name|Outcome
operator|.
name|SUCCESS
argument_list|,
name|occupiedAfterCall
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|interruptedBeforeCall
operator|&&
name|expectedOutcome
operator|!=
name|Outcome
operator|.
name|INTERRUPT
argument_list|,
name|interruptedAfterCall
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|doEnterScenarioSetUp ()
specifier|private
name|void
name|doEnterScenarioSetUp
parameter_list|()
block|{
switch|switch
condition|(
name|scenario
condition|)
block|{
case|case
name|SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
case|:
name|enterSatisfyGuardAndLeaveInCurrentThread
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING
case|:
break|break;
case|case
name|SATISFIED_AND_OCCUPIED_BEFORE_ENTERING
case|:
name|enterSatisfyGuardAndLeaveInCurrentThread
argument_list|()
expr_stmt|;
name|enterAndRemainOccupyingInAnotherThread
argument_list|()
expr_stmt|;
break|break;
case|case
name|SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING
case|:
name|enterSatisfyGuardAndLeaveInCurrentThread
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unsupported scenario: "
operator|+
name|scenario
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
DECL|method|runWaitTest ()
specifier|private
name|void
name|runWaitTest
parameter_list|()
block|{
name|assertFalse
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|doWaitScenarioSetUp
argument_list|()
expr_stmt|;
name|boolean
name|interruptedBeforeCall
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
decl_stmt|;
name|Outcome
name|actualOutcome
init|=
name|doCall
argument_list|()
decl_stmt|;
name|boolean
name|occupiedAfterCall
init|=
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
decl_stmt|;
name|boolean
name|interruptedAfterCall
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedOutcome
argument_list|,
name|actualOutcome
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|occupiedAfterCall
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|interruptedBeforeCall
operator|&&
name|expectedOutcome
operator|!=
name|Outcome
operator|.
name|INTERRUPT
argument_list|,
name|interruptedAfterCall
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|monitor
operator|.
name|isOccupiedByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|doWaitScenarioSetUp ()
specifier|private
name|void
name|doWaitScenarioSetUp
parameter_list|()
block|{
switch|switch
condition|(
name|scenario
condition|)
block|{
case|case
name|SATISFIED_BEFORE_WAITING
case|:
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|SATISFIED_WHILE_WAITING
case|:
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|enterSatisfyGuardAndLeaveInAnotherThread
argument_list|()
expr_stmt|;
comment|// enter blocks until we call waitFor
break|break;
case|case
name|UNSATISFIED_BEFORE_AND_WHILE_WAITING
case|:
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|SATISFIED_AND_INTERRUPTED_BEFORE_WAITING
case|:
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING
case|:
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unsupported scenario: "
operator|+
name|scenario
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
DECL|method|doCall ()
specifier|private
name|Outcome
name|doCall
parameter_list|()
block|{
name|boolean
name|guarded
init|=
name|isGuarded
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|boolean
name|timed
init|=
name|isTimed
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|new
name|Object
index|[
operator|(
name|guarded
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|timed
condition|?
literal|2
else|:
literal|0
operator|)
index|]
decl_stmt|;
if|if
condition|(
name|guarded
condition|)
block|{
name|arguments
index|[
literal|0
index|]
operator|=
name|guard
expr_stmt|;
block|}
if|if
condition|(
name|timed
condition|)
block|{
name|arguments
index|[
name|arguments
operator|.
name|length
operator|-
literal|2
index|]
operator|=
name|timeout
operator|.
name|millis
expr_stmt|;
name|arguments
index|[
name|arguments
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|TimeUnit
operator|.
name|MILLISECONDS
expr_stmt|;
block|}
try|try
block|{
name|Object
name|result
decl_stmt|;
name|doingCallLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|result
operator|=
name|method
operator|.
name|invoke
argument_list|(
name|monitor
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|callCompletedLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|Outcome
operator|.
name|SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Boolean
operator|)
name|result
condition|)
block|{
return|return
name|Outcome
operator|.
name|SUCCESS
return|;
block|}
else|else
block|{
return|return
name|Outcome
operator|.
name|FAILURE
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|targetException
parameter_list|)
block|{
name|Throwable
name|actualException
init|=
name|targetException
operator|.
name|getTargetException
argument_list|()
decl_stmt|;
if|if
condition|(
name|actualException
operator|instanceof
name|InterruptedException
condition|)
block|{
return|return
name|Outcome
operator|.
name|INTERRUPT
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected exception"
argument_list|,
name|targetException
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected exception"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
DECL|method|enterSatisfyGuardAndLeaveInCurrentThread ()
specifier|private
name|void
name|enterSatisfyGuardAndLeaveInCurrentThread
parameter_list|()
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|enterSatisfyGuardAndLeaveInAnotherThread ()
specifier|private
name|void
name|enterSatisfyGuardAndLeaveInAnotherThread
parameter_list|()
block|{
specifier|final
name|CountDownLatch
name|startedLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|startThread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|startedLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|enterSatisfyGuardAndLeaveInCurrentThread
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|awaitUninterruptibly
argument_list|(
name|startedLatch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|enterAndRemainOccupyingInAnotherThread ()
specifier|private
name|void
name|enterAndRemainOccupyingInAnotherThread
parameter_list|()
block|{
specifier|final
name|CountDownLatch
name|enteredLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|startThread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|enteredLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|awaitUninterruptibly
argument_list|(
name|tearDownLatch
argument_list|)
expr_stmt|;
name|guard
operator|.
name|setSatisfied
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|awaitUninterruptibly
argument_list|(
name|enteredLatch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|startThread (Runnable runnable)
specifier|static
name|Thread
name|startThread
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|runnable
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|thread
return|;
block|}
end_function

begin_comment
comment|/**    * Generates a test case verifying that calling any enterXxx, tryEnterXxx, or waitForXxx method    * with a guard that doesn't match the monitor produces an IllegalMonitorStateException.    */
end_comment

begin_function
DECL|method|generateGuardWithWrongMonitorTestCase (final Method method, final boolean fair1, final boolean fair2)
specifier|private
specifier|static
name|TestCase
name|generateGuardWithWrongMonitorTestCase
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|boolean
name|fair1
parameter_list|,
specifier|final
name|boolean
name|fair2
parameter_list|)
block|{
specifier|final
name|boolean
name|timed
init|=
name|isTimed
argument_list|(
name|method
argument_list|)
decl_stmt|;
comment|// Not going to bother with all timeouts, just 0ms.
return|return
operator|new
name|TestCase
argument_list|(
name|method
operator|.
name|getName
argument_list|()
operator|+
operator|(
name|timed
condition|?
literal|"(0ms)"
else|:
literal|"()"
operator|)
operator|+
literal|"/WrongMonitor->IMSE"
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|runTest
parameter_list|()
throws|throws
name|Throwable
block|{
name|Monitor
name|monitor1
init|=
operator|new
name|Monitor
argument_list|(
name|fair1
argument_list|)
decl_stmt|;
name|Monitor
name|monitor2
init|=
operator|new
name|Monitor
argument_list|(
name|fair2
argument_list|)
decl_stmt|;
name|FlagGuard
name|guard
init|=
operator|new
name|FlagGuard
argument_list|(
name|monitor2
argument_list|)
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|(
name|timed
condition|?
operator|new
name|Object
index|[]
block|{
name|guard
block|,
literal|0L
block|,
name|TimeUnit
operator|.
name|MILLISECONDS
block|}
else|:
operator|new
name|Object
index|[]
block|{
name|guard
block|}
operator|)
decl_stmt|;
name|boolean
name|occupyMonitor
init|=
name|isWaitFor
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|occupyMonitor
condition|)
block|{
comment|// If we don't already occupy the monitor, we'll get an IMSE regardless of the guard (see
comment|// generateWaitForWhenNotOccupyingTestCase).
name|monitor1
operator|.
name|enter
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|method
operator|.
name|invoke
argument_list|(
name|monitor1
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected IllegalMonitorStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|IllegalMonitorStateException
operator|.
name|class
argument_list|,
name|e
operator|.
name|getTargetException
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|occupyMonitor
condition|)
block|{
name|monitor1
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Generates a test case verifying that calling any waitForXxx method when not occupying the    * monitor produces an IllegalMonitorStateException.    */
end_comment

begin_function
DECL|method|generateWaitForWhenNotOccupyingTestCase (final Method method, final boolean fair)
specifier|private
specifier|static
name|TestCase
name|generateWaitForWhenNotOccupyingTestCase
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|boolean
name|fair
parameter_list|)
block|{
specifier|final
name|boolean
name|timed
init|=
name|isTimed
argument_list|(
name|method
argument_list|)
decl_stmt|;
comment|// Not going to bother with all timeouts, just 0ms.
name|String
name|testName
init|=
name|method
operator|.
name|getName
argument_list|()
operator|+
operator|(
name|fair
condition|?
literal|"(fair)"
else|:
literal|"(nonfair)"
operator|)
operator|+
operator|(
name|timed
condition|?
literal|"(0ms)"
else|:
literal|"()"
operator|)
operator|+
literal|"/NotOccupying->IMSE"
decl_stmt|;
return|return
operator|new
name|TestCase
argument_list|(
name|testName
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|runTest
parameter_list|()
throws|throws
name|Throwable
block|{
name|Monitor
name|monitor
init|=
operator|new
name|Monitor
argument_list|(
name|fair
argument_list|)
decl_stmt|;
name|FlagGuard
name|guard
init|=
operator|new
name|FlagGuard
argument_list|(
name|monitor
argument_list|)
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|(
name|timed
condition|?
operator|new
name|Object
index|[]
block|{
name|guard
block|,
literal|0L
block|,
name|TimeUnit
operator|.
name|MILLISECONDS
block|}
else|:
operator|new
name|Object
index|[]
block|{
name|guard
block|}
operator|)
decl_stmt|;
try|try
block|{
name|method
operator|.
name|invoke
argument_list|(
name|monitor
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected IllegalMonitorStateException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|IllegalMonitorStateException
operator|.
name|class
argument_list|,
name|e
operator|.
name|getTargetException
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
end_function

unit|}
end_unit

