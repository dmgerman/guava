begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2010 The Guava Authors  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|com.google.common.util.concurrent
package|package
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ObjectArrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * A bounded {@linkplain BlockingQueue blocking queue} backed by an  * array.  This queue orders elements FIFO (first-in-first-out).  The  *<em>head</em> of the queue is that element that has been on the  * queue the longest time.  The<em>tail</em> of the queue is that  * element that has been on the queue the shortest time. New elements  * are inserted at the tail of the queue, and the queue retrieval  * operations obtain elements at the head of the queue.  *  *<p>This is a classic&quot;bounded buffer&quot;, in which a  * fixed-sized array holds elements inserted by producers and  * extracted by consumers.  Once created, the capacity cannot be  * increased.  Attempts to<tt>put</tt> an element into a full queue  * will result in the operation blocking; attempts to<tt>take</tt> an  * element from an empty queue will similarly block.  *  *<p> This class supports an optional fairness policy for ordering  * waiting producer and consumer threads.  By default, this ordering  * is not guaranteed. However, a queue constructed with fairness set  * to<tt>true</tt> grants threads access in FIFO order. Fairness  * generally decreases throughput but reduces variability and avoids  * starvation.  *  *<p>This class and its iterator implement all of the  *<em>optional</em> methods of the {@link Collection} and {@link  * Iterator} interfaces.  *  * @author Doug Lea  * @author Justin T. Sampson  * @param<E> the type of elements held in this collection  */
end_comment

begin_class
DECL|class|MonitorBasedArrayBlockingQueue
specifier|public
class|class
name|MonitorBasedArrayBlockingQueue
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|E
argument_list|>
implements|implements
name|BlockingQueue
argument_list|<
name|E
argument_list|>
block|{
comment|// Based on revision 1.58 of ArrayBlockingQueue by Doug Lea, from
comment|// http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/
comment|/** The queued items  */
DECL|field|items
specifier|final
name|E
index|[]
name|items
decl_stmt|;
comment|/** items index for next take, poll or remove */
DECL|field|takeIndex
name|int
name|takeIndex
decl_stmt|;
comment|/** items index for next put, offer, or add. */
DECL|field|putIndex
name|int
name|putIndex
decl_stmt|;
comment|/** Number of items in the queue */
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
comment|/*      * Concurrency control uses the classic two-condition algorithm      * found in any textbook.      */
comment|/** Monitor guarding all access */
DECL|field|monitor
specifier|final
name|Monitor
name|monitor
decl_stmt|;
comment|/** Guard for waiting takes */
DECL|field|notEmpty
specifier|private
specifier|final
name|Monitor
operator|.
name|Guard
name|notEmpty
decl_stmt|;
comment|/** Guard for waiting puts */
DECL|field|notFull
specifier|private
specifier|final
name|Monitor
operator|.
name|Guard
name|notFull
decl_stmt|;
comment|// Internal helper methods
comment|/**      * Circularly increment i.      */
DECL|method|inc (int i)
specifier|final
name|int
name|inc
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
operator|++
name|i
operator|==
name|items
operator|.
name|length
operator|)
condition|?
literal|0
else|:
name|i
return|;
block|}
comment|/**      * Inserts element at current put position, advances, and signals.      * Call only when occupying monitor.      */
DECL|method|insert (E x)
specifier|private
name|void
name|insert
parameter_list|(
name|E
name|x
parameter_list|)
block|{
name|items
index|[
name|putIndex
index|]
operator|=
name|x
expr_stmt|;
name|putIndex
operator|=
name|inc
argument_list|(
name|putIndex
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
comment|/**      * Extracts element at current take position, advances, and signals.      * Call only when occupying monitor.      */
DECL|method|extract ()
specifier|private
name|E
name|extract
parameter_list|()
block|{
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
name|E
name|x
init|=
name|items
index|[
name|takeIndex
index|]
decl_stmt|;
name|items
index|[
name|takeIndex
index|]
operator|=
literal|null
expr_stmt|;
name|takeIndex
operator|=
name|inc
argument_list|(
name|takeIndex
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/**      * Utility for remove and iterator.remove: Delete item at position i.      * Call only when occupying monitor.      */
DECL|method|removeAt (int i)
name|void
name|removeAt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
comment|// if removing front item, just advance
if|if
condition|(
name|i
operator|==
name|takeIndex
condition|)
block|{
name|items
index|[
name|takeIndex
index|]
operator|=
literal|null
expr_stmt|;
name|takeIndex
operator|=
name|inc
argument_list|(
name|takeIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// slide over all others up through putIndex.
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nexti
init|=
name|inc
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nexti
operator|!=
name|putIndex
condition|)
block|{
name|items
index|[
name|i
index|]
operator|=
name|items
index|[
name|nexti
index|]
expr_stmt|;
name|i
operator|=
name|nexti
expr_stmt|;
block|}
else|else
block|{
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|putIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|--
name|count
expr_stmt|;
block|}
comment|/**      * Creates an<tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)      * capacity and default access policy.      *      * @param capacity the capacity of this queue      * @throws IllegalArgumentException if<tt>capacity</tt> is less than 1      */
DECL|method|MonitorBasedArrayBlockingQueue (int capacity)
specifier|public
name|MonitorBasedArrayBlockingQueue
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|this
argument_list|(
name|capacity
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an<tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)      * capacity and the specified access policy.      *      * @param capacity the capacity of this queue      * @param fair if<tt>true</tt> then queue accesses for threads blocked      *        on insertion or removal, are processed in FIFO order;      *        if<tt>false</tt> the access order is unspecified.      * @throws IllegalArgumentException if<tt>capacity</tt> is less than 1      */
DECL|method|MonitorBasedArrayBlockingQueue (int capacity, boolean fair)
specifier|public
name|MonitorBasedArrayBlockingQueue
parameter_list|(
name|int
name|capacity
parameter_list|,
name|boolean
name|fair
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|items
operator|=
name|newEArray
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
name|monitor
operator|=
operator|new
name|Monitor
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|notEmpty
operator|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|count
operator|>
literal|0
return|;
block|}
block|}
expr_stmt|;
name|notFull
operator|=
operator|new
name|Monitor
operator|.
name|Guard
argument_list|(
name|monitor
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isSatisfied
parameter_list|()
block|{
return|return
name|count
operator|<
name|items
operator|.
name|length
return|;
block|}
block|}
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// please don't try this home, kids
DECL|method|newEArray (int capacity)
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|E
index|[]
name|newEArray
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
return|return
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|capacity
index|]
return|;
block|}
comment|/**      * Creates an<tt>MonitorBasedArrayBlockingQueue</tt> with the given (fixed)      * capacity, the specified access policy and initially containing the      * elements of the given collection,      * added in traversal order of the collection's iterator.      *      * @param capacity the capacity of this queue      * @param fair if<tt>true</tt> then queue accesses for threads blocked      *        on insertion or removal, are processed in FIFO order;      *        if<tt>false</tt> the access order is unspecified.      * @param c the collection of elements to initially contain      * @throws IllegalArgumentException if<tt>capacity</tt> is less than      *<tt>c.size()</tt>, or less than 1.      * @throws NullPointerException if the specified collection or any      *         of its elements are null      */
DECL|method|MonitorBasedArrayBlockingQueue (int capacity, boolean fair, Collection<? extends E> c)
specifier|public
name|MonitorBasedArrayBlockingQueue
parameter_list|(
name|int
name|capacity
parameter_list|,
name|boolean
name|fair
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|this
argument_list|(
name|capacity
argument_list|,
name|fair
argument_list|)
expr_stmt|;
if|if
condition|(
name|capacity
operator|<
name|c
operator|.
name|size
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
for|for
control|(
name|E
name|e
range|:
name|c
control|)
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue if it is      * possible to do so immediately without exceeding the queue's capacity,      * returning<tt>true</tt> upon success and throwing an      *<tt>IllegalStateException</tt> if this queue is full.      *      * @param e the element to add      * @return<tt>true</tt> (as specified by {@link Collection#add})      * @throws IllegalStateException if this queue is full      * @throws NullPointerException if the specified element is null      */
DECL|method|add (E e)
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|super
operator|.
name|add
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue if it is      * possible to do so immediately without exceeding the queue's capacity,      * returning<tt>true</tt> upon success and<tt>false</tt> if this queue      * is full.  This method is generally preferable to method {@link #add},      * which can fail to insert an element only by throwing an exception.      *      * @throws NullPointerException if the specified element is null      */
annotation|@
name|Override
DECL|method|offer (E e)
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
if|if
condition|(
name|monitor
operator|.
name|enterIf
argument_list|(
name|notFull
argument_list|)
condition|)
block|{
try|try
block|{
name|insert
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Inserts the specified element at the tail of this queue, waiting      * for space to become available if the queue is full.      *      * @throws InterruptedException {@inheritDoc}      * @throws NullPointerException {@inheritDoc}      */
annotation|@
name|Override
DECL|method|put (E e)
specifier|public
name|void
name|put
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enterWhen
argument_list|(
name|notFull
argument_list|)
expr_stmt|;
try|try
block|{
name|insert
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Inserts the specified element at the tail of this queue, waiting      * up to the specified wait time for space to become available if      * the queue is full.      *      * @throws InterruptedException {@inheritDoc}      * @throws NullPointerException {@inheritDoc}      */
annotation|@
name|Override
DECL|method|offer (E e, long timeout, TimeUnit unit)
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
if|if
condition|(
name|monitor
operator|.
name|enterWhen
argument_list|(
name|notFull
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
try|try
block|{
name|insert
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|poll ()
specifier|public
name|E
name|poll
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
if|if
condition|(
name|monitor
operator|.
name|enterIf
argument_list|(
name|notEmpty
argument_list|)
condition|)
block|{
try|try
block|{
return|return
name|extract
argument_list|()
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|take ()
specifier|public
name|E
name|take
parameter_list|()
throws|throws
name|InterruptedException
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enterWhen
argument_list|(
name|notEmpty
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|extract
argument_list|()
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|poll (long timeout, TimeUnit unit)
specifier|public
name|E
name|poll
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
if|if
condition|(
name|monitor
operator|.
name|enterWhen
argument_list|(
name|notEmpty
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
condition|)
block|{
try|try
block|{
return|return
name|extract
argument_list|()
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|peek ()
specifier|public
name|E
name|peek
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
if|if
condition|(
name|monitor
operator|.
name|enterIf
argument_list|(
name|notEmpty
argument_list|)
condition|)
block|{
try|try
block|{
return|return
name|items
index|[
name|takeIndex
index|]
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// this doc comment is overridden to remove the reference to collections
comment|// greater in size than Integer.MAX_VALUE
comment|/**      * Returns the number of elements in this queue.      *      * @return the number of elements in this queue      */
DECL|method|size ()
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|count
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|// this doc comment is a modified copy of the inherited doc comment,
comment|// without the reference to unlimited queues.
comment|/**      * Returns the number of additional elements that this queue can ideally      * (in the absence of memory or resource constraints) accept without      * blocking. This is always equal to the initial capacity of this queue      * less the current<tt>size</tt> of this queue.      *      *<p>Note that you<em>cannot</em> always tell if an attempt to insert      * an element will succeed by inspecting<tt>remainingCapacity</tt>      * because it may be the case that another thread is about to      * insert or remove an element.      */
annotation|@
name|Override
DECL|method|remainingCapacity ()
specifier|public
name|int
name|remainingCapacity
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|items
operator|.
name|length
operator|-
name|count
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Removes a single instance of the specified element from this queue,      * if it is present.  More formally, removes an element<tt>e</tt> such      * that<tt>o.equals(e)</tt>, if this queue contains one or more such      * elements.      * Returns<tt>true</tt> if this queue contained the specified element      * (or equivalently, if this queue changed as a result of the call).      *      * @param o element to be removed from this queue, if present      * @return<tt>true</tt> if this queue changed as a result of the call      */
DECL|method|remove (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>=
name|count
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns<tt>true</tt> if this queue contains the specified element.      * More formally, returns<tt>true</tt> if and only if this queue contains      * at least one element<tt>e</tt> such that<tt>o.equals(e)</tt>.      *      * @param o object to be checked for containment in this queue      * @return<tt>true</tt> if this queue contains the specified element      */
DECL|method|contains (@ullable Object o)
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|k
operator|++
operator|<
name|count
condition|)
block|{
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns an array containing all of the elements in this queue, in      * proper sequence.      *      *<p>The returned array will be "safe" in that no references to it are      * maintained by this queue.  (In other words, this method must allocate      * a new array).  The caller is thus free to modify the returned array.      *      *<p>This method acts as bridge between array-based and collection-based      * APIs.      *      * @return an array containing all of the elements in this queue      */
DECL|method|toArray ()
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|Object
index|[]
name|a
init|=
operator|new
name|Object
index|[
name|count
index|]
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
while|while
condition|(
name|k
operator|<
name|count
condition|)
block|{
name|a
index|[
name|k
operator|++
index|]
operator|=
name|items
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns an array containing all of the elements in this queue, in      * proper sequence; the runtime type of the returned array is that of      * the specified array.  If the queue fits in the specified array, it      * is returned therein.  Otherwise, a new array is allocated with the      * runtime type of the specified array and the size of this queue.      *      *<p>If this queue fits in the specified array with room to spare      * (i.e., the array has more elements than this queue), the element in      * the array immediately following the end of the queue is set to      *<tt>null</tt>.      *      *<p>Like the {@link #toArray()} method, this method acts as bridge between      * array-based and collection-based APIs.  Further, this method allows      * precise control over the runtime type of the output array, and may,      * under certain circumstances, be used to save allocation costs.      *      *<p>Suppose<tt>x</tt> is a queue known to contain only strings.      * The following code can be used to dump the queue into a newly      * allocated array of<tt>String</tt>:      *      *<pre>      *     String[] y = x.toArray(new String[0]);</pre>      *      *<p>Note that<tt>toArray(new Object[0])</tt> is identical in function to      *<tt>toArray()</tt>.      *      * @param a the array into which the elements of the queue are to      *          be stored, if it is big enough; otherwise, a new array of the      *          same runtime type is allocated for this purpose      * @return an array containing all of the elements in this queue      * @throws ArrayStoreException if the runtime type of the specified array      *         is not a supertype of the runtime type of every element in      *         this queue      * @throws NullPointerException if the specified array is null      */
DECL|method|toArray (T[] a)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|a
operator|.
name|length
operator|<
name|count
condition|)
name|a
operator|=
name|ObjectArrays
operator|.
name|newArray
argument_list|(
name|a
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
while|while
condition|(
name|k
operator|<
name|count
condition|)
block|{
comment|// This cast is not itself safe, but the following statement
comment|// will fail if the runtime type of items[i] is not assignable
comment|// to the runtime type of a[k++], which is all that the method
comment|// contract requires (see @throws ArrayStoreException above).
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|t
init|=
operator|(
name|T
operator|)
name|items
index|[
name|i
index|]
decl_stmt|;
name|a
index|[
name|k
operator|++
index|]
operator|=
name|t
expr_stmt|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|length
operator|>
name|count
condition|)
name|a
index|[
name|count
index|]
operator|=
literal|null
expr_stmt|;
return|return
name|a
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Atomically removes all of the elements from this queue.      * The queue will be empty after this call returns.      */
DECL|method|clear ()
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
name|int
name|k
init|=
name|count
decl_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|0
condition|)
block|{
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|putIndex
operator|=
literal|0
expr_stmt|;
name|takeIndex
operator|=
literal|0
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @throws UnsupportedOperationException {@inheritDoc}      * @throws ClassCastException            {@inheritDoc}      * @throws NullPointerException          {@inheritDoc}      * @throws IllegalArgumentException      {@inheritDoc}      */
annotation|@
name|Override
DECL|method|drainTo (Collection<? super E> c)
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|count
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|max
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|putIndex
operator|=
literal|0
expr_stmt|;
name|takeIndex
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @throws UnsupportedOperationException {@inheritDoc}      * @throws ClassCastException            {@inheritDoc}      * @throws NullPointerException          {@inheritDoc}      * @throws IllegalArgumentException      {@inheritDoc}      */
annotation|@
name|Override
DECL|method|drainTo (Collection<? super E> c, int maxElements)
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|,
name|int
name|maxElements
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|maxElements
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
specifier|final
name|E
index|[]
name|items
init|=
name|this
operator|.
name|items
decl_stmt|;
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|takeIndex
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
operator|(
name|maxElements
operator|<
name|count
operator|)
condition|?
name|maxElements
else|:
name|count
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|max
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|i
operator|=
name|inc
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|count
operator|-=
name|n
expr_stmt|;
name|takeIndex
operator|=
name|i
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns an iterator over the elements in this queue in proper sequence.      * The returned<tt>Iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *      * @return an iterator over the elements in this queue in proper sequence      */
DECL|method|iterator ()
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
return|return
operator|new
name|Itr
argument_list|()
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Iterator for MonitorBasedArrayBlockingQueue      */
DECL|class|Itr
specifier|private
class|class
name|Itr
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
comment|/**          * Index of element to be returned by next,          * or a negative number if no such.          */
DECL|field|nextIndex
specifier|private
name|int
name|nextIndex
decl_stmt|;
comment|/**          * nextItem holds on to item fields because once we claim          * that an element exists in hasNext(), we must return it in          * the following next() call even if it was in the process of          * being removed when hasNext() was called.          */
DECL|field|nextItem
specifier|private
name|E
name|nextItem
decl_stmt|;
comment|/**          * Index of element returned by most recent call to next.          * Reset to -1 if this element is deleted by a call to remove.          */
DECL|field|lastRet
specifier|private
name|int
name|lastRet
decl_stmt|;
DECL|method|Itr ()
name|Itr
parameter_list|()
block|{
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|nextIndex
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|nextIndex
operator|=
name|takeIndex
expr_stmt|;
name|nextItem
operator|=
name|items
index|[
name|takeIndex
index|]
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
comment|/*              * No sync. We can return true by mistake here              * only if this iterator passed across threads,              * which we don't support anyway.              */
return|return
name|nextIndex
operator|>=
literal|0
return|;
block|}
comment|/**          * Checks whether nextIndex is valid; if so setting nextItem.          * Stops iterator when either hits putIndex or sees null item.          */
DECL|method|checkNext ()
specifier|private
name|void
name|checkNext
parameter_list|()
block|{
if|if
condition|(
name|nextIndex
operator|==
name|putIndex
condition|)
block|{
name|nextIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|nextItem
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|nextItem
operator|=
name|items
index|[
name|nextIndex
index|]
expr_stmt|;
if|if
condition|(
name|nextItem
operator|==
literal|null
condition|)
name|nextIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|E
name|next
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|MonitorBasedArrayBlockingQueue
operator|.
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|nextIndex
operator|<
literal|0
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|lastRet
operator|=
name|nextIndex
expr_stmt|;
name|E
name|x
init|=
name|nextItem
decl_stmt|;
name|nextIndex
operator|=
name|inc
argument_list|(
name|nextIndex
argument_list|)
expr_stmt|;
name|checkNext
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
specifier|final
name|Monitor
name|monitor
init|=
name|MonitorBasedArrayBlockingQueue
operator|.
name|this
operator|.
name|monitor
decl_stmt|;
name|monitor
operator|.
name|enter
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|i
init|=
name|lastRet
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|ti
init|=
name|takeIndex
decl_stmt|;
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// back up cursor (reset to front if was first element)
name|nextIndex
operator|=
operator|(
name|i
operator|==
name|ti
operator|)
condition|?
name|takeIndex
else|:
name|i
expr_stmt|;
name|checkNext
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

